(function(modules) {
    var installedModules = {};

    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
        }
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
        };
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.l = true;
        return module.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.d = function(exports, name, getter) {
        if (!__webpack_require__.o(exports, name)) {
            Object.defineProperty(exports, name, {
                configurable: false,
                enumerable: true,
                get: getter
            });
        }
    };
    __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function getDefault() {
            return module['default'];
        } : function getModuleExports() {
            return module;
        };
        __webpack_require__.d(getter, 'a', getter);
        return getter;
    };
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    __webpack_require__.p = "";
    return __webpack_require__(__webpack_require__.s = 27);
})
([(function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
    });
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    var __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__ = __webpack_require__(11);
    var __WEBPACK_IMPORTED_MODULE_2__TimelineMax_js__ = __webpack_require__(15);
    var __WEBPACK_IMPORTED_MODULE_3__TweenMax_js__ = __webpack_require__(41);
    var __WEBPACK_IMPORTED_MODULE_4__CSSPlugin_js__ = __webpack_require__(7);
    var __WEBPACK_IMPORTED_MODULE_5__AttrPlugin_js__ = __webpack_require__(16);
    var __WEBPACK_IMPORTED_MODULE_6__RoundPropsPlugin_js__ = __webpack_require__(17);
    var __WEBPACK_IMPORTED_MODULE_7__DirectionalRotationPlugin_js__ = __webpack_require__(18);
    var __WEBPACK_IMPORTED_MODULE_8__BezierPlugin_js__ = __webpack_require__(19);
    var __WEBPACK_IMPORTED_MODULE_9__EasePack_js__ = __webpack_require__(20);
    __webpack_require__.d(__webpack_exports__, "default", function() {
        return __WEBPACK_IMPORTED_MODULE_3__TweenMax_js__["a"];
    });
    __webpack_require__.d(__webpack_exports__, "TweenLite", function() {
        return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"];
    });
    __webpack_require__.d(__webpack_exports__, "TweenMax", function() {
        return __WEBPACK_IMPORTED_MODULE_3__TweenMax_js__["a"];
    });
    __webpack_require__.d(__webpack_exports__, "TimelineLite", function() {
        return __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a"];
    });
    __webpack_require__.d(__webpack_exports__, "TimelineMax", function() {
        return __WEBPACK_IMPORTED_MODULE_2__TimelineMax_js__["a"];
    });
    __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() {
        return __WEBPACK_IMPORTED_MODULE_4__CSSPlugin_js__["default"];
    });
    __webpack_require__.d(__webpack_exports__, "AttrPlugin", function() {
        return __WEBPACK_IMPORTED_MODULE_5__AttrPlugin_js__["a"];
    });
    __webpack_require__.d(__webpack_exports__, "BezierPlugin", function() {
        return __WEBPACK_IMPORTED_MODULE_8__BezierPlugin_js__["a"];
    });
    __webpack_require__.d(__webpack_exports__, "RoundPropsPlugin", function() {
        return __WEBPACK_IMPORTED_MODULE_6__RoundPropsPlugin_js__["a"];
    });
    __webpack_require__.d(__webpack_exports__, "DirectionalRotationPlugin", function() {
        return __WEBPACK_IMPORTED_MODULE_7__DirectionalRotationPlugin_js__["a"];
    });
    __webpack_require__.d(__webpack_exports__, "TweenPlugin", function() {
        return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["TweenPlugin"];
    });
    __webpack_require__.d(__webpack_exports__, "Ease", function() {
        return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"];
    });
    __webpack_require__.d(__webpack_exports__, "Power0", function() {
        return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Power0"];
    });
    __webpack_require__.d(__webpack_exports__, "Power1", function() {
        return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Power1"];
    });
    __webpack_require__.d(__webpack_exports__, "Power2", function() {
        return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Power2"];
    });
    __webpack_require__.d(__webpack_exports__, "Power3", function() {
        return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Power3"];
    });
    __webpack_require__.d(__webpack_exports__, "Power4", function() {
        return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Power4"];
    });
    __webpack_require__.d(__webpack_exports__, "Linear", function() {
        return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Linear"];
    });
    __webpack_require__.d(__webpack_exports__, "Back", function() {
        return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["a"];
    });
    __webpack_require__.d(__webpack_exports__, "Elastic", function() {
        return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["d"];
    });
    __webpack_require__.d(__webpack_exports__, "Bounce", function() {
        return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["b"];
    });
    __webpack_require__.d(__webpack_exports__, "RoughEase", function() {
        return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["g"];
    });
    __webpack_require__.d(__webpack_exports__, "SlowMo", function() {
        return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["i"];
    });
    __webpack_require__.d(__webpack_exports__, "SteppedEase", function() {
        return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["j"];
    });
    __webpack_require__.d(__webpack_exports__, "Circ", function() {
        return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["c"];
    });
    __webpack_require__.d(__webpack_exports__, "Expo", function() {
        return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["e"];
    });
    __webpack_require__.d(__webpack_exports__, "Sine", function() {
        return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["h"];
    });
    __webpack_require__.d(__webpack_exports__, "ExpoScaleEase", function() {
        return __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["f"];
    });
    __webpack_require__.d(__webpack_exports__, "_gsScope", function() {
        return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"];
    });
    /*!
     * VERSION: 2.0.1
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     **/
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
    });
    (function(module, global) {
        __webpack_require__.d(__webpack_exports__, "default", function() {
            return TweenLite;
        });
        /*!
         * VERSION: 2.0.1
         * DATE: 2018-05-30
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         *
         * @author: Jack Doyle, jack@greensock.com
         */
        const _gsScope = (typeof(window) !== "undefined") ? window : (typeof(module) !== "undefined" && module.exports && typeof(global) !== "undefined") ? global : this || {};
        __webpack_exports__["_gsScope"] = _gsScope;
        const TweenLite = (function(window, moduleName) {
            "use strict";
            var _exports = {},
                _doc = window.document,
                _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
            if (_globals.TweenLite) {
                return _globals.TweenLite;
            }
            var _namespace = function(ns) {
                    var a = ns.split("."),
                        p = _globals,
                        i;
                    for (i = 0; i < a.length; i++) {
                        p[a[i]] = p = p[a[i]] || {};
                    }
                    return p;
                },
                gs = _namespace("com.greensock"),
                _tinyNum = 0.0000000001,
                _slice = function(a) {
                    var b = [],
                        l = a.length,
                        i;
                    for (i = 0; i !== l; b.push(a[i++])) {}
                    return b;
                },
                _emptyFunc = function() {},
                _isArray = (function() {
                    var toString = Object.prototype.toString,
                        array = toString.call([]);
                    return function(obj) {
                        return obj != null && (obj instanceof Array || (typeof(obj) === "object" && !!obj.push && toString.call(obj) === array));
                    };
                }()),
                a, i, p, _ticker, _tickerActive, _defLookup = {},
                Definition = function(ns, dependencies, func, global) {
                    this.sc = (_defLookup[ns]) ? _defLookup[ns].sc : [];
                    _defLookup[ns] = this;
                    this.gsClass = null;
                    this.func = func;
                    var _classes = [];
                    this.check = function(init) {
                        var i = dependencies.length,
                            missing = i,
                            cur, a, n, cl;
                        while (--i > -1) {
                            if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
                                _classes[i] = cur.gsClass;
                                missing--;
                            } else if (init) {
                                cur.sc.push(this);
                            }
                        }
                        if (missing === 0 && func) {
                            a = ("com.greensock." + ns).split(".");
                            n = a.pop();
                            cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);
                            if (global) {
                                _globals[n] = _exports[n] = cl;
                            }
                            for (i = 0; i < this.sc.length; i++) {
                                this.sc[i].check();
                            }
                        }
                    };
                    this.check(true);
                },
                _gsDefine = window._gsDefine = function(ns, dependencies, func, global) {
                    return new Definition(ns, dependencies, func, global);
                },
                _class = gs._class = function(ns, func, global) {
                    func = func || function() {};
                    _gsDefine(ns, [], function() {
                        return func;
                    }, global);
                    return func;
                };
            _gsDefine.globals = _globals;
            var _baseParams = [0, 0, 1, 1],
                Ease = _class("easing.Ease", function(func, extraParams, type, power) {
                    this._func = func;
                    this._type = type || 0;
                    this._power = power || 0;
                    this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
                }, true),
                _easeMap = Ease.map = {},
                _easeReg = Ease.register = function(ease, names, types, create) {
                    var na = names.split(","),
                        i = na.length,
                        ta = (types || "easeIn,easeOut,easeInOut").split(","),
                        e, name, j, type;
                    while (--i > -1) {
                        name = na[i];
                        e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
                        j = ta.length;
                        while (--j > -1) {
                            type = ta[j];
                            _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
                        }
                    }
                };
            p = Ease.prototype;
            p._calcEnd = false;
            p.getRatio = function(p) {
                if (this._func) {
                    this._params[0] = p;
                    return this._func.apply(null, this._params);
                }
                var t = this._type,
                    pw = this._power,
                    r = (t === 1) ? 1 - p : (t === 2) ? p : (p < 0.5) ? p * 2 : (1 - p) * 2;
                if (pw === 1) {
                    r *= r;
                } else if (pw === 2) {
                    r *= r * r;
                } else if (pw === 3) {
                    r *= r * r * r;
                } else if (pw === 4) {
                    r *= r * r * r * r;
                }
                return (t === 1) ? 1 - r : (t === 2) ? r : (p < 0.5) ? r / 2 : 1 - (r / 2);
            };
            a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
            i = a.length;
            while (--i > -1) {
                p = a[i] + ",Power" + i;
                _easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
                _easeReg(new Ease(null, null, 2, i), p, "easeIn" + ((i === 0) ? ",easeNone" : ""));
                _easeReg(new Ease(null, null, 3, i), p, "easeInOut");
            }
            _easeMap.linear = gs.easing.Linear.easeIn;
            _easeMap.swing = gs.easing.Quad.easeInOut;
            var EventDispatcher = _class("events.EventDispatcher", function(target) {
                this._listeners = {};
                this._eventTarget = target || this;
            });
            p = EventDispatcher.prototype;
            p.addEventListener = function(type, callback, scope, useParam, priority) {
                priority = priority || 0;
                var list = this._listeners[type],
                    index = 0,
                    listener, i;
                if (this === _ticker && !_tickerActive) {
                    _ticker.wake();
                }
                if (list == null) {
                    this._listeners[type] = list = [];
                }
                i = list.length;
                while (--i > -1) {
                    listener = list[i];
                    if (listener.c === callback && listener.s === scope) {
                        list.splice(i, 1);
                    } else if (index === 0 && listener.pr < priority) {
                        index = i + 1;
                    }
                }
                list.splice(index, 0, {
                    c: callback,
                    s: scope,
                    up: useParam,
                    pr: priority
                });
            };
            p.removeEventListener = function(type, callback) {
                var list = this._listeners[type],
                    i;
                if (list) {
                    i = list.length;
                    while (--i > -1) {
                        if (list[i].c === callback) {
                            list.splice(i, 1);
                            return;
                        }
                    }
                }
            };
            p.dispatchEvent = function(type) {
                var list = this._listeners[type],
                    i, t, listener;
                if (list) {
                    i = list.length;
                    if (i > 1) {
                        list = list.slice(0);
                    }
                    t = this._eventTarget;
                    while (--i > -1) {
                        listener = list[i];
                        if (listener) {
                            if (listener.up) {
                                listener.c.call(listener.s || t, {
                                    type: type,
                                    target: t
                                });
                            } else {
                                listener.c.call(listener.s || t);
                            }
                        }
                    }
                }
            };
            var _reqAnimFrame = window.requestAnimationFrame,
                _cancelAnimFrame = window.cancelAnimationFrame,
                _getTime = Date.now || function() {
                    return new Date().getTime();
                },
                _lastUpdate = _getTime();
            a = ["ms", "moz", "webkit", "o"];
            i = a.length;
            while (--i > -1 && !_reqAnimFrame) {
                _reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
                _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
            }
            _class("Ticker", function(fps, useRAF) {
                var _self = this,
                    _startTime = _getTime(),
                    _useRAF = (useRAF !== false && _reqAnimFrame) ? "auto" : false,
                    _lagThreshold = 500,
                    _adjustedLag = 33,
                    _tickWord = "tick",
                    _fps, _req, _id, _gap, _nextTime, _tick = function(manual) {
                        var elapsed = _getTime() - _lastUpdate,
                            overlap, dispatch;
                        if (elapsed > _lagThreshold) {
                            _startTime += elapsed - _adjustedLag;
                        }
                        _lastUpdate += elapsed;
                        _self.time = (_lastUpdate - _startTime) / 1000;
                        overlap = _self.time - _nextTime;
                        if (!_fps || overlap > 0 || manual === true) {
                            _self.frame++;
                            _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
                            dispatch = true;
                        }
                        if (manual !== true) {
                            _id = _req(_tick);
                        }
                        if (dispatch) {
                            _self.dispatchEvent(_tickWord);
                        }
                    };
                EventDispatcher.call(_self);
                _self.time = _self.frame = 0;
                _self.tick = function() {
                    _tick(true);
                };
                _self.lagSmoothing = function(threshold, adjustedLag) {
                    if (!arguments.length) {
                        return (_lagThreshold < 1 / _tinyNum);
                    }
                    _lagThreshold = threshold || (1 / _tinyNum);
                    _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
                };
                _self.sleep = function() {
                    if (_id == null) {
                        return;
                    }
                    if (!_useRAF || !_cancelAnimFrame) {
                        clearTimeout(_id);
                    } else {
                        _cancelAnimFrame(_id);
                    }
                    _req = _emptyFunc;
                    _id = null;
                    if (_self === _ticker) {
                        _tickerActive = false;
                    }
                };
                _self.wake = function(seamless) {
                    if (_id !== null) {
                        _self.sleep();
                    } else if (seamless) {
                        _startTime += -_lastUpdate + (_lastUpdate = _getTime());
                    } else if (_self.frame > 10) {
                        _lastUpdate = _getTime() - _lagThreshold + 5;
                    }
                    _req = (_fps === 0) ? _emptyFunc : (!_useRAF || !_reqAnimFrame) ? function(f) {
                        return setTimeout(f, ((_nextTime - _self.time) * 1000 + 1) | 0);
                    } : _reqAnimFrame;
                    if (_self === _ticker) {
                        _tickerActive = true;
                    }
                    _tick(2);
                };
                _self.fps = function(value) {
                    if (!arguments.length) {
                        return _fps;
                    }
                    _fps = value;
                    _gap = 1 / (_fps || 60);
                    _nextTime = this.time + _gap;
                    _self.wake();
                };
                _self.useRAF = function(value) {
                    if (!arguments.length) {
                        return _useRAF;
                    }
                    _self.sleep();
                    _useRAF = value;
                    _self.fps(_fps);
                };
                _self.fps(fps);
                setTimeout(function() {
                    if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
                        _self.useRAF(false);
                    }
                }, 1500);
            });
            p = gs.Ticker.prototype = new gs.events.EventDispatcher();
            p.constructor = gs.Ticker;
            var Animation = _class("core.Animation", function(duration, vars) {
                this.vars = vars = vars || {};
                this._duration = this._totalDuration = duration || 0;
                this._delay = Number(vars.delay) || 0;
                this._timeScale = 1;
                this._active = (vars.immediateRender === true);
                this.data = vars.data;
                this._reversed = (vars.reversed === true);
                if (!_rootTimeline) {
                    return;
                }
                if (!_tickerActive) {
                    _ticker.wake();
                }
                var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
                tl.add(this, tl._time);
                if (this.vars.paused) {
                    this.paused(true);
                }
            });
            _ticker = Animation.ticker = new gs.Ticker();
            p = Animation.prototype;
            p._dirty = p._gc = p._initted = p._paused = false;
            p._totalTime = p._time = 0;
            p._rawPrevTime = -1;
            p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
            p._paused = false;
            var _checkTimeout = function() {
                if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) {
                    _ticker.wake();
                }
                var t = setTimeout(_checkTimeout, 2000);
                if (t.unref) {
                    t.unref();
                }
            };
            _checkTimeout();
            p.play = function(from, suppressEvents) {
                if (from != null) {
                    this.seek(from, suppressEvents);
                }
                return this.reversed(false).paused(false);
            };
            p.pause = function(atTime, suppressEvents) {
                if (atTime != null) {
                    this.seek(atTime, suppressEvents);
                }
                return this.paused(true);
            };
            p.resume = function(from, suppressEvents) {
                if (from != null) {
                    this.seek(from, suppressEvents);
                }
                return this.paused(false);
            };
            p.seek = function(time, suppressEvents) {
                return this.totalTime(Number(time), suppressEvents !== false);
            };
            p.restart = function(includeDelay, suppressEvents) {
                return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, (suppressEvents !== false), true);
            };
            p.reverse = function(from, suppressEvents) {
                if (from != null) {
                    this.seek((from || this.totalDuration()), suppressEvents);
                }
                return this.reversed(true).paused(false);
            };
            p.render = function(time, suppressEvents, force) {};
            p.invalidate = function() {
                this._time = this._totalTime = 0;
                this._initted = this._gc = false;
                this._rawPrevTime = -1;
                if (this._gc || !this.timeline) {
                    this._enabled(true);
                }
                return this;
            };
            p.isActive = function() {
                var tl = this._timeline,
                    startTime = this._startTime,
                    rawTime;
                return (!tl || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - 0.0000001));
            };
            p._enabled = function(enabled, ignoreTimeline) {
                if (!_tickerActive) {
                    _ticker.wake();
                }
                this._gc = !enabled;
                this._active = this.isActive();
                if (ignoreTimeline !== true) {
                    if (enabled && !this.timeline) {
                        this._timeline.add(this, this._startTime - this._delay);
                    } else if (!enabled && this.timeline) {
                        this._timeline._remove(this, true);
                    }
                }
                return false;
            };
            p._kill = function(vars, target) {
                return this._enabled(false, false);
            };
            p.kill = function(vars, target) {
                this._kill(vars, target);
                return this;
            };
            p._uncache = function(includeSelf) {
                var tween = includeSelf ? this : this.timeline;
                while (tween) {
                    tween._dirty = true;
                    tween = tween.timeline;
                }
                return this;
            };
            p._swapSelfInParams = function(params) {
                var i = params.length,
                    copy = params.concat();
                while (--i > -1) {
                    if (params[i] === "{self}") {
                        copy[i] = this;
                    }
                }
                return copy;
            };
            p._callback = function(type) {
                var v = this.vars,
                    callback = v[type],
                    params = v[type + "Params"],
                    scope = v[type + "Scope"] || v.callbackScope || this,
                    l = params ? params.length : 0;
                switch (l) {
                    case 0:
                        callback.call(scope);
                        break;
                    case 1:
                        callback.call(scope, params[0]);
                        break;
                    case 2:
                        callback.call(scope, params[0], params[1]);
                        break;
                    default:
                        callback.apply(scope, params);
                }
            };
            p.eventCallback = function(type, callback, params, scope) {
                if ((type || "").substr(0, 2) === "on") {
                    var v = this.vars;
                    if (arguments.length === 1) {
                        return v[type];
                    }
                    if (callback == null) {
                        delete v[type];
                    } else {
                        v[type] = callback;
                        v[type + "Params"] = (_isArray(params) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
                        v[type + "Scope"] = scope;
                    }
                    if (type === "onUpdate") {
                        this._onUpdate = callback;
                    }
                }
                return this;
            };
            p.delay = function(value) {
                if (!arguments.length) {
                    return this._delay;
                }
                if (this._timeline.smoothChildTiming) {
                    this.startTime(this._startTime + value - this._delay);
                }
                this._delay = value;
                return this;
            };
            p.duration = function(value) {
                if (!arguments.length) {
                    this._dirty = false;
                    return this._duration;
                }
                this._duration = this._totalDuration = value;
                this._uncache(true);
                if (this._timeline.smoothChildTiming)
                    if (this._time > 0)
                        if (this._time < this._duration)
                            if (value !== 0) {
                                this.totalTime(this._totalTime * (value / this._duration), true);
                            }
                return this;
            };
            p.totalDuration = function(value) {
                this._dirty = false;
                return (!arguments.length) ? this._totalDuration : this.duration(value);
            };
            p.time = function(value, suppressEvents) {
                if (!arguments.length) {
                    return this._time;
                }
                if (this._dirty) {
                    this.totalDuration();
                }
                return this.totalTime((value > this._duration) ? this._duration : value, suppressEvents);
            };
            p.totalTime = function(time, suppressEvents, uncapped) {
                if (!_tickerActive) {
                    _ticker.wake();
                }
                if (!arguments.length) {
                    return this._totalTime;
                }
                if (this._timeline) {
                    if (time < 0 && !uncapped) {
                        time += this.totalDuration();
                    }
                    if (this._timeline.smoothChildTiming) {
                        if (this._dirty) {
                            this.totalDuration();
                        }
                        var totalDuration = this._totalDuration,
                            tl = this._timeline;
                        if (time > totalDuration && !uncapped) {
                            time = totalDuration;
                        }
                        this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : totalDuration - time) / this._timeScale);
                        if (!tl._dirty) {
                            this._uncache(false);
                        }
                        if (tl._timeline) {
                            while (tl._timeline) {
                                if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
                                    tl.totalTime(tl._totalTime, true);
                                }
                                tl = tl._timeline;
                            }
                        }
                    }
                    if (this._gc) {
                        this._enabled(true, false);
                    }
                    if (this._totalTime !== time || this._duration === 0) {
                        if (_lazyTweens.length) {
                            _lazyRender();
                        }
                        this.render(time, suppressEvents, false);
                        if (_lazyTweens.length) {
                            _lazyRender();
                        }
                    }
                }
                return this;
            };
            p.progress = p.totalProgress = function(value, suppressEvents) {
                var duration = this.duration();
                return (!arguments.length) ? (duration ? this._time / duration : this.ratio) : this.totalTime(duration * value, suppressEvents);
            };
            p.startTime = function(value) {
                if (!arguments.length) {
                    return this._startTime;
                }
                if (value !== this._startTime) {
                    this._startTime = value;
                    if (this.timeline)
                        if (this.timeline._sortChildren) {
                            this.timeline.add(this, value - this._delay);
                        }
                }
                return this;
            };
            p.endTime = function(includeRepeats) {
                return this._startTime + ((includeRepeats != false) ? this.totalDuration() : this.duration()) / this._timeScale;
            };
            p.timeScale = function(value) {
                if (!arguments.length) {
                    return this._timeScale;
                }
                var pauseTime, t;
                value = value || _tinyNum;
                if (this._timeline && this._timeline.smoothChildTiming) {
                    pauseTime = this._pauseTime;
                    t = (pauseTime || pauseTime === 0) ? pauseTime : this._timeline.totalTime();
                    this._startTime = t - ((t - this._startTime) * this._timeScale / value);
                }
                this._timeScale = value;
                t = this.timeline;
                while (t && t.timeline) {
                    t._dirty = true;
                    t.totalDuration();
                    t = t.timeline;
                }
                return this;
            };
            p.reversed = function(value) {
                if (!arguments.length) {
                    return this._reversed;
                }
                if (value != this._reversed) {
                    this._reversed = value;
                    this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
                }
                return this;
            };
            p.paused = function(value) {
                if (!arguments.length) {
                    return this._paused;
                }
                var tl = this._timeline,
                    raw, elapsed;
                if (value != this._paused)
                    if (tl) {
                        if (!_tickerActive && !value) {
                            _ticker.wake();
                        }
                        raw = tl.rawTime();
                        elapsed = raw - this._pauseTime;
                        if (!value && tl.smoothChildTiming) {
                            this._startTime += elapsed;
                            this._uncache(false);
                        }
                        this._pauseTime = value ? raw : null;
                        this._paused = value;
                        this._active = this.isActive();
                        if (!value && elapsed !== 0 && this._initted && this.duration()) {
                            raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
                            this.render(raw, (raw === this._totalTime), true);
                        }
                    }
                if (this._gc && !value) {
                    this._enabled(true, false);
                }
                return this;
            };
            var SimpleTimeline = _class("core.SimpleTimeline", function(vars) {
                Animation.call(this, 0, vars);
                this.autoRemoveChildren = this.smoothChildTiming = true;
            });
            p = SimpleTimeline.prototype = new Animation();
            p.constructor = SimpleTimeline;
            p.kill()._gc = false;
            p._first = p._last = p._recent = null;
            p._sortChildren = false;
            p.add = p.insert = function(child, position, align, stagger) {
                var prevTween, st;
                child._startTime = Number(position || 0) + child._delay;
                if (child._paused)
                    if (this !== child._timeline) {
                        child._pauseTime = this.rawTime() - (child._timeline.rawTime() - child._pauseTime);
                    }
                if (child.timeline) {
                    child.timeline._remove(child, true);
                }
                child.timeline = child._timeline = this;
                if (child._gc) {
                    child._enabled(true, true);
                }
                prevTween = this._last;
                if (this._sortChildren) {
                    st = child._startTime;
                    while (prevTween && prevTween._startTime > st) {
                        prevTween = prevTween._prev;
                    }
                }
                if (prevTween) {
                    child._next = prevTween._next;
                    prevTween._next = child;
                } else {
                    child._next = this._first;
                    this._first = child;
                }
                if (child._next) {
                    child._next._prev = child;
                } else {
                    this._last = child;
                }
                child._prev = prevTween;
                this._recent = child;
                if (this._timeline) {
                    this._uncache(true);
                }
                return this;
            };
            p._remove = function(tween, skipDisable) {
                if (tween.timeline === this) {
                    if (!skipDisable) {
                        tween._enabled(false, true);
                    }
                    if (tween._prev) {
                        tween._prev._next = tween._next;
                    } else if (this._first === tween) {
                        this._first = tween._next;
                    }
                    if (tween._next) {
                        tween._next._prev = tween._prev;
                    } else if (this._last === tween) {
                        this._last = tween._prev;
                    }
                    tween._next = tween._prev = tween.timeline = null;
                    if (tween === this._recent) {
                        this._recent = this._last;
                    }
                    if (this._timeline) {
                        this._uncache(true);
                    }
                }
                return this;
            };
            p.render = function(time, suppressEvents, force) {
                var tween = this._first,
                    next;
                this._totalTime = this._time = this._rawPrevTime = time;
                while (tween) {
                    next = tween._next;
                    if (tween._active || (time >= tween._startTime && !tween._paused && !tween._gc)) {
                        if (!tween._reversed) {
                            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
                        } else {
                            tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
                        }
                    }
                    tween = next;
                }
            };
            p.rawTime = function() {
                if (!_tickerActive) {
                    _ticker.wake();
                }
                return this._totalTime;
            };
            var TweenLite = _class("TweenLite", function(target, duration, vars) {
                    Animation.call(this, duration, vars);
                    this.render = TweenLite.prototype.render;
                    if (target == null) {
                        throw "Cannot tween a null target.";
                    }
                    this.target = target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
                    var isSelector = (target.jquery || (target.length && target !== window && target[0] && (target[0] === window || (target[0].nodeType && target[0].style && !target.nodeType)))),
                        overwrite = this.vars.overwrite,
                        i, targ, targets;
                    this._overwrite = overwrite = (overwrite == null) ? _overwriteLookup[TweenLite.defaultOverwrite] : (typeof(overwrite) === "number") ? overwrite >> 0 : _overwriteLookup[overwrite];
                    if ((isSelector || target instanceof Array || (target.push && _isArray(target))) && typeof(target[0]) !== "number") {
                        this._targets = targets = _slice(target);
                        this._propLookup = [];
                        this._siblings = [];
                        for (i = 0; i < targets.length; i++) {
                            targ = targets[i];
                            if (!targ) {
                                targets.splice(i--, 1);
                                continue;
                            } else if (typeof(targ) === "string") {
                                targ = targets[i--] = TweenLite.selector(targ);
                                if (typeof(targ) === "string") {
                                    targets.splice(i + 1, 1);
                                }
                                continue;
                            } else if (targ.length && targ !== window && targ[0] && (targ[0] === window || (targ[0].nodeType && targ[0].style && !targ.nodeType))) {
                                targets.splice(i--, 1);
                                this._targets = targets = targets.concat(_slice(targ));
                                continue;
                            }
                            this._siblings[i] = _register(targ, this, false);
                            if (overwrite === 1)
                                if (this._siblings[i].length > 1) {
                                    _applyOverwrite(targ, this, null, 1, this._siblings[i]);
                                }
                        }
                    } else {
                        this._propLookup = {};
                        this._siblings = _register(target, this, false);
                        if (overwrite === 1)
                            if (this._siblings.length > 1) {
                                _applyOverwrite(target, this, null, 1, this._siblings);
                            }
                    }
                    if (this.vars.immediateRender || (duration === 0 && this._delay === 0 && this.vars.immediateRender !== false)) {
                        this._time = -_tinyNum;
                        this.render(Math.min(0, -this._delay));
                    }
                }, true),
                _isSelector = function(v) {
                    return (v && v.length && v !== window && v[0] && (v[0] === window || (v[0].nodeType && v[0].style && !v.nodeType)));
                },
                _autoCSS = function(vars, target) {
                    var css = {},
                        p;
                    for (p in vars) {
                        if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))) {
                            css[p] = vars[p];
                            delete vars[p];
                        }
                    }
                    vars.css = css;
                };
            p = TweenLite.prototype = new Animation();
            p.constructor = TweenLite;
            p.kill()._gc = false;
            p.ratio = 0;
            p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
            p._notifyPluginsOfEnabled = p._lazy = false;
            TweenLite.version = "2.0.1";
            TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
            TweenLite.defaultOverwrite = "auto";
            TweenLite.ticker = _ticker;
            TweenLite.autoSleep = 120;
            TweenLite.lagSmoothing = function(threshold, adjustedLag) {
                _ticker.lagSmoothing(threshold, adjustedLag);
            };
            TweenLite.selector = window.$ || window.jQuery || function(e) {
                var selector = window.$ || window.jQuery;
                if (selector) {
                    TweenLite.selector = selector;
                    return selector(e);
                }
                if (!_doc) {
                    _doc = window.document;
                }
                return (!_doc) ? e : (_doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById((e.charAt(0) === "#") ? e.substr(1) : e));
            };
            var _lazyTweens = [],
                _lazyLookup = {},
                _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
                _relExp = /[\+-]=-?[\.\d]/,
                _setRatio = function(v) {
                    var pt = this._firstPT,
                        min = 0.000001,
                        val;
                    while (pt) {
                        val = !pt.blob ? pt.c * v + pt.s : (v === 1 && this.end != null) ? this.end : v ? this.join("") : this.start;
                        if (pt.m) {
                            val = pt.m.call(this._tween, val, this._target || pt.t, this._tween);
                        } else if (val < min)
                            if (val > -min && !pt.blob) {
                                val = 0;
                            }
                        if (!pt.f) {
                            pt.t[pt.p] = val;
                        } else if (pt.fp) {
                            pt.t[pt.p](pt.fp, val);
                        } else {
                            pt.t[pt.p](val);
                        }
                        pt = pt._next;
                    }
                },
                _blobDif = function(start, end, filter, pt) {
                    var a = [],
                        charIndex = 0,
                        s = "",
                        color = 0,
                        startNums, endNums, num, i, l, nonNumbers, currentNum;
                    a.start = start;
                    a.end = end;
                    start = a[0] = start + "";
                    end = a[1] = end + "";
                    if (filter) {
                        filter(a);
                        start = a[0];
                        end = a[1];
                    }
                    a.length = 0;
                    startNums = start.match(_numbersExp) || [];
                    endNums = end.match(_numbersExp) || [];
                    if (pt) {
                        pt._next = null;
                        pt.blob = 1;
                        a._firstPT = a._applyPT = pt;
                    }
                    l = endNums.length;
                    for (i = 0; i < l; i++) {
                        currentNum = endNums[i];
                        nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
                        s += (nonNumbers || !i) ? nonNumbers : ",";
                        charIndex += nonNumbers.length;
                        if (color) {
                            color = (color + 1) % 5;
                        } else if (nonNumbers.substr(-5) === "rgba(") {
                            color = 1;
                        }
                        if (currentNum === startNums[i] || startNums.length <= i) {
                            s += currentNum;
                        } else {
                            if (s) {
                                a.push(s);
                                s = "";
                            }
                            num = parseFloat(startNums[i]);
                            a.push(num);
                            a._firstPT = {
                                _next: a._firstPT,
                                t: a,
                                p: a.length - 1,
                                s: num,
                                c: ((currentNum.charAt(1) === "=") ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : (parseFloat(currentNum) - num)) || 0,
                                f: 0,
                                m: (color && color < 4) ? Math.round : 0
                            };
                        }
                        charIndex += currentNum.length;
                    }
                    s += end.substr(charIndex);
                    if (s) {
                        a.push(s);
                    }
                    a.setRatio = _setRatio;
                    if (_relExp.test(end)) {
                        a.end = null;
                    }
                    return a;
                },
                _addPropTween = function(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
                    if (typeof(end) === "function") {
                        end = end(index || 0, target);
                    }
                    var type = typeof(target[prop]),
                        getterName = (type !== "function") ? "" : ((prop.indexOf("set") || typeof(target["get" + prop.substr(3)]) !== "function") ? prop : "get" + prop.substr(3)),
                        s = (start !== "get") ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
                        isRelative = (typeof(end) === "string" && end.charAt(1) === "="),
                        pt = {
                            t: target,
                            p: prop,
                            s: s,
                            f: (type === "function"),
                            pg: 0,
                            n: overwriteProp || prop,
                            m: (!mod ? 0 : (typeof(mod) === "function") ? mod : Math.round),
                            pr: 0,
                            c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : (parseFloat(end) - s) || 0
                        },
                        blob;
                    if (typeof(s) !== "number" || (typeof(end) !== "number" && !isRelative)) {
                        if (funcParam || isNaN(s) || (!isRelative && isNaN(end)) || typeof(s) === "boolean" || typeof(end) === "boolean") {
                            pt.fp = funcParam;
                            blob = _blobDif(s, (isRelative ? (parseFloat(pt.s) + pt.c) + (pt.s + "").replace(/[0-9\-\.]/g, "") : end), stringFilter || TweenLite.defaultStringFilter, pt);
                            pt = {
                                t: blob,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 2,
                                pg: 0,
                                n: overwriteProp || prop,
                                pr: 0,
                                m: 0
                            };
                        } else {
                            pt.s = parseFloat(s);
                            if (!isRelative) {
                                pt.c = (parseFloat(end) - pt.s) || 0;
                            }
                        }
                    }
                    if (pt.c) {
                        if ((pt._next = this._firstPT)) {
                            pt._next._prev = pt;
                        }
                        this._firstPT = pt;
                        return pt;
                    }
                },
                _internals = TweenLite._internals = {
                    isArray: _isArray,
                    isSelector: _isSelector,
                    lazyTweens: _lazyTweens,
                    blobDif: _blobDif
                },
                _plugins = TweenLite._plugins = {},
                _tweenLookup = _internals.tweenLookup = {},
                _tweenLookupNum = 0,
                _reservedProps = _internals.reservedProps = {
                    ease: 1,
                    delay: 1,
                    overwrite: 1,
                    onComplete: 1,
                    onCompleteParams: 1,
                    onCompleteScope: 1,
                    useFrames: 1,
                    runBackwards: 1,
                    startAt: 1,
                    onUpdate: 1,
                    onUpdateParams: 1,
                    onUpdateScope: 1,
                    onStart: 1,
                    onStartParams: 1,
                    onStartScope: 1,
                    onReverseComplete: 1,
                    onReverseCompleteParams: 1,
                    onReverseCompleteScope: 1,
                    onRepeat: 1,
                    onRepeatParams: 1,
                    onRepeatScope: 1,
                    easeParams: 1,
                    yoyo: 1,
                    immediateRender: 1,
                    repeat: 1,
                    repeatDelay: 1,
                    data: 1,
                    paused: 1,
                    reversed: 1,
                    autoCSS: 1,
                    lazy: 1,
                    onOverwrite: 1,
                    callbackScope: 1,
                    stringFilter: 1,
                    id: 1,
                    yoyoEase: 1
                },
                _overwriteLookup = {
                    none: 0,
                    all: 1,
                    auto: 2,
                    concurrent: 3,
                    allOnStart: 4,
                    preexisting: 5,
                    "true": 1,
                    "false": 0
                },
                _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
                _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
                _nextGCFrame = 30,
                _lazyRender = _internals.lazyRender = function() {
                    var i = _lazyTweens.length,
                        tween;
                    _lazyLookup = {};
                    while (--i > -1) {
                        tween = _lazyTweens[i];
                        if (tween && tween._lazy !== false) {
                            tween.render(tween._lazy[0], tween._lazy[1], true);
                            tween._lazy = false;
                        }
                    }
                    _lazyTweens.length = 0;
                };
            _rootTimeline._startTime = _ticker.time;
            _rootFramesTimeline._startTime = _ticker.frame;
            _rootTimeline._active = _rootFramesTimeline._active = true;
            setTimeout(_lazyRender, 1);
            Animation._updateRoot = TweenLite.render = function() {
                var i, a, p;
                if (_lazyTweens.length) {
                    _lazyRender();
                }
                _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
                _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
                if (_lazyTweens.length) {
                    _lazyRender();
                }
                if (_ticker.frame >= _nextGCFrame) {
                    _nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
                    for (p in _tweenLookup) {
                        a = _tweenLookup[p].tweens;
                        i = a.length;
                        while (--i > -1) {
                            if (a[i]._gc) {
                                a.splice(i, 1);
                            }
                        }
                        if (a.length === 0) {
                            delete _tweenLookup[p];
                        }
                    }
                    p = _rootTimeline._first;
                    if (!p || p._paused)
                        if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
                            while (p && p._paused) {
                                p = p._next;
                            }
                            if (!p) {
                                _ticker.sleep();
                            }
                        }
                }
            };
            _ticker.addEventListener("tick", Animation._updateRoot);
            var _register = function(target, tween, scrub) {
                    var id = target._gsTweenID,
                        a, i;
                    if (!_tweenLookup[id || (target._gsTweenID = id = "t" + (_tweenLookupNum++))]) {
                        _tweenLookup[id] = {
                            target: target,
                            tweens: []
                        };
                    }
                    if (tween) {
                        a = _tweenLookup[id].tweens;
                        a[(i = a.length)] = tween;
                        if (scrub) {
                            while (--i > -1) {
                                if (a[i] === tween) {
                                    a.splice(i, 1);
                                }
                            }
                        }
                    }
                    return _tweenLookup[id].tweens;
                },
                _onOverwrite = function(overwrittenTween, overwritingTween, target, killedProps) {
                    var func = overwrittenTween.vars.onOverwrite,
                        r1, r2;
                    if (func) {
                        r1 = func(overwrittenTween, overwritingTween, target, killedProps);
                    }
                    func = TweenLite.onOverwrite;
                    if (func) {
                        r2 = func(overwrittenTween, overwritingTween, target, killedProps);
                    }
                    return (r1 !== false && r2 !== false);
                },
                _applyOverwrite = function(target, tween, props, mode, siblings) {
                    var i, changed, curTween, l;
                    if (mode === 1 || mode >= 4) {
                        l = siblings.length;
                        for (i = 0; i < l; i++) {
                            if ((curTween = siblings[i]) !== tween) {
                                if (!curTween._gc) {
                                    if (curTween._kill(null, target, tween)) {
                                        changed = true;
                                    }
                                }
                            } else if (mode === 5) {
                                break;
                            }
                        }
                        return changed;
                    }
                    var startTime = tween._startTime + _tinyNum,
                        overlaps = [],
                        oCount = 0,
                        zeroDur = (tween._duration === 0),
                        globalStart;
                    i = siblings.length;
                    while (--i > -1) {
                        if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {} else if (curTween._timeline !== tween._timeline) {
                            globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
                            if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
                                overlaps[oCount++] = curTween;
                            }
                        } else if (curTween._startTime <= startTime)
                            if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime)
                                if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
                                    overlaps[oCount++] = curTween;
                                }
                    }
                    i = oCount;
                    while (--i > -1) {
                        curTween = overlaps[i];
                        if (mode === 2)
                            if (curTween._kill(props, target, tween)) {
                                changed = true;
                            }
                        if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
                            if (mode !== 2 && !_onOverwrite(curTween, tween)) {
                                continue;
                            }
                            if (curTween._enabled(false, false)) {
                                changed = true;
                            }
                        }
                    }
                    return changed;
                },
                _checkOverlap = function(tween, reference, zeroDur) {
                    var tl = tween._timeline,
                        ts = tl._timeScale,
                        t = tween._startTime;
                    while (tl._timeline) {
                        t += tl._startTime;
                        ts *= tl._timeScale;
                        if (tl._paused) {
                            return -100;
                        }
                        tl = tl._timeline;
                    }
                    t /= ts;
                    return (t > reference) ? t - reference : ((zeroDur && t === reference) || (!tween._initted && t - reference < 2 * _tinyNum)) ? _tinyNum : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum) ? 0 : t - reference - _tinyNum;
                };
            p._init = function() {
                var v = this.vars,
                    op = this._overwrittenProps,
                    dur = this._duration,
                    immediate = !!v.immediateRender,
                    ease = v.ease,
                    i, initPlugins, pt, p, startVars, l;
                if (v.startAt) {
                    if (this._startAt) {
                        this._startAt.render(-1, true);
                        this._startAt.kill();
                    }
                    startVars = {};
                    for (p in v.startAt) {
                        startVars[p] = v.startAt[p];
                    }
                    startVars.data = "isStart";
                    startVars.overwrite = false;
                    startVars.immediateRender = true;
                    startVars.lazy = (immediate && v.lazy !== false);
                    startVars.startAt = startVars.delay = null;
                    startVars.onUpdate = v.onUpdate;
                    startVars.onUpdateParams = v.onUpdateParams;
                    startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
                    this._startAt = TweenLite.to(this.target || {}, 0, startVars);
                    if (immediate) {
                        if (this._time > 0) {
                            this._startAt = null;
                        } else if (dur !== 0) {
                            return;
                        }
                    }
                } else if (v.runBackwards && dur !== 0) {
                    if (this._startAt) {
                        this._startAt.render(-1, true);
                        this._startAt.kill();
                        this._startAt = null;
                    } else {
                        if (this._time !== 0) {
                            immediate = false;
                        }
                        pt = {};
                        for (p in v) {
                            if (!_reservedProps[p] || p === "autoCSS") {
                                pt[p] = v[p];
                            }
                        }
                        pt.overwrite = 0;
                        pt.data = "isFromStart";
                        pt.lazy = (immediate && v.lazy !== false);
                        pt.immediateRender = immediate;
                        this._startAt = TweenLite.to(this.target, 0, pt);
                        if (!immediate) {
                            this._startAt._init();
                            this._startAt._enabled(false);
                            if (this.vars.immediateRender) {
                                this._startAt = null;
                            }
                        } else if (this._time === 0) {
                            return;
                        }
                    }
                }
                this._ease = ease = (!ease) ? TweenLite.defaultEase : (ease instanceof Ease) ? ease : (typeof(ease) === "function") ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
                if (v.easeParams instanceof Array && ease.config) {
                    this._ease = ease.config.apply(ease, v.easeParams);
                }
                this._easeType = this._ease._type;
                this._easePower = this._ease._power;
                this._firstPT = null;
                if (this._targets) {
                    l = this._targets.length;
                    for (i = 0; i < l; i++) {
                        if (this._initProps(this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (op ? op[i] : null), i)) {
                            initPlugins = true;
                        }
                    }
                } else {
                    initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
                }
                if (initPlugins) {
                    TweenLite._onPluginEvent("_onInitAllProps", this);
                }
                if (op)
                    if (!this._firstPT)
                        if (typeof(this.target) !== "function") {
                            this._enabled(false, false);
                        }
                if (v.runBackwards) {
                    pt = this._firstPT;
                    while (pt) {
                        pt.s += pt.c;
                        pt.c = -pt.c;
                        pt = pt._next;
                    }
                }
                this._onUpdate = v.onUpdate;
                this._initted = true;
            };
            p._initProps = function(target, propLookup, siblings, overwrittenProps, index) {
                var p, i, initPlugins, plugin, pt, v;
                if (target == null) {
                    return false;
                }
                if (_lazyLookup[target._gsTweenID]) {
                    _lazyRender();
                }
                if (!this.vars.css)
                    if (target.style)
                        if (target !== window && target.nodeType)
                            if (_plugins.css)
                                if (this.vars.autoCSS !== false) {
                                    _autoCSS(this.vars, target);
                                }
                for (p in this.vars) {
                    v = this.vars[p];
                    if (_reservedProps[p]) {
                        if (v)
                            if ((v instanceof Array) || (v.push && _isArray(v)))
                                if (v.join("").indexOf("{self}") !== -1) {
                                    this.vars[p] = v = this._swapSelfInParams(v, this);
                                }
                    } else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {
                        this._firstPT = pt = {
                            _next: this._firstPT,
                            t: plugin,
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 1,
                            n: p,
                            pg: 1,
                            pr: plugin._priority,
                            m: 0
                        };
                        i = plugin._overwriteProps.length;
                        while (--i > -1) {
                            propLookup[plugin._overwriteProps[i]] = this._firstPT;
                        }
                        if (plugin._priority || plugin._onInitAllProps) {
                            initPlugins = true;
                        }
                        if (plugin._onDisable || plugin._onEnable) {
                            this._notifyPluginsOfEnabled = true;
                        }
                        if (pt._next) {
                            pt._next._prev = pt;
                        }
                    } else {
                        propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
                    }
                }
                if (overwrittenProps)
                    if (this._kill(overwrittenProps, target)) {
                        return this._initProps(target, propLookup, siblings, overwrittenProps, index);
                    }
                if (this._overwrite > 1)
                    if (this._firstPT)
                        if (siblings.length > 1)
                            if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
                                this._kill(propLookup, target);
                                return this._initProps(target, propLookup, siblings, overwrittenProps, index);
                            }
                if (this._firstPT)
                    if ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration)) {
                        _lazyLookup[target._gsTweenID] = true;
                    }
                return initPlugins;
            };
            p.render = function(time, suppressEvents, force) {
                var prevTime = this._time,
                    duration = this._duration,
                    prevRawPrevTime = this._rawPrevTime,
                    isComplete, callback, pt, rawPrevTime;
                if (time >= duration - 0.0000001 && time >= 0) {
                    this._totalTime = this._time = duration;
                    this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
                    if (!this._reversed) {
                        isComplete = true;
                        callback = "onComplete";
                        force = (force || this._timeline.autoRemoveChildren);
                    }
                    if (duration === 0)
                        if (this._initted || !this.vars.lazy || force) {
                            if (this._startTime === this._timeline._duration) {
                                time = 0;
                            }
                            if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause"))
                                if (prevRawPrevTime !== time) {
                                    force = true;
                                    if (prevRawPrevTime > _tinyNum) {
                                        callback = "onReverseComplete";
                                    }
                                }
                            this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum;
                        }
                } else if (time < 0.0000001) {
                    this._totalTime = this._time = 0;
                    this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
                    if (prevTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
                        callback = "onReverseComplete";
                        isComplete = this._reversed;
                    }
                    if (time < 0) {
                        this._active = false;
                        if (duration === 0)
                            if (this._initted || !this.vars.lazy || force) {
                                if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
                                    force = true;
                                }
                                this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum;
                            }
                    }
                    if (!this._initted || (this._startAt && this._startAt.progress())) {
                        force = true;
                    }
                } else {
                    this._totalTime = this._time = time;
                    if (this._easeType) {
                        var r = time / duration,
                            type = this._easeType,
                            pow = this._easePower;
                        if (type === 1 || (type === 3 && r >= 0.5)) {
                            r = 1 - r;
                        }
                        if (type === 3) {
                            r *= 2;
                        }
                        if (pow === 1) {
                            r *= r;
                        } else if (pow === 2) {
                            r *= r * r;
                        } else if (pow === 3) {
                            r *= r * r * r;
                        } else if (pow === 4) {
                            r *= r * r * r * r;
                        }
                        if (type === 1) {
                            this.ratio = 1 - r;
                        } else if (type === 2) {
                            this.ratio = r;
                        } else if (time / duration < 0.5) {
                            this.ratio = r / 2;
                        } else {
                            this.ratio = 1 - (r / 2);
                        }
                    } else {
                        this.ratio = this._ease.getRatio(time / duration);
                    }
                }
                if (this._time === prevTime && !force) {
                    return;
                } else if (!this._initted) {
                    this._init();
                    if (!this._initted || this._gc) {
                        return;
                    } else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
                        this._time = this._totalTime = prevTime;
                        this._rawPrevTime = prevRawPrevTime;
                        _lazyTweens.push(this);
                        this._lazy = [time, suppressEvents];
                        return;
                    }
                    if (this._time && !isComplete) {
                        this.ratio = this._ease.getRatio(this._time / duration);
                    } else if (isComplete && this._ease._calcEnd) {
                        this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
                    }
                }
                if (this._lazy !== false) {
                    this._lazy = false;
                }
                if (!this._active)
                    if (!this._paused && this._time !== prevTime && time >= 0) {
                        this._active = true;
                    }
                if (prevTime === 0) {
                    if (this._startAt) {
                        if (time >= 0) {
                            this._startAt.render(time, true, force);
                        } else if (!callback) {
                            callback = "_dummyGS";
                        }
                    }
                    if (this.vars.onStart)
                        if (this._time !== 0 || duration === 0)
                            if (!suppressEvents) {
                                this._callback("onStart");
                            }
                }
                pt = this._firstPT;
                while (pt) {
                    if (pt.f) {
                        pt.t[pt.p](pt.c * this.ratio + pt.s);
                    } else {
                        pt.t[pt.p] = pt.c * this.ratio + pt.s;
                    }
                    pt = pt._next;
                }
                if (this._onUpdate) {
                    if (time < 0)
                        if (this._startAt && time !== -0.0001) {
                            this._startAt.render(time, true, force);
                        }
                    if (!suppressEvents)
                        if (this._time !== prevTime || isComplete || force) {
                            this._callback("onUpdate");
                        }
                }
                if (callback)
                    if (!this._gc || force) {
                        if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) {
                            this._startAt.render(time, true, force);
                        }
                        if (isComplete) {
                            if (this._timeline.autoRemoveChildren) {
                                this._enabled(false, false);
                            }
                            this._active = false;
                        }
                        if (!suppressEvents && this.vars[callback]) {
                            this._callback(callback);
                        }
                        if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
                            this._rawPrevTime = 0;
                        }
                    }
            };
            p._kill = function(vars, target, overwritingTween) {
                if (vars === "all") {
                    vars = null;
                }
                if (vars == null)
                    if (target == null || target === this.target) {
                        this._lazy = false;
                        return this._enabled(false, false);
                    }
                target = (typeof(target) !== "string") ? (target || this._targets || this.target) : TweenLite.selector(target) || target;
                var simultaneousOverwrite = (overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline),
                    i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
                if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
                    i = target.length;
                    while (--i > -1) {
                        if (this._kill(vars, target[i], overwritingTween)) {
                            changed = true;
                        }
                    }
                } else {
                    if (this._targets) {
                        i = this._targets.length;
                        while (--i > -1) {
                            if (target === this._targets[i]) {
                                propLookup = this._propLookup[i] || {};
                                this._overwrittenProps = this._overwrittenProps || [];
                                overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
                                break;
                            }
                        }
                    } else if (target !== this.target) {
                        return false;
                    } else {
                        propLookup = this._propLookup;
                        overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
                    }
                    if (propLookup) {
                        killProps = vars || propLookup;
                        record = (vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof(vars) !== "object" || !vars._tempKill));
                        if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
                            for (p in killProps) {
                                if (propLookup[p]) {
                                    if (!killed) {
                                        killed = [];
                                    }
                                    killed.push(p);
                                }
                            }
                            if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
                                return false;
                            }
                        }
                        for (p in killProps) {
                            if ((pt = propLookup[p])) {
                                if (simultaneousOverwrite) {
                                    if (pt.f) {
                                        pt.t[pt.p](pt.s);
                                    } else {
                                        pt.t[pt.p] = pt.s;
                                    }
                                    changed = true;
                                }
                                if (pt.pg && pt.t._kill(killProps)) {
                                    changed = true;
                                }
                                if (!pt.pg || pt.t._overwriteProps.length === 0) {
                                    if (pt._prev) {
                                        pt._prev._next = pt._next;
                                    } else if (pt === this._firstPT) {
                                        this._firstPT = pt._next;
                                    }
                                    if (pt._next) {
                                        pt._next._prev = pt._prev;
                                    }
                                    pt._next = pt._prev = null;
                                }
                                delete propLookup[p];
                            }
                            if (record) {
                                overwrittenProps[p] = 1;
                            }
                        }
                        if (!this._firstPT && this._initted) {
                            this._enabled(false, false);
                        }
                    }
                }
                return changed;
            };
            p.invalidate = function() {
                if (this._notifyPluginsOfEnabled) {
                    TweenLite._onPluginEvent("_onDisable", this);
                }
                this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
                this._notifyPluginsOfEnabled = this._active = this._lazy = false;
                this._propLookup = (this._targets) ? {} : [];
                Animation.prototype.invalidate.call(this);
                if (this.vars.immediateRender) {
                    this._time = -_tinyNum;
                    this.render(Math.min(0, -this._delay));
                }
                return this;
            };
            p._enabled = function(enabled, ignoreTimeline) {
                if (!_tickerActive) {
                    _ticker.wake();
                }
                if (enabled && this._gc) {
                    var targets = this._targets,
                        i;
                    if (targets) {
                        i = targets.length;
                        while (--i > -1) {
                            this._siblings[i] = _register(targets[i], this, true);
                        }
                    } else {
                        this._siblings = _register(this.target, this, true);
                    }
                }
                Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
                if (this._notifyPluginsOfEnabled)
                    if (this._firstPT) {
                        return TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
                    }
                return false;
            };
            TweenLite.to = function(target, duration, vars) {
                return new TweenLite(target, duration, vars);
            };
            TweenLite.from = function(target, duration, vars) {
                vars.runBackwards = true;
                vars.immediateRender = (vars.immediateRender != false);
                return new TweenLite(target, duration, vars);
            };
            TweenLite.fromTo = function(target, duration, fromVars, toVars) {
                toVars.startAt = fromVars;
                toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
                return new TweenLite(target, duration, toVars);
            };
            TweenLite.delayedCall = function(delay, callback, params, scope, useFrames) {
                return new TweenLite(callback, 0, {
                    delay: delay,
                    onComplete: callback,
                    onCompleteParams: params,
                    callbackScope: scope,
                    onReverseComplete: callback,
                    onReverseCompleteParams: params,
                    immediateRender: false,
                    lazy: false,
                    useFrames: useFrames,
                    overwrite: 0
                });
            };
            TweenLite.set = function(target, vars) {
                return new TweenLite(target, 0, vars);
            };
            TweenLite.getTweensOf = function(target, onlyActive) {
                if (target == null) {
                    return [];
                }
                target = (typeof(target) !== "string") ? target : TweenLite.selector(target) || target;
                var i, a, j, t;
                if ((_isArray(target) || _isSelector(target)) && typeof(target[0]) !== "number") {
                    i = target.length;
                    a = [];
                    while (--i > -1) {
                        a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
                    }
                    i = a.length;
                    while (--i > -1) {
                        t = a[i];
                        j = i;
                        while (--j > -1) {
                            if (t === a[j]) {
                                a.splice(i, 1);
                            }
                        }
                    }
                } else if (target._gsTweenID) {
                    a = _register(target).concat();
                    i = a.length;
                    while (--i > -1) {
                        if (a[i]._gc || (onlyActive && !a[i].isActive())) {
                            a.splice(i, 1);
                        }
                    }
                }
                return a || [];
            };
            TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function(target, onlyActive, vars) {
                if (typeof(onlyActive) === "object") {
                    vars = onlyActive;
                    onlyActive = false;
                }
                var a = TweenLite.getTweensOf(target, onlyActive),
                    i = a.length;
                while (--i > -1) {
                    a[i]._kill(vars, target);
                }
            };
            var TweenPlugin = _class("plugins.TweenPlugin", function(props, priority) {
                this._overwriteProps = (props || "").split(",");
                this._propName = this._overwriteProps[0];
                this._priority = priority || 0;
                this._super = TweenPlugin.prototype;
            }, true);
            p = TweenPlugin.prototype;
            TweenPlugin.version = "1.19.0";
            TweenPlugin.API = 2;
            p._firstPT = null;
            p._addTween = _addPropTween;
            p.setRatio = _setRatio;
            p._kill = function(lookup) {
                var a = this._overwriteProps,
                    pt = this._firstPT,
                    i;
                if (lookup[this._propName] != null) {
                    this._overwriteProps = [];
                } else {
                    i = a.length;
                    while (--i > -1) {
                        if (lookup[a[i]] != null) {
                            a.splice(i, 1);
                        }
                    }
                }
                while (pt) {
                    if (lookup[pt.n] != null) {
                        if (pt._next) {
                            pt._next._prev = pt._prev;
                        }
                        if (pt._prev) {
                            pt._prev._next = pt._next;
                            pt._prev = null;
                        } else if (this._firstPT === pt) {
                            this._firstPT = pt._next;
                        }
                    }
                    pt = pt._next;
                }
                return false;
            };
            p._mod = p._roundProps = function(lookup) {
                var pt = this._firstPT,
                    val;
                while (pt) {
                    val = lookup[this._propName] || (pt.n != null && lookup[pt.n.split(this._propName + "_").join("")]);
                    if (val && typeof(val) === "function") {
                        if (pt.f === 2) {
                            pt.t._applyPT.m = val;
                        } else {
                            pt.m = val;
                        }
                    }
                    pt = pt._next;
                }
            };
            TweenLite._onPluginEvent = function(type, tween) {
                var pt = tween._firstPT,
                    changed, pt2, first, last, next;
                if (type === "_onInitAllProps") {
                    while (pt) {
                        next = pt._next;
                        pt2 = first;
                        while (pt2 && pt2.pr > pt.pr) {
                            pt2 = pt2._next;
                        }
                        if ((pt._prev = pt2 ? pt2._prev : last)) {
                            pt._prev._next = pt;
                        } else {
                            first = pt;
                        }
                        if ((pt._next = pt2)) {
                            pt2._prev = pt;
                        } else {
                            last = pt;
                        }
                        pt = next;
                    }
                    pt = tween._firstPT = first;
                }
                while (pt) {
                    if (pt.pg)
                        if (typeof(pt.t[type]) === "function")
                            if (pt.t[type]()) {
                                changed = true;
                            }
                    pt = pt._next;
                }
                return changed;
            };
            TweenPlugin.activate = function(plugins) {
                var i = plugins.length;
                while (--i > -1) {
                    if (plugins[i].API === TweenPlugin.API) {
                        _plugins[(new plugins[i]())._propName] = plugins[i];
                    }
                }
                return true;
            };
            _gsDefine.plugin = function(config) {
                if (!config || !config.propName || !config.init || !config.API) {
                    throw "illegal plugin definition.";
                }
                var propName = config.propName,
                    priority = config.priority || 0,
                    overwriteProps = config.overwriteProps,
                    map = {
                        init: "_onInitTween",
                        set: "setRatio",
                        kill: "_kill",
                        round: "_mod",
                        mod: "_mod",
                        initAll: "_onInitAllProps"
                    },
                    Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function() {
                        TweenPlugin.call(this, propName, priority);
                        this._overwriteProps = overwriteProps || [];
                    }, (config.global === true)),
                    p = Plugin.prototype = new TweenPlugin(propName),
                    prop;
                p.constructor = Plugin;
                Plugin.API = config.API;
                for (prop in map) {
                    if (typeof(config[prop]) === "function") {
                        p[map[prop]] = config[prop];
                    }
                }
                Plugin.version = config.version;
                TweenPlugin.activate([Plugin]);
                return Plugin;
            };
            a = window._gsQueue;
            if (a) {
                for (i = 0; i < a.length; i++) {
                    a[i]();
                }
                for (p in _defLookup) {
                    if (!_defLookup[p].func) {
                        window.console.log("GSAP encountered missing dependency: " + p);
                    }
                }
            }
            _tickerActive = false;
            return TweenLite;
        })(_gsScope, "TweenLite");
        __webpack_exports__["TweenLite"] = TweenLite;
        const gs = _gsScope.com.greensock;
        const SimpleTimeline = gs.core.SimpleTimeline;
        __webpack_exports__["SimpleTimeline"] = SimpleTimeline;
        const Animation = gs.core.Animation;
        __webpack_exports__["Animation"] = Animation;
        const Ease = _gsScope.Ease;
        __webpack_exports__["Ease"] = Ease;
        const Linear = _gsScope.Linear;
        __webpack_exports__["Linear"] = Linear;
        const Power0 = Linear;
        __webpack_exports__["Power0"] = Power0;
        const Power1 = _gsScope.Power1;
        __webpack_exports__["Power1"] = Power1;
        const Power2 = _gsScope.Power2;
        __webpack_exports__["Power2"] = Power2;
        const Power3 = _gsScope.Power3;
        __webpack_exports__["Power3"] = Power3;
        const Power4 = _gsScope.Power4;
        __webpack_exports__["Power4"] = Power4;
        const TweenPlugin = _gsScope.TweenPlugin;
        __webpack_exports__["TweenPlugin"] = TweenPlugin;
        const EventDispatcher = gs.events.EventDispatcher;
        __webpack_exports__["EventDispatcher"] = EventDispatcher;
    }.call(__webpack_exports__, __webpack_require__(40)(module), __webpack_require__(6)))
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.isFirefox = exports.destroyInstances = exports.getRandomFloat = exports.getRandomInt = exports.parseHTML = exports.removeElem = exports.NodeList = exports.stringToDOM = exports.toNodeList = exports.hasClass = exports.removeClass = exports.addClass = exports.toggleClass = exports.data = exports.qsa = exports.qs = exports.byClassName = exports.byId = undefined;
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    exports.handleEvent = handleEvent;
    exports.createconfig = createconfig;
    exports.index = index;
    exports.eq = eq;
    exports.inViewport = inViewport;
    exports.getDevice = getDevice;
    exports.isMobile = isMobile;
    exports.calculateRatio = calculateRatio;
    exports.lerp = lerp;
    exports.viewportSize = viewportSize;
    exports.degrees = degrees;
    exports.radians = radians;
    var _classie = __webpack_require__(52);
    var _classie2 = _interopRequireDefault(_classie);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var camelCaseRegExp = /-([a-z])/ig;
    var toCamelCase = function toCamelCase(str) {
        return str.replace(camelCaseRegExp, function(match) {
            return match[1].toUpperCase();
        });
    };
    var byId = exports.byId = function byId(id) {
        return document.getElementById(id);
    };
    var byClassName = exports.byClassName = function byClassName(selector) {
        var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
        Array.toArray(ctx.getElementsByClassName(selector));
    };
    var qs = exports.qs = function qs(selector) {
        var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
        return ctx.querySelector(selector);
    };
    var qsa = exports.qsa = function qsa(selector) {
        var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
        return Array.from(ctx.querySelectorAll(selector));
    };
    var data = exports.data = function data(attr, ctx) {
        return ctx.hasAttribute('data-' + attr) ? ctx.getAttribute('data-' + attr) : '';
    };
    var toggleClass = exports.toggleClass = function toggleClass(el, className, toggle) {
        var fn = toggle === undefined ? 'toggle' : toggle ? 'add' : 'remove';
        _classie2.default[fn](el, className);
    };
    var addClass = exports.addClass = function addClass(el, className) {
        _classie2.default.add(el, className);
    };
    var removeClass = exports.removeClass = function removeClass(el, className) {
        _classie2.default.remove(el, className);
    };
    var hasClass = exports.hasClass = function hasClass(el, className) {
        return _classie2.default['has'](el, className);
    };
    var toNodeList = exports.toNodeList = function toNodeList(elements) {
        return new NodeList(elements);
    };

    function handleEvent(eventName) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            onElement = _ref.onElement,
            withCallback = _ref.withCallback,
            _ref$useCapture = _ref.useCapture,
            useCapture = _ref$useCapture === undefined ? false : _ref$useCapture;
        var thisArg = arguments[2];
        var element = onElement || document.documentElement;

        function handler(event) {
            if (typeof withCallback === 'function') {
                withCallback.call(thisArg, event);
            }
        }
        handler.destroy = function destroy() {
            return element.removeEventListener(eventName, handler, useCapture);
        };
        element.addEventListener(eventName, handler, useCapture);
        return handler;
    }

    function createconfig() {
        var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var config = arguments[1];
        return Object.assign({}, config, o);
    }
    var stringToDOM = exports.stringToDOM = function stringToDOM() {
        var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var fragment = document.createDocumentFragment();
        var wrapper = fragment.appendChild(document.createElement('div'));
        wrapper.innerHTML = string.trim();
        return wrapper.children[0];
    };

    function index(element) {
        var sib = element.parentNode.childNodes;
        var n = 0;
        for (var i = 0; i < sib.length; i += 1) {
            if (sib[i] === element) return n;
            if (sib[i].nodeType === 1) n += 1;
        }
        return -1;
    }

    function eq(parent, i) {
        return i >= 0 && i < parent.length ? parent[i] : -1;
    }

    function inViewport(element) {
        var rect = element.getBoundingClientRect();
        var html = document.documentElement;
        return rect.top >= 0 && rect.top < html.clientHeight || rect.bottom >= 0 && rect.bottom < html.clientHeight;
    }

    function getDevice() {
        var device = window.getComputedStyle(document.body, '::after').getPropertyValue('content');
        device = device.replace(/('|")/g, '');
        return device;
    }

    function isMobile() {
        return !(getDevice() !== 'xs' && getDevice() !== 'sm');
    }

    function calculateRatio(width, height) {
        return width / height;
    }

    function lerp(a, b, n) {
        return (1 - n) * a + n * b;
    }

    function viewportSize() {
        var coords = {
            x: window.innerWidth,
            y: window.innerHeight,
            ratio: window.innerWidth / window.innerHeight
        };
        window.addEventListener('resize', function() {
            coords = {
                x: window.innerWidth,
                y: window.innerHeight,
                ratio: window.innerWidth / window.innerHeight
            };
        });
        return coords;
    }
    var NodeList = function() {
        function NodeList(elements) {
            var ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
            _classCallCheck(this, NodeList);
            this.els = typeof elements === 'string' ? qsa(elements, ctx) : Array.from(elements);
        }
        _createClass(NodeList, [{
            key: 'toArray',
            value: function toArray() {
                return this.els;
            }
        }, {
            key: 'eq',
            value: function eq(index) {
                return this.els[index];
            }
        }, {
            key: 'indexOf',
            value: function indexOf(target) {
                return this.els.indexOf(target);
            }
        }, {
            key: 'attr',
            value: function attr(_attr, value) {
                var els = this.els;
                var attrStr = toCamelCase(_attr);
                if (value) {
                    this.els.forEach(function(el) {
                        return el[attrStr] = value;
                    });
                    return this;
                }
                var el = els.length > 0 ? els[0] : undefined;
                var hook = NodeList.attrHooks[attrStr];
                if (!el) {
                    return undefined;
                }
                return hook ? hook(el) : el[attrStr];
            }
        }, {
            key: 'addClass',
            value: function addClass(className) {
                this.els.forEach(function(el) {
                    return _classie2.default.add(el, className);
                });
                return this;
            }
        }, {
            key: 'removeClass',
            value: function removeClass(className) {
                this.els.forEach(function(el) {
                    return _classie2.default.remove(el, className);
                });
                return this;
            }
        }, {
            key: 'toggleClass',
            value: function toggleClass(className, toggle) {
                var fn = toggle === undefined ? 'toggle' : toggle ? 'add' : 'remove';
                this.els.forEach(function(el) {
                    return _classie2.default[fn](el, className);
                });
                return this;
            }
        }]);
        return NodeList;
    }();
    exports.NodeList = NodeList;
    NodeList.attrHooks = {
        'for': function _for(el) {
            return el.htmlFor;
        },
        'class': function _class(el) {
            return el.className;
        }
    };

    function degrees(radians) {
        return radians * 180 / Math.PI;
    };

    function radians(degrees) {
        return degrees * Math.PI / 180;
    };
    var removeElem = exports.removeElem = function removeElem(elem) {
        var child = document.querySelector(elem);
        child.parentNode.removeChild(child);
    };
    var parseHTML = exports.parseHTML = function parseHTML(html) {
        var parser = new DOMParser();
        return parser.parseFromString(html, 'text/html');
    };
    var getRandomInt = exports.getRandomInt = function getRandomInt(a, b) {
        return Math.floor(Math.random() * b) + a;
    };
    var getRandomFloat = exports.getRandomFloat = function getRandomFloat(a, b) {
        return Math.random() * (b - a) + a;
    };
    var destroyInstances = exports.destroyInstances = function destroyInstances(to_destroy) {
        for (var instance in BUFFA[to_destroy]) {
            var idx = parseInt(instance);
            BUFFA[to_destroy][idx].destroy();
            BUFFA[to_destroy][idx] = null;
            delete BUFFA[to_destroy][idx];
        }
        BUFFA[to_destroy] = [];
    };
    var isFirefox = exports.isFirefox = function isFirefox(_) {
        return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
    };
}), (function(module, exports) {
    module.exports = jQuery;
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
    });
    __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() {
        return WebGLRenderTargetCube;
    });
    __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() {
        return WebGLRenderTarget;
    });
    __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() {
        return WebGLRenderer;
    });
    __webpack_require__.d(__webpack_exports__, "ShaderLib", function() {
        return ShaderLib;
    });
    __webpack_require__.d(__webpack_exports__, "UniformsLib", function() {
        return UniformsLib;
    });
    __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() {
        return UniformsUtils;
    });
    __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() {
        return ShaderChunk;
    });
    __webpack_require__.d(__webpack_exports__, "FogExp2", function() {
        return FogExp2;
    });
    __webpack_require__.d(__webpack_exports__, "Fog", function() {
        return Fog;
    });
    __webpack_require__.d(__webpack_exports__, "Scene", function() {
        return Scene;
    });
    __webpack_require__.d(__webpack_exports__, "LensFlare", function() {
        return LensFlare;
    });
    __webpack_require__.d(__webpack_exports__, "Sprite", function() {
        return Sprite;
    });
    __webpack_require__.d(__webpack_exports__, "LOD", function() {
        return LOD;
    });
    __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() {
        return SkinnedMesh;
    });
    __webpack_require__.d(__webpack_exports__, "Skeleton", function() {
        return Skeleton;
    });
    __webpack_require__.d(__webpack_exports__, "Bone", function() {
        return Bone;
    });
    __webpack_require__.d(__webpack_exports__, "Mesh", function() {
        return Mesh;
    });
    __webpack_require__.d(__webpack_exports__, "LineSegments", function() {
        return LineSegments;
    });
    __webpack_require__.d(__webpack_exports__, "LineLoop", function() {
        return LineLoop;
    });
    __webpack_require__.d(__webpack_exports__, "Line", function() {
        return Line;
    });
    __webpack_require__.d(__webpack_exports__, "Points", function() {
        return Points;
    });
    __webpack_require__.d(__webpack_exports__, "Group", function() {
        return Group;
    });
    __webpack_require__.d(__webpack_exports__, "VideoTexture", function() {
        return VideoTexture;
    });
    __webpack_require__.d(__webpack_exports__, "DataTexture", function() {
        return DataTexture;
    });
    __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() {
        return CompressedTexture;
    });
    __webpack_require__.d(__webpack_exports__, "CubeTexture", function() {
        return CubeTexture;
    });
    __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() {
        return CanvasTexture;
    });
    __webpack_require__.d(__webpack_exports__, "DepthTexture", function() {
        return DepthTexture;
    });
    __webpack_require__.d(__webpack_exports__, "Texture", function() {
        return Texture;
    });
    __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() {
        return CompressedTextureLoader;
    });
    __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() {
        return DataTextureLoader;
    });
    __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() {
        return CubeTextureLoader;
    });
    __webpack_require__.d(__webpack_exports__, "TextureLoader", function() {
        return TextureLoader;
    });
    __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() {
        return ObjectLoader;
    });
    __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() {
        return MaterialLoader;
    });
    __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() {
        return BufferGeometryLoader;
    });
    __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() {
        return DefaultLoadingManager;
    });
    __webpack_require__.d(__webpack_exports__, "LoadingManager", function() {
        return LoadingManager;
    });
    __webpack_require__.d(__webpack_exports__, "JSONLoader", function() {
        return JSONLoader;
    });
    __webpack_require__.d(__webpack_exports__, "ImageLoader", function() {
        return ImageLoader;
    });
    __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() {
        return ImageBitmapLoader;
    });
    __webpack_require__.d(__webpack_exports__, "FontLoader", function() {
        return FontLoader;
    });
    __webpack_require__.d(__webpack_exports__, "FileLoader", function() {
        return FileLoader;
    });
    __webpack_require__.d(__webpack_exports__, "Loader", function() {
        return Loader;
    });
    __webpack_require__.d(__webpack_exports__, "LoaderUtils", function() {
        return LoaderUtils;
    });
    __webpack_require__.d(__webpack_exports__, "Cache", function() {
        return Cache;
    });
    __webpack_require__.d(__webpack_exports__, "AudioLoader", function() {
        return AudioLoader;
    });
    __webpack_require__.d(__webpack_exports__, "SpotLightShadow", function() {
        return SpotLightShadow;
    });
    __webpack_require__.d(__webpack_exports__, "SpotLight", function() {
        return SpotLight;
    });
    __webpack_require__.d(__webpack_exports__, "PointLight", function() {
        return PointLight;
    });
    __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() {
        return RectAreaLight;
    });
    __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() {
        return HemisphereLight;
    });
    __webpack_require__.d(__webpack_exports__, "DirectionalLightShadow", function() {
        return DirectionalLightShadow;
    });
    __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() {
        return DirectionalLight;
    });
    __webpack_require__.d(__webpack_exports__, "AmbientLight", function() {
        return AmbientLight;
    });
    __webpack_require__.d(__webpack_exports__, "LightShadow", function() {
        return LightShadow;
    });
    __webpack_require__.d(__webpack_exports__, "Light", function() {
        return Light;
    });
    __webpack_require__.d(__webpack_exports__, "StereoCamera", function() {
        return StereoCamera;
    });
    __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() {
        return PerspectiveCamera;
    });
    __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() {
        return OrthographicCamera;
    });
    __webpack_require__.d(__webpack_exports__, "CubeCamera", function() {
        return CubeCamera;
    });
    __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() {
        return ArrayCamera;
    });
    __webpack_require__.d(__webpack_exports__, "Camera", function() {
        return Camera;
    });
    __webpack_require__.d(__webpack_exports__, "AudioListener", function() {
        return AudioListener;
    });
    __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() {
        return PositionalAudio;
    });
    __webpack_require__.d(__webpack_exports__, "AudioContext", function() {
        return AudioContext;
    });
    __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() {
        return AudioAnalyser;
    });
    __webpack_require__.d(__webpack_exports__, "Audio", function() {
        return Audio;
    });
    __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() {
        return VectorKeyframeTrack;
    });
    __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() {
        return StringKeyframeTrack;
    });
    __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() {
        return QuaternionKeyframeTrack;
    });
    __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() {
        return NumberKeyframeTrack;
    });
    __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() {
        return ColorKeyframeTrack;
    });
    __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() {
        return BooleanKeyframeTrack;
    });
    __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() {
        return PropertyMixer;
    });
    __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() {
        return PropertyBinding;
    });
    __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() {
        return KeyframeTrack;
    });
    __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() {
        return AnimationUtils;
    });
    __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() {
        return AnimationObjectGroup;
    });
    __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() {
        return AnimationMixer;
    });
    __webpack_require__.d(__webpack_exports__, "AnimationClip", function() {
        return AnimationClip;
    });
    __webpack_require__.d(__webpack_exports__, "Uniform", function() {
        return Uniform;
    });
    __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() {
        return InstancedBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() {
        return BufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "Geometry", function() {
        return Geometry;
    });
    __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() {
        return InterleavedBufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() {
        return InstancedInterleavedBuffer;
    });
    __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() {
        return InterleavedBuffer;
    });
    __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() {
        return InstancedBufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Face3", function() {
        return Face3;
    });
    __webpack_require__.d(__webpack_exports__, "Object3D", function() {
        return Object3D;
    });
    __webpack_require__.d(__webpack_exports__, "Raycaster", function() {
        return Raycaster;
    });
    __webpack_require__.d(__webpack_exports__, "Layers", function() {
        return Layers;
    });
    __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() {
        return EventDispatcher;
    });
    __webpack_require__.d(__webpack_exports__, "Clock", function() {
        return Clock;
    });
    __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() {
        return QuaternionLinearInterpolant;
    });
    __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() {
        return LinearInterpolant;
    });
    __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() {
        return DiscreteInterpolant;
    });
    __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() {
        return CubicInterpolant;
    });
    __webpack_require__.d(__webpack_exports__, "Interpolant", function() {
        return Interpolant;
    });
    __webpack_require__.d(__webpack_exports__, "Triangle", function() {
        return Triangle;
    });
    __webpack_require__.d(__webpack_exports__, "Math", function() {
        return _Math;
    });
    __webpack_require__.d(__webpack_exports__, "Spherical", function() {
        return Spherical;
    });
    __webpack_require__.d(__webpack_exports__, "Cylindrical", function() {
        return Cylindrical;
    });
    __webpack_require__.d(__webpack_exports__, "Plane", function() {
        return Plane;
    });
    __webpack_require__.d(__webpack_exports__, "Frustum", function() {
        return Frustum;
    });
    __webpack_require__.d(__webpack_exports__, "Sphere", function() {
        return Sphere;
    });
    __webpack_require__.d(__webpack_exports__, "Ray", function() {
        return Ray;
    });
    __webpack_require__.d(__webpack_exports__, "Matrix4", function() {
        return Matrix4;
    });
    __webpack_require__.d(__webpack_exports__, "Matrix3", function() {
        return Matrix3;
    });
    __webpack_require__.d(__webpack_exports__, "Box3", function() {
        return Box3;
    });
    __webpack_require__.d(__webpack_exports__, "Box2", function() {
        return Box2;
    });
    __webpack_require__.d(__webpack_exports__, "Line3", function() {
        return Line3;
    });
    __webpack_require__.d(__webpack_exports__, "Euler", function() {
        return Euler;
    });
    __webpack_require__.d(__webpack_exports__, "Vector4", function() {
        return Vector4;
    });
    __webpack_require__.d(__webpack_exports__, "Vector3", function() {
        return Vector3;
    });
    __webpack_require__.d(__webpack_exports__, "Vector2", function() {
        return Vector2;
    });
    __webpack_require__.d(__webpack_exports__, "Quaternion", function() {
        return Quaternion;
    });
    __webpack_require__.d(__webpack_exports__, "Color", function() {
        return Color;
    });
    __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() {
        return ImmediateRenderObject;
    });
    __webpack_require__.d(__webpack_exports__, "VertexNormalsHelper", function() {
        return VertexNormalsHelper;
    });
    __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() {
        return SpotLightHelper;
    });
    __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() {
        return SkeletonHelper;
    });
    __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() {
        return PointLightHelper;
    });
    __webpack_require__.d(__webpack_exports__, "RectAreaLightHelper", function() {
        return RectAreaLightHelper;
    });
    __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() {
        return HemisphereLightHelper;
    });
    __webpack_require__.d(__webpack_exports__, "GridHelper", function() {
        return GridHelper;
    });
    __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() {
        return PolarGridHelper;
    });
    __webpack_require__.d(__webpack_exports__, "FaceNormalsHelper", function() {
        return FaceNormalsHelper;
    });
    __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() {
        return DirectionalLightHelper;
    });
    __webpack_require__.d(__webpack_exports__, "CameraHelper", function() {
        return CameraHelper;
    });
    __webpack_require__.d(__webpack_exports__, "BoxHelper", function() {
        return BoxHelper;
    });
    __webpack_require__.d(__webpack_exports__, "Box3Helper", function() {
        return Box3Helper;
    });
    __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() {
        return PlaneHelper;
    });
    __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() {
        return ArrowHelper;
    });
    __webpack_require__.d(__webpack_exports__, "AxesHelper", function() {
        return AxesHelper;
    });
    __webpack_require__.d(__webpack_exports__, "Shape", function() {
        return Shape;
    });
    __webpack_require__.d(__webpack_exports__, "Path", function() {
        return Path;
    });
    __webpack_require__.d(__webpack_exports__, "ShapePath", function() {
        return ShapePath;
    });
    __webpack_require__.d(__webpack_exports__, "Font", function() {
        return Font;
    });
    __webpack_require__.d(__webpack_exports__, "CurvePath", function() {
        return CurvePath;
    });
    __webpack_require__.d(__webpack_exports__, "Curve", function() {
        return Curve;
    });
    __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() {
        return ShapeUtils;
    });
    __webpack_require__.d(__webpack_exports__, "SceneUtils", function() {
        return SceneUtils;
    });
    __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() {
        return WebGLUtils;
    });
    __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() {
        return WireframeGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() {
        return ParametricGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() {
        return ParametricBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() {
        return TetrahedronGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() {
        return TetrahedronBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() {
        return OctahedronGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() {
        return OctahedronBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() {
        return IcosahedronGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() {
        return IcosahedronBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() {
        return DodecahedronGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() {
        return DodecahedronBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() {
        return PolyhedronGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() {
        return PolyhedronBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() {
        return TubeGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() {
        return TubeBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() {
        return TorusKnotGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() {
        return TorusKnotBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() {
        return TorusGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() {
        return TorusBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "TextGeometry", function() {
        return TextGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() {
        return TextBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() {
        return SphereGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() {
        return SphereBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "RingGeometry", function() {
        return RingGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() {
        return RingBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() {
        return PlaneGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() {
        return PlaneBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() {
        return LatheGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() {
        return LatheBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() {
        return ShapeGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() {
        return ShapeBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() {
        return ExtrudeGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() {
        return ExtrudeBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() {
        return EdgesGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() {
        return ConeGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() {
        return ConeBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() {
        return CylinderGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() {
        return CylinderBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() {
        return CircleGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() {
        return CircleBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() {
        return BoxGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() {
        return BoxBufferGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() {
        return ShadowMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() {
        return SpriteMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() {
        return RawShaderMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() {
        return ShaderMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() {
        return PointsMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() {
        return MeshPhysicalMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() {
        return MeshStandardMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() {
        return MeshPhongMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() {
        return MeshToonMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() {
        return MeshNormalMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() {
        return MeshLambertMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() {
        return MeshDepthMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() {
        return MeshDistanceMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() {
        return MeshBasicMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() {
        return LineDashedMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() {
        return LineBasicMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "Material", function() {
        return Material;
    });
    __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() {
        return Float64BufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() {
        return Float32BufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() {
        return Uint32BufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() {
        return Int32BufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() {
        return Uint16BufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() {
        return Int16BufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() {
        return Uint8ClampedBufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() {
        return Uint8BufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() {
        return Int8BufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() {
        return BufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "ArcCurve", function() {
        return ArcCurve;
    });
    __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() {
        return CatmullRomCurve3;
    });
    __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() {
        return CubicBezierCurve;
    });
    __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() {
        return CubicBezierCurve3;
    });
    __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() {
        return EllipseCurve;
    });
    __webpack_require__.d(__webpack_exports__, "LineCurve", function() {
        return LineCurve;
    });
    __webpack_require__.d(__webpack_exports__, "LineCurve3", function() {
        return LineCurve3;
    });
    __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() {
        return QuadraticBezierCurve;
    });
    __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() {
        return QuadraticBezierCurve3;
    });
    __webpack_require__.d(__webpack_exports__, "SplineCurve", function() {
        return SplineCurve;
    });
    __webpack_require__.d(__webpack_exports__, "REVISION", function() {
        return REVISION;
    });
    __webpack_require__.d(__webpack_exports__, "MOUSE", function() {
        return MOUSE;
    });
    __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() {
        return CullFaceNone;
    });
    __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() {
        return CullFaceBack;
    });
    __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() {
        return CullFaceFront;
    });
    __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() {
        return CullFaceFrontBack;
    });
    __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() {
        return FrontFaceDirectionCW;
    });
    __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() {
        return FrontFaceDirectionCCW;
    });
    __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() {
        return BasicShadowMap;
    });
    __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() {
        return PCFShadowMap;
    });
    __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() {
        return PCFSoftShadowMap;
    });
    __webpack_require__.d(__webpack_exports__, "FrontSide", function() {
        return FrontSide;
    });
    __webpack_require__.d(__webpack_exports__, "BackSide", function() {
        return BackSide;
    });
    __webpack_require__.d(__webpack_exports__, "DoubleSide", function() {
        return DoubleSide;
    });
    __webpack_require__.d(__webpack_exports__, "FlatShading", function() {
        return FlatShading;
    });
    __webpack_require__.d(__webpack_exports__, "SmoothShading", function() {
        return SmoothShading;
    });
    __webpack_require__.d(__webpack_exports__, "NoColors", function() {
        return NoColors;
    });
    __webpack_require__.d(__webpack_exports__, "FaceColors", function() {
        return FaceColors;
    });
    __webpack_require__.d(__webpack_exports__, "VertexColors", function() {
        return VertexColors;
    });
    __webpack_require__.d(__webpack_exports__, "NoBlending", function() {
        return NoBlending;
    });
    __webpack_require__.d(__webpack_exports__, "NormalBlending", function() {
        return NormalBlending;
    });
    __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() {
        return AdditiveBlending;
    });
    __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() {
        return SubtractiveBlending;
    });
    __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() {
        return MultiplyBlending;
    });
    __webpack_require__.d(__webpack_exports__, "CustomBlending", function() {
        return CustomBlending;
    });
    __webpack_require__.d(__webpack_exports__, "AddEquation", function() {
        return AddEquation;
    });
    __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() {
        return SubtractEquation;
    });
    __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() {
        return ReverseSubtractEquation;
    });
    __webpack_require__.d(__webpack_exports__, "MinEquation", function() {
        return MinEquation;
    });
    __webpack_require__.d(__webpack_exports__, "MaxEquation", function() {
        return MaxEquation;
    });
    __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() {
        return ZeroFactor;
    });
    __webpack_require__.d(__webpack_exports__, "OneFactor", function() {
        return OneFactor;
    });
    __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() {
        return SrcColorFactor;
    });
    __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() {
        return OneMinusSrcColorFactor;
    });
    __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() {
        return SrcAlphaFactor;
    });
    __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() {
        return OneMinusSrcAlphaFactor;
    });
    __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() {
        return DstAlphaFactor;
    });
    __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() {
        return OneMinusDstAlphaFactor;
    });
    __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() {
        return DstColorFactor;
    });
    __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() {
        return OneMinusDstColorFactor;
    });
    __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() {
        return SrcAlphaSaturateFactor;
    });
    __webpack_require__.d(__webpack_exports__, "NeverDepth", function() {
        return NeverDepth;
    });
    __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() {
        return AlwaysDepth;
    });
    __webpack_require__.d(__webpack_exports__, "LessDepth", function() {
        return LessDepth;
    });
    __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() {
        return LessEqualDepth;
    });
    __webpack_require__.d(__webpack_exports__, "EqualDepth", function() {
        return EqualDepth;
    });
    __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() {
        return GreaterEqualDepth;
    });
    __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() {
        return GreaterDepth;
    });
    __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() {
        return NotEqualDepth;
    });
    __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() {
        return MultiplyOperation;
    });
    __webpack_require__.d(__webpack_exports__, "MixOperation", function() {
        return MixOperation;
    });
    __webpack_require__.d(__webpack_exports__, "AddOperation", function() {
        return AddOperation;
    });
    __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() {
        return NoToneMapping;
    });
    __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() {
        return LinearToneMapping;
    });
    __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() {
        return ReinhardToneMapping;
    });
    __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() {
        return Uncharted2ToneMapping;
    });
    __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() {
        return CineonToneMapping;
    });
    __webpack_require__.d(__webpack_exports__, "UVMapping", function() {
        return UVMapping;
    });
    __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() {
        return CubeReflectionMapping;
    });
    __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() {
        return CubeRefractionMapping;
    });
    __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() {
        return EquirectangularReflectionMapping;
    });
    __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() {
        return EquirectangularRefractionMapping;
    });
    __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() {
        return SphericalReflectionMapping;
    });
    __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() {
        return CubeUVReflectionMapping;
    });
    __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() {
        return CubeUVRefractionMapping;
    });
    __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() {
        return RepeatWrapping;
    });
    __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() {
        return ClampToEdgeWrapping;
    });
    __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() {
        return MirroredRepeatWrapping;
    });
    __webpack_require__.d(__webpack_exports__, "NearestFilter", function() {
        return NearestFilter;
    });
    __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() {
        return NearestMipMapNearestFilter;
    });
    __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() {
        return NearestMipMapLinearFilter;
    });
    __webpack_require__.d(__webpack_exports__, "LinearFilter", function() {
        return LinearFilter;
    });
    __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() {
        return LinearMipMapNearestFilter;
    });
    __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() {
        return LinearMipMapLinearFilter;
    });
    __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() {
        return UnsignedByteType;
    });
    __webpack_require__.d(__webpack_exports__, "ByteType", function() {
        return ByteType;
    });
    __webpack_require__.d(__webpack_exports__, "ShortType", function() {
        return ShortType;
    });
    __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() {
        return UnsignedShortType;
    });
    __webpack_require__.d(__webpack_exports__, "IntType", function() {
        return IntType;
    });
    __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() {
        return UnsignedIntType;
    });
    __webpack_require__.d(__webpack_exports__, "FloatType", function() {
        return FloatType;
    });
    __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() {
        return HalfFloatType;
    });
    __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() {
        return UnsignedShort4444Type;
    });
    __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() {
        return UnsignedShort5551Type;
    });
    __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() {
        return UnsignedShort565Type;
    });
    __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() {
        return UnsignedInt248Type;
    });
    __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() {
        return AlphaFormat;
    });
    __webpack_require__.d(__webpack_exports__, "RGBFormat", function() {
        return RGBFormat;
    });
    __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() {
        return RGBAFormat;
    });
    __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() {
        return LuminanceFormat;
    });
    __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() {
        return LuminanceAlphaFormat;
    });
    __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() {
        return RGBEFormat;
    });
    __webpack_require__.d(__webpack_exports__, "DepthFormat", function() {
        return DepthFormat;
    });
    __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() {
        return DepthStencilFormat;
    });
    __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() {
        return RGB_S3TC_DXT1_Format;
    });
    __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() {
        return RGBA_S3TC_DXT1_Format;
    });
    __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() {
        return RGBA_S3TC_DXT3_Format;
    });
    __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() {
        return RGBA_S3TC_DXT5_Format;
    });
    __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() {
        return RGB_PVRTC_4BPPV1_Format;
    });
    __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() {
        return RGB_PVRTC_2BPPV1_Format;
    });
    __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() {
        return RGBA_PVRTC_4BPPV1_Format;
    });
    __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() {
        return RGBA_PVRTC_2BPPV1_Format;
    });
    __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() {
        return RGB_ETC1_Format;
    });
    __webpack_require__.d(__webpack_exports__, "LoopOnce", function() {
        return LoopOnce;
    });
    __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() {
        return LoopRepeat;
    });
    __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() {
        return LoopPingPong;
    });
    __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() {
        return InterpolateDiscrete;
    });
    __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() {
        return InterpolateLinear;
    });
    __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() {
        return InterpolateSmooth;
    });
    __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() {
        return ZeroCurvatureEnding;
    });
    __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() {
        return ZeroSlopeEnding;
    });
    __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() {
        return WrapAroundEnding;
    });
    __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() {
        return TrianglesDrawMode;
    });
    __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() {
        return TriangleStripDrawMode;
    });
    __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() {
        return TriangleFanDrawMode;
    });
    __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() {
        return LinearEncoding;
    });
    __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() {
        return sRGBEncoding;
    });
    __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() {
        return GammaEncoding;
    });
    __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() {
        return RGBEEncoding;
    });
    __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() {
        return LogLuvEncoding;
    });
    __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() {
        return RGBM7Encoding;
    });
    __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() {
        return RGBM16Encoding;
    });
    __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() {
        return RGBDEncoding;
    });
    __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() {
        return BasicDepthPacking;
    });
    __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() {
        return RGBADepthPacking;
    });
    __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() {
        return BoxGeometry;
    });
    __webpack_require__.d(__webpack_exports__, "Face4", function() {
        return Face4;
    });
    __webpack_require__.d(__webpack_exports__, "LineStrip", function() {
        return LineStrip;
    });
    __webpack_require__.d(__webpack_exports__, "LinePieces", function() {
        return LinePieces;
    });
    __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() {
        return MeshFaceMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() {
        return MultiMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "PointCloud", function() {
        return PointCloud;
    });
    __webpack_require__.d(__webpack_exports__, "Particle", function() {
        return Particle;
    });
    __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() {
        return ParticleSystem;
    });
    __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() {
        return PointCloudMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() {
        return ParticleBasicMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() {
        return ParticleSystemMaterial;
    });
    __webpack_require__.d(__webpack_exports__, "Vertex", function() {
        return Vertex;
    });
    __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() {
        return DynamicBufferAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() {
        return Int8Attribute;
    });
    __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() {
        return Uint8Attribute;
    });
    __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() {
        return Uint8ClampedAttribute;
    });
    __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() {
        return Int16Attribute;
    });
    __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() {
        return Uint16Attribute;
    });
    __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() {
        return Int32Attribute;
    });
    __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() {
        return Uint32Attribute;
    });
    __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() {
        return Float32Attribute;
    });
    __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() {
        return Float64Attribute;
    });
    __webpack_require__.d(__webpack_exports__, "ClosedSplineCurve3", function() {
        return ClosedSplineCurve3;
    });
    __webpack_require__.d(__webpack_exports__, "SplineCurve3", function() {
        return SplineCurve3;
    });
    __webpack_require__.d(__webpack_exports__, "Spline", function() {
        return Spline;
    });
    __webpack_require__.d(__webpack_exports__, "AxisHelper", function() {
        return AxisHelper;
    });
    __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() {
        return BoundingBoxHelper;
    });
    __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() {
        return EdgesHelper;
    });
    __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() {
        return WireframeHelper;
    });
    __webpack_require__.d(__webpack_exports__, "XHRLoader", function() {
        return XHRLoader;
    });
    __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() {
        return BinaryTextureLoader;
    });
    __webpack_require__.d(__webpack_exports__, "GeometryUtils", function() {
        return GeometryUtils;
    });
    __webpack_require__.d(__webpack_exports__, "ImageUtils", function() {
        return ImageUtils;
    });
    __webpack_require__.d(__webpack_exports__, "Projector", function() {
        return Projector;
    });
    __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() {
        return CanvasRenderer;
    });
    if (Number.EPSILON === undefined) {
        Number.EPSILON = Math.pow(2, -52);
    }
    if (Number.isInteger === undefined) {
        Number.isInteger = function(value) {
            return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
        };
    }
    if (Math.sign === undefined) {
        Math.sign = function(x) {
            return (x < 0) ? -1 : (x > 0) ? 1 : +x;
        };
    }
    if ('name' in Function.prototype === false) {
        Object.defineProperty(Function.prototype, 'name', {
            get: function() {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
            }
        });
    }
    if (Object.assign === undefined) {
        (function() {
            Object.assign = function(target) {
                if (target === undefined || target === null) {
                    throw new TypeError('Cannot convert undefined or null to object');
                }
                var output = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (source !== undefined && source !== null) {
                        for (var nextKey in source) {
                            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                                output[nextKey] = source[nextKey];
                            }
                        }
                    }
                }
                return output;
            };
        })();
    }

    function EventDispatcher() {}
    Object.assign(EventDispatcher.prototype, {
        addEventListener: function(type, listener) {
            if (this._listeners === undefined) this._listeners = {};
            var listeners = this._listeners;
            if (listeners[type] === undefined) {
                listeners[type] = [];
            }
            if (listeners[type].indexOf(listener) === -1) {
                listeners[type].push(listener);
            }
        },
        hasEventListener: function(type, listener) {
            if (this._listeners === undefined) return false;
            var listeners = this._listeners;
            return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
        },
        removeEventListener: function(type, listener) {
            if (this._listeners === undefined) return;
            var listeners = this._listeners;
            var listenerArray = listeners[type];
            if (listenerArray !== undefined) {
                var index = listenerArray.indexOf(listener);
                if (index !== -1) {
                    listenerArray.splice(index, 1);
                }
            }
        },
        dispatchEvent: function(event) {
            if (this._listeners === undefined) return;
            var listeners = this._listeners;
            var listenerArray = listeners[event.type];
            if (listenerArray !== undefined) {
                event.target = this;
                var array = listenerArray.slice(0);
                for (var i = 0, l = array.length; i < l; i++) {
                    array[i].call(this, event);
                }
            }
        }
    });
    var REVISION = '89';
    var MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var FrontFaceDirectionCW = 0;
    var FrontFaceDirectionCCW = 1;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var Uncharted2ToneMapping = 3;
    var CineonToneMapping = 4;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var SphericalReflectionMapping = 305;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var NearestFilter = 1003;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipMapLinearFilter = 1008;
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RGB_S3TC_DXT1_Format = 2001;
    var RGBA_S3TC_DXT1_Format = 2002;
    var RGBA_S3TC_DXT3_Format = 2003;
    var RGBA_S3TC_DXT5_Format = 2004;
    var RGB_PVRTC_4BPPV1_Format = 2100;
    var RGB_PVRTC_2BPPV1_Format = 2101;
    var RGBA_PVRTC_4BPPV1_Format = 2102;
    var RGBA_PVRTC_2BPPV1_Format = 2103;
    var RGB_ETC1_Format = 2151;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;
    var _Math = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: (function() {
            var lut = [];
            for (var i = 0; i < 256; i++) {
                lut[i] = (i < 16 ? '0' : '') + (i).toString(16).toUpperCase();
            }
            return function() {
                var d0 = Math.random() * 0xffffffff | 0;
                var d1 = Math.random() * 0xffffffff | 0;
                var d2 = Math.random() * 0xffffffff | 0;
                var d3 = Math.random() * 0xffffffff | 0;
                return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' +
                    lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' +
                    lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] +
                    lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
            };
        })(),
        clamp: function(value, min, max) {
            return Math.max(min, Math.min(max, value));
        },
        euclideanModulo: function(n, m) {
            return ((n % m) + m) % m;
        },
        mapLinear: function(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },
        lerp: function(x, y, t) {
            return (1 - t) * x + t * y;
        },
        smoothstep: function(x, min, max) {
            if (x <= min) return 0;
            if (x >= max) return 1;
            x = (x - min) / (max - min);
            return x * x * (3 - 2 * x);
        },
        smootherstep: function(x, min, max) {
            if (x <= min) return 0;
            if (x >= max) return 1;
            x = (x - min) / (max - min);
            return x * x * x * (x * (x * 6 - 15) + 10);
        },
        randInt: function(low, high) {
            return low + Math.floor(Math.random() * (high - low + 1));
        },
        randFloat: function(low, high) {
            return low + Math.random() * (high - low);
        },
        randFloatSpread: function(range) {
            return range * (0.5 - Math.random());
        },
        degToRad: function(degrees) {
            return degrees * _Math.DEG2RAD;
        },
        radToDeg: function(radians) {
            return radians * _Math.RAD2DEG;
        },
        isPowerOfTwo: function(value) {
            return (value & (value - 1)) === 0 && value !== 0;
        },
        ceilPowerOfTwo: function(value) {
            return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
        },
        floorPowerOfTwo: function(value) {
            return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
        }
    };

    function Vector2(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    Object.defineProperties(Vector2.prototype, {
        "width": {
            get: function() {
                return this.x;
            },
            set: function(value) {
                this.x = value;
            }
        },
        "height": {
            get: function() {
                return this.y;
            },
            set: function(value) {
                this.y = value;
            }
        }
    });
    Object.assign(Vector2.prototype, {
        isVector2: true,
        set: function(x, y) {
            this.x = x;
            this.y = y;
            return this;
        },
        setScalar: function(scalar) {
            this.x = scalar;
            this.y = scalar;
            return this;
        },
        setX: function(x) {
            this.x = x;
            return this;
        },
        setY: function(y) {
            this.y = y;
            return this;
        },
        setComponent: function(index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error('index is out of range: ' + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y);
        },
        copy: function(v) {
            this.x = v.x;
            this.y = v.y;
            return this;
        },
        add: function(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            return this;
        },
        addScalar: function(s) {
            this.x += s;
            this.y += s;
            return this;
        },
        addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this;
        },
        addScaledVector: function(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            return this;
        },
        sub: function(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            return this;
        },
        subScalar: function(s) {
            this.x -= s;
            this.y -= s;
            return this;
        },
        subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;
        },
        multiply: function(v) {
            this.x *= v.x;
            this.y *= v.y;
            return this;
        },
        multiplyScalar: function(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            return this;
        },
        divide: function(v) {
            this.x /= v.x;
            this.y /= v.y;
            return this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        applyMatrix3: function(m) {
            var x = this.x,
                y = this.y;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6];
            this.y = e[1] * x + e[4] * y + e[7];
            return this;
        },
        min: function(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            return this;
        },
        max: function(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            return this;
        },
        clamp: function(min, max) {
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            return this;
        },
        clampScalar: function() {
            var min = new Vector2();
            var max = new Vector2();
            return function clampScalar(minVal, maxVal) {
                min.set(minVal, minVal);
                max.set(maxVal, maxVal);
                return this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        },
        ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        },
        round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        },
        roundToZero: function() {
            this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
            return this;
        },
        negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        angle: function() {
            var angle = Math.atan2(this.y, this.x);
            if (angle < 0) angle += 2 * Math.PI;
            return angle;
        },
        distanceTo: function(v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function(v) {
            var dx = this.x - v.x,
                dy = this.y - v.y;
            return dx * dx + dy * dy;
        },
        manhattanDistanceTo: function(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        },
        setLength: function(length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            return this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function(v) {
            return ((v.x === this.x) && (v.y === this.y));
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            return array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            if (offset !== undefined) {
                console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            return this;
        },
        rotateAround: function(center, angle) {
            var c = Math.cos(angle),
                s = Math.sin(angle);
            var x = this.x - center.x;
            var y = this.y - center.y;
            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;
            return this;
        }
    });

    function Matrix4() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        if (arguments.length > 0) {
            console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
        }
    }
    Object.assign(Matrix4.prototype, {
        isMatrix4: true,
        set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            te[0] = n11;
            te[4] = n12;
            te[8] = n13;
            te[12] = n14;
            te[1] = n21;
            te[5] = n22;
            te[9] = n23;
            te[13] = n24;
            te[2] = n31;
            te[6] = n32;
            te[10] = n33;
            te[14] = n34;
            te[3] = n41;
            te[7] = n42;
            te[11] = n43;
            te[15] = n44;
            return this;
        },
        identity: function() {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        },
        clone: function() {
            return new Matrix4().fromArray(this.elements);
        },
        copy: function(m) {
            var te = this.elements;
            var me = m.elements;
            te[0] = me[0];
            te[1] = me[1];
            te[2] = me[2];
            te[3] = me[3];
            te[4] = me[4];
            te[5] = me[5];
            te[6] = me[6];
            te[7] = me[7];
            te[8] = me[8];
            te[9] = me[9];
            te[10] = me[10];
            te[11] = me[11];
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            te[15] = me[15];
            return this;
        },
        copyPosition: function(m) {
            var te = this.elements,
                me = m.elements;
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            return this;
        },
        extractBasis: function(xAxis, yAxis, zAxis) {
            xAxis.setFromMatrixColumn(this, 0);
            yAxis.setFromMatrixColumn(this, 1);
            zAxis.setFromMatrixColumn(this, 2);
            return this;
        },
        makeBasis: function(xAxis, yAxis, zAxis) {
            this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
            return this;
        },
        extractRotation: function() {
            var v1 = new Vector3();
            return function extractRotation(m) {
                var te = this.elements;
                var me = m.elements;
                var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
                var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
                var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
                te[0] = me[0] * scaleX;
                te[1] = me[1] * scaleX;
                te[2] = me[2] * scaleX;
                te[4] = me[4] * scaleY;
                te[5] = me[5] * scaleY;
                te[6] = me[6] * scaleY;
                te[8] = me[8] * scaleZ;
                te[9] = me[9] * scaleZ;
                te[10] = me[10] * scaleZ;
                return this;
            };
        }(),
        makeRotationFromEuler: function(euler) {
            if (!(euler && euler.isEuler)) {
                console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
            }
            var te = this.elements;
            var x = euler.x,
                y = euler.y,
                z = euler.z;
            var a = Math.cos(x),
                b = Math.sin(x);
            var c = Math.cos(y),
                d = Math.sin(y);
            var e = Math.cos(z),
                f = Math.sin(z);
            if (euler.order === 'XYZ') {
                var ae = a * e,
                    af = a * f,
                    be = b * e,
                    bf = b * f;
                te[0] = c * e;
                te[4] = -c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
            } else if (euler.order === 'YXZ') {
                var ce = c * e,
                    cf = c * f,
                    de = d * e,
                    df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e;
                te[9] = -b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
            } else if (euler.order === 'ZXY') {
                var ce = c * e,
                    cf = c * f,
                    de = d * e,
                    df = d * f;
                te[0] = ce - df * b;
                te[4] = -a * f;
                te[8] = de + cf * b;
                te[1] = cf + de * b;
                te[5] = a * e;
                te[9] = df - ce * b;
                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
            } else if (euler.order === 'ZYX') {
                var ae = a * e,
                    af = a * f,
                    be = b * e,
                    bf = b * f;
                te[0] = c * e;
                te[4] = be * d - af;
                te[8] = ae * d + bf;
                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;
                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
            } else if (euler.order === 'YZX') {
                var ac = a * c,
                    ad = a * d,
                    bc = b * c,
                    bd = b * d;
                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e;
                te[9] = -b * e;
                te[2] = -d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
            } else if (euler.order === 'XZY') {
                var ac = a * c,
                    ad = a * d,
                    bc = b * c,
                    bd = b * d;
                te[0] = c * e;
                te[4] = -f;
                te[8] = d * e;
                te[1] = ac * f + bd;
                te[5] = a * e;
                te[9] = ad * f - bc;
                te[2] = bc * f - ad;
                te[6] = b * e;
                te[10] = bd * f + ac;
            }
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        },
        makeRotationFromQuaternion: function(q) {
            var te = this.elements;
            var x = q._x,
                y = q._y,
                z = q._z,
                w = q._w;
            var x2 = x + x,
                y2 = y + y,
                z2 = z + z;
            var xx = x * x2,
                xy = x * y2,
                xz = x * z2;
            var yy = y * y2,
                yz = y * z2,
                zz = z * z2;
            var wx = w * x2,
                wy = w * y2,
                wz = w * z2;
            te[0] = 1 - (yy + zz);
            te[4] = xy - wz;
            te[8] = xz + wy;
            te[1] = xy + wz;
            te[5] = 1 - (xx + zz);
            te[9] = yz - wx;
            te[2] = xz - wy;
            te[6] = yz + wx;
            te[10] = 1 - (xx + yy);
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        },
        lookAt: function() {
            var x = new Vector3();
            var y = new Vector3();
            var z = new Vector3();
            return function lookAt(eye, target, up) {
                var te = this.elements;
                z.subVectors(eye, target);
                if (z.lengthSq() === 0) {
                    z.z = 1;
                }
                z.normalize();
                x.crossVectors(up, z);
                if (x.lengthSq() === 0) {
                    if (Math.abs(up.z) === 1) {
                        z.x += 0.0001;
                    } else {
                        z.z += 0.0001;
                    }
                    z.normalize();
                    x.crossVectors(up, z);
                }
                x.normalize();
                y.crossVectors(z, x);
                te[0] = x.x;
                te[4] = y.x;
                te[8] = z.x;
                te[1] = x.y;
                te[5] = y.y;
                te[9] = z.y;
                te[2] = x.z;
                te[6] = y.z;
                te[10] = z.z;
                return this;
            };
        }(),
        multiply: function(m, n) {
            if (n !== undefined) {
                console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
                return this.multiplyMatrices(m, n);
            }
            return this.multiplyMatrices(this, m);
        },
        premultiply: function(m) {
            return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function(a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0],
                a12 = ae[4],
                a13 = ae[8],
                a14 = ae[12];
            var a21 = ae[1],
                a22 = ae[5],
                a23 = ae[9],
                a24 = ae[13];
            var a31 = ae[2],
                a32 = ae[6],
                a33 = ae[10],
                a34 = ae[14];
            var a41 = ae[3],
                a42 = ae[7],
                a43 = ae[11],
                a44 = ae[15];
            var b11 = be[0],
                b12 = be[4],
                b13 = be[8],
                b14 = be[12];
            var b21 = be[1],
                b22 = be[5],
                b23 = be[9],
                b24 = be[13];
            var b31 = be[2],
                b32 = be[6],
                b33 = be[10],
                b34 = be[14];
            var b41 = be[3],
                b42 = be[7],
                b43 = be[11],
                b44 = be[15];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        },
        multiplyScalar: function(s) {
            var te = this.elements;
            te[0] *= s;
            te[4] *= s;
            te[8] *= s;
            te[12] *= s;
            te[1] *= s;
            te[5] *= s;
            te[9] *= s;
            te[13] *= s;
            te[2] *= s;
            te[6] *= s;
            te[10] *= s;
            te[14] *= s;
            te[3] *= s;
            te[7] *= s;
            te[11] *= s;
            te[15] *= s;
            return this;
        },
        applyToBufferAttribute: function() {
            var v1 = new Vector3();
            return function applyToBufferAttribute(attribute) {
                for (var i = 0, l = attribute.count; i < l; i++) {
                    v1.x = attribute.getX(i);
                    v1.y = attribute.getY(i);
                    v1.z = attribute.getZ(i);
                    v1.applyMatrix4(this);
                    attribute.setXYZ(i, v1.x, v1.y, v1.z);
                }
                return attribute;
            };
        }(),
        determinant: function() {
            var te = this.elements;
            var n11 = te[0],
                n12 = te[4],
                n13 = te[8],
                n14 = te[12];
            var n21 = te[1],
                n22 = te[5],
                n23 = te[9],
                n24 = te[13];
            var n31 = te[2],
                n32 = te[6],
                n33 = te[10],
                n34 = te[14];
            var n41 = te[3],
                n42 = te[7],
                n43 = te[11],
                n44 = te[15];
            return (n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) +
                n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) +
                n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) +
                n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31));
        },
        transpose: function() {
            var te = this.elements;
            var tmp;
            tmp = te[1];
            te[1] = te[4];
            te[4] = tmp;
            tmp = te[2];
            te[2] = te[8];
            te[8] = tmp;
            tmp = te[6];
            te[6] = te[9];
            te[9] = tmp;
            tmp = te[3];
            te[3] = te[12];
            te[12] = tmp;
            tmp = te[7];
            te[7] = te[13];
            te[13] = tmp;
            tmp = te[11];
            te[11] = te[14];
            te[14] = tmp;
            return this;
        },
        setPosition: function(v) {
            var te = this.elements;
            te[12] = v.x;
            te[13] = v.y;
            te[14] = v.z;
            return this;
        },
        getInverse: function(m, throwOnDegenerate) {
            var te = this.elements,
                me = m.elements,
                n11 = me[0],
                n21 = me[1],
                n31 = me[2],
                n41 = me[3],
                n12 = me[4],
                n22 = me[5],
                n32 = me[6],
                n42 = me[7],
                n13 = me[8],
                n23 = me[9],
                n33 = me[10],
                n43 = me[11],
                n14 = me[12],
                n24 = me[13],
                n34 = me[14],
                n44 = me[15],
                t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0) {
                var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (throwOnDegenerate === true) {
                    throw new Error(msg);
                } else {
                    console.warn(msg);
                }
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            te[4] = t12 * detInv;
            te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            te[8] = t13 * detInv;
            te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            te[12] = t14 * detInv;
            te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        },
        scale: function(v) {
            var te = this.elements;
            var x = v.x,
                y = v.y,
                z = v.z;
            te[0] *= x;
            te[4] *= y;
            te[8] *= z;
            te[1] *= x;
            te[5] *= y;
            te[9] *= z;
            te[2] *= x;
            te[6] *= y;
            te[10] *= z;
            te[3] *= x;
            te[7] *= y;
            te[11] *= z;
            return this;
        },
        getMaxScaleOnAxis: function() {
            var te = this.elements;
            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        },
        makeTranslation: function(x, y, z) {
            this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
            return this;
        },
        makeRotationX: function(theta) {
            var c = Math.cos(theta),
                s = Math.sin(theta);
            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
            return this;
        },
        makeRotationY: function(theta) {
            var c = Math.cos(theta),
                s = Math.sin(theta);
            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
            return this;
        },
        makeRotationZ: function(theta) {
            var c = Math.cos(theta),
                s = Math.sin(theta);
            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        },
        makeRotationAxis: function(axis, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var t = 1 - c;
            var x = axis.x,
                y = axis.y,
                z = axis.z;
            var tx = t * x,
                ty = t * y;
            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
            return this;
        },
        makeScale: function(x, y, z) {
            this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
            return this;
        },
        makeShear: function(x, y, z) {
            this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
            return this;
        },
        compose: function(position, quaternion, scale) {
            this.makeRotationFromQuaternion(quaternion);
            this.scale(scale);
            this.setPosition(position);
            return this;
        },
        decompose: function() {
            var vector = new Vector3();
            var matrix = new Matrix4();
            return function decompose(position, quaternion, scale) {
                var te = this.elements;
                var sx = vector.set(te[0], te[1], te[2]).length();
                var sy = vector.set(te[4], te[5], te[6]).length();
                var sz = vector.set(te[8], te[9], te[10]).length();
                var det = this.determinant();
                if (det < 0) sx = -sx;
                position.x = te[12];
                position.y = te[13];
                position.z = te[14];
                matrix.copy(this);
                var invSX = 1 / sx;
                var invSY = 1 / sy;
                var invSZ = 1 / sz;
                matrix.elements[0] *= invSX;
                matrix.elements[1] *= invSX;
                matrix.elements[2] *= invSX;
                matrix.elements[4] *= invSY;
                matrix.elements[5] *= invSY;
                matrix.elements[6] *= invSY;
                matrix.elements[8] *= invSZ;
                matrix.elements[9] *= invSZ;
                matrix.elements[10] *= invSZ;
                quaternion.setFromRotationMatrix(matrix);
                scale.x = sx;
                scale.y = sy;
                scale.z = sz;
                return this;
            };
        }(),
        makePerspective: function(left, right, top, bottom, near, far) {
            if (far === undefined) {
                console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
            }
            var te = this.elements;
            var x = 2 * near / (right - left);
            var y = 2 * near / (top - bottom);
            var a = (right + left) / (right - left);
            var b = (top + bottom) / (top - bottom);
            var c = -(far + near) / (far - near);
            var d = -2 * far * near / (far - near);
            te[0] = x;
            te[4] = 0;
            te[8] = a;
            te[12] = 0;
            te[1] = 0;
            te[5] = y;
            te[9] = b;
            te[13] = 0;
            te[2] = 0;
            te[6] = 0;
            te[10] = c;
            te[14] = d;
            te[3] = 0;
            te[7] = 0;
            te[11] = -1;
            te[15] = 0;
            return this;
        },
        makeOrthographic: function(left, right, top, bottom, near, far) {
            var te = this.elements;
            var w = 1.0 / (right - left);
            var h = 1.0 / (top - bottom);
            var p = 1.0 / (far - near);
            var x = (right + left) * w;
            var y = (top + bottom) * h;
            var z = (far + near) * p;
            te[0] = 2 * w;
            te[4] = 0;
            te[8] = 0;
            te[12] = -x;
            te[1] = 0;
            te[5] = 2 * h;
            te[9] = 0;
            te[13] = -y;
            te[2] = 0;
            te[6] = 0;
            te[10] = -2 * p;
            te[14] = -z;
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[15] = 1;
            return this;
        },
        equals: function(matrix) {
            var te = this.elements;
            var me = matrix.elements;
            for (var i = 0; i < 16; i++) {
                if (te[i] !== me[i]) return false;
            }
            return true;
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            for (var i = 0; i < 16; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            array[offset + 9] = te[9];
            array[offset + 10] = te[10];
            array[offset + 11] = te[11];
            array[offset + 12] = te[12];
            array[offset + 13] = te[13];
            array[offset + 14] = te[14];
            array[offset + 15] = te[15];
            return array;
        }
    });

    function Quaternion(x, y, z, w) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._w = (w !== undefined) ? w : 1;
    }
    Object.assign(Quaternion, {
        slerp: function(qa, qb, qm, t) {
            return qm.copy(qa).slerp(qb, t);
        },
        slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
            var x0 = src0[srcOffset0 + 0],
                y0 = src0[srcOffset0 + 1],
                z0 = src0[srcOffset0 + 2],
                w0 = src0[srcOffset0 + 3],
                x1 = src1[srcOffset1 + 0],
                y1 = src1[srcOffset1 + 1],
                z1 = src1[srcOffset1 + 2],
                w1 = src1[srcOffset1 + 3];
            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t,
                    cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
                    dir = (cos >= 0 ? 1 : -1),
                    sqrSin = 1 - cos * cos;
                if (sqrSin > Number.EPSILON) {
                    var sin = Math.sqrt(sqrSin),
                        len = Math.atan2(sin, cos * dir);
                    s = Math.sin(s * len) / sin;
                    t = Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir;
                if (s === 1 - t) {
                    var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                    x0 *= f;
                    y0 *= f;
                    z0 *= f;
                    w0 *= f;
                }
            }
            dst[dstOffset] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
        }
    });
    Object.defineProperties(Quaternion.prototype, {
        x: {
            get: function() {
                return this._x;
            },
            set: function(value) {
                this._x = value;
                this.onChangeCallback();
            }
        },
        y: {
            get: function() {
                return this._y;
            },
            set: function(value) {
                this._y = value;
                this.onChangeCallback();
            }
        },
        z: {
            get: function() {
                return this._z;
            },
            set: function(value) {
                this._z = value;
                this.onChangeCallback();
            }
        },
        w: {
            get: function() {
                return this._w;
            },
            set: function(value) {
                this._w = value;
                this.onChangeCallback();
            }
        }
    });
    Object.assign(Quaternion.prototype, {
        set: function(x, y, z, w) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
            this.onChangeCallback();
            return this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function(quaternion) {
            this._x = quaternion.x;
            this._y = quaternion.y;
            this._z = quaternion.z;
            this._w = quaternion.w;
            this.onChangeCallback();
            return this;
        },
        setFromEuler: function(euler, update) {
            if (!(euler && euler.isEuler)) {
                throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
            }
            var x = euler._x,
                y = euler._y,
                z = euler._z,
                order = euler.order;
            var cos = Math.cos;
            var sin = Math.sin;
            var c1 = cos(x / 2);
            var c2 = cos(y / 2);
            var c3 = cos(z / 2);
            var s1 = sin(x / 2);
            var s2 = sin(y / 2);
            var s3 = sin(z / 2);
            if (order === 'XYZ') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === 'YXZ') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            } else if (order === 'ZXY') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === 'ZYX') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            } else if (order === 'YZX') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === 'XZY') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            if (update !== false) this.onChangeCallback();
            return this;
        },
        setFromAxisAngle: function(axis, angle) {
            var halfAngle = angle / 2,
                s = Math.sin(halfAngle);
            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = Math.cos(halfAngle);
            this.onChangeCallback();
            return this;
        },
        setFromRotationMatrix: function(m) {
            var te = m.elements,
                m11 = te[0],
                m12 = te[4],
                m13 = te[8],
                m21 = te[1],
                m22 = te[5],
                m23 = te[9],
                m31 = te[2],
                m32 = te[6],
                m33 = te[10],
                trace = m11 + m22 + m33,
                s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                this._w = 0.25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
            } else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this._w = (m32 - m23) / s;
                this._x = 0.25 * s;
                this._y = (m12 + m21) / s;
                this._z = (m13 + m31) / s;
            } else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this._w = (m13 - m31) / s;
                this._x = (m12 + m21) / s;
                this._y = 0.25 * s;
                this._z = (m23 + m32) / s;
            } else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this._w = (m21 - m12) / s;
                this._x = (m13 + m31) / s;
                this._y = (m23 + m32) / s;
                this._z = 0.25 * s;
            }
            this.onChangeCallback();
            return this;
        },
        setFromUnitVectors: function() {
            var v1 = new Vector3();
            var r;
            var EPS = 0.000001;
            return function setFromUnitVectors(vFrom, vTo) {
                if (v1 === undefined) v1 = new Vector3();
                r = vFrom.dot(vTo) + 1;
                if (r < EPS) {
                    r = 0;
                    if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                        v1.set(-vFrom.y, vFrom.x, 0);
                    } else {
                        v1.set(0, -vFrom.z, vFrom.y);
                    }
                } else {
                    v1.crossVectors(vFrom, vTo);
                }
                this._x = v1.x;
                this._y = v1.y;
                this._z = v1.z;
                this._w = r;
                return this.normalize();
            };
        }(),
        inverse: function() {
            return this.conjugate().normalize();
        },
        conjugate: function() {
            this._x *= -1;
            this._y *= -1;
            this._z *= -1;
            this.onChangeCallback();
            return this;
        },
        dot: function(v) {
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        },
        normalize: function() {
            var l = this.length();
            if (l === 0) {
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
            } else {
                l = 1 / l;
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
            }
            this.onChangeCallback();
            return this;
        },
        multiply: function(q, p) {
            if (p !== undefined) {
                console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
                return this.multiplyQuaternions(q, p);
            }
            return this.multiplyQuaternions(this, q);
        },
        premultiply: function(q) {
            return this.multiplyQuaternions(q, this);
        },
        multiplyQuaternions: function(a, b) {
            var qax = a._x,
                qay = a._y,
                qaz = a._z,
                qaw = a._w;
            var qbx = b._x,
                qby = b._y,
                qbz = b._z,
                qbw = b._w;
            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            this.onChangeCallback();
            return this;
        },
        slerp: function(qb, t) {
            if (t === 0) return this;
            if (t === 1) return this.copy(qb);
            var x = this._x,
                y = this._y,
                z = this._z,
                w = this._w;
            var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (cosHalfTheta < 0) {
                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;
                cosHalfTheta = -cosHalfTheta;
            } else {
                this.copy(qb);
            }
            if (cosHalfTheta >= 1.0) {
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
                return this;
            }
            var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < 0.001) {
                this._w = 0.5 * (w + this._w);
                this._x = 0.5 * (x + this._x);
                this._y = 0.5 * (y + this._y);
                this._z = 0.5 * (z + this._z);
                return this;
            }
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
                ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this._w = (w * ratioA + this._w * ratioB);
            this._x = (x * ratioA + this._x * ratioB);
            this._y = (y * ratioA + this._y * ratioB);
            this._z = (z * ratioA + this._z * ratioB);
            this.onChangeCallback();
            return this;
        },
        equals: function(quaternion) {
            return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            this._x = array[offset];
            this._y = array[offset + 1];
            this._z = array[offset + 2];
            this._w = array[offset + 3];
            this.onChangeCallback();
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._w;
            return array;
        },
        onChange: function(callback) {
            this.onChangeCallback = callback;
            return this;
        },
        onChangeCallback: function() {}
    });

    function Vector3(x, y, z) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
    }
    Object.assign(Vector3.prototype, {
        isVector3: true,
        set: function(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        },
        setScalar: function(scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            return this;
        },
        setX: function(x) {
            this.x = x;
            return this;
        },
        setY: function(y) {
            this.y = y;
            return this;
        },
        setZ: function(z) {
            this.z = z;
            return this;
        },
        setComponent: function(index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error('index is out of range: ' + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z);
        },
        copy: function(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        },
        add: function(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        },
        addScalar: function(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
        },
        addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this;
        },
        addScaledVector: function(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            return this;
        },
        sub: function(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        },
        subScalar: function(s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            return this;
        },
        subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
        },
        multiply: function(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
                return this.multiplyVectors(v, w);
            }
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            return this;
        },
        multiplyScalar: function(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            return this;
        },
        multiplyVectors: function(a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this;
        },
        applyEuler: function() {
            var quaternion = new Quaternion();
            return function applyEuler(euler) {
                if (!(euler && euler.isEuler)) {
                    console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
                }
                return this.applyQuaternion(quaternion.setFromEuler(euler));
            };
        }(),
        applyAxisAngle: function() {
            var quaternion = new Quaternion();
            return function applyAxisAngle(axis, angle) {
                return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
            };
        }(),
        applyMatrix3: function(m) {
            var x = this.x,
                y = this.y,
                z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;
            return this;
        },
        applyMatrix4: function(m) {
            var x = this.x,
                y = this.y,
                z = this.z;
            var e = m.elements;
            var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
            this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
            this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
            return this;
        },
        applyQuaternion: function(q) {
            var x = this.x,
                y = this.y,
                z = this.z;
            var qx = q.x,
                qy = q.y,
                qz = q.z,
                qw = q.w;
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        },
        project: function() {
            var matrix = new Matrix4();
            return function project(camera) {
                matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
                return this.applyMatrix4(matrix);
            };
        }(),
        unproject: function() {
            var matrix = new Matrix4();
            return function unproject(camera) {
                matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
                return this.applyMatrix4(matrix);
            };
        }(),
        transformDirection: function(m) {
            var x = this.x,
                y = this.y,
                z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z;
            this.y = e[1] * x + e[5] * y + e[9] * z;
            this.z = e[2] * x + e[6] * y + e[10] * z;
            return this.normalize();
        },
        divide: function(v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            return this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        min: function(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            return this;
        },
        max: function(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            return this;
        },
        clamp: function(min, max) {
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            this.z = Math.max(min.z, Math.min(max.z, this.z));
            return this;
        },
        clampScalar: function() {
            var min = new Vector3();
            var max = new Vector3();
            return function clampScalar(minVal, maxVal) {
                min.set(minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal);
                return this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this;
        },
        ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this;
        },
        round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this;
        },
        roundToZero: function() {
            this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
            return this;
        },
        negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        setLength: function(length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        cross: function(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
                return this.crossVectors(v, w);
            }
            return this.crossVectors(this, v);
        },
        crossVectors: function(a, b) {
            var ax = a.x,
                ay = a.y,
                az = a.z;
            var bx = b.x,
                by = b.y,
                bz = b.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
        },
        projectOnVector: function(vector) {
            var scalar = vector.dot(this) / vector.lengthSq();
            return this.copy(vector).multiplyScalar(scalar);
        },
        projectOnPlane: function() {
            var v1 = new Vector3();
            return function projectOnPlane(planeNormal) {
                v1.copy(this).projectOnVector(planeNormal);
                return this.sub(v1);
            };
        }(),
        reflect: function() {
            var v1 = new Vector3();
            return function reflect(normal) {
                return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
            };
        }(),
        angleTo: function(v) {
            var theta = this.dot(v) / (Math.sqrt(this.lengthSq() * v.lengthSq()));
            return Math.acos(_Math.clamp(theta, -1, 1));
        },
        distanceTo: function(v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function(v) {
            var dx = this.x - v.x,
                dy = this.y - v.y,
                dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        },
        manhattanDistanceTo: function(v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        },
        setFromSpherical: function(s) {
            var sinPhiRadius = Math.sin(s.phi) * s.radius;
            this.x = sinPhiRadius * Math.sin(s.theta);
            this.y = Math.cos(s.phi) * s.radius;
            this.z = sinPhiRadius * Math.cos(s.theta);
            return this;
        },
        setFromCylindrical: function(c) {
            this.x = c.radius * Math.sin(c.theta);
            this.y = c.y;
            this.z = c.radius * Math.cos(c.theta);
            return this;
        },
        setFromMatrixPosition: function(m) {
            var e = m.elements;
            this.x = e[12];
            this.y = e[13];
            this.z = e[14];
            return this;
        },
        setFromMatrixScale: function(m) {
            var sx = this.setFromMatrixColumn(m, 0).length();
            var sy = this.setFromMatrixColumn(m, 1).length();
            var sz = this.setFromMatrixColumn(m, 2).length();
            this.x = sx;
            this.y = sy;
            this.z = sz;
            return this;
        },
        setFromMatrixColumn: function(m, index) {
            return this.fromArray(m.elements, index * 4);
        },
        equals: function(v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            return array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            if (offset !== undefined) {
                console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            return this;
        }
    });

    function Matrix3() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (arguments.length > 0) {
            console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
        }
    }
    Object.assign(Matrix3.prototype, {
        isMatrix3: true,
        set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var te = this.elements;
            te[0] = n11;
            te[1] = n21;
            te[2] = n31;
            te[3] = n12;
            te[4] = n22;
            te[5] = n32;
            te[6] = n13;
            te[7] = n23;
            te[8] = n33;
            return this;
        },
        identity: function() {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
        },
        clone: function() {
            return new this.constructor().fromArray(this.elements);
        },
        copy: function(m) {
            var te = this.elements;
            var me = m.elements;
            te[0] = me[0];
            te[1] = me[1];
            te[2] = me[2];
            te[3] = me[3];
            te[4] = me[4];
            te[5] = me[5];
            te[6] = me[6];
            te[7] = me[7];
            te[8] = me[8];
            return this;
        },
        setFromMatrix4: function(m) {
            var me = m.elements;
            this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
            return this;
        },
        applyToBufferAttribute: function() {
            var v1 = new Vector3();
            return function applyToBufferAttribute(attribute) {
                for (var i = 0, l = attribute.count; i < l; i++) {
                    v1.x = attribute.getX(i);
                    v1.y = attribute.getY(i);
                    v1.z = attribute.getZ(i);
                    v1.applyMatrix3(this);
                    attribute.setXYZ(i, v1.x, v1.y, v1.z);
                }
                return attribute;
            };
        }(),
        multiply: function(m) {
            return this.multiplyMatrices(this, m);
        },
        premultiply: function(m) {
            return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function(a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0],
                a12 = ae[3],
                a13 = ae[6];
            var a21 = ae[1],
                a22 = ae[4],
                a23 = ae[7];
            var a31 = ae[2],
                a32 = ae[5],
                a33 = ae[8];
            var b11 = be[0],
                b12 = be[3],
                b13 = be[6];
            var b21 = be[1],
                b22 = be[4],
                b23 = be[7];
            var b31 = be[2],
                b32 = be[5],
                b33 = be[8];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31;
            te[3] = a11 * b12 + a12 * b22 + a13 * b32;
            te[6] = a11 * b13 + a12 * b23 + a13 * b33;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31;
            te[4] = a21 * b12 + a22 * b22 + a23 * b32;
            te[7] = a21 * b13 + a22 * b23 + a23 * b33;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31;
            te[5] = a31 * b12 + a32 * b22 + a33 * b32;
            te[8] = a31 * b13 + a32 * b23 + a33 * b33;
            return this;
        },
        multiplyScalar: function(s) {
            var te = this.elements;
            te[0] *= s;
            te[3] *= s;
            te[6] *= s;
            te[1] *= s;
            te[4] *= s;
            te[7] *= s;
            te[2] *= s;
            te[5] *= s;
            te[8] *= s;
            return this;
        },
        determinant: function() {
            var te = this.elements;
            var a = te[0],
                b = te[1],
                c = te[2],
                d = te[3],
                e = te[4],
                f = te[5],
                g = te[6],
                h = te[7],
                i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        },
        getInverse: function(matrix, throwOnDegenerate) {
            if (matrix && matrix.isMatrix4) {
                console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            }
            var me = matrix.elements,
                te = this.elements,
                n11 = me[0],
                n21 = me[1],
                n31 = me[2],
                n12 = me[3],
                n22 = me[4],
                n32 = me[5],
                n13 = me[6],
                n23 = me[7],
                n33 = me[8],
                t11 = n33 * n22 - n32 * n23,
                t12 = n32 * n13 - n33 * n12,
                t13 = n23 * n12 - n22 * n13,
                det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) {
                var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (throwOnDegenerate === true) {
                    throw new Error(msg);
                } else {
                    console.warn(msg);
                }
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        },
        transpose: function() {
            var tmp, m = this.elements;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        },
        getNormalMatrix: function(matrix4) {
            return this.setFromMatrix4(matrix4).getInverse(this).transpose();
        },
        transposeIntoArray: function(r) {
            var m = this.elements;
            r[0] = m[0];
            r[1] = m[3];
            r[2] = m[6];
            r[3] = m[1];
            r[4] = m[4];
            r[5] = m[7];
            r[6] = m[2];
            r[7] = m[5];
            r[8] = m[8];
            return this;
        },
        setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {
            var c = Math.cos(rotation);
            var s = Math.sin(rotation);
            this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        },
        scale: function(sx, sy) {
            var te = this.elements;
            te[0] *= sx;
            te[3] *= sx;
            te[6] *= sx;
            te[1] *= sy;
            te[4] *= sy;
            te[7] *= sy;
            return this;
        },
        rotate: function(theta) {
            var c = Math.cos(theta);
            var s = Math.sin(theta);
            var te = this.elements;
            var a11 = te[0],
                a12 = te[3],
                a13 = te[6];
            var a21 = te[1],
                a22 = te[4],
                a23 = te[7];
            te[0] = c * a11 + s * a21;
            te[3] = c * a12 + s * a22;
            te[6] = c * a13 + s * a23;
            te[1] = -s * a11 + c * a21;
            te[4] = -s * a12 + c * a22;
            te[7] = -s * a13 + c * a23;
            return this;
        },
        translate: function(tx, ty) {
            var te = this.elements;
            te[0] += tx * te[2];
            te[3] += tx * te[5];
            te[6] += tx * te[8];
            te[1] += ty * te[2];
            te[4] += ty * te[5];
            te[7] += ty * te[8];
            return this;
        },
        equals: function(matrix) {
            var te = this.elements;
            var me = matrix.elements;
            for (var i = 0; i < 9; i++) {
                if (te[i] !== me[i]) return false;
            }
            return true;
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            for (var i = 0; i < 9; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            return array;
        }
    });
    var textureId = 0;

    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        Object.defineProperty(this, 'id', {
            value: textureId++
        });
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
        this.mipmaps = [];
        this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
        this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
        this.format = format !== undefined ? format : RGBAFormat;
        this.type = type !== undefined ? type : UnsignedByteType;
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.center = new Vector2(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix3();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4;
        this.encoding = encoding !== undefined ? encoding : LinearEncoding;
        this.version = 0;
        this.onUpdate = null;
    }
    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Texture,
        isTexture: true,
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.name = source.name;
            this.image = source.image;
            this.mipmaps = source.mipmaps.slice(0);
            this.mapping = source.mapping;
            this.wrapS = source.wrapS;
            this.wrapT = source.wrapT;
            this.magFilter = source.magFilter;
            this.minFilter = source.minFilter;
            this.anisotropy = source.anisotropy;
            this.format = source.format;
            this.type = source.type;
            this.offset.copy(source.offset);
            this.repeat.copy(source.repeat);
            this.center.copy(source.center);
            this.rotation = source.rotation;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrix.copy(source.matrix);
            this.generateMipmaps = source.generateMipmaps;
            this.premultiplyAlpha = source.premultiplyAlpha;
            this.flipY = source.flipY;
            this.unpackAlignment = source.unpackAlignment;
            this.encoding = source.encoding;
            return this;
        },
        toJSON: function(meta) {
            var isRootObject = (meta === undefined || typeof meta === 'string');
            if (!isRootObject && meta.textures[this.uuid] !== undefined) {
                return meta.textures[this.uuid];
            }

            function getDataURL(image) {
                var canvas;
                if (image instanceof HTMLCanvasElement) {
                    canvas = image;
                } else {
                    canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    var context = canvas.getContext('2d');
                    if (image instanceof ImageData) {
                        context.putImageData(image, 0, 0);
                    } else {
                        context.drawImage(image, 0, 0, image.width, image.height);
                    }
                }
                if (canvas.width > 2048 || canvas.height > 2048) {
                    return canvas.toDataURL('image/jpeg', 0.6);
                } else {
                    return canvas.toDataURL('image/png');
                }
            }
            var output = {
                metadata: {
                    version: 4.5,
                    type: 'Texture',
                    generator: 'Texture.toJSON'
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (this.image !== undefined) {
                var image = this.image;
                if (image.uuid === undefined) {
                    image.uuid = _Math.generateUUID();
                }
                if (!isRootObject && meta.images[image.uuid] === undefined) {
                    meta.images[image.uuid] = {
                        uuid: image.uuid,
                        url: getDataURL(image)
                    };
                }
                output.image = image.uuid;
            }
            if (!isRootObject) {
                meta.textures[this.uuid] = output;
            }
            return output;
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            });
        },
        transformUv: function(uv) {
            if (this.mapping !== UVMapping) return;
            uv.applyMatrix3(this.matrix);
            if (uv.x < 0 || uv.x > 1) {
                switch (this.wrapS) {
                    case RepeatWrapping:
                        uv.x = uv.x - Math.floor(uv.x);
                        break;
                    case ClampToEdgeWrapping:
                        uv.x = uv.x < 0 ? 0 : 1;
                        break;
                    case MirroredRepeatWrapping:
                        if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                            uv.x = Math.ceil(uv.x) - uv.x;
                        } else {
                            uv.x = uv.x - Math.floor(uv.x);
                        }
                        break;
                }
            }
            if (uv.y < 0 || uv.y > 1) {
                switch (this.wrapT) {
                    case RepeatWrapping:
                        uv.y = uv.y - Math.floor(uv.y);
                        break;
                    case ClampToEdgeWrapping:
                        uv.y = uv.y < 0 ? 0 : 1;
                        break;
                    case MirroredRepeatWrapping:
                        if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                            uv.y = Math.ceil(uv.y) - uv.y;
                        } else {
                            uv.y = uv.y - Math.floor(uv.y);
                        }
                        break;
                }
            }
            if (this.flipY) {
                uv.y = 1 - uv.y;
            }
        }
    });
    Object.defineProperty(Texture.prototype, "needsUpdate", {
        set: function(value) {
            if (value === true) this.version++;
        }
    });

    function Vector4(x, y, z, w) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = (w !== undefined) ? w : 1;
    }
    Object.assign(Vector4.prototype, {
        isVector4: true,
        set: function(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        },
        setScalar: function(scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            this.w = scalar;
            return this;
        },
        setX: function(x) {
            this.x = x;
            return this;
        },
        setY: function(y) {
            this.y = y;
            return this;
        },
        setZ: function(z) {
            this.z = z;
            return this;
        },
        setW: function(w) {
            this.w = w;
            return this;
        },
        setComponent: function(index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                case 3:
                    this.w = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);
            }
            return this;
        },
        getComponent: function(index) {
            switch (index) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error('index is out of range: ' + index);
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function(v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = (v.w !== undefined) ? v.w : 1;
            return this;
        },
        add: function(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
            return this;
        },
        addScalar: function(s) {
            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;
            return this;
        },
        addVectors: function(a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this;
        },
        addScaledVector: function(v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            this.w += v.w * s;
            return this;
        },
        sub: function(v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
            return this;
        },
        subScalar: function(s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            this.w -= s;
            return this;
        },
        subVectors: function(a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this;
        },
        multiplyScalar: function(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
            return this;
        },
        applyMatrix4: function(m) {
            var x = this.x,
                y = this.y,
                z = this.z,
                w = this.w;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
            return this;
        },
        divideScalar: function(scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        setAxisAngleFromQuaternion: function(q) {
            this.w = 2 * Math.acos(q.w);
            var s = Math.sqrt(1 - q.w * q.w);
            if (s < 0.0001) {
                this.x = 1;
                this.y = 0;
                this.z = 0;
            } else {
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
            }
            return this;
        },
        setAxisAngleFromRotationMatrix: function(m) {
            var angle, x, y, z, epsilon = 0.01,
                epsilon2 = 0.1,
                te = m.elements,
                m11 = te[0],
                m12 = te[4],
                m13 = te[8],
                m21 = te[1],
                m22 = te[5],
                m23 = te[9],
                m31 = te[2],
                m32 = te[6],
                m33 = te[10];
            if ((Math.abs(m12 - m21) < epsilon) && (Math.abs(m13 - m31) < epsilon) && (Math.abs(m23 - m32) < epsilon)) {
                if ((Math.abs(m12 + m21) < epsilon2) && (Math.abs(m13 + m31) < epsilon2) && (Math.abs(m23 + m32) < epsilon2) && (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
                    this.set(1, 0, 0, 0);
                    return this;
                }
                angle = Math.PI;
                var xx = (m11 + 1) / 2;
                var yy = (m22 + 1) / 2;
                var zz = (m33 + 1) / 2;
                var xy = (m12 + m21) / 4;
                var xz = (m13 + m31) / 4;
                var yz = (m23 + m32) / 4;
                if ((xx > yy) && (xx > zz)) {
                    if (xx < epsilon) {
                        x = 0;
                        y = 0.707106781;
                        z = 0.707106781;
                    } else {
                        x = Math.sqrt(xx);
                        y = xy / x;
                        z = xz / x;
                    }
                } else if (yy > zz) {
                    if (yy < epsilon) {
                        x = 0.707106781;
                        y = 0;
                        z = 0.707106781;
                    } else {
                        y = Math.sqrt(yy);
                        x = xy / y;
                        z = yz / y;
                    }
                } else {
                    if (zz < epsilon) {
                        x = 0.707106781;
                        y = 0.707106781;
                        z = 0;
                    } else {
                        z = Math.sqrt(zz);
                        x = xz / z;
                        y = yz / z;
                    }
                }
                this.set(x, y, z, angle);
                return this;
            }
            var s = Math.sqrt((m32 - m23) * (m32 - m23) +
                (m13 - m31) * (m13 - m31) +
                (m21 - m12) * (m21 - m12));
            if (Math.abs(s) < 0.001) s = 1;
            this.x = (m32 - m23) / s;
            this.y = (m13 - m31) / s;
            this.z = (m21 - m12) / s;
            this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
            return this;
        },
        min: function(v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            this.w = Math.min(this.w, v.w);
            return this;
        },
        max: function(v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            this.w = Math.max(this.w, v.w);
            return this;
        },
        clamp: function(min, max) {
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            this.z = Math.max(min.z, Math.min(max.z, this.z));
            this.w = Math.max(min.w, Math.min(max.w, this.w));
            return this;
        },
        clampScalar: function() {
            var min, max;
            return function clampScalar(minVal, maxVal) {
                if (min === undefined) {
                    min = new Vector4();
                    max = new Vector4();
                }
                min.set(minVal, minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal, maxVal);
                return this.clamp(min, max);
            };
        }(),
        clampLength: function(min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function() {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);
            return this;
        },
        ceil: function() {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this;
        },
        round: function() {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);
            return this;
        },
        roundToZero: function() {
            this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
            this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
            return this;
        },
        negate: function() {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
        },
        dot: function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1);
        },
        setLength: function(length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function(v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            this.w += (v.w - this.w) * alpha;
            return this;
        },
        lerpVectors: function(v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function(v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;
            return array;
        },
        fromBufferAttribute: function(attribute, index, offset) {
            if (offset !== undefined) {
                console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            this.w = attribute.getW(index);
            return this;
        }
    });

    function WebGLRenderTarget(width, height, options) {
        this.uuid = _Math.generateUUID();
        this.width = width;
        this.height = height;
        this.scissor = new Vector4(0, 0, width, height);
        this.scissorTest = false;
        this.viewport = new Vector4(0, 0, width, height);
        options = options || {};
        if (options.minFilter === undefined) options.minFilter = LinearFilter;
        this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
        this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    }
    WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: WebGLRenderTarget,
        isWebGLRenderTarget: true,
        setSize: function(width, height) {
            if (this.width !== width || this.height !== height) {
                this.width = width;
                this.height = height;
                this.dispose();
            }
            this.viewport.set(0, 0, width, height);
            this.scissor.set(0, 0, width, height);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.width = source.width;
            this.height = source.height;
            this.viewport.copy(source.viewport);
            this.texture = source.texture.clone();
            this.depthBuffer = source.depthBuffer;
            this.stencilBuffer = source.stencilBuffer;
            this.depthTexture = source.depthTexture;
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });

    function WebGLRenderTargetCube(width, height, options) {
        WebGLRenderTarget.call(this, width, height, options);
        this.activeCubeFace = 0;
        this.activeMipMapLevel = 0;
    }
    WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
    WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = {
            data: data,
            width: width,
            height: height
        };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
    }
    DataTexture.prototype = Object.create(Texture.prototype);
    DataTexture.prototype.constructor = DataTexture;
    DataTexture.prototype.isDataTexture = true;

    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        images = images !== undefined ? images : [];
        mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
        Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.flipY = false;
    }
    CubeTexture.prototype = Object.create(Texture.prototype);
    CubeTexture.prototype.constructor = CubeTexture;
    CubeTexture.prototype.isCubeTexture = true;
    Object.defineProperty(CubeTexture.prototype, 'images', {
        get: function() {
            return this.image;
        },
        set: function(value) {
            this.image = value;
        }
    });
    var emptyTexture = new Texture();
    var emptyCubeTexture = new CubeTexture();

    function UniformContainer() {
        this.seq = [];
        this.map = {};
    }
    var arrayCacheF32 = [];
    var arrayCacheI32 = [];
    var mat4array = new Float32Array(16);
    var mat3array = new Float32Array(9);

    function flatten(array, nBlocks, blockSize) {
        var firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0) return array;
        var n = nBlocks * blockSize,
            r = arrayCacheF32[n];
        if (r === undefined) {
            r = new Float32Array(n);
            arrayCacheF32[n] = r;
        }
        if (nBlocks !== 0) {
            firstElem.toArray(r, 0);
            for (var i = 1, offset = 0; i !== nBlocks; ++i) {
                offset += blockSize;
                array[i].toArray(r, offset);
            }
        }
        return r;
    }

    function allocTexUnits(renderer, n) {
        var r = arrayCacheI32[n];
        if (r === undefined) {
            r = new Int32Array(n);
            arrayCacheI32[n] = r;
        }
        for (var i = 0; i !== n; ++i)
            r[i] = renderer.allocTextureUnit();
        return r;
    }

    function setValue1f(gl, v) {
        gl.uniform1f(this.addr, v);
    }

    function setValue1i(gl, v) {
        gl.uniform1i(this.addr, v);
    }

    function setValue2fv(gl, v) {
        if (v.x === undefined) {
            gl.uniform2fv(this.addr, v);
        } else {
            gl.uniform2f(this.addr, v.x, v.y);
        }
    }

    function setValue3fv(gl, v) {
        if (v.x !== undefined) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
        } else if (v.r !== undefined) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
        } else {
            gl.uniform3fv(this.addr, v);
        }
    }

    function setValue4fv(gl, v) {
        if (v.x === undefined) {
            gl.uniform4fv(this.addr, v);
        } else {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        }
    }

    function setValue2fm(gl, v) {
        gl.uniformMatrix2fv(this.addr, false, v.elements || v);
    }

    function setValue3fm(gl, v) {
        if (v.elements === undefined) {
            gl.uniformMatrix3fv(this.addr, false, v);
        } else {
            mat3array.set(v.elements);
            gl.uniformMatrix3fv(this.addr, false, mat3array);
        }
    }

    function setValue4fm(gl, v) {
        if (v.elements === undefined) {
            gl.uniformMatrix4fv(this.addr, false, v);
        } else {
            mat4array.set(v.elements);
            gl.uniformMatrix4fv(this.addr, false, mat4array);
        }
    }

    function setValueT1(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit);
        renderer.setTexture2D(v || emptyTexture, unit);
    }

    function setValueT6(gl, v, renderer) {
        var unit = renderer.allocTextureUnit();
        gl.uniform1i(this.addr, unit);
        renderer.setTextureCube(v || emptyCubeTexture, unit);
    }

    function setValue2iv(gl, v) {
        gl.uniform2iv(this.addr, v);
    }

    function setValue3iv(gl, v) {
        gl.uniform3iv(this.addr, v);
    }

    function setValue4iv(gl, v) {
        gl.uniform4iv(this.addr, v);
    }

    function getSingularSetter(type) {
        switch (type) {
            case 0x1406:
                return setValue1f;
            case 0x8b50:
                return setValue2fv;
            case 0x8b51:
                return setValue3fv;
            case 0x8b52:
                return setValue4fv;
            case 0x8b5a:
                return setValue2fm;
            case 0x8b5b:
                return setValue3fm;
            case 0x8b5c:
                return setValue4fm;
            case 0x8b5e:
            case 0x8d66:
                return setValueT1;
            case 0x8b60:
                return setValueT6;
            case 0x1404:
            case 0x8b56:
                return setValue1i;
            case 0x8b53:
            case 0x8b57:
                return setValue2iv;
            case 0x8b54:
            case 0x8b58:
                return setValue3iv;
            case 0x8b55:
            case 0x8b59:
                return setValue4iv;
        }
    }

    function setValue1fv(gl, v) {
        gl.uniform1fv(this.addr, v);
    }

    function setValue1iv(gl, v) {
        gl.uniform1iv(this.addr, v);
    }

    function setValueV2a(gl, v) {
        gl.uniform2fv(this.addr, flatten(v, this.size, 2));
    }

    function setValueV3a(gl, v) {
        gl.uniform3fv(this.addr, flatten(v, this.size, 3));
    }

    function setValueV4a(gl, v) {
        gl.uniform4fv(this.addr, flatten(v, this.size, 4));
    }

    function setValueM2a(gl, v) {
        gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));
    }

    function setValueM3a(gl, v) {
        gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));
    }

    function setValueM4a(gl, v) {
        gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));
    }

    function setValueT1a(gl, v, renderer) {
        var n = v.length,
            units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) {
            renderer.setTexture2D(v[i] || emptyTexture, units[i]);
        }
    }

    function setValueT6a(gl, v, renderer) {
        var n = v.length,
            units = allocTexUnits(renderer, n);
        gl.uniform1iv(this.addr, units);
        for (var i = 0; i !== n; ++i) {
            renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
        }
    }

    function getPureArraySetter(type) {
        switch (type) {
            case 0x1406:
                return setValue1fv;
            case 0x8b50:
                return setValueV2a;
            case 0x8b51:
                return setValueV3a;
            case 0x8b52:
                return setValueV4a;
            case 0x8b5a:
                return setValueM2a;
            case 0x8b5b:
                return setValueM3a;
            case 0x8b5c:
                return setValueM4a;
            case 0x8b5e:
                return setValueT1a;
            case 0x8b60:
                return setValueT6a;
            case 0x1404:
            case 0x8b56:
                return setValue1iv;
            case 0x8b53:
            case 0x8b57:
                return setValue2iv;
            case 0x8b54:
            case 0x8b58:
                return setValue3iv;
            case 0x8b55:
            case 0x8b59:
                return setValue4iv;
        }
    }

    function SingleUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.setValue = getSingularSetter(activeInfo.type);
    }

    function PureArrayUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter(activeInfo.type);
    }

    function StructuredUniform(id) {
        this.id = id;
        UniformContainer.call(this);
    }
    StructuredUniform.prototype.setValue = function(gl, value) {
        var seq = this.seq;
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            u.setValue(gl, value[u.id]);
        }
    };
    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

    function addUniform(container, uniformObject) {
        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
    }

    function parseUniform(activeInfo, addr, container) {
        var path = activeInfo.name,
            pathLength = path.length;
        RePathPart.lastIndex = 0;
        for (;;) {
            var match = RePathPart.exec(path),
                matchEnd = RePathPart.lastIndex,
                id = match[1],
                idIsIndex = match[2] === ']',
                subscript = match[3];
            if (idIsIndex) id = id | 0;
            if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
                addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                break;
            } else {
                var map = container.map,
                    next = map[id];
                if (next === undefined) {
                    next = new StructuredUniform(id);
                    addUniform(container, next);
                }
                container = next;
            }
        }
    }

    function WebGLUniforms(gl, program, renderer) {
        UniformContainer.call(this);
        this.renderer = renderer;
        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < n; ++i) {
            var info = gl.getActiveUniform(program, i),
                path = info.name,
                addr = gl.getUniformLocation(program, path);
            parseUniform(info, addr, this);
        }
    }
    WebGLUniforms.prototype.setValue = function(gl, name, value) {
        var u = this.map[name];
        if (u !== undefined) u.setValue(gl, value, this.renderer);
    };
    WebGLUniforms.prototype.setOptional = function(gl, object, name) {
        var v = object[name];
        if (v !== undefined) this.setValue(gl, name, v);
    };
    WebGLUniforms.upload = function(gl, seq, values, renderer) {
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i],
                v = values[u.id];
            if (v.needsUpdate !== false) {
                u.setValue(gl, v.value, renderer);
            }
        }
    };
    WebGLUniforms.seqWithValue = function(seq, values) {
        var r = [];
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            if (u.id in values) r.push(u);
        }
        return r;
    };
    var ColorKeywords = {
        'aliceblue': 0xF0F8FF,
        'antiquewhite': 0xFAEBD7,
        'aqua': 0x00FFFF,
        'aquamarine': 0x7FFFD4,
        'azure': 0xF0FFFF,
        'beige': 0xF5F5DC,
        'bisque': 0xFFE4C4,
        'black': 0x000000,
        'blanchedalmond': 0xFFEBCD,
        'blue': 0x0000FF,
        'blueviolet': 0x8A2BE2,
        'brown': 0xA52A2A,
        'burlywood': 0xDEB887,
        'cadetblue': 0x5F9EA0,
        'chartreuse': 0x7FFF00,
        'chocolate': 0xD2691E,
        'coral': 0xFF7F50,
        'cornflowerblue': 0x6495ED,
        'cornsilk': 0xFFF8DC,
        'crimson': 0xDC143C,
        'cyan': 0x00FFFF,
        'darkblue': 0x00008B,
        'darkcyan': 0x008B8B,
        'darkgoldenrod': 0xB8860B,
        'darkgray': 0xA9A9A9,
        'darkgreen': 0x006400,
        'darkgrey': 0xA9A9A9,
        'darkkhaki': 0xBDB76B,
        'darkmagenta': 0x8B008B,
        'darkolivegreen': 0x556B2F,
        'darkorange': 0xFF8C00,
        'darkorchid': 0x9932CC,
        'darkred': 0x8B0000,
        'darksalmon': 0xE9967A,
        'darkseagreen': 0x8FBC8F,
        'darkslateblue': 0x483D8B,
        'darkslategray': 0x2F4F4F,
        'darkslategrey': 0x2F4F4F,
        'darkturquoise': 0x00CED1,
        'darkviolet': 0x9400D3,
        'deeppink': 0xFF1493,
        'deepskyblue': 0x00BFFF,
        'dimgray': 0x696969,
        'dimgrey': 0x696969,
        'dodgerblue': 0x1E90FF,
        'firebrick': 0xB22222,
        'floralwhite': 0xFFFAF0,
        'forestgreen': 0x228B22,
        'fuchsia': 0xFF00FF,
        'gainsboro': 0xDCDCDC,
        'ghostwhite': 0xF8F8FF,
        'gold': 0xFFD700,
        'goldenrod': 0xDAA520,
        'gray': 0x808080,
        'green': 0x008000,
        'greenyellow': 0xADFF2F,
        'grey': 0x808080,
        'honeydew': 0xF0FFF0,
        'hotpink': 0xFF69B4,
        'indianred': 0xCD5C5C,
        'indigo': 0x4B0082,
        'ivory': 0xFFFFF0,
        'khaki': 0xF0E68C,
        'lavender': 0xE6E6FA,
        'lavenderblush': 0xFFF0F5,
        'lawngreen': 0x7CFC00,
        'lemonchiffon': 0xFFFACD,
        'lightblue': 0xADD8E6,
        'lightcoral': 0xF08080,
        'lightcyan': 0xE0FFFF,
        'lightgoldenrodyellow': 0xFAFAD2,
        'lightgray': 0xD3D3D3,
        'lightgreen': 0x90EE90,
        'lightgrey': 0xD3D3D3,
        'lightpink': 0xFFB6C1,
        'lightsalmon': 0xFFA07A,
        'lightseagreen': 0x20B2AA,
        'lightskyblue': 0x87CEFA,
        'lightslategray': 0x778899,
        'lightslategrey': 0x778899,
        'lightsteelblue': 0xB0C4DE,
        'lightyellow': 0xFFFFE0,
        'lime': 0x00FF00,
        'limegreen': 0x32CD32,
        'linen': 0xFAF0E6,
        'magenta': 0xFF00FF,
        'maroon': 0x800000,
        'mediumaquamarine': 0x66CDAA,
        'mediumblue': 0x0000CD,
        'mediumorchid': 0xBA55D3,
        'mediumpurple': 0x9370DB,
        'mediumseagreen': 0x3CB371,
        'mediumslateblue': 0x7B68EE,
        'mediumspringgreen': 0x00FA9A,
        'mediumturquoise': 0x48D1CC,
        'mediumvioletred': 0xC71585,
        'midnightblue': 0x191970,
        'mintcream': 0xF5FFFA,
        'mistyrose': 0xFFE4E1,
        'moccasin': 0xFFE4B5,
        'navajowhite': 0xFFDEAD,
        'navy': 0x000080,
        'oldlace': 0xFDF5E6,
        'olive': 0x808000,
        'olivedrab': 0x6B8E23,
        'orange': 0xFFA500,
        'orangered': 0xFF4500,
        'orchid': 0xDA70D6,
        'palegoldenrod': 0xEEE8AA,
        'palegreen': 0x98FB98,
        'paleturquoise': 0xAFEEEE,
        'palevioletred': 0xDB7093,
        'papayawhip': 0xFFEFD5,
        'peachpuff': 0xFFDAB9,
        'peru': 0xCD853F,
        'pink': 0xFFC0CB,
        'plum': 0xDDA0DD,
        'powderblue': 0xB0E0E6,
        'purple': 0x800080,
        'rebeccapurple': 0x663399,
        'red': 0xFF0000,
        'rosybrown': 0xBC8F8F,
        'royalblue': 0x4169E1,
        'saddlebrown': 0x8B4513,
        'salmon': 0xFA8072,
        'sandybrown': 0xF4A460,
        'seagreen': 0x2E8B57,
        'seashell': 0xFFF5EE,
        'sienna': 0xA0522D,
        'silver': 0xC0C0C0,
        'skyblue': 0x87CEEB,
        'slateblue': 0x6A5ACD,
        'slategray': 0x708090,
        'slategrey': 0x708090,
        'snow': 0xFFFAFA,
        'springgreen': 0x00FF7F,
        'steelblue': 0x4682B4,
        'tan': 0xD2B48C,
        'teal': 0x008080,
        'thistle': 0xD8BFD8,
        'tomato': 0xFF6347,
        'turquoise': 0x40E0D0,
        'violet': 0xEE82EE,
        'wheat': 0xF5DEB3,
        'white': 0xFFFFFF,
        'whitesmoke': 0xF5F5F5,
        'yellow': 0xFFFF00,
        'yellowgreen': 0x9ACD32
    };

    function Color(r, g, b) {
        if (g === undefined && b === undefined) {
            return this.set(r);
        }
        return this.setRGB(r, g, b);
    }
    Object.assign(Color.prototype, {
        isColor: true,
        r: 1,
        g: 1,
        b: 1,
        set: function(value) {
            if (value && value.isColor) {
                this.copy(value);
            } else if (typeof value === 'number') {
                this.setHex(value);
            } else if (typeof value === 'string') {
                this.setStyle(value);
            }
            return this;
        },
        setScalar: function(scalar) {
            this.r = scalar;
            this.g = scalar;
            this.b = scalar;
            return this;
        },
        setHex: function(hex) {
            hex = Math.floor(hex);
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        },
        setRGB: function(r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
            return this;
        },
        setHSL: function() {
            function hue2rgb(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
                return p;
            }
            return function setHSL(h, s, l) {
                h = _Math.euclideanModulo(h, 1);
                s = _Math.clamp(s, 0, 1);
                l = _Math.clamp(l, 0, 1);
                if (s === 0) {
                    this.r = this.g = this.b = l;
                } else {
                    var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
                    var q = (2 * l) - p;
                    this.r = hue2rgb(q, p, h + 1 / 3);
                    this.g = hue2rgb(q, p, h);
                    this.b = hue2rgb(q, p, h - 1 / 3);
                }
                return this;
            };
        }(),
        setStyle: function(style) {
            function handleAlpha(string) {
                if (string === undefined) return;
                if (parseFloat(string) < 1) {
                    console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
                }
            }
            var m;
            if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                var color;
                var name = m[1];
                var components = m[2];
                switch (name) {
                    case 'rgb':
                    case 'rgba':
                        if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                            handleAlpha(color[5]);
                            return this;
                        }
                        if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                            handleAlpha(color[5]);
                            return this;
                        }
                        break;
                    case 'hsl':
                    case 'hsla':
                        if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            var h = parseFloat(color[1]) / 360;
                            var s = parseInt(color[2], 10) / 100;
                            var l = parseInt(color[3], 10) / 100;
                            handleAlpha(color[5]);
                            return this.setHSL(h, s, l);
                        }
                        break;
                }
            } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                var hex = m[1];
                var size = hex.length;
                if (size === 3) {
                    this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                    this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                    this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                    return this;
                } else if (size === 6) {
                    this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                    this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                    this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                    return this;
                }
            }
            if (style && style.length > 0) {
                var hex = ColorKeywords[style];
                if (hex !== undefined) {
                    this.setHex(hex);
                } else {
                    console.warn('THREE.Color: Unknown color ' + style);
                }
            }
            return this;
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b);
        },
        copy: function(color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            return this;
        },
        copyGammaToLinear: function(color, gammaFactor) {
            if (gammaFactor === undefined) gammaFactor = 2.0;
            this.r = Math.pow(color.r, gammaFactor);
            this.g = Math.pow(color.g, gammaFactor);
            this.b = Math.pow(color.b, gammaFactor);
            return this;
        },
        copyLinearToGamma: function(color, gammaFactor) {
            if (gammaFactor === undefined) gammaFactor = 2.0;
            var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
            this.r = Math.pow(color.r, safeInverse);
            this.g = Math.pow(color.g, safeInverse);
            this.b = Math.pow(color.b, safeInverse);
            return this;
        },
        convertGammaToLinear: function() {
            var r = this.r,
                g = this.g,
                b = this.b;
            this.r = r * r;
            this.g = g * g;
            this.b = b * b;
            return this;
        },
        convertLinearToGamma: function() {
            this.r = Math.sqrt(this.r);
            this.g = Math.sqrt(this.g);
            this.b = Math.sqrt(this.b);
            return this;
        },
        getHex: function() {
            return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
        },
        getHexString: function() {
            return ('000000' + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function(optionalTarget) {
            var hsl = optionalTarget || {
                h: 0,
                s: 0,
                l: 0
            };
            var r = this.r,
                g = this.g,
                b = this.b;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var hue, saturation;
            var lightness = (min + max) / 2.0;
            if (min === max) {
                hue = 0;
                saturation = 0;
            } else {
                var delta = max - min;
                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                switch (max) {
                    case r:
                        hue = (g - b) / delta + (g < b ? 6 : 0);
                        break;
                    case g:
                        hue = (b - r) / delta + 2;
                        break;
                    case b:
                        hue = (r - g) / delta + 4;
                        break;
                }
                hue /= 6;
            }
            hsl.h = hue;
            hsl.s = saturation;
            hsl.l = lightness;
            return hsl;
        },
        getStyle: function() {
            return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
        },
        offsetHSL: function(h, s, l) {
            var hsl = this.getHSL();
            hsl.h += h;
            hsl.s += s;
            hsl.l += l;
            this.setHSL(hsl.h, hsl.s, hsl.l);
            return this;
        },
        add: function(color) {
            this.r += color.r;
            this.g += color.g;
            this.b += color.b;
            return this;
        },
        addColors: function(color1, color2) {
            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;
            return this;
        },
        addScalar: function(s) {
            this.r += s;
            this.g += s;
            this.b += s;
            return this;
        },
        sub: function(color) {
            this.r = Math.max(0, this.r - color.r);
            this.g = Math.max(0, this.g - color.g);
            this.b = Math.max(0, this.b - color.b);
            return this;
        },
        multiply: function(color) {
            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;
            return this;
        },
        multiplyScalar: function(s) {
            this.r *= s;
            this.g *= s;
            this.b *= s;
            return this;
        },
        lerp: function(color, alpha) {
            this.r += (color.r - this.r) * alpha;
            this.g += (color.g - this.g) * alpha;
            this.b += (color.b - this.b) * alpha;
            return this;
        },
        equals: function(c) {
            return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
        },
        fromArray: function(array, offset) {
            if (offset === undefined) offset = 0;
            this.r = array[offset];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this.r;
            array[offset + 1] = this.g;
            array[offset + 2] = this.b;
            return array;
        },
        toJSON: function() {
            return this.getHex();
        }
    });
    var UniformsLib = {
        common: {
            diffuse: {
                value: new Color(0xeeeeee)
            },
            opacity: {
                value: 1.0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Matrix3()
            },
            alphaMap: {
                value: null
            },
        },
        specularmap: {
            specularMap: {
                value: null
            },
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1.0
            },
            refractionRatio: {
                value: 0.98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 0.00025
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2000
            },
            fogColor: {
                value: new Color(0xffffff)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Color(0xeeeeee)
            },
            opacity: {
                value: 1.0
            },
            size: {
                value: 1.0
            },
            scale: {
                value: 1.0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Matrix3()
            }
        }
    };
    var UniformsUtils = {
        merge: function(uniforms) {
            var merged = {};
            for (var u = 0; u < uniforms.length; u++) {
                var tmp = this.clone(uniforms[u]);
                for (var p in tmp) {
                    merged[p] = tmp[p];
                }
            }
            return merged;
        },
        clone: function(uniforms_src) {
            var uniforms_dst = {};
            for (var u in uniforms_src) {
                uniforms_dst[u] = {};
                for (var p in uniforms_src[u]) {
                    var parameter_src = uniforms_src[u][p];
                    if (parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture)) {
                        uniforms_dst[u][p] = parameter_src.clone();
                    } else if (Array.isArray(parameter_src)) {
                        uniforms_dst[u][p] = parameter_src.slice();
                    } else {
                        uniforms_dst[u][p] = parameter_src;
                    }
                }
            }
            return uniforms_dst;
        }
    };
    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
    var begin_vertex = "\nvec3 transformed = vec3( position );\n";
    var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
    var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";
    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
    var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
    var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";
    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
    var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";
    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
    var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";
    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
    var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
    var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";
    var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";
    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";
    var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";
    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
    var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
    var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
    var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";
    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
    var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
    var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";
    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";
    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
    var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
    var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";
    var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";
    var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";
    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";
    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";
    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
    var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
    var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
    var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";
    var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";
    var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";
    var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";
    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
    var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";
    var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";
    var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
    var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
    var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";
    var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";
    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";
    var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var ShaderChunk = {
        alphamap_fragment: alphamap_fragment,
        alphamap_pars_fragment: alphamap_pars_fragment,
        alphatest_fragment: alphatest_fragment,
        aomap_fragment: aomap_fragment,
        aomap_pars_fragment: aomap_pars_fragment,
        begin_vertex: begin_vertex,
        beginnormal_vertex: beginnormal_vertex,
        bsdfs: bsdfs,
        bumpmap_pars_fragment: bumpmap_pars_fragment,
        clipping_planes_fragment: clipping_planes_fragment,
        clipping_planes_pars_fragment: clipping_planes_pars_fragment,
        clipping_planes_pars_vertex: clipping_planes_pars_vertex,
        clipping_planes_vertex: clipping_planes_vertex,
        color_fragment: color_fragment,
        color_pars_fragment: color_pars_fragment,
        color_pars_vertex: color_pars_vertex,
        color_vertex: color_vertex,
        common: common,
        cube_uv_reflection_fragment: cube_uv_reflection_fragment,
        defaultnormal_vertex: defaultnormal_vertex,
        displacementmap_pars_vertex: displacementmap_pars_vertex,
        displacementmap_vertex: displacementmap_vertex,
        emissivemap_fragment: emissivemap_fragment,
        emissivemap_pars_fragment: emissivemap_pars_fragment,
        encodings_fragment: encodings_fragment,
        encodings_pars_fragment: encodings_pars_fragment,
        envmap_fragment: envmap_fragment,
        envmap_pars_fragment: envmap_pars_fragment,
        envmap_pars_vertex: envmap_pars_vertex,
        envmap_vertex: envmap_vertex,
        fog_vertex: fog_vertex,
        fog_pars_vertex: fog_pars_vertex,
        fog_fragment: fog_fragment,
        fog_pars_fragment: fog_pars_fragment,
        gradientmap_pars_fragment: gradientmap_pars_fragment,
        lightmap_fragment: lightmap_fragment,
        lightmap_pars_fragment: lightmap_pars_fragment,
        lights_lambert_vertex: lights_lambert_vertex,
        lights_pars: lights_pars,
        lights_phong_fragment: lights_phong_fragment,
        lights_phong_pars_fragment: lights_phong_pars_fragment,
        lights_physical_fragment: lights_physical_fragment,
        lights_physical_pars_fragment: lights_physical_pars_fragment,
        lights_template: lights_template,
        logdepthbuf_fragment: logdepthbuf_fragment,
        logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
        logdepthbuf_vertex: logdepthbuf_vertex,
        map_fragment: map_fragment,
        map_pars_fragment: map_pars_fragment,
        map_particle_fragment: map_particle_fragment,
        map_particle_pars_fragment: map_particle_pars_fragment,
        metalnessmap_fragment: metalnessmap_fragment,
        metalnessmap_pars_fragment: metalnessmap_pars_fragment,
        morphnormal_vertex: morphnormal_vertex,
        morphtarget_pars_vertex: morphtarget_pars_vertex,
        morphtarget_vertex: morphtarget_vertex,
        normal_fragment: normal_fragment,
        normalmap_pars_fragment: normalmap_pars_fragment,
        packing: packing,
        premultiplied_alpha_fragment: premultiplied_alpha_fragment,
        project_vertex: project_vertex,
        dithering_fragment: dithering_fragment,
        dithering_pars_fragment: dithering_pars_fragment,
        roughnessmap_fragment: roughnessmap_fragment,
        roughnessmap_pars_fragment: roughnessmap_pars_fragment,
        shadowmap_pars_fragment: shadowmap_pars_fragment,
        shadowmap_pars_vertex: shadowmap_pars_vertex,
        shadowmap_vertex: shadowmap_vertex,
        shadowmask_pars_fragment: shadowmask_pars_fragment,
        skinbase_vertex: skinbase_vertex,
        skinning_pars_vertex: skinning_pars_vertex,
        skinning_vertex: skinning_vertex,
        skinnormal_vertex: skinnormal_vertex,
        specularmap_fragment: specularmap_fragment,
        specularmap_pars_fragment: specularmap_pars_fragment,
        tonemapping_fragment: tonemapping_fragment,
        tonemapping_pars_fragment: tonemapping_pars_fragment,
        uv_pars_fragment: uv_pars_fragment,
        uv_pars_vertex: uv_pars_vertex,
        uv_vertex: uv_vertex,
        uv2_pars_fragment: uv2_pars_fragment,
        uv2_pars_vertex: uv2_pars_vertex,
        uv2_vertex: uv2_vertex,
        worldpos_vertex: worldpos_vertex,
        cube_frag: cube_frag,
        cube_vert: cube_vert,
        depth_frag: depth_frag,
        depth_vert: depth_vert,
        distanceRGBA_frag: distanceRGBA_frag,
        distanceRGBA_vert: distanceRGBA_vert,
        equirect_frag: equirect_frag,
        equirect_vert: equirect_vert,
        linedashed_frag: linedashed_frag,
        linedashed_vert: linedashed_vert,
        meshbasic_frag: meshbasic_frag,
        meshbasic_vert: meshbasic_vert,
        meshlambert_frag: meshlambert_frag,
        meshlambert_vert: meshlambert_vert,
        meshphong_frag: meshphong_frag,
        meshphong_vert: meshphong_vert,
        meshphysical_frag: meshphysical_frag,
        meshphysical_vert: meshphysical_vert,
        normal_frag: normal_frag,
        normal_vert: normal_vert,
        points_frag: points_frag,
        points_vert: points_vert,
        shadow_frag: shadow_frag,
        shadow_vert: shadow_vert
    };
    var ShaderLib = {
        basic: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0x000000)
                }
            }]),
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0x000000)
                },
                specular: {
                    value: new Color(0x111111)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0x000000)
                },
                roughness: {
                    value: 0.5
                },
                metalness: {
                    value: 0.5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
        },
        points: {
            uniforms: UniformsUtils.merge([UniformsLib.points, UniformsLib.fog]),
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.displacementmap]),
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
                opacity: {
                    value: 1.0
                }
            }]),
            vertexShader: ShaderChunk.normal_vert,
            fragmentShader: ShaderChunk.normal_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1.0
                }
            },
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                },
            },
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.displacementmap, {
                referencePosition: {
                    value: new Vector3()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }]),
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
            uniforms: UniformsUtils.merge([UniformsLib.lights, UniformsLib.fog, {
                color: {
                    value: new Color(0x00000)
                },
                opacity: {
                    value: 1.0
                }
            }, ]),
            vertexShader: ShaderChunk.shadow_vert,
            fragmentShader: ShaderChunk.shadow_frag
        }
    };
    ShaderLib.physical = {
        uniforms: UniformsUtils.merge([ShaderLib.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    };

    function Box2(min, max) {
        this.min = (min !== undefined) ? min : new Vector2(+Infinity, +Infinity);
        this.max = (max !== undefined) ? max : new Vector2(-Infinity, -Infinity);
    }
    Object.assign(Box2.prototype, {
        set: function(min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        },
        setFromPoints: function(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        },
        setFromCenterAndSize: function() {
            var v1 = new Vector2();
            return function setFromCenterAndSize(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(0.5);
                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        },
        makeEmpty: function() {
            this.min.x = this.min.y = +Infinity;
            this.max.x = this.max.y = -Infinity;
            return this;
        },
        isEmpty: function() {
            return (this.max.x < this.min.x) || (this.max.y < this.min.y);
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
        },
        getSize: function(optionalTarget) {
            var result = optionalTarget || new Vector2();
            return this.isEmpty() ? result.set(0, 0) : result.subVectors(this.max, this.min);
        },
        expandByPoint: function(point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        },
        expandByVector: function(vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        },
        expandByScalar: function(scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        },
        containsPoint: function(point) {
            return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        },
        containsBox: function(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        },
        getParameter: function(point, optionalTarget) {
            var result = optionalTarget || new Vector2();
            return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        },
        intersectsBox: function(box) {
            return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        },
        clampPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector2();
            return result.copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var v1 = new Vector2();
            return function distanceToPoint(point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
            };
        }(),
        intersect: function(box) {
            this.min.max(box.min);
            this.max.min(box.max);
            return this;
        },
        union: function(box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        },
        translate: function(offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        },
        equals: function(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    });

    function WebGLFlareRenderer(renderer, gl, state, textures, capabilities) {
        var vertexBuffer, elementBuffer;
        var shader, program, attributes, uniforms;
        var tempTexture, occlusionTexture;

        function init() {
            var vertices = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]);
            var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
            vertexBuffer = gl.createBuffer();
            elementBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
            tempTexture = gl.createTexture();
            occlusionTexture = gl.createTexture();
            state.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            shader = {
                vertexShader: ['uniform lowp int renderType;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'uniform float rotation;', 'uniform sampler2D occlusionMap;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'varying float vVisibility;', 'void main() {', '	vUV = uv;', '	vec2 pos = position;', '	if ( renderType == 2 ) {', '		vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );', '		visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );', '		visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );', '		visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );', '		visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );', '		visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );', '		visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );', '		visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );', '		visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );', '		vVisibility =        visibility.r / 9.0;', '		vVisibility *= 1.0 - visibility.g / 9.0;', '		vVisibility *=       visibility.b / 9.0;', '		vVisibility *= 1.0 - visibility.a / 9.0;', '		pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;', '		pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;', '	}', '	gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );', '}'].join('\n'),
                fragmentShader: ['uniform lowp int renderType;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform vec3 color;', 'varying vec2 vUV;', 'varying float vVisibility;', 'void main() {', '	if ( renderType == 0 ) {', '		gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );', '	} else if ( renderType == 1 ) {', '		gl_FragColor = texture2D( map, vUV );', '	} else {', '		vec4 texture = texture2D( map, vUV );', '		texture.a *= opacity * vVisibility;', '		gl_FragColor = texture;', '		gl_FragColor.rgb *= color;', '	}', '}'].join('\n')
            };
            program = createProgram(shader);
            attributes = {
                vertex: gl.getAttribLocation(program, 'position'),
                uv: gl.getAttribLocation(program, 'uv')
            };
            uniforms = {
                renderType: gl.getUniformLocation(program, 'renderType'),
                map: gl.getUniformLocation(program, 'map'),
                occlusionMap: gl.getUniformLocation(program, 'occlusionMap'),
                opacity: gl.getUniformLocation(program, 'opacity'),
                color: gl.getUniformLocation(program, 'color'),
                scale: gl.getUniformLocation(program, 'scale'),
                rotation: gl.getUniformLocation(program, 'rotation'),
                screenPosition: gl.getUniformLocation(program, 'screenPosition')
            };
        }
        this.render = function(flares, scene, camera, viewport) {
            if (flares.length === 0) return;
            var tempPosition = new Vector3();
            var invAspect = viewport.w / viewport.z,
                halfViewportWidth = viewport.z * 0.5,
                halfViewportHeight = viewport.w * 0.5;
            var size = 16 / viewport.w,
                scale = new Vector2(size * invAspect, size);
            var screenPosition = new Vector3(1, 1, 0),
                screenPositionPixels = new Vector2(1, 1);
            var validArea = new Box2();
            validArea.min.set(viewport.x, viewport.y);
            validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));
            if (program === undefined) {
                init();
            }
            state.useProgram(program);
            state.initAttributes();
            state.enableAttribute(attributes.vertex);
            state.enableAttribute(attributes.uv);
            state.disableUnusedAttributes();
            gl.uniform1i(uniforms.occlusionMap, 0);
            gl.uniform1i(uniforms.map, 1);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            state.disable(gl.CULL_FACE);
            state.buffers.depth.setMask(false);
            for (var i = 0, l = flares.length; i < l; i++) {
                size = 16 / viewport.w;
                scale.set(size * invAspect, size);
                var flare = flares[i];
                tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
                tempPosition.applyMatrix4(camera.matrixWorldInverse);
                tempPosition.applyMatrix4(camera.projectionMatrix);
                screenPosition.copy(tempPosition);
                screenPositionPixels.x = viewport.x + (screenPosition.x * halfViewportWidth) + halfViewportWidth - 8;
                screenPositionPixels.y = viewport.y + (screenPosition.y * halfViewportHeight) + halfViewportHeight - 8;
                if (validArea.containsPoint(screenPositionPixels) === true) {
                    state.activeTexture(gl.TEXTURE0);
                    state.bindTexture(gl.TEXTURE_2D, null);
                    state.activeTexture(gl.TEXTURE1);
                    state.bindTexture(gl.TEXTURE_2D, tempTexture);
                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                    gl.uniform1i(uniforms.renderType, 0);
                    gl.uniform2f(uniforms.scale, scale.x, scale.y);
                    gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                    state.disable(gl.BLEND);
                    state.enable(gl.DEPTH_TEST);
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    state.activeTexture(gl.TEXTURE0);
                    state.bindTexture(gl.TEXTURE_2D, occlusionTexture);
                    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0);
                    gl.uniform1i(uniforms.renderType, 1);
                    state.disable(gl.DEPTH_TEST);
                    state.activeTexture(gl.TEXTURE1);
                    state.bindTexture(gl.TEXTURE_2D, tempTexture);
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    flare.positionScreen.copy(screenPosition);
                    if (flare.customUpdateCallback) {
                        flare.customUpdateCallback(flare);
                    } else {
                        flare.updateLensFlares();
                    }
                    gl.uniform1i(uniforms.renderType, 2);
                    state.enable(gl.BLEND);
                    for (var j = 0, jl = flare.lensFlares.length; j < jl; j++) {
                        var sprite = flare.lensFlares[j];
                        if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
                            screenPosition.x = sprite.x;
                            screenPosition.y = sprite.y;
                            screenPosition.z = sprite.z;
                            size = sprite.size * sprite.scale / viewport.w;
                            scale.x = size * invAspect;
                            scale.y = size;
                            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                            gl.uniform2f(uniforms.scale, scale.x, scale.y);
                            gl.uniform1f(uniforms.rotation, sprite.rotation);
                            gl.uniform1f(uniforms.opacity, sprite.opacity);
                            gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                            state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                            textures.setTexture2D(sprite.texture, 1);
                            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                        }
                    }
                }
            }
            state.enable(gl.CULL_FACE);
            state.enable(gl.DEPTH_TEST);
            state.buffers.depth.setMask(true);
            state.reset();
        };

        function createProgram(shader) {
            var program = gl.createProgram();
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var prefix = 'precision ' + capabilities.precision + ' float;\n';
            gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
            gl.shaderSource(vertexShader, prefix + shader.vertexShader);
            gl.compileShader(fragmentShader);
            gl.compileShader(vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.linkProgram(program);
            return program;
        }
    }

    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    }
    CanvasTexture.prototype = Object.create(Texture.prototype);
    CanvasTexture.prototype.constructor = CanvasTexture;

    function WebGLSpriteRenderer(renderer, gl, state, textures, capabilities) {
        var vertexBuffer, elementBuffer;
        var program, attributes, uniforms;
        var texture;
        var spritePosition = new Vector3();
        var spriteRotation = new Quaternion();
        var spriteScale = new Vector3();

        function init() {
            var vertices = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]);
            var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
            vertexBuffer = gl.createBuffer();
            elementBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
            program = createProgram();
            attributes = {
                position: gl.getAttribLocation(program, 'position'),
                uv: gl.getAttribLocation(program, 'uv')
            };
            uniforms = {
                uvOffset: gl.getUniformLocation(program, 'uvOffset'),
                uvScale: gl.getUniformLocation(program, 'uvScale'),
                rotation: gl.getUniformLocation(program, 'rotation'),
                scale: gl.getUniformLocation(program, 'scale'),
                color: gl.getUniformLocation(program, 'color'),
                map: gl.getUniformLocation(program, 'map'),
                opacity: gl.getUniformLocation(program, 'opacity'),
                modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
                projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
                fogType: gl.getUniformLocation(program, 'fogType'),
                fogDensity: gl.getUniformLocation(program, 'fogDensity'),
                fogNear: gl.getUniformLocation(program, 'fogNear'),
                fogFar: gl.getUniformLocation(program, 'fogFar'),
                fogColor: gl.getUniformLocation(program, 'fogColor'),
                fogDepth: gl.getUniformLocation(program, 'fogDepth'),
                alphaTest: gl.getUniformLocation(program, 'alphaTest')
            };
            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            canvas.width = 8;
            canvas.height = 8;
            var context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.fillRect(0, 0, 8, 8);
            texture = new CanvasTexture(canvas);
        }
        this.render = function(sprites, scene, camera) {
            if (sprites.length === 0) return;
            if (program === undefined) {
                init();
            }
            state.useProgram(program);
            state.initAttributes();
            state.enableAttribute(attributes.position);
            state.enableAttribute(attributes.uv);
            state.disableUnusedAttributes();
            state.disable(gl.CULL_FACE);
            state.enable(gl.BLEND);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
            state.activeTexture(gl.TEXTURE0);
            gl.uniform1i(uniforms.map, 0);
            var oldFogType = 0;
            var sceneFogType = 0;
            var fog = scene.fog;
            if (fog) {
                gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
                if (fog.isFog) {
                    gl.uniform1f(uniforms.fogNear, fog.near);
                    gl.uniform1f(uniforms.fogFar, fog.far);
                    gl.uniform1i(uniforms.fogType, 1);
                    oldFogType = 1;
                    sceneFogType = 1;
                } else if (fog.isFogExp2) {
                    gl.uniform1f(uniforms.fogDensity, fog.density);
                    gl.uniform1i(uniforms.fogType, 2);
                    oldFogType = 2;
                    sceneFogType = 2;
                }
            } else {
                gl.uniform1i(uniforms.fogType, 0);
                oldFogType = 0;
                sceneFogType = 0;
            }
            for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
                sprite.z = -sprite.modelViewMatrix.elements[14];
            }
            sprites.sort(painterSortStable);
            var scale = [];
            for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                var material = sprite.material;
                if (material.visible === false) continue;
                sprite.onBeforeRender(renderer, scene, camera, undefined, material, undefined);
                gl.uniform1f(uniforms.alphaTest, material.alphaTest);
                gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
                sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
                scale[0] = spriteScale.x;
                scale[1] = spriteScale.y;
                var fogType = 0;
                if (scene.fog && material.fog) {
                    fogType = sceneFogType;
                }
                if (oldFogType !== fogType) {
                    gl.uniform1i(uniforms.fogType, fogType);
                    oldFogType = fogType;
                }
                if (material.map !== null) {
                    gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                    gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
                } else {
                    gl.uniform2f(uniforms.uvOffset, 0, 0);
                    gl.uniform2f(uniforms.uvScale, 1, 1);
                }
                gl.uniform1f(uniforms.opacity, material.opacity);
                gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
                gl.uniform1f(uniforms.rotation, material.rotation);
                gl.uniform2fv(uniforms.scale, scale);
                state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
                state.buffers.depth.setTest(material.depthTest);
                state.buffers.depth.setMask(material.depthWrite);
                state.buffers.color.setMask(material.colorWrite);
                textures.setTexture2D(material.map || texture, 0);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                sprite.onAfterRender(renderer, scene, camera, undefined, material, undefined);
            }
            state.enable(gl.CULL_FACE);
            state.reset();
        };

        function createProgram() {
            var program = gl.createProgram();
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(vertexShader, ['precision ' + capabilities.precision + ' float;', '#define SHADER_NAME ' + 'SpriteMaterial', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform float rotation;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'varying float fogDepth;', 'void main() {', '	vUV = uvOffset + uv * uvScale;', '	vec2 alignedPosition = position * scale;', '	vec2 rotatedPosition;', '	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;', '	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;', '	vec4 mvPosition;', '	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );', '	mvPosition.xy += rotatedPosition;', '	gl_Position = projectionMatrix * mvPosition;', '	fogDepth = - mvPosition.z;', '}'].join('\n'));
            gl.shaderSource(fragmentShader, ['precision ' + capabilities.precision + ' float;', '#define SHADER_NAME ' + 'SpriteMaterial', 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', 'varying vec2 vUV;', 'varying float fogDepth;', 'void main() {', '	vec4 texture = texture2D( map, vUV );', '	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', '	if ( gl_FragColor.a < alphaTest ) discard;', '	if ( fogType > 0 ) {', '		float fogFactor = 0.0;', '		if ( fogType == 1 ) {', '			fogFactor = smoothstep( fogNear, fogFar, fogDepth );', '		} else {', '			const float LOG2 = 1.442695;', '			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );', '			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '		}', '		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );', '	}', '}'].join('\n'));
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }

        function painterSortStable(a, b) {
            if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
            } else if (a.z !== b.z) {
                return b.z - a.z;
            } else {
                return b.id - a.id;
            }
        }
    }
    var materialId = 0;

    function Material() {
        Object.defineProperty(this, 'id', {
            value: materialId++
        });
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'Material';
        this.fog = true;
        this.lights = true;
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.flatShading = false;
        this.vertexColors = NoColors;
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.colorWrite = true;
        this.precision = null;
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaTest = 0;
        this.premultipliedAlpha = false;
        this.overdraw = 0;
        this.visible = true;
        this.userData = {};
        this.needsUpdate = true;
    }
    Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Material,
        isMaterial: true,
        onBeforeCompile: function() {},
        setValues: function(values) {
            if (values === undefined) return;
            for (var key in values) {
                var newValue = values[key];
                if (newValue === undefined) {
                    console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                    continue;
                }
                if (key === 'shading') {
                    console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                    this.flatShading = (newValue === FlatShading) ? true : false;
                    continue;
                }
                var currentValue = this[key];
                if (currentValue === undefined) {
                    console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                    continue;
                }
                if (currentValue && currentValue.isColor) {
                    currentValue.set(newValue);
                } else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {
                    currentValue.copy(newValue);
                } else if (key === 'overdraw') {
                    this[key] = Number(newValue);
                } else {
                    this[key] = newValue;
                }
            }
        },
        toJSON: function(meta) {
            var isRoot = (meta === undefined || typeof meta === 'string');
            if (isRoot) {
                meta = {
                    textures: {},
                    images: {}
                };
            }
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;
            if (this.color && this.color.isColor) data.color = this.color.getHex();
            if (this.roughness !== undefined) data.roughness = this.roughness;
            if (this.metalness !== undefined) data.metalness = this.metalness;
            if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
            if (this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
            if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
            if (this.shininess !== undefined) data.shininess = this.shininess;
            if (this.clearCoat !== undefined) data.clearCoat = this.clearCoat;
            if (this.clearCoatRoughness !== undefined) data.clearCoatRoughness = this.clearCoatRoughness;
            if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
            if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
            if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
            if (this.bumpMap && this.bumpMap.isTexture) {
                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
            }
            if (this.normalMap && this.normalMap.isTexture) {
                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalScale = this.normalScale.toArray();
            }
            if (this.displacementMap && this.displacementMap.isTexture) {
                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
            }
            if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
            if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
            if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
            if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
            if (this.envMap && this.envMap.isTexture) {
                data.envMap = this.envMap.toJSON(meta).uuid;
                data.reflectivity = this.reflectivity;
            }
            if (this.gradientMap && this.gradientMap.isTexture) {
                data.gradientMap = this.gradientMap.toJSON(meta).uuid;
            }
            if (this.size !== undefined) data.size = this.size;
            if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
            if (this.blending !== NormalBlending) data.blending = this.blending;
            if (this.flatShading === true) data.flatShading = this.flatShading;
            if (this.side !== FrontSide) data.side = this.side;
            if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;
            if (this.opacity < 1) data.opacity = this.opacity;
            if (this.transparent === true) data.transparent = this.transparent;
            data.depthFunc = this.depthFunc;
            data.depthTest = this.depthTest;
            data.depthWrite = this.depthWrite;
            if (this.rotation !== 0) data.rotation = this.rotation;
            if (this.linewidth !== 1) data.linewidth = this.linewidth;
            if (this.dashSize !== undefined) data.dashSize = this.dashSize;
            if (this.gapSize !== undefined) data.gapSize = this.gapSize;
            if (this.scale !== undefined) data.scale = this.scale;
            if (this.dithering === true) data.dithering = true;
            if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
            if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
            if (this.wireframe === true) data.wireframe = this.wireframe;
            if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
            if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
            if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
            if (this.morphTargets === true) data.morphTargets = true;
            if (this.skinning === true) data.skinning = true;
            if (this.visible === false) data.visible = false;
            if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;

            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
            if (isRoot) {
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (textures.length > 0) data.textures = textures;
                if (images.length > 0) data.images = images;
            }
            return data;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.name = source.name;
            this.fog = source.fog;
            this.lights = source.lights;
            this.blending = source.blending;
            this.side = source.side;
            this.flatShading = source.flatShading;
            this.vertexColors = source.vertexColors;
            this.opacity = source.opacity;
            this.transparent = source.transparent;
            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;
            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;
            this.colorWrite = source.colorWrite;
            this.precision = source.precision;
            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;
            this.dithering = source.dithering;
            this.alphaTest = source.alphaTest;
            this.premultipliedAlpha = source.premultipliedAlpha;
            this.overdraw = source.overdraw;
            this.visible = source.visible;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            this.clipShadows = source.clipShadows;
            this.clipIntersection = source.clipIntersection;
            var srcPlanes = source.clippingPlanes,
                dstPlanes = null;
            if (srcPlanes !== null) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (var i = 0; i !== n; ++i)
                    dstPlanes[i] = srcPlanes[i].clone();
            }
            this.clippingPlanes = dstPlanes;
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });

    function MeshDepthMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshDepthMaterial';
        this.depthPacking = BasicDepthPacking;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.setValues(parameters);
    }
    MeshDepthMaterial.prototype = Object.create(Material.prototype);
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    MeshDepthMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.depthPacking = source.depthPacking;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    };

    function MeshDistanceMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshDistanceMaterial';
        this.referencePosition = new Vector3();
        this.nearDistance = 1;
        this.farDistance = 1000;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.fog = false;
        this.lights = false;
        this.setValues(parameters);
    }
    MeshDistanceMaterial.prototype = Object.create(Material.prototype);
    MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
    MeshDistanceMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
    };

    function Box3(min, max) {
        this.min = (min !== undefined) ? min : new Vector3(+Infinity, +Infinity, +Infinity);
        this.max = (max !== undefined) ? max : new Vector3(-Infinity, -Infinity, -Infinity);
    }
    Object.assign(Box3.prototype, {
        isBox3: true,
        set: function(min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        },
        setFromArray: function(array) {
            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for (var i = 0, l = array.length; i < l; i += 3) {
                var x = array[i];
                var y = array[i + 1];
                var z = array[i + 2];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (z < minZ) minZ = z;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (z > maxZ) maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
            return this;
        },
        setFromBufferAttribute: function(attribute) {
            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for (var i = 0, l = attribute.count; i < l; i++) {
                var x = attribute.getX(i);
                var y = attribute.getY(i);
                var z = attribute.getZ(i);
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (z < minZ) minZ = z;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (z > maxZ) maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
            return this;
        },
        setFromPoints: function(points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        },
        setFromCenterAndSize: function() {
            var v1 = new Vector3();
            return function setFromCenterAndSize(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(0.5);
                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
            };
        }(),
        setFromObject: function(object) {
            this.makeEmpty();
            return this.expandByObject(object);
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        },
        makeEmpty: function() {
            this.min.x = this.min.y = this.min.z = +Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this;
        },
        isEmpty: function() {
            return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.addVectors(this.min, this.max).multiplyScalar(0.5);
        },
        getSize: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.isEmpty() ? result.set(0, 0, 0) : result.subVectors(this.max, this.min);
        },
        expandByPoint: function(point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        },
        expandByVector: function(vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        },
        expandByScalar: function(scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        },
        expandByObject: function() {
            var scope, i, l;
            var v1 = new Vector3();

            function traverse(node) {
                var geometry = node.geometry;
                if (geometry !== undefined) {
                    if (geometry.isGeometry) {
                        var vertices = geometry.vertices;
                        for (i = 0, l = vertices.length; i < l; i++) {
                            v1.copy(vertices[i]);
                            v1.applyMatrix4(node.matrixWorld);
                            scope.expandByPoint(v1);
                        }
                    } else if (geometry.isBufferGeometry) {
                        var attribute = geometry.attributes.position;
                        if (attribute !== undefined) {
                            for (i = 0, l = attribute.count; i < l; i++) {
                                v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                                scope.expandByPoint(v1);
                            }
                        }
                    }
                }
            }
            return function expandByObject(object) {
                scope = this;
                object.updateMatrixWorld(true);
                object.traverse(traverse);
                return this;
            };
        }(),
        containsPoint: function(point) {
            return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        },
        containsBox: function(box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        },
        getParameter: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        },
        intersectsBox: function(box) {
            return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        },
        intersectsSphere: (function() {
            var closestPoint = new Vector3();
            return function intersectsSphere(sphere) {
                this.clampPoint(sphere.center, closestPoint);
                return closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
            };
        })(),
        intersectsPlane: function(plane) {
            var min, max;
            if (plane.normal.x > 0) {
                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
            } else {
                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
            }
            if (plane.normal.y > 0) {
                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
            } else {
                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
            }
            if (plane.normal.z > 0) {
                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
            } else {
                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
            }
            return (min <= plane.constant && max >= plane.constant);
        },
        clampPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function() {
            var v1 = new Vector3();
            return function distanceToPoint(point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
            };
        }(),
        getBoundingSphere: function() {
            var v1 = new Vector3();
            return function getBoundingSphere(optionalTarget) {
                var result = optionalTarget || new Sphere();
                this.getCenter(result.center);
                result.radius = this.getSize(v1).length() * 0.5;
                return result;
            };
        }(),
        intersect: function(box) {
            this.min.max(box.min);
            this.max.min(box.max);
            if (this.isEmpty()) this.makeEmpty();
            return this;
        },
        union: function(box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        },
        applyMatrix4: function() {
            var points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
            return function applyMatrix4(matrix) {
                if (this.isEmpty()) return this;
                points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
                points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
                points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
                points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
                points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
                points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
                points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
                points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
                this.setFromPoints(points);
                return this;
            };
        }(),
        translate: function(offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        },
        equals: function(box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    });

    function Sphere(center, radius) {
        this.center = (center !== undefined) ? center : new Vector3();
        this.radius = (radius !== undefined) ? radius : 0;
    }
    Object.assign(Sphere.prototype, {
        set: function(center, radius) {
            this.center.copy(center);
            this.radius = radius;
            return this;
        },
        setFromPoints: function() {
            var box = new Box3();
            return function setFromPoints(points, optionalCenter) {
                var center = this.center;
                if (optionalCenter !== undefined) {
                    center.copy(optionalCenter);
                } else {
                    box.setFromPoints(points).getCenter(center);
                }
                var maxRadiusSq = 0;
                for (var i = 0, il = points.length; i < il; i++) {
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                }
                this.radius = Math.sqrt(maxRadiusSq);
                return this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(sphere) {
            this.center.copy(sphere.center);
            this.radius = sphere.radius;
            return this;
        },
        empty: function() {
            return (this.radius <= 0);
        },
        containsPoint: function(point) {
            return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
        },
        distanceToPoint: function(point) {
            return (point.distanceTo(this.center) - this.radius);
        },
        intersectsSphere: function(sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
        },
        intersectsBox: function(box) {
            return box.intersectsSphere(this);
        },
        intersectsPlane: function(plane) {
            return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        },
        clampPoint: function(point, optionalTarget) {
            var deltaLengthSq = this.center.distanceToSquared(point);
            var result = optionalTarget || new Vector3();
            result.copy(point);
            if (deltaLengthSq > (this.radius * this.radius)) {
                result.sub(this.center).normalize();
                result.multiplyScalar(this.radius).add(this.center);
            }
            return result;
        },
        getBoundingBox: function(optionalTarget) {
            var box = optionalTarget || new Box3();
            box.set(this.center, this.center);
            box.expandByScalar(this.radius);
            return box;
        },
        applyMatrix4: function(matrix) {
            this.center.applyMatrix4(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        },
        translate: function(offset) {
            this.center.add(offset);
            return this;
        },
        equals: function(sphere) {
            return sphere.center.equals(this.center) && (sphere.radius === this.radius);
        }
    });

    function Plane(normal, constant) {
        this.normal = (normal !== undefined) ? normal : new Vector3(1, 0, 0);
        this.constant = (constant !== undefined) ? constant : 0;
    }
    Object.assign(Plane.prototype, {
        set: function(normal, constant) {
            this.normal.copy(normal);
            this.constant = constant;
            return this;
        },
        setComponents: function(x, y, z, w) {
            this.normal.set(x, y, z);
            this.constant = w;
            return this;
        },
        setFromNormalAndCoplanarPoint: function(normal, point) {
            this.normal.copy(normal);
            this.constant = -point.dot(this.normal);
            return this;
        },
        setFromCoplanarPoints: function() {
            var v1 = new Vector3();
            var v2 = new Vector3();
            return function setFromCoplanarPoints(a, b, c) {
                var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
                this.setFromNormalAndCoplanarPoint(normal, a);
                return this;
            };
        }(),
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(plane) {
            this.normal.copy(plane.normal);
            this.constant = plane.constant;
            return this;
        },
        normalize: function() {
            var inverseNormalLength = 1.0 / this.normal.length();
            this.normal.multiplyScalar(inverseNormalLength);
            this.constant *= inverseNormalLength;
            return this;
        },
        negate: function() {
            this.constant *= -1;
            this.normal.negate();
            return this;
        },
        distanceToPoint: function(point) {
            return this.normal.dot(point) + this.constant;
        },
        distanceToSphere: function(sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        },
        projectPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        },
        intersectLine: function() {
            var v1 = new Vector3();
            return function intersectLine(line, optionalTarget) {
                var result = optionalTarget || new Vector3();
                var direction = line.delta(v1);
                var denominator = this.normal.dot(direction);
                if (denominator === 0) {
                    if (this.distanceToPoint(line.start) === 0) {
                        return result.copy(line.start);
                    }
                    return undefined;
                }
                var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                if (t < 0 || t > 1) {
                    return undefined;
                }
                return result.copy(direction).multiplyScalar(t).add(line.start);
            };
        }(),
        intersectsLine: function(line) {
            var startSign = this.distanceToPoint(line.start);
            var endSign = this.distanceToPoint(line.end);
            return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
        },
        intersectsBox: function(box) {
            return box.intersectsPlane(this);
        },
        intersectsSphere: function(sphere) {
            return sphere.intersectsPlane(this);
        },
        coplanarPoint: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.copy(this.normal).multiplyScalar(-this.constant);
        },
        applyMatrix4: function() {
            var v1 = new Vector3();
            var m1 = new Matrix3();
            return function applyMatrix4(matrix, optionalNormalMatrix) {
                var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
                var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
                var normal = this.normal.applyMatrix3(normalMatrix).normalize();
                this.constant = -referencePoint.dot(normal);
                return this;
            };
        }(),
        translate: function(offset) {
            this.constant -= offset.dot(this.normal);
            return this;
        },
        equals: function(plane) {
            return plane.normal.equals(this.normal) && (plane.constant === this.constant);
        }
    });

    function Frustum(p0, p1, p2, p3, p4, p5) {
        this.planes = [(p0 !== undefined) ? p0 : new Plane(), (p1 !== undefined) ? p1 : new Plane(), (p2 !== undefined) ? p2 : new Plane(), (p3 !== undefined) ? p3 : new Plane(), (p4 !== undefined) ? p4 : new Plane(), (p5 !== undefined) ? p5 : new Plane()];
    }
    Object.assign(Frustum.prototype, {
        set: function(p0, p1, p2, p3, p4, p5) {
            var planes = this.planes;
            planes[0].copy(p0);
            planes[1].copy(p1);
            planes[2].copy(p2);
            planes[3].copy(p3);
            planes[4].copy(p4);
            planes[5].copy(p5);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(frustum) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                planes[i].copy(frustum.planes[i]);
            }
            return this;
        },
        setFromMatrix: function(m) {
            var planes = this.planes;
            var me = m.elements;
            var me0 = me[0],
                me1 = me[1],
                me2 = me[2],
                me3 = me[3];
            var me4 = me[4],
                me5 = me[5],
                me6 = me[6],
                me7 = me[7];
            var me8 = me[8],
                me9 = me[9],
                me10 = me[10],
                me11 = me[11];
            var me12 = me[12],
                me13 = me[13],
                me14 = me[14],
                me15 = me[15];
            planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
            return this;
        },
        intersectsObject: function() {
            var sphere = new Sphere();
            return function intersectsObject(object) {
                var geometry = object.geometry;
                if (geometry.boundingSphere === null)
                    geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
                return this.intersectsSphere(sphere);
            };
        }(),
        intersectsSprite: function() {
            var sphere = new Sphere();
            return function intersectsSprite(sprite) {
                sphere.center.set(0, 0, 0);
                sphere.radius = 0.7071067811865476;
                sphere.applyMatrix4(sprite.matrixWorld);
                return this.intersectsSphere(sphere);
            };
        }(),
        intersectsSphere: function(sphere) {
            var planes = this.planes;
            var center = sphere.center;
            var negRadius = -sphere.radius;
            for (var i = 0; i < 6; i++) {
                var distance = planes[i].distanceToPoint(center);
                if (distance < negRadius) {
                    return false;
                }
            }
            return true;
        },
        intersectsBox: function() {
            var p1 = new Vector3(),
                p2 = new Vector3();
            return function intersectsBox(box) {
                var planes = this.planes;
                for (var i = 0; i < 6; i++) {
                    var plane = planes[i];
                    p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                    p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                    p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                    p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                    p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                    p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                    var d1 = plane.distanceToPoint(p1);
                    var d2 = plane.distanceToPoint(p2);
                    if (d1 < 0 && d2 < 0) {
                        return false;
                    }
                }
                return true;
            };
        }(),
        containsPoint: function(point) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                if (planes[i].distanceToPoint(point) < 0) {
                    return false;
                }
            }
            return true;
        }
    });

    function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
        var _frustum = new Frustum(),
            _projScreenMatrix = new Matrix4(),
            _shadowMapSize = new Vector2(),
            _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize),
            _lookTarget = new Vector3(),
            _lightPositionWorld = new Vector3(),
            _MorphingFlag = 1,
            _SkinningFlag = 2,
            _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1,
            _depthMaterials = new Array(_NumberOfMaterialVariants),
            _distanceMaterials = new Array(_NumberOfMaterialVariants),
            _materialCache = {};
        var cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
        var cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
        var cube2DViewPorts = [new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4()];
        for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
            var useMorphing = (i & _MorphingFlag) !== 0;
            var useSkinning = (i & _SkinningFlag) !== 0;
            var depthMaterial = new MeshDepthMaterial({
                depthPacking: RGBADepthPacking,
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _depthMaterials[i] = depthMaterial;
            var distanceMaterial = new MeshDistanceMaterial({
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _distanceMaterials[i] = distanceMaterial;
        }
        var scope = this;
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = PCFShadowMap;
        this.renderReverseSided = true;
        this.renderSingleSided = true;
        this.render = function(lights, scene, camera) {
            if (scope.enabled === false) return;
            if (scope.autoUpdate === false && scope.needsUpdate === false) return;
            if (lights.length === 0) return;
            var _gl = _renderer.context;
            var _state = _renderer.state;
            _state.disable(_gl.BLEND);
            _state.buffers.color.setClear(1, 1, 1, 1);
            _state.buffers.depth.setTest(true);
            _state.setScissorTest(false);
            var faceCount;
            for (var i = 0, il = lights.length; i < il; i++) {
                var light = lights[i];
                var shadow = light.shadow;
                var isPointLight = light && light.isPointLight;
                if (shadow === undefined) {
                    console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                    continue;
                }
                var shadowCamera = shadow.camera;
                _shadowMapSize.copy(shadow.mapSize);
                _shadowMapSize.min(_maxShadowMapSize);
                if (isPointLight) {
                    var vpWidth = _shadowMapSize.x;
                    var vpHeight = _shadowMapSize.y;
                    cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                    cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
                    _shadowMapSize.x *= 4.0;
                    _shadowMapSize.y *= 2.0;
                }
                if (shadow.map === null) {
                    var pars = {
                        minFilter: NearestFilter,
                        magFilter: NearestFilter,
                        format: RGBAFormat
                    };
                    shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                    shadow.map.texture.name = light.name + ".shadowMap";
                    shadowCamera.updateProjectionMatrix();
                }
                if (shadow.isSpotLightShadow) {
                    shadow.update(light);
                }
                var shadowMap = shadow.map;
                var shadowMatrix = shadow.matrix;
                _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                shadowCamera.position.copy(_lightPositionWorld);
                if (isPointLight) {
                    faceCount = 6;
                    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
                } else {
                    faceCount = 1;
                    _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                    shadowCamera.lookAt(_lookTarget);
                    shadowCamera.updateMatrixWorld();
                    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                    shadowMatrix.multiply(shadowCamera.projectionMatrix);
                    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                }
                _renderer.setRenderTarget(shadowMap);
                _renderer.clear();
                for (var face = 0; face < faceCount; face++) {
                    if (isPointLight) {
                        _lookTarget.copy(shadowCamera.position);
                        _lookTarget.add(cubeDirections[face]);
                        shadowCamera.up.copy(cubeUps[face]);
                        shadowCamera.lookAt(_lookTarget);
                        shadowCamera.updateMatrixWorld();
                        var vpDimensions = cube2DViewPorts[face];
                        _state.viewport(vpDimensions);
                    }
                    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                    _frustum.setFromMatrix(_projScreenMatrix);
                    renderObject(scene, camera, shadowCamera, isPointLight);
                }
            }
            scope.needsUpdate = false;
        };

        function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
            var geometry = object.geometry;
            var result = null;
            var materialVariants = _depthMaterials;
            var customMaterial = object.customDepthMaterial;
            if (isPointLight) {
                materialVariants = _distanceMaterials;
                customMaterial = object.customDistanceMaterial;
            }
            if (!customMaterial) {
                var useMorphing = false;
                if (material.morphTargets) {
                    if (geometry && geometry.isBufferGeometry) {
                        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                    } else if (geometry && geometry.isGeometry) {
                        useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
                    }
                }
                if (object.isSkinnedMesh && material.skinning === false) {
                    console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
                }
                var useSkinning = object.isSkinnedMesh && material.skinning;
                var variantIndex = 0;
                if (useMorphing) variantIndex |= _MorphingFlag;
                if (useSkinning) variantIndex |= _SkinningFlag;
                result = materialVariants[variantIndex];
            } else {
                result = customMaterial;
            }
            if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
                var keyA = result.uuid,
                    keyB = material.uuid;
                var materialsForVariant = _materialCache[keyA];
                if (materialsForVariant === undefined) {
                    materialsForVariant = {};
                    _materialCache[keyA] = materialsForVariant;
                }
                var cachedMaterial = materialsForVariant[keyB];
                if (cachedMaterial === undefined) {
                    cachedMaterial = result.clone();
                    materialsForVariant[keyB] = cachedMaterial;
                }
                result = cachedMaterial;
            }
            result.visible = material.visible;
            result.wireframe = material.wireframe;
            var side = material.side;
            if (scope.renderSingleSided && side == DoubleSide) {
                side = FrontSide;
            }
            if (scope.renderReverseSided) {
                if (side === FrontSide) side = BackSide;
                else if (side === BackSide) side = FrontSide;
            }
            result.side = side;
            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;
            result.clipIntersection = material.clipIntersection;
            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;
            if (isPointLight && result.isMeshDistanceMaterial) {
                result.referencePosition.copy(lightPositionWorld);
                result.nearDistance = shadowCameraNear;
                result.farDistance = shadowCameraFar;
            }
            return result;
        }

        function renderObject(object, camera, shadowCamera, isPointLight) {
            if (object.visible === false) return;
            var visible = object.layers.test(camera.layers);
            if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    var geometry = _objects.update(object);
                    var material = object.material;
                    if (Array.isArray(material)) {
                        var groups = geometry.groups;
                        for (var k = 0, kl = groups.length; k < kl; k++) {
                            var group = groups[k];
                            var groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) {
                                var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                            }
                        }
                    } else if (material.visible) {
                        var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                        _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                renderObject(children[i], camera, shadowCamera, isPointLight);
            }
        }
    }

    function WebGLAttributes(gl) {
        var buffers = {};

        function createBuffer(attribute, bufferType) {
            var array = attribute.array;
            var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
            var buffer = gl.createBuffer();
            gl.bindBuffer(bufferType, buffer);
            gl.bufferData(bufferType, array, usage);
            attribute.onUploadCallback();
            var type = gl.FLOAT;
            if (array instanceof Float32Array) {
                type = gl.FLOAT;
            } else if (array instanceof Float64Array) {
                console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
            } else if (array instanceof Uint16Array) {
                type = gl.UNSIGNED_SHORT;
            } else if (array instanceof Int16Array) {
                type = gl.SHORT;
            } else if (array instanceof Uint32Array) {
                type = gl.UNSIGNED_INT;
            } else if (array instanceof Int32Array) {
                type = gl.INT;
            } else if (array instanceof Int8Array) {
                type = gl.BYTE;
            } else if (array instanceof Uint8Array) {
                type = gl.UNSIGNED_BYTE;
            }
            return {
                buffer: buffer,
                type: type,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version
            };
        }

        function updateBuffer(buffer, attribute, bufferType) {
            var array = attribute.array;
            var updateRange = attribute.updateRange;
            gl.bindBuffer(bufferType, buffer);
            if (attribute.dynamic === false) {
                gl.bufferData(bufferType, array, gl.STATIC_DRAW);
            } else if (updateRange.count === -1) {
                gl.bufferSubData(bufferType, 0, array);
            } else if (updateRange.count === 0) {
                console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
            } else {
                gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
                updateRange.count = -1;
            }
        }

        function get(attribute) {
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            return buffers[attribute.uuid];
        }

        function remove(attribute) {
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            var data = buffers[attribute.uuid];
            if (data) {
                gl.deleteBuffer(data.buffer);
                delete buffers[attribute.uuid];
            }
        }

        function update(attribute, bufferType) {
            if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
            var data = buffers[attribute.uuid];
            if (data === undefined) {
                buffers[attribute.uuid] = createBuffer(attribute, bufferType);
            } else if (data.version < attribute.version) {
                updateBuffer(data.buffer, attribute, bufferType);
                data.version = attribute.version;
            }
        }
        return {
            get: get,
            remove: remove,
            update: update
        };
    }

    function Euler(x, y, z, order) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._order = order || Euler.DefaultOrder;
    }
    Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
    Euler.DefaultOrder = 'XYZ';
    Object.defineProperties(Euler.prototype, {
        x: {
            get: function() {
                return this._x;
            },
            set: function(value) {
                this._x = value;
                this.onChangeCallback();
            }
        },
        y: {
            get: function() {
                return this._y;
            },
            set: function(value) {
                this._y = value;
                this.onChangeCallback();
            }
        },
        z: {
            get: function() {
                return this._z;
            },
            set: function(value) {
                this._z = value;
                this.onChangeCallback();
            }
        },
        order: {
            get: function() {
                return this._order;
            },
            set: function(value) {
                this._order = value;
                this.onChangeCallback();
            }
        }
    });
    Object.assign(Euler.prototype, {
        isEuler: true,
        set: function(x, y, z, order) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order || this._order;
            this.onChangeCallback();
            return this;
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function(euler) {
            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;
            this.onChangeCallback();
            return this;
        },
        setFromRotationMatrix: function(m, order, update) {
            var clamp = _Math.clamp;
            var te = m.elements;
            var m11 = te[0],
                m12 = te[4],
                m13 = te[8];
            var m21 = te[1],
                m22 = te[5],
                m23 = te[9];
            var m31 = te[2],
                m32 = te[6],
                m33 = te[10];
            order = order || this._order;
            if (order === 'XYZ') {
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.99999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
            } else if (order === 'YXZ') {
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.99999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
            } else if (order === 'ZXY') {
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.99999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
            } else if (order === 'ZYX') {
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.99999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
            } else if (order === 'YZX') {
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.99999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
            } else if (order === 'XZY') {
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.99999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
            } else {
                console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
            }
            this._order = order;
            if (update !== false) this.onChangeCallback();
            return this;
        },
        setFromQuaternion: function() {
            var matrix = new Matrix4();
            return function setFromQuaternion(q, order, update) {
                matrix.makeRotationFromQuaternion(q);
                return this.setFromRotationMatrix(matrix, order, update);
            };
        }(),
        setFromVector3: function(v, order) {
            return this.set(v.x, v.y, v.z, order || this._order);
        },
        reorder: function() {
            var q = new Quaternion();
            return function reorder(newOrder) {
                q.setFromEuler(this);
                return this.setFromQuaternion(q, newOrder);
            };
        }(),
        equals: function(euler) {
            return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
        },
        fromArray: function(array) {
            this._x = array[0];
            this._y = array[1];
            this._z = array[2];
            if (array[3] !== undefined) this._order = array[3];
            this.onChangeCallback();
            return this;
        },
        toArray: function(array, offset) {
            if (array === undefined) array = [];
            if (offset === undefined) offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._order;
            return array;
        },
        toVector3: function(optionalResult) {
            if (optionalResult) {
                return optionalResult.set(this._x, this._y, this._z);
            } else {
                return new Vector3(this._x, this._y, this._z);
            }
        },
        onChange: function(callback) {
            this.onChangeCallback = callback;
            return this;
        },
        onChangeCallback: function() {}
    });

    function Layers() {
        this.mask = 1 | 0;
    }
    Object.assign(Layers.prototype, {
        set: function(channel) {
            this.mask = 1 << channel | 0;
        },
        enable: function(channel) {
            this.mask |= 1 << channel | 0;
        },
        toggle: function(channel) {
            this.mask ^= 1 << channel | 0;
        },
        disable: function(channel) {
            this.mask &= ~(1 << channel | 0);
        },
        test: function(layers) {
            return (this.mask & layers.mask) !== 0;
        }
    });
    var object3DId = 0;

    function Object3D() {
        Object.defineProperty(this, 'id', {
            value: object3DId++
        });
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'Object3D';
        this.parent = null;
        this.children = [];
        this.up = Object3D.DefaultUp.clone();
        var position = new Vector3();
        var rotation = new Euler();
        var quaternion = new Quaternion();
        var scale = new Vector3(1, 1, 1);

        function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
        }

        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, undefined, false);
        }
        rotation.onChange(onRotationChange);
        quaternion.onChange(onQuaternionChange);
        Object.defineProperties(this, {
            position: {
                enumerable: true,
                value: position
            },
            rotation: {
                enumerable: true,
                value: rotation
            },
            quaternion: {
                enumerable: true,
                value: quaternion
            },
            scale: {
                enumerable: true,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        });
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.userData = {};
    }
    Object3D.DefaultUp = new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Object3D,
        isObject3D: true,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(matrix) {
            this.matrix.multiplyMatrices(matrix, this.matrix);
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function(q) {
            this.quaternion.premultiply(q);
            return this;
        },
        setRotationFromAxisAngle: function(axis, angle) {
            this.quaternion.setFromAxisAngle(axis, angle);
        },
        setRotationFromEuler: function(euler) {
            this.quaternion.setFromEuler(euler, true);
        },
        setRotationFromMatrix: function(m) {
            this.quaternion.setFromRotationMatrix(m);
        },
        setRotationFromQuaternion: function(q) {
            this.quaternion.copy(q);
        },
        rotateOnAxis: function() {
            var q1 = new Quaternion();
            return function rotateOnAxis(axis, angle) {
                q1.setFromAxisAngle(axis, angle);
                this.quaternion.multiply(q1);
                return this;
            };
        }(),
        rotateOnWorldAxis: function() {
            var q1 = new Quaternion();
            return function rotateOnWorldAxis(axis, angle) {
                q1.setFromAxisAngle(axis, angle);
                this.quaternion.premultiply(q1);
                return this;
            };
        }(),
        rotateX: function() {
            var v1 = new Vector3(1, 0, 0);
            return function rotateX(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        rotateY: function() {
            var v1 = new Vector3(0, 1, 0);
            return function rotateY(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        rotateZ: function() {
            var v1 = new Vector3(0, 0, 1);
            return function rotateZ(angle) {
                return this.rotateOnAxis(v1, angle);
            };
        }(),
        translateOnAxis: function() {
            var v1 = new Vector3();
            return function translateOnAxis(axis, distance) {
                v1.copy(axis).applyQuaternion(this.quaternion);
                this.position.add(v1.multiplyScalar(distance));
                return this;
            };
        }(),
        translateX: function() {
            var v1 = new Vector3(1, 0, 0);
            return function translateX(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        translateY: function() {
            var v1 = new Vector3(0, 1, 0);
            return function translateY(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        translateZ: function() {
            var v1 = new Vector3(0, 0, 1);
            return function translateZ(distance) {
                return this.translateOnAxis(v1, distance);
            };
        }(),
        localToWorld: function(vector) {
            return vector.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function() {
            var m1 = new Matrix4();
            return function worldToLocal(vector) {
                return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
            };
        }(),
        lookAt: function() {
            var m1 = new Matrix4();
            var vector = new Vector3();
            return function lookAt(x, y, z) {
                if (x.isVector3) {
                    vector.copy(x);
                } else {
                    vector.set(x, y, z);
                }
                if (this.isCamera) {
                    m1.lookAt(this.position, vector, this.up);
                } else {
                    m1.lookAt(vector, this.position, this.up);
                }
                this.quaternion.setFromRotationMatrix(m1);
            };
        }(),
        add: function(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            if (object === this) {
                console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                return this;
            }
            if ((object && object.isObject3D)) {
                if (object.parent !== null) {
                    object.parent.remove(object);
                }
                object.parent = this;
                object.dispatchEvent({
                    type: 'added'
                });
                this.children.push(object);
            } else {
                console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
            }
            return this;
        },
        remove: function(object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.remove(arguments[i]);
                }
                return this;
            }
            var index = this.children.indexOf(object);
            if (index !== -1) {
                object.parent = null;
                object.dispatchEvent({
                    type: 'removed'
                });
                this.children.splice(index, 1);
            }
            return this;
        },
        getObjectById: function(id) {
            return this.getObjectByProperty('id', id);
        },
        getObjectByName: function(name) {
            return this.getObjectByProperty('name', name);
        },
        getObjectByProperty: function(name, value) {
            if (this[name] === value) return this;
            for (var i = 0, l = this.children.length; i < l; i++) {
                var child = this.children[i];
                var object = child.getObjectByProperty(name, value);
                if (object !== undefined) {
                    return object;
                }
            }
            return undefined;
        },
        getWorldPosition: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            this.updateMatrixWorld(true);
            return result.setFromMatrixPosition(this.matrixWorld);
        },
        getWorldQuaternion: function() {
            var position = new Vector3();
            var scale = new Vector3();
            return function getWorldQuaternion(optionalTarget) {
                var result = optionalTarget || new Quaternion();
                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(position, result, scale);
                return result;
            };
        }(),
        getWorldRotation: function() {
            var quaternion = new Quaternion();
            return function getWorldRotation(optionalTarget) {
                var result = optionalTarget || new Euler();
                this.getWorldQuaternion(quaternion);
                return result.setFromQuaternion(quaternion, this.rotation.order, false);
            };
        }(),
        getWorldScale: function() {
            var position = new Vector3();
            var quaternion = new Quaternion();
            return function getWorldScale(optionalTarget) {
                var result = optionalTarget || new Vector3();
                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(position, quaternion, result);
                return result;
            };
        }(),
        getWorldDirection: function() {
            var quaternion = new Quaternion();
            return function getWorldDirection(optionalTarget) {
                var result = optionalTarget || new Vector3();
                this.getWorldQuaternion(quaternion);
                return result.set(0, 0, 1).applyQuaternion(quaternion);
            };
        }(),
        raycast: function() {},
        traverse: function(callback) {
            callback(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverse(callback);
            }
        },
        traverseVisible: function(callback) {
            if (this.visible === false) return;
            callback(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverseVisible(callback);
            }
        },
        traverseAncestors: function(callback) {
            var parent = this.parent;
            if (parent !== null) {
                callback(parent);
                parent.traverseAncestors(callback);
            }
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = true;
        },
        updateMatrixWorld: function(force) {
            if (this.matrixAutoUpdate) this.updateMatrix();
            if (this.matrixWorldNeedsUpdate || force) {
                if (this.parent === null) {
                    this.matrixWorld.copy(this.matrix);
                } else {
                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                }
                this.matrixWorldNeedsUpdate = false;
                force = true;
            }
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].updateMatrixWorld(force);
            }
        },
        toJSON: function(meta) {
            var isRootObject = (meta === undefined || typeof meta === 'string');
            var output = {};
            if (isRootObject) {
                meta = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                };
                output.metadata = {
                    version: 4.5,
                    type: 'Object',
                    generator: 'Object3D.toJSON'
                };
            }
            var object = {};
            object.uuid = this.uuid;
            object.type = this.type;
            if (this.name !== '') object.name = this.name;
            if (this.castShadow === true) object.castShadow = true;
            if (this.receiveShadow === true) object.receiveShadow = true;
            if (this.visible === false) object.visible = false;
            if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
            object.matrix = this.matrix.toArray();

            function serialize(library, element) {
                if (library[element.uuid] === undefined) {
                    library[element.uuid] = element.toJSON(meta);
                }
                return element.uuid;
            }
            if (this.geometry !== undefined) {
                object.geometry = serialize(meta.geometries, this.geometry);
                var parameters = this.geometry.parameters;
                if (parameters !== undefined && parameters.shapes !== undefined) {
                    var shapes = parameters.shapes;
                    if (Array.isArray(shapes)) {
                        for (var i = 0, l = shapes.length; i < l; i++) {
                            var shape = shapes[i];
                            serialize(meta.shapes, shape);
                        }
                    } else {
                        serialize(meta.shapes, shapes);
                    }
                }
            }
            if (this.material !== undefined) {
                if (Array.isArray(this.material)) {
                    var uuids = [];
                    for (var i = 0, l = this.material.length; i < l; i++) {
                        uuids.push(serialize(meta.materials, this.material[i]));
                    }
                    object.material = uuids;
                } else {
                    object.material = serialize(meta.materials, this.material);
                }
            }
            if (this.children.length > 0) {
                object.children = [];
                for (var i = 0; i < this.children.length; i++) {
                    object.children.push(this.children[i].toJSON(meta).object);
                }
            }
            if (isRootObject) {
                var geometries = extractFromCache(meta.geometries);
                var materials = extractFromCache(meta.materials);
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                var shapes = extractFromCache(meta.shapes);
                if (geometries.length > 0) output.geometries = geometries;
                if (materials.length > 0) output.materials = materials;
                if (textures.length > 0) output.textures = textures;
                if (images.length > 0) output.images = images;
                if (shapes.length > 0) output.shapes = shapes;
            }
            output.object = object;
            return output;

            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
        },
        clone: function(recursive) {
            return new this.constructor().copy(this, recursive);
        },
        copy: function(source, recursive) {
            if (recursive === undefined) recursive = true;
            this.name = source.name;
            this.up.copy(source.up);
            this.position.copy(source.position);
            this.quaternion.copy(source.quaternion);
            this.scale.copy(source.scale);
            this.matrix.copy(source.matrix);
            this.matrixWorld.copy(source.matrixWorld);
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
            this.layers.mask = source.layers.mask;
            this.visible = source.visible;
            this.castShadow = source.castShadow;
            this.receiveShadow = source.receiveShadow;
            this.frustumCulled = source.frustumCulled;
            this.renderOrder = source.renderOrder;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            if (recursive === true) {
                for (var i = 0; i < source.children.length; i++) {
                    var child = source.children[i];
                    this.add(child.clone());
                }
            }
            return this;
        }
    });

    function Camera() {
        Object3D.call(this);
        this.type = 'Camera';
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
    }
    Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Camera,
        isCamera: true,
        copy: function(source, recursive) {
            Object3D.prototype.copy.call(this, source, recursive);
            this.matrixWorldInverse.copy(source.matrixWorldInverse);
            this.projectionMatrix.copy(source.projectionMatrix);
            return this;
        },
        getWorldDirection: function() {
            var quaternion = new Quaternion();
            return function getWorldDirection(optionalTarget) {
                var result = optionalTarget || new Vector3();
                this.getWorldQuaternion(quaternion);
                return result.set(0, 0, -1).applyQuaternion(quaternion);
            };
        }(),
        updateMatrixWorld: function(force) {
            Object3D.prototype.updateMatrixWorld.call(this, force);
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        clone: function() {
            return new this.constructor().copy(this);
        }
    });

    function OrthographicCamera(left, right, top, bottom, near, far) {
        Camera.call(this);
        this.type = 'OrthographicCamera';
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = (near !== undefined) ? near : 0.1;
        this.far = (far !== undefined) ? far : 2000;
        this.updateProjectionMatrix();
    }
    OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: OrthographicCamera,
        isOrthographicCamera: true,
        copy: function(source, recursive) {
            Camera.prototype.copy.call(this, source, recursive);
            this.left = source.left;
            this.right = source.right;
            this.top = source.top;
            this.bottom = source.bottom;
            this.near = source.near;
            this.far = source.far;
            this.zoom = source.zoom;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            return this;
        },
        setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
            if (this.view === null) {
                this.view = {
                    enabled: true,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                };
            }
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
            this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            if (this.view !== null) {
                this.view.enabled = false;
            }
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var dx = (this.right - this.left) / (2 * this.zoom);
            var dy = (this.top - this.bottom) / (2 * this.zoom);
            var cx = (this.right + this.left) / 2;
            var cy = (this.top + this.bottom) / 2;
            var left = cx - dx;
            var right = cx + dx;
            var top = cy + dy;
            var bottom = cy - dy;
            if (this.view !== null && this.view.enabled) {
                var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
                var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
                var scaleW = (this.right - this.left) / this.view.width;
                var scaleH = (this.top - this.bottom) / this.view.height;
                left += scaleW * (this.view.offsetX / zoomW);
                right = left + scaleW * (this.view.width / zoomW);
                top -= scaleH * (this.view.offsetY / zoomH);
                bottom = top - scaleH * (this.view.height / zoomH);
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.zoom = this.zoom;
            data.object.left = this.left;
            data.object.right = this.right;
            data.object.top = this.top;
            data.object.bottom = this.bottom;
            data.object.near = this.near;
            data.object.far = this.far;
            if (this.view !== null) data.object.view = Object.assign({}, this.view);
            return data;
        }
    });

    function Face3(a, b, c, normal, color, materialIndex) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = (normal && normal.isVector3) ? normal : new Vector3();
        this.vertexNormals = Array.isArray(normal) ? normal : [];
        this.color = (color && color.isColor) ? color : new Color();
        this.vertexColors = Array.isArray(color) ? color : [];
        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    }
    Object.assign(Face3.prototype, {
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.a = source.a;
            this.b = source.b;
            this.c = source.c;
            this.normal.copy(source.normal);
            this.color.copy(source.color);
            this.materialIndex = source.materialIndex;
            for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
                this.vertexNormals[i] = source.vertexNormals[i].clone();
            }
            for (var i = 0, il = source.vertexColors.length; i < il; i++) {
                this.vertexColors[i] = source.vertexColors[i].clone();
            }
            return this;
        }
    });
    var geometryId = 0;

    function Geometry() {
        Object.defineProperty(this, 'id', {
            value: geometryId += 2
        });
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'Geometry';
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.elementsNeedUpdate = false;
        this.verticesNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.lineDistancesNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Geometry,
        isGeometry: true,
        applyMatrix: function(matrix) {
            var normalMatrix = new Matrix3().getNormalMatrix(matrix);
            for (var i = 0, il = this.vertices.length; i < il; i++) {
                var vertex = this.vertices[i];
                vertex.applyMatrix4(matrix);
            }
            for (var i = 0, il = this.faces.length; i < il; i++) {
                var face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                    face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
                }
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            this.verticesNeedUpdate = true;
            this.normalsNeedUpdate = true;
            return this;
        },
        rotateX: function() {
            var m1 = new Matrix4();
            return function rotateX(angle) {
                m1.makeRotationX(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        rotateY: function() {
            var m1 = new Matrix4();
            return function rotateY(angle) {
                m1.makeRotationY(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        rotateZ: function() {
            var m1 = new Matrix4();
            return function rotateZ(angle) {
                m1.makeRotationZ(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        translate: function() {
            var m1 = new Matrix4();
            return function translate(x, y, z) {
                m1.makeTranslation(x, y, z);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        scale: function() {
            var m1 = new Matrix4();
            return function scale(x, y, z) {
                m1.makeScale(x, y, z);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        lookAt: function() {
            var obj = new Object3D();
            return function lookAt(vector) {
                obj.lookAt(vector);
                obj.updateMatrix();
                this.applyMatrix(obj.matrix);
            };
        }(),
        fromBufferGeometry: function(geometry) {
            var scope = this;
            var indices = geometry.index !== null ? geometry.index.array : undefined;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;
            var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
            var colors = attributes.color !== undefined ? attributes.color.array : undefined;
            var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
            var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
            if (uvs2 !== undefined) this.faceVertexUvs[1] = [];
            var tempNormals = [];
            var tempUVs = [];
            var tempUVs2 = [];
            for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
                scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));
                if (normals !== undefined) {
                    tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));
                }
                if (colors !== undefined) {
                    scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));
                }
                if (uvs !== undefined) {
                    tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
                }
                if (uvs2 !== undefined) {
                    tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
                }
            }

            function addFace(a, b, c, materialIndex) {
                var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
                var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
                var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                scope.faces.push(face);
                if (uvs !== undefined) {
                    scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
                }
                if (uvs2 !== undefined) {
                    scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
                }
            }
            var groups = geometry.groups;
            if (groups.length > 0) {
                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    var start = group.start;
                    var count = group.count;
                    for (var j = start, jl = start + count; j < jl; j += 3) {
                        if (indices !== undefined) {
                            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                        } else {
                            addFace(j, j + 1, j + 2, group.materialIndex);
                        }
                    }
                }
            } else {
                if (indices !== undefined) {
                    for (var i = 0; i < indices.length; i += 3) {
                        addFace(indices[i], indices[i + 1], indices[i + 2]);
                    }
                } else {
                    for (var i = 0; i < positions.length / 3; i += 3) {
                        addFace(i, i + 1, i + 2);
                    }
                }
            }
            this.computeFaceNormals();
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            return this;
        },
        center: function() {
            this.computeBoundingBox();
            var offset = this.boundingBox.getCenter().negate();
            this.translate(offset.x, offset.y, offset.z);
            return offset;
        },
        normalize: function() {
            this.computeBoundingSphere();
            var center = this.boundingSphere.center;
            var radius = this.boundingSphere.radius;
            var s = radius === 0 ? 1 : 1.0 / radius;
            var matrix = new Matrix4();
            matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
            this.applyMatrix(matrix);
            return this;
        },
        computeFaceNormals: function() {
            var cb = new Vector3(),
                ab = new Vector3();
            for (var f = 0, fl = this.faces.length; f < fl; f++) {
                var face = this.faces[f];
                var vA = this.vertices[face.a];
                var vB = this.vertices[face.b];
                var vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                cb.normalize();
                face.normal.copy(cb);
            }
        },
        computeVertexNormals: function(areaWeighted) {
            if (areaWeighted === undefined) areaWeighted = true;
            var v, vl, f, fl, face, vertices;
            vertices = new Array(this.vertices.length);
            for (v = 0, vl = this.vertices.length; v < vl; v++) {
                vertices[v] = new Vector3();
            }
            if (areaWeighted) {
                var vA, vB, vC;
                var cb = new Vector3(),
                    ab = new Vector3();
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    vA = this.vertices[face.a];
                    vB = this.vertices[face.b];
                    vC = this.vertices[face.c];
                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb.cross(ab);
                    vertices[face.a].add(cb);
                    vertices[face.b].add(cb);
                    vertices[face.c].add(cb);
                }
            } else {
                this.computeFaceNormals();
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    vertices[face.a].add(face.normal);
                    vertices[face.b].add(face.normal);
                    vertices[face.c].add(face.normal);
                }
            }
            for (v = 0, vl = this.vertices.length; v < vl; v++) {
                vertices[v].normalize();
            }
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(vertices[face.a]);
                    vertexNormals[1].copy(vertices[face.b]);
                    vertexNormals[2].copy(vertices[face.c]);
                } else {
                    vertexNormals[0] = vertices[face.a].clone();
                    vertexNormals[1] = vertices[face.b].clone();
                    vertexNormals[2] = vertices[face.c].clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        },
        computeFlatVertexNormals: function() {
            var f, fl, face;
            this.computeFaceNormals();
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(face.normal);
                    vertexNormals[1].copy(face.normal);
                    vertexNormals[2].copy(face.normal);
                } else {
                    vertexNormals[0] = face.normal.clone();
                    vertexNormals[1] = face.normal.clone();
                    vertexNormals[2] = face.normal.clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        },
        computeMorphNormals: function() {
            var i, il, f, fl, face;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                if (!face.__originalFaceNormal) {
                    face.__originalFaceNormal = face.normal.clone();
                } else {
                    face.__originalFaceNormal.copy(face.normal);
                }
                if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
                for (i = 0, il = face.vertexNormals.length; i < il; i++) {
                    if (!face.__originalVertexNormals[i]) {
                        face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                    } else {
                        face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                    }
                }
            }
            var tmpGeo = new Geometry();
            tmpGeo.faces = this.faces;
            for (i = 0, il = this.morphTargets.length; i < il; i++) {
                if (!this.morphNormals[i]) {
                    this.morphNormals[i] = {};
                    this.morphNormals[i].faceNormals = [];
                    this.morphNormals[i].vertexNormals = [];
                    var dstNormalsFace = this.morphNormals[i].faceNormals;
                    var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                    var faceNormal, vertexNormals;
                    for (f = 0, fl = this.faces.length; f < fl; f++) {
                        faceNormal = new Vector3();
                        vertexNormals = {
                            a: new Vector3(),
                            b: new Vector3(),
                            c: new Vector3()
                        };
                        dstNormalsFace.push(faceNormal);
                        dstNormalsVertex.push(vertexNormals);
                    }
                }
                var morphNormals = this.morphNormals[i];
                tmpGeo.vertices = this.morphTargets[i].vertices;
                tmpGeo.computeFaceNormals();
                tmpGeo.computeVertexNormals();
                var faceNormal, vertexNormals;
                for (f = 0, fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    faceNormal = morphNormals.faceNormals[f];
                    vertexNormals = morphNormals.vertexNormals[f];
                    faceNormal.copy(face.normal);
                    vertexNormals.a.copy(face.vertexNormals[0]);
                    vertexNormals.b.copy(face.vertexNormals[1]);
                    vertexNormals.c.copy(face.vertexNormals[2]);
                }
            }
            for (f = 0, fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                face.normal = face.__originalFaceNormal;
                face.vertexNormals = face.__originalVertexNormals;
            }
        },
        computeLineDistances: function() {
            var d = 0;
            var vertices = this.vertices;
            for (var i = 0, il = vertices.length; i < il; i++) {
                if (i > 0) {
                    d += vertices[i].distanceTo(vertices[i - 1]);
                }
                this.lineDistances[i] = d;
            }
        },
        computeBoundingBox: function() {
            if (this.boundingBox === null) {
                this.boundingBox = new Box3();
            }
            this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function() {
            if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
            }
            this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function(geometry, matrix, materialIndexOffset) {
            if (!(geometry && geometry.isGeometry)) {
                console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
                return;
            }
            var normalMatrix, vertexOffset = this.vertices.length,
                vertices1 = this.vertices,
                vertices2 = geometry.vertices,
                faces1 = this.faces,
                faces2 = geometry.faces,
                uvs1 = this.faceVertexUvs[0],
                uvs2 = geometry.faceVertexUvs[0],
                colors1 = this.colors,
                colors2 = geometry.colors;
            if (materialIndexOffset === undefined) materialIndexOffset = 0;
            if (matrix !== undefined) {
                normalMatrix = new Matrix3().getNormalMatrix(matrix);
            }
            for (var i = 0, il = vertices2.length; i < il; i++) {
                var vertex = vertices2[i];
                var vertexCopy = vertex.clone();
                if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
                vertices1.push(vertexCopy);
            }
            for (var i = 0, il = colors2.length; i < il; i++) {
                colors1.push(colors2[i].clone());
            }
            for (i = 0, il = faces2.length; i < il; i++) {
                var face = faces2[i],
                    faceCopy, normal, color, faceVertexNormals = face.vertexNormals,
                    faceVertexColors = face.vertexColors;
                faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                faceCopy.normal.copy(face.normal);
                if (normalMatrix !== undefined) {
                    faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                }
                for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                    normal = faceVertexNormals[j].clone();
                    if (normalMatrix !== undefined) {
                        normal.applyMatrix3(normalMatrix).normalize();
                    }
                    faceCopy.vertexNormals.push(normal);
                }
                faceCopy.color.copy(face.color);
                for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                    color = faceVertexColors[j];
                    faceCopy.vertexColors.push(color.clone());
                }
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
                faces1.push(faceCopy);
            }
            for (i = 0, il = uvs2.length; i < il; i++) {
                var uv = uvs2[i],
                    uvCopy = [];
                if (uv === undefined) {
                    continue;
                }
                for (var j = 0, jl = uv.length; j < jl; j++) {
                    uvCopy.push(uv[j].clone());
                }
                uvs1.push(uvCopy);
            }
        },
        mergeMesh: function(mesh) {
            if (!(mesh && mesh.isMesh)) {
                console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
                return;
            }
            mesh.matrixAutoUpdate && mesh.updateMatrix();
            this.merge(mesh.geometry, mesh.matrix);
        },
        mergeVertices: function() {
            var verticesMap = {};
            var unique = [],
                changes = [];
            var v, key;
            var precisionPoints = 4;
            var precision = Math.pow(10, precisionPoints);
            var i, il, face;
            var indices, j, jl;
            for (i = 0, il = this.vertices.length; i < il; i++) {
                v = this.vertices[i];
                key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
                if (verticesMap[key] === undefined) {
                    verticesMap[key] = i;
                    unique.push(this.vertices[i]);
                    changes[i] = unique.length - 1;
                } else {
                    changes[i] = changes[verticesMap[key]];
                }
            }
            var faceIndicesToRemove = [];
            for (i = 0, il = this.faces.length; i < il; i++) {
                face = this.faces[i];
                face.a = changes[face.a];
                face.b = changes[face.b];
                face.c = changes[face.c];
                indices = [face.a, face.b, face.c];
                for (var n = 0; n < 3; n++) {
                    if (indices[n] === indices[(n + 1) % 3]) {
                        faceIndicesToRemove.push(i);
                        break;
                    }
                }
            }
            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                this.faces.splice(idx, 1);
                for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
                    this.faceVertexUvs[j].splice(idx, 1);
                }
            }
            var diff = this.vertices.length - unique.length;
            this.vertices = unique;
            return diff;
        },
        setFromPoints: function(points) {
            this.vertices = [];
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
            }
            return this;
        },
        sortFacesByMaterialIndex: function() {
            var faces = this.faces;
            var length = faces.length;
            for (var i = 0; i < length; i++) {
                faces[i]._id = i;
            }

            function materialIndexSort(a, b) {
                return a.materialIndex - b.materialIndex;
            }
            faces.sort(materialIndexSort);
            var uvs1 = this.faceVertexUvs[0];
            var uvs2 = this.faceVertexUvs[1];
            var newUvs1, newUvs2;
            if (uvs1 && uvs1.length === length) newUvs1 = [];
            if (uvs2 && uvs2.length === length) newUvs2 = [];
            for (var i = 0; i < length; i++) {
                var id = faces[i]._id;
                if (newUvs1) newUvs1.push(uvs1[id]);
                if (newUvs2) newUvs2.push(uvs2[id]);
            }
            if (newUvs1) this.faceVertexUvs[0] = newUvs1;
            if (newUvs2) this.faceVertexUvs[1] = newUvs2;
        },
        toJSON: function() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Geometry',
                    generator: 'Geometry.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                    if (parameters[key] !== undefined) data[key] = parameters[key];
                }
                return data;
            }
            var vertices = [];
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
            var faces = [];
            var normals = [];
            var normalsHash = {};
            var colors = [];
            var colorsHash = {};
            var uvs = [];
            var uvsHash = {};
            for (var i = 0; i < this.faces.length; i++) {
                var face = this.faces[i];
                var hasMaterial = true;
                var hasFaceUv = false;
                var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
                var hasFaceNormal = face.normal.length() > 0;
                var hasFaceVertexNormal = face.vertexNormals.length > 0;
                var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                var hasFaceVertexColor = face.vertexColors.length > 0;
                var faceType = 0;
                faceType = setBit(faceType, 0, 0);
                faceType = setBit(faceType, 1, hasMaterial);
                faceType = setBit(faceType, 2, hasFaceUv);
                faceType = setBit(faceType, 3, hasFaceVertexUv);
                faceType = setBit(faceType, 4, hasFaceNormal);
                faceType = setBit(faceType, 5, hasFaceVertexNormal);
                faceType = setBit(faceType, 6, hasFaceColor);
                faceType = setBit(faceType, 7, hasFaceVertexColor);
                faces.push(faceType);
                faces.push(face.a, face.b, face.c);
                faces.push(face.materialIndex);
                if (hasFaceVertexUv) {
                    var faceVertexUvs = this.faceVertexUvs[0][i];
                    faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                }
                if (hasFaceNormal) {
                    faces.push(getNormalIndex(face.normal));
                }
                if (hasFaceVertexNormal) {
                    var vertexNormals = face.vertexNormals;
                    faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                }
                if (hasFaceColor) {
                    faces.push(getColorIndex(face.color));
                }
                if (hasFaceVertexColor) {
                    var vertexColors = face.vertexColors;
                    faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                }
            }

            function setBit(value, position, enabled) {
                return enabled ? value | (1 << position) : value & (~(1 << position));
            }

            function getNormalIndex(normal) {
                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                if (normalsHash[hash] !== undefined) {
                    return normalsHash[hash];
                }
                normalsHash[hash] = normals.length / 3;
                normals.push(normal.x, normal.y, normal.z);
                return normalsHash[hash];
            }

            function getColorIndex(color) {
                var hash = color.r.toString() + color.g.toString() + color.b.toString();
                if (colorsHash[hash] !== undefined) {
                    return colorsHash[hash];
                }
                colorsHash[hash] = colors.length;
                colors.push(color.getHex());
                return colorsHash[hash];
            }

            function getUvIndex(uv) {
                var hash = uv.x.toString() + uv.y.toString();
                if (uvsHash[hash] !== undefined) {
                    return uvsHash[hash];
                }
                uvsHash[hash] = uvs.length / 2;
                uvs.push(uv.x, uv.y);
                return uvsHash[hash];
            }
            data.data = {};
            data.data.vertices = vertices;
            data.data.normals = normals;
            if (colors.length > 0) data.data.colors = colors;
            if (uvs.length > 0) data.data.uvs = [uvs];
            data.data.faces = faces;
            return data;
        },
        clone: function() {
            return new Geometry().copy(this);
        },
        copy: function(source) {
            var i, il, j, jl, k, kl;
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [
                []
            ];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.name = source.name;
            var vertices = source.vertices;
            for (i = 0, il = vertices.length; i < il; i++) {
                this.vertices.push(vertices[i].clone());
            }
            var colors = source.colors;
            for (i = 0, il = colors.length; i < il; i++) {
                this.colors.push(colors[i].clone());
            }
            var faces = source.faces;
            for (i = 0, il = faces.length; i < il; i++) {
                this.faces.push(faces[i].clone());
            }
            for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
                var faceVertexUvs = source.faceVertexUvs[i];
                if (this.faceVertexUvs[i] === undefined) {
                    this.faceVertexUvs[i] = [];
                }
                for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
                    var uvs = faceVertexUvs[j],
                        uvsCopy = [];
                    for (k = 0, kl = uvs.length; k < kl; k++) {
                        var uv = uvs[k];
                        uvsCopy.push(uv.clone());
                    }
                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }
            var morphTargets = source.morphTargets;
            for (i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = {};
                morphTarget.name = morphTargets[i].name;
                if (morphTargets[i].vertices !== undefined) {
                    morphTarget.vertices = [];
                    for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
                        morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
                    }
                }
                if (morphTargets[i].normals !== undefined) {
                    morphTarget.normals = [];
                    for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
                        morphTarget.normals.push(morphTargets[i].normals[j].clone());
                    }
                }
                this.morphTargets.push(morphTarget);
            }
            var morphNormals = source.morphNormals;
            for (i = 0, il = morphNormals.length; i < il; i++) {
                var morphNormal = {};
                if (morphNormals[i].vertexNormals !== undefined) {
                    morphNormal.vertexNormals = [];
                    for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
                        var srcVertexNormal = morphNormals[i].vertexNormals[j];
                        var destVertexNormal = {};
                        destVertexNormal.a = srcVertexNormal.a.clone();
                        destVertexNormal.b = srcVertexNormal.b.clone();
                        destVertexNormal.c = srcVertexNormal.c.clone();
                        morphNormal.vertexNormals.push(destVertexNormal);
                    }
                }
                if (morphNormals[i].faceNormals !== undefined) {
                    morphNormal.faceNormals = [];
                    for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
                        morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
                    }
                }
                this.morphNormals.push(morphNormal);
            }
            var skinWeights = source.skinWeights;
            for (i = 0, il = skinWeights.length; i < il; i++) {
                this.skinWeights.push(skinWeights[i].clone());
            }
            var skinIndices = source.skinIndices;
            for (i = 0, il = skinIndices.length; i < il; i++) {
                this.skinIndices.push(skinIndices[i].clone());
            }
            var lineDistances = source.lineDistances;
            for (i = 0, il = lineDistances.length; i < il; i++) {
                this.lineDistances.push(lineDistances[i]);
            }
            var boundingBox = source.boundingBox;
            if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
            }
            var boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
            }
            this.elementsNeedUpdate = source.elementsNeedUpdate;
            this.verticesNeedUpdate = source.verticesNeedUpdate;
            this.uvsNeedUpdate = source.uvsNeedUpdate;
            this.normalsNeedUpdate = source.normalsNeedUpdate;
            this.colorsNeedUpdate = source.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = source.groupsNeedUpdate;
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });

    function BufferAttribute(array, itemSize, normalized) {
        if (Array.isArray(array)) {
            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        }
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== undefined ? array.length / itemSize : 0;
        this.normalized = normalized === true;
        this.dynamic = false;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.onUploadCallback = function() {};
        this.version = 0;
    }
    Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
        set: function(value) {
            if (value === true) this.version++;
        }
    });
    Object.assign(BufferAttribute.prototype, {
        isBufferAttribute: true,
        setArray: function(array) {
            if (Array.isArray(array)) {
                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }
            this.count = array !== undefined ? array.length / this.itemSize : 0;
            this.array = array;
        },
        setDynamic: function(value) {
            this.dynamic = value;
            return this;
        },
        copy: function(source) {
            this.array = new source.array.constructor(source.array);
            this.itemSize = source.itemSize;
            this.count = source.count;
            this.normalized = source.normalized;
            this.dynamic = source.dynamic;
            return this;
        },
        copyAt: function(index1, attribute, index2) {
            index1 *= this.itemSize;
            index2 *= attribute.itemSize;
            for (var i = 0, l = this.itemSize; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        },
        copyArray: function(array) {
            this.array.set(array);
            return this;
        },
        copyColorsArray: function(colors) {
            var array = this.array,
                offset = 0;
            for (var i = 0, l = colors.length; i < l; i++) {
                var color = colors[i];
                if (color === undefined) {
                    console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                    color = new Color();
                }
                array[offset++] = color.r;
                array[offset++] = color.g;
                array[offset++] = color.b;
            }
            return this;
        },
        copyIndicesArray: function(indices) {
            var array = this.array,
                offset = 0;
            for (var i = 0, l = indices.length; i < l; i++) {
                var index = indices[i];
                array[offset++] = index.a;
                array[offset++] = index.b;
                array[offset++] = index.c;
            }
            return this;
        },
        copyVector2sArray: function(vectors) {
            var array = this.array,
                offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                    vector = new Vector2();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
            }
            return this;
        },
        copyVector3sArray: function(vectors) {
            var array = this.array,
                offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                    vector = new Vector3();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
            }
            return this;
        },
        copyVector4sArray: function(vectors) {
            var array = this.array,
                offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                    vector = new Vector4();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
                array[offset++] = vector.w;
            }
            return this;
        },
        set: function(value, offset) {
            if (offset === undefined) offset = 0;
            this.array.set(value, offset);
            return this;
        },
        getX: function(index) {
            return this.array[index * this.itemSize];
        },
        setX: function(index, x) {
            this.array[index * this.itemSize] = x;
            return this;
        },
        getY: function(index) {
            return this.array[index * this.itemSize + 1];
        },
        setY: function(index, y) {
            this.array[index * this.itemSize + 1] = y;
            return this;
        },
        getZ: function(index) {
            return this.array[index * this.itemSize + 2];
        },
        setZ: function(index, z) {
            this.array[index * this.itemSize + 2] = z;
            return this;
        },
        getW: function(index) {
            return this.array[index * this.itemSize + 3];
        },
        setW: function(index, w) {
            this.array[index * this.itemSize + 3] = w;
            return this;
        },
        setXY: function(index, x, y) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            return this;
        },
        setXYZ: function(index, x, y, z) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            return this;
        },
        setXYZW: function(index, x, y, z, w) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            this.array[index + 3] = w;
            return this;
        },
        onUpload: function(callback) {
            this.onUploadCallback = callback;
            return this;
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
    });

    function Int8BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
    }
    Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

    function Uint8BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
    }
    Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

    function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
    }
    Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

    function Int16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
    }
    Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

    function Uint16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
    }
    Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

    function Int32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
    }
    Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

    function Uint32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
    }
    Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

    function Float32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
    }
    Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

    function Float64BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
    }
    Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

    function DirectGeometry() {
        this.indices = [];
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {};
        this.skinWeights = [];
        this.skinIndices = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    Object.assign(DirectGeometry.prototype, {
        computeGroups: function(geometry) {
            var group;
            var groups = [];
            var materialIndex = undefined;
            var faces = geometry.faces;
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                if (face.materialIndex !== materialIndex) {
                    materialIndex = face.materialIndex;
                    if (group !== undefined) {
                        group.count = (i * 3) - group.start;
                        groups.push(group);
                    }
                    group = {
                        start: i * 3,
                        materialIndex: materialIndex
                    };
                }
            }
            if (group !== undefined) {
                group.count = (i * 3) - group.start;
                groups.push(group);
            }
            this.groups = groups;
        },
        fromGeometry: function(geometry) {
            var faces = geometry.faces;
            var vertices = geometry.vertices;
            var faceVertexUvs = geometry.faceVertexUvs;
            var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
            var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
            var morphTargets = geometry.morphTargets;
            var morphTargetsLength = morphTargets.length;
            var morphTargetsPosition;
            if (morphTargetsLength > 0) {
                morphTargetsPosition = [];
                for (var i = 0; i < morphTargetsLength; i++) {
                    morphTargetsPosition[i] = [];
                }
                this.morphTargets.position = morphTargetsPosition;
            }
            var morphNormals = geometry.morphNormals;
            var morphNormalsLength = morphNormals.length;
            var morphTargetsNormal;
            if (morphNormalsLength > 0) {
                morphTargetsNormal = [];
                for (var i = 0; i < morphNormalsLength; i++) {
                    morphTargetsNormal[i] = [];
                }
                this.morphTargets.normal = morphTargetsNormal;
            }
            var skinIndices = geometry.skinIndices;
            var skinWeights = geometry.skinWeights;
            var hasSkinIndices = skinIndices.length === vertices.length;
            var hasSkinWeights = skinWeights.length === vertices.length;
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
                } else {
                    var normal = face.normal;
                    this.normals.push(normal, normal, normal);
                }
                var vertexColors = face.vertexColors;
                if (vertexColors.length === 3) {
                    this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
                } else {
                    var color = face.color;
                    this.colors.push(color, color, color);
                }
                if (hasFaceVertexUv === true) {
                    var vertexUvs = faceVertexUvs[0][i];
                    if (vertexUvs !== undefined) {
                        this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    } else {
                        console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
                        this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                    }
                }
                if (hasFaceVertexUv2 === true) {
                    var vertexUvs = faceVertexUvs[1][i];
                    if (vertexUvs !== undefined) {
                        this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    } else {
                        console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
                        this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                    }
                }
                for (var j = 0; j < morphTargetsLength; j++) {
                    var morphTarget = morphTargets[j].vertices;
                    morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                }
                for (var j = 0; j < morphNormalsLength; j++) {
                    var morphNormal = morphNormals[j].vertexNormals[i];
                    morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
                }
                if (hasSkinIndices) {
                    this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
                }
                if (hasSkinWeights) {
                    this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
                }
            }
            this.computeGroups(geometry);
            this.verticesNeedUpdate = geometry.verticesNeedUpdate;
            this.normalsNeedUpdate = geometry.normalsNeedUpdate;
            this.colorsNeedUpdate = geometry.colorsNeedUpdate;
            this.uvsNeedUpdate = geometry.uvsNeedUpdate;
            this.groupsNeedUpdate = geometry.groupsNeedUpdate;
            return this;
        }
    });

    function arrayMax(array) {
        if (array.length === 0) return -Infinity;
        var max = array[0];
        for (var i = 1, l = array.length; i < l; ++i) {
            if (array[i] > max) max = array[i];
        }
        return max;
    }
    var bufferGeometryId = 1;

    function BufferGeometry() {
        Object.defineProperty(this, 'id', {
            value: bufferGeometryId += 2
        });
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'BufferGeometry';
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = {
            start: 0,
            count: Infinity
        };
    }
    BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: BufferGeometry,
        isBufferGeometry: true,
        getIndex: function() {
            return this.index;
        },
        setIndex: function(index) {
            if (Array.isArray(index)) {
                this.index = new(arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
            } else {
                this.index = index;
            }
        },
        addAttribute: function(name, attribute) {
            if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
                console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
                this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
                return;
            }
            if (name === 'index') {
                console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
                this.setIndex(attribute);
                return;
            }
            this.attributes[name] = attribute;
            return this;
        },
        getAttribute: function(name) {
            return this.attributes[name];
        },
        removeAttribute: function(name) {
            delete this.attributes[name];
            return this;
        },
        addGroup: function(start, count, materialIndex) {
            this.groups.push({
                start: start,
                count: count,
                materialIndex: materialIndex !== undefined ? materialIndex : 0
            });
        },
        clearGroups: function() {
            this.groups = [];
        },
        setDrawRange: function(start, count) {
            this.drawRange.start = start;
            this.drawRange.count = count;
        },
        applyMatrix: function(matrix) {
            var position = this.attributes.position;
            if (position !== undefined) {
                matrix.applyToBufferAttribute(position);
                position.needsUpdate = true;
            }
            var normal = this.attributes.normal;
            if (normal !== undefined) {
                var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                normalMatrix.applyToBufferAttribute(normal);
                normal.needsUpdate = true;
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            return this;
        },
        rotateX: function() {
            var m1 = new Matrix4();
            return function rotateX(angle) {
                m1.makeRotationX(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        rotateY: function() {
            var m1 = new Matrix4();
            return function rotateY(angle) {
                m1.makeRotationY(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        rotateZ: function() {
            var m1 = new Matrix4();
            return function rotateZ(angle) {
                m1.makeRotationZ(angle);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        translate: function() {
            var m1 = new Matrix4();
            return function translate(x, y, z) {
                m1.makeTranslation(x, y, z);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        scale: function() {
            var m1 = new Matrix4();
            return function scale(x, y, z) {
                m1.makeScale(x, y, z);
                this.applyMatrix(m1);
                return this;
            };
        }(),
        lookAt: function() {
            var obj = new Object3D();
            return function lookAt(vector) {
                obj.lookAt(vector);
                obj.updateMatrix();
                this.applyMatrix(obj.matrix);
            };
        }(),
        center: function() {
            this.computeBoundingBox();
            var offset = this.boundingBox.getCenter().negate();
            this.translate(offset.x, offset.y, offset.z);
            return offset;
        },
        setFromObject: function(object) {
            var geometry = object.geometry;
            if (object.isPoints || object.isLine) {
                var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
                var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
                this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
                this.addAttribute('color', colors.copyColorsArray(geometry.colors));
                if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                    var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                    this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
                }
                if (geometry.boundingSphere !== null) {
                    this.boundingSphere = geometry.boundingSphere.clone();
                }
                if (geometry.boundingBox !== null) {
                    this.boundingBox = geometry.boundingBox.clone();
                }
            } else if (object.isMesh) {
                if (geometry && geometry.isGeometry) {
                    this.fromGeometry(geometry);
                }
            }
            return this;
        },
        setFromPoints: function(points) {
            var position = [];
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                position.push(point.x, point.y, point.z || 0);
            }
            this.addAttribute('position', new Float32BufferAttribute(position, 3));
            return this;
        },
        updateFromObject: function(object) {
            var geometry = object.geometry;
            if (object.isMesh) {
                var direct = geometry.__directGeometry;
                if (geometry.elementsNeedUpdate === true) {
                    direct = undefined;
                    geometry.elementsNeedUpdate = false;
                }
                if (direct === undefined) {
                    return this.fromGeometry(geometry);
                }
                direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
                geometry.verticesNeedUpdate = false;
                geometry.normalsNeedUpdate = false;
                geometry.colorsNeedUpdate = false;
                geometry.uvsNeedUpdate = false;
                geometry.groupsNeedUpdate = false;
                geometry = direct;
            }
            var attribute;
            if (geometry.verticesNeedUpdate === true) {
                attribute = this.attributes.position;
                if (attribute !== undefined) {
                    attribute.copyVector3sArray(geometry.vertices);
                    attribute.needsUpdate = true;
                }
                geometry.verticesNeedUpdate = false;
            }
            if (geometry.normalsNeedUpdate === true) {
                attribute = this.attributes.normal;
                if (attribute !== undefined) {
                    attribute.copyVector3sArray(geometry.normals);
                    attribute.needsUpdate = true;
                }
                geometry.normalsNeedUpdate = false;
            }
            if (geometry.colorsNeedUpdate === true) {
                attribute = this.attributes.color;
                if (attribute !== undefined) {
                    attribute.copyColorsArray(geometry.colors);
                    attribute.needsUpdate = true;
                }
                geometry.colorsNeedUpdate = false;
            }
            if (geometry.uvsNeedUpdate) {
                attribute = this.attributes.uv;
                if (attribute !== undefined) {
                    attribute.copyVector2sArray(geometry.uvs);
                    attribute.needsUpdate = true;
                }
                geometry.uvsNeedUpdate = false;
            }
            if (geometry.lineDistancesNeedUpdate) {
                attribute = this.attributes.lineDistance;
                if (attribute !== undefined) {
                    attribute.copyArray(geometry.lineDistances);
                    attribute.needsUpdate = true;
                }
                geometry.lineDistancesNeedUpdate = false;
            }
            if (geometry.groupsNeedUpdate) {
                geometry.computeGroups(object.geometry);
                this.groups = geometry.groups;
                geometry.groupsNeedUpdate = false;
            }
            return this;
        },
        fromGeometry: function(geometry) {
            geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
            return this.fromDirectGeometry(geometry.__directGeometry);
        },
        fromDirectGeometry: function(geometry) {
            var positions = new Float32Array(geometry.vertices.length * 3);
            this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
            if (geometry.normals.length > 0) {
                var normals = new Float32Array(geometry.normals.length * 3);
                this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
            }
            if (geometry.colors.length > 0) {
                var colors = new Float32Array(geometry.colors.length * 3);
                this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
            }
            if (geometry.uvs.length > 0) {
                var uvs = new Float32Array(geometry.uvs.length * 2);
                this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
            }
            if (geometry.uvs2.length > 0) {
                var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
            }
            if (geometry.indices.length > 0) {
                var TypeArray = arrayMax(geometry.indices) > 65535 ? Uint32Array : Uint16Array;
                var indices = new TypeArray(geometry.indices.length * 3);
                this.setIndex(new BufferAttribute(indices, 1).copyIndicesArray(geometry.indices));
            }
            this.groups = geometry.groups;
            for (var name in geometry.morphTargets) {
                var array = [];
                var morphTargets = geometry.morphTargets[name];
                for (var i = 0, l = morphTargets.length; i < l; i++) {
                    var morphTarget = morphTargets[i];
                    var attribute = new Float32BufferAttribute(morphTarget.length * 3, 3);
                    array.push(attribute.copyVector3sArray(morphTarget));
                }
                this.morphAttributes[name] = array;
            }
            if (geometry.skinIndices.length > 0) {
                var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
                this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
            }
            if (geometry.skinWeights.length > 0) {
                var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
                this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            return this;
        },
        computeBoundingBox: function() {
            if (this.boundingBox === null) {
                this.boundingBox = new Box3();
            }
            var position = this.attributes.position;
            if (position !== undefined) {
                this.boundingBox.setFromBufferAttribute(position);
            } else {
                this.boundingBox.makeEmpty();
            }
            if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
            }
        },
        computeBoundingSphere: function() {
            var box = new Box3();
            var vector = new Vector3();
            return function computeBoundingSphere() {
                if (this.boundingSphere === null) {
                    this.boundingSphere = new Sphere();
                }
                var position = this.attributes.position;
                if (position) {
                    var center = this.boundingSphere.center;
                    box.setFromBufferAttribute(position);
                    box.getCenter(center);
                    var maxRadiusSq = 0;
                    for (var i = 0, il = position.count; i < il; i++) {
                        vector.x = position.getX(i);
                        vector.y = position.getY(i);
                        vector.z = position.getZ(i);
                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                    }
                    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                    if (isNaN(this.boundingSphere.radius)) {
                        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                    }
                }
            };
        }(),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var index = this.index;
            var attributes = this.attributes;
            var groups = this.groups;
            if (attributes.position) {
                var positions = attributes.position.array;
                if (attributes.normal === undefined) {
                    this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
                } else {
                    var array = attributes.normal.array;
                    for (var i = 0, il = array.length; i < il; i++) {
                        array[i] = 0;
                    }
                }
                var normals = attributes.normal.array;
                var vA, vB, vC;
                var pA = new Vector3(),
                    pB = new Vector3(),
                    pC = new Vector3();
                var cb = new Vector3(),
                    ab = new Vector3();
                if (index) {
                    var indices = index.array;
                    if (groups.length === 0) {
                        this.addGroup(0, indices.length);
                    }
                    for (var j = 0, jl = groups.length; j < jl; ++j) {
                        var group = groups[j];
                        var start = group.start;
                        var count = group.count;
                        for (var i = start, il = start + count; i < il; i += 3) {
                            vA = indices[i + 0] * 3;
                            vB = indices[i + 1] * 3;
                            vC = indices[i + 2] * 3;
                            pA.fromArray(positions, vA);
                            pB.fromArray(positions, vB);
                            pC.fromArray(positions, vC);
                            cb.subVectors(pC, pB);
                            ab.subVectors(pA, pB);
                            cb.cross(ab);
                            normals[vA] += cb.x;
                            normals[vA + 1] += cb.y;
                            normals[vA + 2] += cb.z;
                            normals[vB] += cb.x;
                            normals[vB + 1] += cb.y;
                            normals[vB + 2] += cb.z;
                            normals[vC] += cb.x;
                            normals[vC + 1] += cb.y;
                            normals[vC + 2] += cb.z;
                        }
                    }
                } else {
                    for (var i = 0, il = positions.length; i < il; i += 9) {
                        pA.fromArray(positions, i);
                        pB.fromArray(positions, i + 3);
                        pC.fromArray(positions, i + 6);
                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);
                        normals[i] = cb.x;
                        normals[i + 1] = cb.y;
                        normals[i + 2] = cb.z;
                        normals[i + 3] = cb.x;
                        normals[i + 4] = cb.y;
                        normals[i + 5] = cb.z;
                        normals[i + 6] = cb.x;
                        normals[i + 7] = cb.y;
                        normals[i + 8] = cb.z;
                    }
                }
                this.normalizeNormals();
                attributes.normal.needsUpdate = true;
            }
        },
        merge: function(geometry, offset) {
            if (!(geometry && geometry.isBufferGeometry)) {
                console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
                return;
            }
            if (offset === undefined) offset = 0;
            var attributes = this.attributes;
            for (var key in attributes) {
                if (geometry.attributes[key] === undefined) continue;
                var attribute1 = attributes[key];
                var attributeArray1 = attribute1.array;
                var attribute2 = geometry.attributes[key];
                var attributeArray2 = attribute2.array;
                var attributeSize = attribute2.itemSize;
                for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
                    attributeArray1[j] = attributeArray2[i];
                }
            }
            return this;
        },
        normalizeNormals: function() {
            var vector = new Vector3();
            return function normalizeNormals() {
                var normals = this.attributes.normal;
                for (var i = 0, il = normals.count; i < il; i++) {
                    vector.x = normals.getX(i);
                    vector.y = normals.getY(i);
                    vector.z = normals.getZ(i);
                    vector.normalize();
                    normals.setXYZ(i, vector.x, vector.y, vector.z);
                }
            };
        }(),
        toNonIndexed: function() {
            if (this.index === null) {
                console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
                return this;
            }
            var geometry2 = new BufferGeometry();
            var indices = this.index.array;
            var attributes = this.attributes;
            for (var name in attributes) {
                var attribute = attributes[name];
                var array = attribute.array;
                var itemSize = attribute.itemSize;
                var array2 = new array.constructor(indices.length * itemSize);
                var index = 0,
                    index2 = 0;
                for (var i = 0, l = indices.length; i < l; i++) {
                    index = indices[i] * itemSize;
                    for (var j = 0; j < itemSize; j++) {
                        array2[index2++] = array[index++];
                    }
                }
                geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
            }
            return geometry2;
        },
        toJSON: function() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'BufferGeometry',
                    generator: 'BufferGeometry.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                    if (parameters[key] !== undefined) data[key] = parameters[key];
                }
                return data;
            }
            data.data = {
                attributes: {}
            };
            var index = this.index;
            if (index !== null) {
                var array = Array.prototype.slice.call(index.array);
                data.data.index = {
                    type: index.array.constructor.name,
                    array: array
                };
            }
            var attributes = this.attributes;
            for (var key in attributes) {
                var attribute = attributes[key];
                var array = Array.prototype.slice.call(attribute.array);
                data.data.attributes[key] = {
                    itemSize: attribute.itemSize,
                    type: attribute.array.constructor.name,
                    array: array,
                    normalized: attribute.normalized
                };
            }
            var groups = this.groups;
            if (groups.length > 0) {
                data.data.groups = JSON.parse(JSON.stringify(groups));
            }
            var boundingSphere = this.boundingSphere;
            if (boundingSphere !== null) {
                data.data.boundingSphere = {
                    center: boundingSphere.center.toArray(),
                    radius: boundingSphere.radius
                };
            }
            return data;
        },
        clone: function() {
            return new BufferGeometry().copy(this);
        },
        copy: function(source) {
            var name, i, l;
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.name = source.name;
            var index = source.index;
            if (index !== null) {
                this.setIndex(index.clone());
            }
            var attributes = source.attributes;
            for (name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }
            var morphAttributes = source.morphAttributes;
            for (name in morphAttributes) {
                var array = [];
                var morphAttribute = morphAttributes[name];
                for (i = 0, l = morphAttribute.length; i < l; i++) {
                    array.push(morphAttribute[i].clone());
                }
                this.morphAttributes[name] = array;
            }
            var groups = source.groups;
            for (i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }
            var boundingBox = source.boundingBox;
            if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
            }
            var boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
            }
            this.drawRange.start = source.drawRange.start;
            this.drawRange.count = source.drawRange.count;
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });

    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        Geometry.call(this);
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
        this.mergeVertices();
    }
    BoxGeometry.prototype = Object.create(Geometry.prototype);
    BoxGeometry.prototype.constructor = BoxGeometry;

    function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        BufferGeometry.call(this);
        this.type = 'BoxBufferGeometry';
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        var scope = this;
        width = width || 1;
        height = height || 1;
        depth = depth || 1;
        widthSegments = Math.floor(widthSegments) || 1;
        heightSegments = Math.floor(heightSegments) || 1;
        depthSegments = Math.floor(depthSegments) || 1;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var numberOfVertices = 0;
        var groupStart = 0;
        buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            var segmentWidth = width / gridX;
            var segmentHeight = height / gridY;
            var widthHalf = width / 2;
            var heightHalf = height / 2;
            var depthHalf = depth / 2;
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var vertexCounter = 0;
            var groupCount = 0;
            var ix, iy;
            var vector = new Vector3();
            for (iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (ix = 0; ix < gridX1; ix++) {
                    var x = ix * segmentWidth - widthHalf;
                    vector[u] = x * udir;
                    vector[v] = y * vdir;
                    vector[w] = depthHalf;
                    vertices.push(vector.x, vector.y, vector.z);
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w] = depth > 0 ? 1 : -1;
                    normals.push(vector.x, vector.y, vector.z);
                    uvs.push(ix / gridX);
                    uvs.push(1 - (iy / gridY));
                    vertexCounter += 1;
                }
            }
            for (iy = 0; iy < gridY; iy++) {
                for (ix = 0; ix < gridX; ix++) {
                    var a = numberOfVertices + ix + gridX1 * iy;
                    var b = numberOfVertices + ix + gridX1 * (iy + 1);
                    var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                    var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                    groupCount += 6;
                }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
        }
    }
    BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

    function PlaneGeometry(width, height, widthSegments, heightSegments) {
        Geometry.call(this);
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
        this.mergeVertices();
    }
    PlaneGeometry.prototype = Object.create(Geometry.prototype);
    PlaneGeometry.prototype.constructor = PlaneGeometry;

    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
        BufferGeometry.call(this);
        this.type = 'PlaneBufferGeometry';
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        width = width || 1;
        height = height || 1;
        var width_half = width / 2;
        var height_half = height / 2;
        var gridX = Math.floor(widthSegments) || 1;
        var gridY = Math.floor(heightSegments) || 1;
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var segment_width = width / gridX;
        var segment_height = height / gridY;
        var ix, iy;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        for (iy = 0; iy < gridY1; iy++) {
            var y = iy * segment_height - height_half;
            for (ix = 0; ix < gridX1; ix++) {
                var x = ix * segment_width - width_half;
                vertices.push(x, -y, 0);
                normals.push(0, 0, 1);
                uvs.push(ix / gridX);
                uvs.push(1 - (iy / gridY));
            }
        }
        for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * (iy + 1);
                var c = (ix + 1) + gridX1 * (iy + 1);
                var d = (ix + 1) + gridX1 * iy;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

    function MeshBasicMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshBasicMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.lights = false;
        this.setValues(parameters);
    }
    MeshBasicMaterial.prototype = Object.create(Material.prototype);
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    MeshBasicMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        return this;
    };

    function ShaderMaterial(parameters) {
        Material.call(this);
        this.type = 'ShaderMaterial';
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
        this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.clipping = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
        };
        this.defaultAttributeValues = {
            'color': [1, 1, 1],
            'uv': [0, 0],
            'uv2': [0, 0]
        };
        this.index0AttributeName = undefined;
        if (parameters !== undefined) {
            if (parameters.attributes !== undefined) {
                console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
            }
            this.setValues(parameters);
        }
    }
    ShaderMaterial.prototype = Object.create(Material.prototype);
    ShaderMaterial.prototype.constructor = ShaderMaterial;
    ShaderMaterial.prototype.isShaderMaterial = true;
    ShaderMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = UniformsUtils.clone(source.uniforms);
        this.defines = source.defines;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.extensions = source.extensions;
        return this;
    };
    ShaderMaterial.prototype.toJSON = function(meta) {
        var data = Material.prototype.toJSON.call(this, meta);
        data.uniforms = this.uniforms;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        return data;
    };

    function Ray(origin, direction) {
        this.origin = (origin !== undefined) ? origin : new Vector3();
        this.direction = (direction !== undefined) ? direction : new Vector3();
    }
    Object.assign(Ray.prototype, {
        set: function(origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(ray) {
            this.origin.copy(ray.origin);
            this.direction.copy(ray.direction);
            return this;
        },
        at: function(t, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.copy(this.direction).multiplyScalar(t).add(this.origin);
        },
        lookAt: function(v) {
            this.direction.copy(v).sub(this.origin).normalize();
            return this;
        },
        recast: function() {
            var v1 = new Vector3();
            return function recast(t) {
                this.origin.copy(this.at(t, v1));
                return this;
            };
        }(),
        closestPointToPoint: function(point, optionalTarget) {
            var result = optionalTarget || new Vector3();
            result.subVectors(point, this.origin);
            var directionDistance = result.dot(this.direction);
            if (directionDistance < 0) {
                return result.copy(this.origin);
            }
            return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        },
        distanceToPoint: function(point) {
            return Math.sqrt(this.distanceSqToPoint(point));
        },
        distanceSqToPoint: function() {
            var v1 = new Vector3();
            return function distanceSqToPoint(point) {
                var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
                if (directionDistance < 0) {
                    return this.origin.distanceToSquared(point);
                }
                v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                return v1.distanceToSquared(point);
            };
        }(),
        distanceSqToSegment: function() {
            var segCenter = new Vector3();
            var segDir = new Vector3();
            var diff = new Vector3();
            return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                segCenter.copy(v0).add(v1).multiplyScalar(0.5);
                segDir.copy(v1).sub(v0).normalize();
                diff.copy(this.origin).sub(segCenter);
                var segExtent = v0.distanceTo(v1) * 0.5;
                var a01 = -this.direction.dot(segDir);
                var b0 = diff.dot(this.direction);
                var b1 = -diff.dot(segDir);
                var c = diff.lengthSq();
                var det = Math.abs(1 - a01 * a01);
                var s0, s1, sqrDist, extDet;
                if (det > 0) {
                    s0 = a01 * b1 - b0;
                    s1 = a01 * b0 - b1;
                    extDet = segExtent * det;
                    if (s0 >= 0) {
                        if (s1 >= -extDet) {
                            if (s1 <= extDet) {
                                var invDet = 1 / det;
                                s0 *= invDet;
                                s1 *= invDet;
                                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                            } else {
                                s1 = segExtent;
                                s0 = Math.max(0, -(a01 * s1 + b0));
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                            }
                        } else {
                            s1 = -segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    } else {
                        if (s1 <= -extDet) {
                            s0 = Math.max(0, -(-a01 * segExtent + b0));
                            s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        } else if (s1 <= extDet) {
                            s0 = 0;
                            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = s1 * (s1 + 2 * b1) + c;
                        } else {
                            s0 = Math.max(0, -(a01 * segExtent + b0));
                            s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    }
                } else {
                    s1 = (a01 > 0) ? -segExtent : segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
                if (optionalPointOnRay) {
                    optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
                }
                if (optionalPointOnSegment) {
                    optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
                }
                return sqrDist;
            };
        }(),
        intersectSphere: function() {
            var v1 = new Vector3();
            return function intersectSphere(sphere, optionalTarget) {
                v1.subVectors(sphere.center, this.origin);
                var tca = v1.dot(this.direction);
                var d2 = v1.dot(v1) - tca * tca;
                var radius2 = sphere.radius * sphere.radius;
                if (d2 > radius2) return null;
                var thc = Math.sqrt(radius2 - d2);
                var t0 = tca - thc;
                var t1 = tca + thc;
                if (t0 < 0 && t1 < 0) return null;
                if (t0 < 0) return this.at(t1, optionalTarget);
                return this.at(t0, optionalTarget);
            };
        }(),
        intersectsSphere: function(sphere) {
            return this.distanceToPoint(sphere.center) <= sphere.radius;
        },
        distanceToPlane: function(plane) {
            var denominator = plane.normal.dot(this.direction);
            if (denominator === 0) {
                if (plane.distanceToPoint(this.origin) === 0) {
                    return 0;
                }
                return null;
            }
            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
            return t >= 0 ? t : null;
        },
        intersectPlane: function(plane, optionalTarget) {
            var t = this.distanceToPlane(plane);
            if (t === null) {
                return null;
            }
            return this.at(t, optionalTarget);
        },
        intersectsPlane: function(plane) {
            var distToPoint = plane.distanceToPoint(this.origin);
            if (distToPoint === 0) {
                return true;
            }
            var denominator = plane.normal.dot(this.direction);
            if (denominator * distToPoint < 0) {
                return true;
            }
            return false;
        },
        intersectBox: function(box, optionalTarget) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var invdirx = 1 / this.direction.x,
                invdiry = 1 / this.direction.y,
                invdirz = 1 / this.direction.z;
            var origin = this.origin;
            if (invdirx >= 0) {
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
            } else {
                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
            }
            if (invdiry >= 0) {
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
            } else {
                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
            }
            if ((tmin > tymax) || (tymin > tmax)) return null;
            if (tymin > tmin || tmin !== tmin) tmin = tymin;
            if (tymax < tmax || tmax !== tmax) tmax = tymax;
            if (invdirz >= 0) {
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
            } else {
                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
            }
            if ((tmin > tzmax) || (tzmin > tmax)) return null;
            if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
            if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
            if (tmax < 0) return null;
            return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
        },
        intersectsBox: (function() {
            var v = new Vector3();
            return function intersectsBox(box) {
                return this.intersectBox(box, v) !== null;
            };
        })(),
        intersectTriangle: function() {
            var diff = new Vector3();
            var edge1 = new Vector3();
            var edge2 = new Vector3();
            var normal = new Vector3();
            return function intersectTriangle(a, b, c, backfaceCulling, optionalTarget) {
                edge1.subVectors(b, a);
                edge2.subVectors(c, a);
                normal.crossVectors(edge1, edge2);
                var DdN = this.direction.dot(normal);
                var sign;
                if (DdN > 0) {
                    if (backfaceCulling) return null;
                    sign = 1;
                } else if (DdN < 0) {
                    sign = -1;
                    DdN = -DdN;
                } else {
                    return null;
                }
                diff.subVectors(this.origin, a);
                var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
                if (DdQxE2 < 0) {
                    return null;
                }
                var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
                if (DdE1xQ < 0) {
                    return null;
                }
                if (DdQxE2 + DdE1xQ > DdN) {
                    return null;
                }
                var QdN = -sign * diff.dot(normal);
                if (QdN < 0) {
                    return null;
                }
                return this.at(QdN / DdN, optionalTarget);
            };
        }(),
        applyMatrix4: function(matrix4) {
            this.origin.applyMatrix4(matrix4);
            this.direction.transformDirection(matrix4);
            return this;
        },
        equals: function(ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
    });

    function Line3(start, end) {
        this.start = (start !== undefined) ? start : new Vector3();
        this.end = (end !== undefined) ? end : new Vector3();
    }
    Object.assign(Line3.prototype, {
        set: function(start, end) {
            this.start.copy(start);
            this.end.copy(end);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(line) {
            this.start.copy(line.start);
            this.end.copy(line.end);
            return this;
        },
        getCenter: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.addVectors(this.start, this.end).multiplyScalar(0.5);
        },
        delta: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.subVectors(this.end, this.start);
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end);
        },
        distance: function() {
            return this.start.distanceTo(this.end);
        },
        at: function(t, optionalTarget) {
            var result = optionalTarget || new Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        },
        closestPointToPointParameter: function() {
            var startP = new Vector3();
            var startEnd = new Vector3();
            return function closestPointToPointParameter(point, clampToLine) {
                startP.subVectors(point, this.start);
                startEnd.subVectors(this.end, this.start);
                var startEnd2 = startEnd.dot(startEnd);
                var startEnd_startP = startEnd.dot(startP);
                var t = startEnd_startP / startEnd2;
                if (clampToLine) {
                    t = _Math.clamp(t, 0, 1);
                }
                return t;
            };
        }(),
        closestPointToPoint: function(point, clampToLine, optionalTarget) {
            var t = this.closestPointToPointParameter(point, clampToLine);
            var result = optionalTarget || new Vector3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        },
        applyMatrix4: function(matrix) {
            this.start.applyMatrix4(matrix);
            this.end.applyMatrix4(matrix);
            return this;
        },
        equals: function(line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        }
    });

    function Triangle(a, b, c) {
        this.a = (a !== undefined) ? a : new Vector3();
        this.b = (b !== undefined) ? b : new Vector3();
        this.c = (c !== undefined) ? c : new Vector3();
    }
    Object.assign(Triangle, {
        normal: function() {
            var v0 = new Vector3();
            return function normal(a, b, c, optionalTarget) {
                var result = optionalTarget || new Vector3();
                result.subVectors(c, b);
                v0.subVectors(a, b);
                result.cross(v0);
                var resultLengthSq = result.lengthSq();
                if (resultLengthSq > 0) {
                    return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
                }
                return result.set(0, 0, 0);
            };
        }(),
        barycoordFromPoint: function() {
            var v0 = new Vector3();
            var v1 = new Vector3();
            var v2 = new Vector3();
            return function barycoordFromPoint(point, a, b, c, optionalTarget) {
                v0.subVectors(c, a);
                v1.subVectors(b, a);
                v2.subVectors(point, a);
                var dot00 = v0.dot(v0);
                var dot01 = v0.dot(v1);
                var dot02 = v0.dot(v2);
                var dot11 = v1.dot(v1);
                var dot12 = v1.dot(v2);
                var denom = (dot00 * dot11 - dot01 * dot01);
                var result = optionalTarget || new Vector3();
                if (denom === 0) {
                    return result.set(-2, -1, -1);
                }
                var invDenom = 1 / denom;
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                return result.set(1 - u - v, v, u);
            };
        }(),
        containsPoint: function() {
            var v1 = new Vector3();
            return function containsPoint(point, a, b, c) {
                var result = Triangle.barycoordFromPoint(point, a, b, c, v1);
                return (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);
            };
        }()
    });
    Object.assign(Triangle.prototype, {
        set: function(a, b, c) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        },
        setFromPointsAndIndices: function(points, i0, i1, i2) {
            this.a.copy(points[i0]);
            this.b.copy(points[i1]);
            this.c.copy(points[i2]);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(triangle) {
            this.a.copy(triangle.a);
            this.b.copy(triangle.b);
            this.c.copy(triangle.c);
            return this;
        },
        area: function() {
            var v0 = new Vector3();
            var v1 = new Vector3();
            return function area() {
                v0.subVectors(this.c, this.b);
                v1.subVectors(this.a, this.b);
                return v0.cross(v1).length() * 0.5;
            };
        }(),
        midpoint: function(optionalTarget) {
            var result = optionalTarget || new Vector3();
            return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        },
        normal: function(optionalTarget) {
            return Triangle.normal(this.a, this.b, this.c, optionalTarget);
        },
        plane: function(optionalTarget) {
            var result = optionalTarget || new Plane();
            return result.setFromCoplanarPoints(this.a, this.b, this.c);
        },
        barycoordFromPoint: function(point, optionalTarget) {
            return Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
        },
        containsPoint: function(point) {
            return Triangle.containsPoint(point, this.a, this.b, this.c);
        },
        closestPointToPoint: function() {
            var plane = new Plane();
            var edgeList = [new Line3(), new Line3(), new Line3()];
            var projectedPoint = new Vector3();
            var closestPoint = new Vector3();
            return function closestPointToPoint(point, optionalTarget) {
                var result = optionalTarget || new Vector3();
                var minDistance = Infinity;
                plane.setFromCoplanarPoints(this.a, this.b, this.c);
                plane.projectPoint(point, projectedPoint);
                if (this.containsPoint(projectedPoint) === true) {
                    result.copy(projectedPoint);
                } else {
                    edgeList[0].set(this.a, this.b);
                    edgeList[1].set(this.b, this.c);
                    edgeList[2].set(this.c, this.a);
                    for (var i = 0; i < edgeList.length; i++) {
                        edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
                        var distance = projectedPoint.distanceToSquared(closestPoint);
                        if (distance < minDistance) {
                            minDistance = distance;
                            result.copy(closestPoint);
                        }
                    }
                }
                return result;
            };
        }(),
        equals: function(triangle) {
            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
    });

    function Mesh(geometry, material) {
        Object3D.call(this);
        this.type = 'Mesh';
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new MeshBasicMaterial({
            color: Math.random() * 0xffffff
        });
        this.drawMode = TrianglesDrawMode;
        this.updateMorphTargets();
    }
    Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Mesh,
        isMesh: true,
        setDrawMode: function(value) {
            this.drawMode = value;
        },
        copy: function(source) {
            Object3D.prototype.copy.call(this, source);
            this.drawMode = source.drawMode;
            if (source.morphTargetInfluences !== undefined) {
                this.morphTargetInfluences = source.morphTargetInfluences.slice();
            }
            if (source.morphTargetDictionary !== undefined) {
                this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
            }
            return this;
        },
        updateMorphTargets: function() {
            var geometry = this.geometry;
            var m, ml, name;
            if (geometry.isBufferGeometry) {
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys(morphAttributes);
                if (keys.length > 0) {
                    var morphAttribute = morphAttributes[keys[0]];
                    if (morphAttribute !== undefined) {
                        this.morphTargetInfluences = [];
                        this.morphTargetDictionary = {};
                        for (m = 0, ml = morphAttribute.length; m < ml; m++) {
                            name = morphAttribute[m].name || String(m);
                            this.morphTargetInfluences.push(0);
                            this.morphTargetDictionary[name] = m;
                        }
                    }
                }
            } else {
                var morphTargets = geometry.morphTargets;
                if (morphTargets !== undefined && morphTargets.length > 0) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for (m = 0, ml = morphTargets.length; m < ml; m++) {
                        name = morphTargets[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        },
        raycast: (function() {
            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();
            var vA = new Vector3();
            var vB = new Vector3();
            var vC = new Vector3();
            var tempA = new Vector3();
            var tempB = new Vector3();
            var tempC = new Vector3();
            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();
            var barycoord = new Vector3();
            var intersectionPoint = new Vector3();
            var intersectionPointWorld = new Vector3();

            function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);
                uv1.multiplyScalar(barycoord.x);
                uv2.multiplyScalar(barycoord.y);
                uv3.multiplyScalar(barycoord.z);
                uv1.add(uv2).add(uv3);
                return uv1.clone();
            }

            function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
                var intersect;
                if (material.side === BackSide) {
                    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
                } else {
                    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
                }
                if (intersect === null) return null;
                intersectionPointWorld.copy(point);
                intersectionPointWorld.applyMatrix4(object.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                if (distance < raycaster.near || distance > raycaster.far) return null;
                return {
                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    object: object
                };
            }

            function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
                vA.fromBufferAttribute(position, a);
                vB.fromBufferAttribute(position, b);
                vC.fromBufferAttribute(position, c);
                var intersection = checkIntersection(object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint);
                if (intersection) {
                    if (uv) {
                        uvA.fromBufferAttribute(uv, a);
                        uvB.fromBufferAttribute(uv, b);
                        uvC.fromBufferAttribute(uv, c);
                        intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
                    }
                    intersection.face = new Face3(a, b, c, Triangle.normal(vA, vB, vC));
                    intersection.faceIndex = a;
                }
                return intersection;
            }
            return function raycast(raycaster, intersects) {
                var geometry = this.geometry;
                var material = this.material;
                var matrixWorld = this.matrixWorld;
                if (material === undefined) return;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                if (raycaster.ray.intersectsSphere(sphere) === false) return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                if (geometry.boundingBox !== null) {
                    if (ray.intersectsBox(geometry.boundingBox) === false) return;
                }
                var intersection;
                if (geometry.isBufferGeometry) {
                    var a, b, c;
                    var index = geometry.index;
                    var position = geometry.attributes.position;
                    var uv = geometry.attributes.uv;
                    var i, l;
                    if (index !== null) {
                        for (i = 0, l = index.count; i < l; i += 3) {
                            a = index.getX(i);
                            b = index.getX(i + 1);
                            c = index.getX(i + 2);
                            intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(i / 3);
                                intersects.push(intersection);
                            }
                        }
                    } else if (position !== undefined) {
                        for (i = 0, l = position.count; i < l; i += 3) {
                            a = i;
                            b = i + 1;
                            c = i + 2;
                            intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
                            if (intersection) {
                                intersection.index = a;
                                intersects.push(intersection);
                            }
                        }
                    }
                } else if (geometry.isGeometry) {
                    var fvA, fvB, fvC;
                    var isMultiMaterial = Array.isArray(material);
                    var vertices = geometry.vertices;
                    var faces = geometry.faces;
                    var uvs;
                    var faceVertexUvs = geometry.faceVertexUvs[0];
                    if (faceVertexUvs.length > 0) uvs = faceVertexUvs;
                    for (var f = 0, fl = faces.length; f < fl; f++) {
                        var face = faces[f];
                        var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                        if (faceMaterial === undefined) continue;
                        fvA = vertices[face.a];
                        fvB = vertices[face.b];
                        fvC = vertices[face.c];
                        if (faceMaterial.morphTargets === true) {
                            var morphTargets = geometry.morphTargets;
                            var morphInfluences = this.morphTargetInfluences;
                            vA.set(0, 0, 0);
                            vB.set(0, 0, 0);
                            vC.set(0, 0, 0);
                            for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                                var influence = morphInfluences[t];
                                if (influence === 0) continue;
                                var targets = morphTargets[t].vertices;
                                vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                                vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                                vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                            }
                            vA.add(fvA);
                            vB.add(fvB);
                            vC.add(fvC);
                            fvA = vA;
                            fvB = vB;
                            fvC = vC;
                        }
                        intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
                        if (intersection) {
                            if (uvs && uvs[f]) {
                                var uvs_f = uvs[f];
                                uvA.copy(uvs_f[0]);
                                uvB.copy(uvs_f[1]);
                                uvC.copy(uvs_f[2]);
                                intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                            }
                            intersection.face = face;
                            intersection.faceIndex = f;
                            intersects.push(intersection);
                        }
                    }
                }
            };
        }()),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });

    function WebGLBackground(renderer, state, geometries, premultipliedAlpha) {
        var clearColor = new Color(0x000000);
        var clearAlpha = 0;
        var planeCamera, planeMesh;
        var boxMesh;

        function render(renderList, scene, camera, forceClear) {
            var background = scene.background;
            if (background === null) {
                setClear(clearColor, clearAlpha);
            } else if (background && background.isColor) {
                setClear(background, 1);
                forceClear = true;
            }
            if (renderer.autoClear || forceClear) {
                renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
            }
            if (background && background.isCubeTexture) {
                if (boxMesh === undefined) {
                    boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                        uniforms: ShaderLib.cube.uniforms,
                        vertexShader: ShaderLib.cube.vertexShader,
                        fragmentShader: ShaderLib.cube.fragmentShader,
                        side: BackSide,
                        depthTest: true,
                        depthWrite: false,
                        fog: false
                    }));
                    boxMesh.geometry.removeAttribute('normal');
                    boxMesh.geometry.removeAttribute('uv');
                    boxMesh.onBeforeRender = function(renderer, scene, camera) {
                        this.matrixWorld.copyPosition(camera.matrixWorld);
                    };
                    geometries.update(boxMesh.geometry);
                }
                boxMesh.material.uniforms.tCube.value = background;
                renderList.push(boxMesh, boxMesh.geometry, boxMesh.material, 0, null);
            } else if (background && background.isTexture) {
                if (planeCamera === undefined) {
                    planeCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                    planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    }));
                    geometries.update(planeMesh.geometry);
                }
                planeMesh.material.map = background;
                renderer.renderBufferDirect(planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null);
            }
        }

        function setClear(color, alpha) {
            state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
        }
        return {
            getClearColor: function() {
                return clearColor;
            },
            setClearColor: function(color, alpha) {
                clearColor.set(color);
                clearAlpha = alpha !== undefined ? alpha : 1;
                setClear(clearColor, clearAlpha);
            },
            getClearAlpha: function() {
                return clearAlpha;
            },
            setClearAlpha: function(alpha) {
                clearAlpha = alpha;
                setClear(clearColor, clearAlpha);
            },
            render: render
        };
    }

    function painterSortStable(a, b) {
        if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        } else if (a.program && b.program && a.program !== b.program) {
            return a.program.id - b.program.id;
        } else if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
            return a.z - b.z;
        } else {
            return a.id - b.id;
        }
    }

    function reversePainterSortStable(a, b) {
        if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        }
        if (a.z !== b.z) {
            return b.z - a.z;
        } else {
            return a.id - b.id;
        }
    }

    function WebGLRenderList() {
        var renderItems = [];
        var renderItemsIndex = 0;
        var opaque = [];
        var transparent = [];

        function init() {
            renderItemsIndex = 0;
            opaque.length = 0;
            transparent.length = 0;
        }

        function push(object, geometry, material, z, group) {
            var renderItem = renderItems[renderItemsIndex];
            if (renderItem === undefined) {
                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    program: material.program,
                    renderOrder: object.renderOrder,
                    z: z,
                    group: group
                };
                renderItems[renderItemsIndex] = renderItem;
            } else {
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.program = material.program;
                renderItem.renderOrder = object.renderOrder;
                renderItem.z = z;
                renderItem.group = group;
            }
            (material.transparent === true ? transparent : opaque).push(renderItem);
            renderItemsIndex++;
        }

        function sort() {
            if (opaque.length > 1) opaque.sort(painterSortStable);
            if (transparent.length > 1) transparent.sort(reversePainterSortStable);
        }
        return {
            opaque: opaque,
            transparent: transparent,
            init: init,
            push: push,
            sort: sort
        };
    }

    function WebGLRenderLists() {
        var lists = {};

        function get(scene, camera) {
            var hash = scene.id + ',' + camera.id;
            var list = lists[hash];
            if (list === undefined) {
                list = new WebGLRenderList();
                lists[hash] = list;
            }
            return list;
        }

        function dispose() {
            lists = {};
        }
        return {
            get: get,
            dispose: dispose
        };
    }

    function absNumericalSort(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
    }

    function WebGLMorphtargets(gl) {
        var influencesList = {};
        var morphInfluences = new Float32Array(8);

        function update(object, geometry, material, program) {
            var objectInfluences = object.morphTargetInfluences;
            var length = objectInfluences.length;
            var influences = influencesList[geometry.id];
            if (influences === undefined) {
                influences = [];
                for (var i = 0; i < length; i++) {
                    influences[i] = [i, 0];
                }
                influencesList[geometry.id] = influences;
            }
            var morphTargets = material.morphTargets && geometry.morphAttributes.position;
            var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
            for (var i = 0; i < length; i++) {
                var influence = influences[i];
                if (influence[1] !== 0) {
                    if (morphTargets) geometry.removeAttribute('morphTarget' + i);
                    if (morphNormals) geometry.removeAttribute('morphNormal' + i);
                }
            }
            for (var i = 0; i < length; i++) {
                var influence = influences[i];
                influence[0] = i;
                influence[1] = objectInfluences[i];
            }
            influences.sort(absNumericalSort);
            for (var i = 0; i < 8; i++) {
                var influence = influences[i];
                if (influence) {
                    var index = influence[0];
                    var value = influence[1];
                    if (value) {
                        if (morphTargets) geometry.addAttribute('morphTarget' + i, morphTargets[index]);
                        if (morphNormals) geometry.addAttribute('morphNormal' + i, morphNormals[index]);
                        morphInfluences[i] = value;
                        continue;
                    }
                }
                morphInfluences[i] = 0;
            }
            program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
        }
        return {
            update: update
        };
    }

    function WebGLIndexedBufferRenderer(gl, extensions, infoRender) {
        var mode;

        function setMode(value) {
            mode = value;
        }
        var type, bytesPerElement;

        function setIndex(value) {
            type = value.type;
            bytesPerElement = value.bytesPerElement;
        }

        function render(start, count) {
            gl.drawElements(mode, count, type, start * bytesPerElement);
            infoRender.calls++;
            infoRender.vertices += count;
            if (mode === gl.TRIANGLES) infoRender.faces += count / 3;
            else if (mode === gl.POINTS) infoRender.points += count;
        }

        function renderInstances(geometry, start, count) {
            var extension = extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
            extension.drawElementsInstancedANGLE(mode, count, type, start * bytesPerElement, geometry.maxInstancedCount);
            infoRender.calls++;
            infoRender.vertices += count * geometry.maxInstancedCount;
            if (mode === gl.TRIANGLES) infoRender.faces += geometry.maxInstancedCount * count / 3;
            else if (mode === gl.POINTS) infoRender.points += geometry.maxInstancedCount * count;
        }
        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render;
        this.renderInstances = renderInstances;
    }

    function WebGLBufferRenderer(gl, extensions, infoRender) {
        var mode;

        function setMode(value) {
            mode = value;
        }

        function render(start, count) {
            gl.drawArrays(mode, start, count);
            infoRender.calls++;
            infoRender.vertices += count;
            if (mode === gl.TRIANGLES) infoRender.faces += count / 3;
            else if (mode === gl.POINTS) infoRender.points += count;
        }

        function renderInstances(geometry, start, count) {
            var extension = extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
            var position = geometry.attributes.position;
            if (position.isInterleavedBufferAttribute) {
                count = position.data.count;
                extension.drawArraysInstancedANGLE(mode, 0, count, geometry.maxInstancedCount);
            } else {
                extension.drawArraysInstancedANGLE(mode, start, count, geometry.maxInstancedCount);
            }
            infoRender.calls++;
            infoRender.vertices += count * geometry.maxInstancedCount;
            if (mode === gl.TRIANGLES) infoRender.faces += geometry.maxInstancedCount * count / 3;
            else if (mode === gl.POINTS) infoRender.points += geometry.maxInstancedCount * count;
        }
        this.setMode = setMode;
        this.render = render;
        this.renderInstances = renderInstances;
    }

    function WebGLGeometries(gl, attributes, infoMemory) {
        var geometries = {};
        var wireframeAttributes = {};

        function onGeometryDispose(event) {
            var geometry = event.target;
            var buffergeometry = geometries[geometry.id];
            if (buffergeometry.index !== null) {
                attributes.remove(buffergeometry.index);
            }
            for (var name in buffergeometry.attributes) {
                attributes.remove(buffergeometry.attributes[name]);
            }
            geometry.removeEventListener('dispose', onGeometryDispose);
            delete geometries[geometry.id];
            var attribute = wireframeAttributes[geometry.id];
            if (attribute) {
                attributes.remove(attribute);
                delete wireframeAttributes[geometry.id];
            }
            attribute = wireframeAttributes[buffergeometry.id];
            if (attribute) {
                attributes.remove(attribute);
                delete wireframeAttributes[buffergeometry.id];
            }
            infoMemory.geometries--;
        }

        function get(object, geometry) {
            var buffergeometry = geometries[geometry.id];
            if (buffergeometry) return buffergeometry;
            geometry.addEventListener('dispose', onGeometryDispose);
            if (geometry.isBufferGeometry) {
                buffergeometry = geometry;
            } else if (geometry.isGeometry) {
                if (geometry._bufferGeometry === undefined) {
                    geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
                }
                buffergeometry = geometry._bufferGeometry;
            }
            geometries[geometry.id] = buffergeometry;
            infoMemory.geometries++;
            return buffergeometry;
        }

        function update(geometry) {
            var index = geometry.index;
            var geometryAttributes = geometry.attributes;
            if (index !== null) {
                attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
            }
            for (var name in geometryAttributes) {
                attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
            }
            var morphAttributes = geometry.morphAttributes;
            for (var name in morphAttributes) {
                var array = morphAttributes[name];
                for (var i = 0, l = array.length; i < l; i++) {
                    attributes.update(array[i], gl.ARRAY_BUFFER);
                }
            }
        }

        function getWireframeAttribute(geometry) {
            var attribute = wireframeAttributes[geometry.id];
            if (attribute) return attribute;
            var indices = [];
            var geometryIndex = geometry.index;
            var geometryAttributes = geometry.attributes;
            if (geometryIndex !== null) {
                var array = geometryIndex.array;
                for (var i = 0, l = array.length; i < l; i += 3) {
                    var a = array[i + 0];
                    var b = array[i + 1];
                    var c = array[i + 2];
                    indices.push(a, b, b, c, c, a);
                }
            } else {
                var array = geometryAttributes.position.array;
                for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {
                    var a = i + 0;
                    var b = i + 1;
                    var c = i + 2;
                    indices.push(a, b, b, c, c, a);
                }
            }
            attribute = new(arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
            attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER);
            wireframeAttributes[geometry.id] = attribute;
            return attribute;
        }
        return {
            get: get,
            update: update,
            getWireframeAttribute: getWireframeAttribute
        };
    }

    function UniformsCache() {
        var lights = {};
        return {
            get: function(light) {
                if (lights[light.id] !== undefined) {
                    return lights[light.id];
                }
                var uniforms;
                switch (light.type) {
                    case 'DirectionalLight':
                        uniforms = {
                            direction: new Vector3(),
                            color: new Color(),
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;
                    case 'SpotLight':
                        uniforms = {
                            position: new Vector3(),
                            direction: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;
                    case 'PointLight':
                        uniforms = {
                            position: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            decay: 0,
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2(),
                            shadowCameraNear: 1,
                            shadowCameraFar: 1000
                        };
                        break;
                    case 'HemisphereLight':
                        uniforms = {
                            direction: new Vector3(),
                            skyColor: new Color(),
                            groundColor: new Color()
                        };
                        break;
                    case 'RectAreaLight':
                        uniforms = {
                            color: new Color(),
                            position: new Vector3(),
                            halfWidth: new Vector3(),
                            halfHeight: new Vector3()
                        };
                        break;
                }
                lights[light.id] = uniforms;
                return uniforms;
            }
        };
    }

    function WebGLLights() {
        var cache = new UniformsCache();
        var state = {
            hash: '',
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        };
        var vector3 = new Vector3();
        var matrix4 = new Matrix4();
        var matrix42 = new Matrix4();

        function setup(lights, shadows, camera) {
            var r = 0,
                g = 0,
                b = 0;
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
            var viewMatrix = camera.matrixWorldInverse;
            for (var i = 0, l = lights.length; i < l; i++) {
                var light = lights[i];
                var color = light.color;
                var intensity = light.intensity;
                var distance = light.distance;
                var shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;
                if (light.isAmbientLight) {
                    r += color.r * intensity;
                    g += color.g * intensity;
                    b += color.b * intensity;
                } else if (light.isDirectionalLight) {
                    var uniforms = cache.get(light);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    state.directional[directionalLength] = uniforms;
                    directionalLength++;
                } else if (light.isSpotLight) {
                    var uniforms = cache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.distance = distance;
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.coneCos = Math.cos(light.angle);
                    uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                    uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }
                    state.spotShadowMap[spotLength] = shadowMap;
                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    state.spot[spotLength] = uniforms;
                    spotLength++;
                } else if (light.isRectAreaLight) {
                    var uniforms = cache.get(light);
                    uniforms.color.copy(color).multiplyScalar(intensity / (light.width * light.height));
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    matrix42.identity();
                    matrix4.copy(light.matrixWorld);
                    matrix4.premultiply(viewMatrix);
                    matrix42.extractRotation(matrix4);
                    uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                    uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                    uniforms.halfWidth.applyMatrix4(matrix42);
                    uniforms.halfHeight.applyMatrix4(matrix42);
                    state.rectArea[rectAreaLength] = uniforms;
                    rectAreaLength++;
                } else if (light.isPointLight) {
                    var uniforms = cache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.distance = light.distance;
                    uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                        uniforms.shadowCameraNear = shadow.camera.near;
                        uniforms.shadowCameraFar = shadow.camera.far;
                    }
                    state.pointShadowMap[pointLength] = shadowMap;
                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    state.point[pointLength] = uniforms;
                    pointLength++;
                } else if (light.isHemisphereLight) {
                    var uniforms = cache.get(light);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.direction.normalize();
                    uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                    state.hemi[hemiLength] = uniforms;
                    hemiLength++;
                }
            }
            state.ambient[0] = r;
            state.ambient[1] = g;
            state.ambient[2] = b;
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;
        }
        return {
            setup: setup,
            state: state
        };
    }

    function WebGLObjects(geometries, infoRender) {
        var updateList = {};

        function update(object) {
            var frame = infoRender.frame;
            var geometry = object.geometry;
            var buffergeometry = geometries.get(object, geometry);
            if (updateList[buffergeometry.id] !== frame) {
                if (geometry.isGeometry) {
                    buffergeometry.updateFromObject(object);
                }
                geometries.update(buffergeometry);
                updateList[buffergeometry.id] = frame;
            }
            return buffergeometry;
        }

        function clear() {
            updateList = {};
        }
        return {
            update: update,
            clear: clear
        };
    }

    function addLineNumbers(string) {
        var lines = string.split('\n');
        for (var i = 0; i < lines.length; i++) {
            lines[i] = (i + 1) + ': ' + lines[i];
        }
        return lines.join('\n');
    }

    function WebGLShader(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
            console.error('THREE.WebGLShader: Shader couldn\'t compile.');
        }
        if (gl.getShaderInfoLog(shader) !== '') {
            console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
        }
        return shader;
    }
    var programIdCount = 0;

    function getEncodingComponents(encoding) {
        switch (encoding) {
            case LinearEncoding:
                return ['Linear', '( value )'];
            case sRGBEncoding:
                return ['sRGB', '( value )'];
            case RGBEEncoding:
                return ['RGBE', '( value )'];
            case RGBM7Encoding:
                return ['RGBM', '( value, 7.0 )'];
            case RGBM16Encoding:
                return ['RGBM', '( value, 16.0 )'];
            case RGBDEncoding:
                return ['RGBD', '( value, 256.0 )'];
            case GammaEncoding:
                return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
            default:
                throw new Error('unsupported encoding: ' + encoding);
        }
    }

    function getTexelDecodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
    }

    function getTexelEncodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
    }

    function getToneMappingFunction(functionName, toneMapping) {
        var toneMappingName;
        switch (toneMapping) {
            case LinearToneMapping:
                toneMappingName = 'Linear';
                break;
            case ReinhardToneMapping:
                toneMappingName = 'Reinhard';
                break;
            case Uncharted2ToneMapping:
                toneMappingName = 'Uncharted2';
                break;
            case CineonToneMapping:
                toneMappingName = 'OptimizedCineon';
                break;
            default:
                throw new Error('unsupported toneMapping: ' + toneMapping);
        }
        return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
    }

    function generateExtensions(extensions, parameters, rendererExtensions) {
        extensions = extensions || {};
        var chunks = [(extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '', (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', (extensions.drawBuffers) && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '', (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
        return chunks.filter(filterEmptyLine).join('\n');
    }

    function generateDefines(defines) {
        var chunks = [];
        for (var name in defines) {
            var value = defines[name];
            if (value === false) continue;
            chunks.push('#define ' + name + ' ' + value);
        }
        return chunks.join('\n');
    }

    function fetchAttributeLocations(gl, program) {
        var attributes = {};
        var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < n; i++) {
            var info = gl.getActiveAttrib(program, i);
            var name = info.name;
            attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
    }

    function filterEmptyLine(string) {
        return string !== '';
    }

    function replaceLightNums(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
    }

    function parseIncludes(string) {
        var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

        function replace(match, include) {
            var replace = ShaderChunk[include];
            if (replace === undefined) {
                throw new Error('Can not resolve #include <' + include + '>');
            }
            return parseIncludes(replace);
        }
        return string.replace(pattern, replace);
    }

    function unrollLoops(string) {
        var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

        function replace(match, start, end, snippet) {
            var unroll = '';
            for (var i = parseInt(start); i < parseInt(end); i++) {
                unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
            }
            return unroll;
        }
        return string.replace(pattern, replace);
    }

    function WebGLProgram(renderer, extensions, code, material, shader, parameters) {
        var gl = renderer.context;
        var defines = material.defines;
        var vertexShader = shader.vertexShader;
        var fragmentShader = shader.fragmentShader;
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
        if (parameters.shadowMapType === PCFShadowMap) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        } else if (parameters.shadowMapType === PCFSoftShadowMap) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        }
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        if (parameters.envMap) {
            switch (material.envMap.mapping) {
                case CubeReflectionMapping:
                case CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;
                case CubeUVReflectionMapping:
                case CubeUVRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                    break;
                case EquirectangularReflectionMapping:
                case EquirectangularRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;
                case SphericalReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;
            }
            switch (material.envMap.mapping) {
                case CubeRefractionMapping:
                case EquirectangularRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;
            }
            switch (material.combine) {
                case MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;
                case MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;
                case AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;
            }
        }
        var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
        var customExtensions = generateExtensions(material.extensions, parameters, extensions);
        var customDefines = generateDefines(defines);
        var program = gl.createProgram();
        var prefixVertex, prefixFragment;
        if (material.isRawShaderMaterial) {
            prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');
            if (prefixVertex.length > 0) {
                prefixVertex += '\n';
            }
            prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');
            if (prefixFragment.length > 0) {
                prefixFragment += '\n';
            }
        } else {
            prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + shader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '', (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes, parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
            prefixFragment = [customExtensions, 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + shader.name, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '', (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes, '#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection), parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', parameters.envMap && extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', (parameters.toneMapping !== NoToneMapping) ? '#define TONE_MAPPING' : '', (parameters.toneMapping !== NoToneMapping) ? ShaderChunk['tonemapping_pars_fragment'] : '', (parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', (parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding) ? ShaderChunk['encodings_pars_fragment'] : '', parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '', parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
        }
        vertexShader = parseIncludes(vertexShader);
        vertexShader = replaceLightNums(vertexShader, parameters);
        fragmentShader = parseIncludes(fragmentShader);
        fragmentShader = replaceLightNums(fragmentShader, parameters);
        if (!material.isShaderMaterial) {
            vertexShader = unrollLoops(vertexShader);
            fragmentShader = unrollLoops(fragmentShader);
        }
        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;
        var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
        var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);
        if (material.index0AttributeName !== undefined) {
            gl.bindAttribLocation(program, 0, material.index0AttributeName);
        } else if (parameters.morphTargets === true) {
            gl.bindAttribLocation(program, 0, 'position');
        }
        gl.linkProgram(program);
        var programLog = gl.getProgramInfoLog(program);
        var vertexLog = gl.getShaderInfoLog(glVertexShader);
        var fragmentLog = gl.getShaderInfoLog(glFragmentShader);
        var runnable = true;
        var haveDiagnostics = true;
        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
            runnable = false;
            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
        } else if (programLog !== '') {
            console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        } else if (vertexLog === '' || fragmentLog === '') {
            haveDiagnostics = false;
        }
        if (haveDiagnostics) {
            this.diagnostics = {
                runnable: runnable,
                material: material,
                programLog: programLog,
                vertexShader: {
                    log: vertexLog,
                    prefix: prefixVertex
                },
                fragmentShader: {
                    log: fragmentLog,
                    prefix: prefixFragment
                }
            };
        }
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);
        var cachedUniforms;
        this.getUniforms = function() {
            if (cachedUniforms === undefined) {
                cachedUniforms = new WebGLUniforms(gl, program, renderer);
            }
            return cachedUniforms;
        };
        var cachedAttributes;
        this.getAttributes = function() {
            if (cachedAttributes === undefined) {
                cachedAttributes = fetchAttributeLocations(gl, program);
            }
            return cachedAttributes;
        };
        this.destroy = function() {
            gl.deleteProgram(program);
            this.program = undefined;
        };
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
                    return this.getUniforms();
                }
            },
            attributes: {
                get: function() {
                    console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
                    return this.getAttributes();
                }
            }
        });
        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
    }

    function WebGLPrograms(renderer, extensions, capabilities) {
        var programs = [];
        var shaderIDs = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'phong',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow'
        };
        var parameterNames = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

        function allocateBones(object) {
            var skeleton = object.skeleton;
            var bones = skeleton.bones;
            if (capabilities.floatVertexTextures) {
                return 1024;
            } else {
                var nVertexUniforms = capabilities.maxVertexUniforms;
                var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                var maxBones = Math.min(nVertexMatrices, bones.length);
                if (maxBones < bones.length) {
                    console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                    return 0;
                }
                return maxBones;
            }
        }

        function getTextureEncodingFromMap(map, gammaOverrideLinear) {
            var encoding;
            if (!map) {
                encoding = LinearEncoding;
            } else if (map.isTexture) {
                encoding = map.encoding;
            } else if (map.isWebGLRenderTarget) {
                console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                encoding = map.texture.encoding;
            }
            if (encoding === LinearEncoding && gammaOverrideLinear) {
                encoding = GammaEncoding;
            }
            return encoding;
        }
        this.getParameters = function(material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
            var shaderID = shaderIDs[material.type];
            var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
            var precision = capabilities.precision;
            if (material.precision !== null) {
                precision = capabilities.getMaxPrecision(material.precision);
                if (precision !== material.precision) {
                    console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
                }
            }
            var currentRenderTarget = renderer.getRenderTarget();
            var parameters = {
                shaderID: shaderID,
                precision: precision,
                supportsVertexTextures: capabilities.vertexTextures,
                outputEncoding: getTextureEncodingFromMap((!currentRenderTarget) ? null : currentRenderTarget.texture, renderer.gammaOutput),
                map: !!material.map,
                mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                envMap: !!material.envMap,
                envMapMode: material.envMap && material.envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                envMapCubeUV: (!!material.envMap) && ((material.envMap.mapping === CubeUVReflectionMapping) || (material.envMap.mapping === CubeUVRefractionMapping)),
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                gradientMap: !!material.gradientMap,
                combine: material.combine,
                vertexColors: material.vertexColors,
                fog: !!fog,
                useFog: material.fog,
                fogExp: (fog && fog.isFogExp2),
                flatShading: material.flatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
                skinning: material.skinning && maxBones > 0,
                maxBones: maxBones,
                useVertexTexture: capabilities.floatVertexTextures,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,
                dithering: material.dithering,
                shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: renderer.toneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false
            };
            return parameters;
        };
        this.getProgramCode = function(material, parameters) {
            var array = [];
            if (parameters.shaderID) {
                array.push(parameters.shaderID);
            } else {
                array.push(material.fragmentShader);
                array.push(material.vertexShader);
            }
            if (material.defines !== undefined) {
                for (var name in material.defines) {
                    array.push(name);
                    array.push(material.defines[name]);
                }
            }
            for (var i = 0; i < parameterNames.length; i++) {
                array.push(parameters[parameterNames[i]]);
            }
            array.push(material.onBeforeCompile.toString());
            array.push(renderer.gammaOutput);
            return array.join();
        };
        this.acquireProgram = function(material, shader, parameters, code) {
            var program;
            for (var p = 0, pl = programs.length; p < pl; p++) {
                var programInfo = programs[p];
                if (programInfo.code === code) {
                    program = programInfo;
                    ++program.usedTimes;
                    break;
                }
            }
            if (program === undefined) {
                program = new WebGLProgram(renderer, extensions, code, material, shader, parameters);
                programs.push(program);
            }
            return program;
        };
        this.releaseProgram = function(program) {
            if (--program.usedTimes === 0) {
                var i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1];
                programs.pop();
                program.destroy();
            }
        };
        this.programs = programs;
    }

    function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, infoMemory) {
        var _isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof window.WebGL2RenderingContext);
        var _videoTextures = {};

        function clampToMaxSize(image, maxSize) {
            if (image.width > maxSize || image.height > maxSize) {
                var scale = maxSize / Math.max(image.width, image.height);
                var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = Math.floor(image.width * scale);
                canvas.height = Math.floor(image.height * scale);
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
                return canvas;
            }
            return image;
        }

        function isPowerOfTwo(image) {
            return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
        }

        function makePowerOfTwo(image) {
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap) {
                var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = _Math.floorPowerOfTwo(image.width);
                canvas.height = _Math.floorPowerOfTwo(image.height);
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, canvas.width, canvas.height);
                console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
                return canvas;
            }
            return image;
        }

        function textureNeedsPowerOfTwo(texture) {
            return (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) || (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter);
        }

        function textureNeedsGenerateMipmaps(texture, isPowerOfTwo) {
            return texture.generateMipmaps && isPowerOfTwo && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }

        function filterFallback(f) {
            if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
                return _gl.NEAREST;
            }
            return _gl.LINEAR;
        }

        function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener('dispose', onTextureDispose);
            deallocateTexture(texture);
            if (texture.isVideoTexture) {
                delete _videoTextures[texture.id];
            }
            infoMemory.textures--;
        }

        function onRenderTargetDispose(event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener('dispose', onRenderTargetDispose);
            deallocateRenderTarget(renderTarget);
            infoMemory.textures--;
        }

        function deallocateTexture(texture) {
            var textureProperties = properties.get(texture);
            if (texture.image && textureProperties.__image__webglTextureCube) {
                _gl.deleteTexture(textureProperties.__image__webglTextureCube);
            } else {
                if (textureProperties.__webglInit === undefined) return;
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            properties.remove(texture);
        }

        function deallocateRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            if (!renderTarget) return;
            if (textureProperties.__webglTexture !== undefined) {
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            if (renderTarget.depthTexture) {
                renderTarget.depthTexture.dispose();
            }
            if (renderTarget.isWebGLRenderTargetCube) {
                for (var i = 0; i < 6; i++) {
                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                    if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                }
            } else {
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            }
            properties.remove(renderTarget.texture);
            properties.remove(renderTarget);
        }

        function setTexture2D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (image === undefined) {
                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
                } else if (image.complete === false) {
                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
                } else {
                    uploadTexture(textureProperties, texture, slot);
                    return;
                }
            }
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }

        function setTextureCube(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.image.length === 6) {
                if (texture.version > 0 && textureProperties.__version !== texture.version) {
                    if (!textureProperties.__image__webglTextureCube) {
                        texture.addEventListener('dispose', onTextureDispose);
                        textureProperties.__image__webglTextureCube = _gl.createTexture();
                        infoMemory.textures++;
                    }
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                    var isCompressed = (texture && texture.isCompressedTexture);
                    var isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);
                    var cubeImage = [];
                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed && !isDataTexture) {
                            cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                        } else {
                            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                        }
                    }
                    var image = cubeImage[0],
                        isPowerOfTwoImage = isPowerOfTwo(image),
                        glFormat = utils.convert(texture.format),
                        glType = utils.convert(texture.type);
                    setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed) {
                            if (isDataTexture) {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                            } else {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                            }
                        } else {
                            var mipmap, mipmaps = cubeImage[i].mipmaps;
                            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                                mipmap = mipmaps[j];
                                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                        state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                    } else {
                                        console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                                    }
                                } else {
                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                }
                            }
                        }
                    }
                    if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
                        _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                    }
                    textureProperties.__version = texture.version;
                    if (texture.onUpdate) texture.onUpdate(texture);
                } else {
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                }
            }
        }

        function setTextureCubeDynamic(texture, slot) {
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
        }

        function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
            var extension;
            if (isPowerOfTwoImage) {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, utils.convert(texture.wrapS));
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, utils.convert(texture.wrapT));
                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, utils.convert(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, utils.convert(texture.minFilter));
            } else {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
                if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
                }
                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
                if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
                }
            }
            extension = extensions.get('EXT_texture_filter_anisotropic');
            if (extension) {
                if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
                if (texture.type === HalfFloatType && extensions.get('OES_texture_half_float_linear') === null) return;
                if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                    _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                    properties.get(texture).__currentAnisotropy = texture.anisotropy;
                }
            }
        }

        function uploadTexture(textureProperties, texture, slot) {
            if (textureProperties.__webglInit === undefined) {
                textureProperties.__webglInit = true;
                texture.addEventListener('dispose', onTextureDispose);
                textureProperties.__webglTexture = _gl.createTexture();
                if (texture.isVideoTexture) {
                    _videoTextures[texture.id] = texture;
                }
                infoMemory.textures++;
            }
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
            if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
                image = makePowerOfTwo(image);
            }
            var isPowerOfTwoImage = isPowerOfTwo(image),
                glFormat = utils.convert(texture.format),
                glType = utils.convert(texture.type);
            setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
            var mipmap, mipmaps = texture.mipmaps;
            if (texture.isDepthTexture) {
                var internalFormat = _gl.DEPTH_COMPONENT;
                if (texture.type === FloatType) {
                    if (!_isWebGL2) throw new Error('Float Depth Texture only supported in WebGL2.0');
                    internalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (_isWebGL2) {
                    internalFormat = _gl.DEPTH_COMPONENT16;
                }
                if (texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT) {
                    if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                        console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                        texture.type = UnsignedShortType;
                        glType = utils.convert(texture.type);
                    }
                }
                if (texture.format === DepthStencilFormat) {
                    internalFormat = _gl.DEPTH_STENCIL;
                    if (texture.type !== UnsignedInt248Type) {
                        console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                        texture.type = UnsignedInt248Type;
                        glType = utils.convert(texture.type);
                    }
                }
                state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
            } else if (texture.isDataTexture) {
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                    texture.generateMipmaps = false;
                } else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
                }
            } else if (texture.isCompressedTexture) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                        if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                            state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        } else {
                            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                        }
                    } else {
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
            } else {
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                    }
                    texture.generateMipmaps = false;
                } else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
                }
            }
            if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) _gl.generateMipmap(_gl.TEXTURE_2D);
            textureProperties.__version = texture.version;
            if (texture.onUpdate) texture.onUpdate(texture);
        }

        function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
            var glFormat = utils.convert(renderTarget.texture.format);
            var glType = utils.convert(renderTarget.texture.type);
            state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }

        function setupRenderBufferStorage(renderbuffer, renderTarget) {
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
            } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
            } else {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
            }
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }

        function setupDepthTexture(framebuffer, renderTarget) {
            var isCube = (renderTarget && renderTarget.isWebGLRenderTargetCube);
            if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
                throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
            }
            if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
            }
            setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
            if (renderTarget.depthTexture.format === DepthFormat) {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            } else {
                throw new Error('Unknown depthTexture format');
            }
        }

        function setupDepthRenderbuffer(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var isCube = (renderTarget.isWebGLRenderTargetCube === true);
            if (renderTarget.depthTexture) {
                if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            } else {
                if (isCube) {
                    renderTargetProperties.__webglDepthbuffer = [];
                    for (var i = 0; i < 6; i++) {
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                        renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                    }
                } else {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                    renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
                }
            }
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }

        function setupRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            renderTarget.addEventListener('dispose', onRenderTargetDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            infoMemory.textures++;
            var isCube = (renderTarget.isWebGLRenderTargetCube === true);
            var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
            if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var i = 0; i < 6; i++) {
                    renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
                }
            } else {
                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            }
            if (isCube) {
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                for (var i = 0; i < 6; i++) {
                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                }
                if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
            } else {
                state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
                if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) _gl.generateMipmap(_gl.TEXTURE_2D);
                state.bindTexture(_gl.TEXTURE_2D, null);
            }
            if (renderTarget.depthBuffer) {
                setupDepthRenderbuffer(renderTarget);
            }
        }

        function updateRenderTargetMipmap(renderTarget) {
            var texture = renderTarget.texture;
            var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
            if (textureNeedsGenerateMipmaps(texture, isTargetPowerOfTwo)) {
                var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                var webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture);
                _gl.generateMipmap(target);
                state.bindTexture(target, null);
            }
        }

        function updateVideoTextures() {
            for (var id in _videoTextures) {
                _videoTextures[id].update();
            }
        }
        this.setTexture2D = setTexture2D;
        this.setTextureCube = setTextureCube;
        this.setTextureCubeDynamic = setTextureCubeDynamic;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
        this.updateVideoTextures = updateVideoTextures;
    }

    function WebGLProperties() {
        var properties = {};

        function get(object) {
            var uuid = object.uuid;
            var map = properties[uuid];
            if (map === undefined) {
                map = {};
                properties[uuid] = map;
            }
            return map;
        }

        function remove(object) {
            delete properties[object.uuid];
        }

        function clear() {
            properties = {};
        }
        return {
            get: get,
            remove: remove,
            clear: clear
        };
    }

    function WebGLState(gl, extensions, utils) {
        function ColorBuffer() {
            var locked = false;
            var color = new Vector4();
            var currentColorMask = null;
            var currentColorClear = new Vector4(0, 0, 0, 0);
            return {
                setMask: function(colorMask) {
                    if (currentColorMask !== colorMask && !locked) {
                        gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                        currentColorMask = colorMask;
                    }
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(r, g, b, a, premultipliedAlpha) {
                    if (premultipliedAlpha === true) {
                        r *= a;
                        g *= a;
                        b *= a;
                    }
                    color.set(r, g, b, a);
                    if (currentColorClear.equals(color) === false) {
                        gl.clearColor(r, g, b, a);
                        currentColorClear.copy(color);
                    }
                },
                reset: function() {
                    locked = false;
                    currentColorMask = null;
                    currentColorClear.set(-1, 0, 0, 0);
                }
            };
        }

        function DepthBuffer() {
            var locked = false;
            var currentDepthMask = null;
            var currentDepthFunc = null;
            var currentDepthClear = null;
            return {
                setTest: function(depthTest) {
                    if (depthTest) {
                        enable(gl.DEPTH_TEST);
                    } else {
                        disable(gl.DEPTH_TEST);
                    }
                },
                setMask: function(depthMask) {
                    if (currentDepthMask !== depthMask && !locked) {
                        gl.depthMask(depthMask);
                        currentDepthMask = depthMask;
                    }
                },
                setFunc: function(depthFunc) {
                    if (currentDepthFunc !== depthFunc) {
                        if (depthFunc) {
                            switch (depthFunc) {
                                case NeverDepth:
                                    gl.depthFunc(gl.NEVER);
                                    break;
                                case AlwaysDepth:
                                    gl.depthFunc(gl.ALWAYS);
                                    break;
                                case LessDepth:
                                    gl.depthFunc(gl.LESS);
                                    break;
                                case LessEqualDepth:
                                    gl.depthFunc(gl.LEQUAL);
                                    break;
                                case EqualDepth:
                                    gl.depthFunc(gl.EQUAL);
                                    break;
                                case GreaterEqualDepth:
                                    gl.depthFunc(gl.GEQUAL);
                                    break;
                                case GreaterDepth:
                                    gl.depthFunc(gl.GREATER);
                                    break;
                                case NotEqualDepth:
                                    gl.depthFunc(gl.NOTEQUAL);
                                    break;
                                default:
                                    gl.depthFunc(gl.LEQUAL);
                            }
                        } else {
                            gl.depthFunc(gl.LEQUAL);
                        }
                        currentDepthFunc = depthFunc;
                    }
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(depth) {
                    if (currentDepthClear !== depth) {
                        gl.clearDepth(depth);
                        currentDepthClear = depth;
                    }
                },
                reset: function() {
                    locked = false;
                    currentDepthMask = null;
                    currentDepthFunc = null;
                    currentDepthClear = null;
                }
            };
        }

        function StencilBuffer() {
            var locked = false;
            var currentStencilMask = null;
            var currentStencilFunc = null;
            var currentStencilRef = null;
            var currentStencilFuncMask = null;
            var currentStencilFail = null;
            var currentStencilZFail = null;
            var currentStencilZPass = null;
            var currentStencilClear = null;
            return {
                setTest: function(stencilTest) {
                    if (stencilTest) {
                        enable(gl.STENCIL_TEST);
                    } else {
                        disable(gl.STENCIL_TEST);
                    }
                },
                setMask: function(stencilMask) {
                    if (currentStencilMask !== stencilMask && !locked) {
                        gl.stencilMask(stencilMask);
                        currentStencilMask = stencilMask;
                    }
                },
                setFunc: function(stencilFunc, stencilRef, stencilMask) {
                    if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                        gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                        currentStencilFunc = stencilFunc;
                        currentStencilRef = stencilRef;
                        currentStencilFuncMask = stencilMask;
                    }
                },
                setOp: function(stencilFail, stencilZFail, stencilZPass) {
                    if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                        gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                        currentStencilFail = stencilFail;
                        currentStencilZFail = stencilZFail;
                        currentStencilZPass = stencilZPass;
                    }
                },
                setLocked: function(lock) {
                    locked = lock;
                },
                setClear: function(stencil) {
                    if (currentStencilClear !== stencil) {
                        gl.clearStencil(stencil);
                        currentStencilClear = stencil;
                    }
                },
                reset: function() {
                    locked = false;
                    currentStencilMask = null;
                    currentStencilFunc = null;
                    currentStencilRef = null;
                    currentStencilFuncMask = null;
                    currentStencilFail = null;
                    currentStencilZFail = null;
                    currentStencilZPass = null;
                    currentStencilClear = null;
                }
            };
        }
        var colorBuffer = new ColorBuffer();
        var depthBuffer = new DepthBuffer();
        var stencilBuffer = new StencilBuffer();
        var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        var newAttributes = new Uint8Array(maxVertexAttributes);
        var enabledAttributes = new Uint8Array(maxVertexAttributes);
        var attributeDivisors = new Uint8Array(maxVertexAttributes);
        var capabilities = {};
        var compressedTextureFormats = null;
        var currentProgram = null;
        var currentBlending = null;
        var currentBlendEquation = null;
        var currentBlendSrc = null;
        var currentBlendDst = null;
        var currentBlendEquationAlpha = null;
        var currentBlendSrcAlpha = null;
        var currentBlendDstAlpha = null;
        var currentPremultipledAlpha = false;
        var currentFlipSided = null;
        var currentCullFace = null;
        var currentLineWidth = null;
        var currentPolygonOffsetFactor = null;
        var currentPolygonOffsetUnits = null;
        var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        var version = parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);
        var lineWidthAvailable = parseFloat(version) >= 1.0;
        var currentTextureSlot = null;
        var currentBoundTextures = {};
        var currentScissor = new Vector4();
        var currentViewport = new Vector4();

        function createTexture(type, target, count) {
            var data = new Uint8Array(4);
            var texture = gl.createTexture();
            gl.bindTexture(type, texture);
            gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            for (var i = 0; i < count; i++) {
                gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            }
            return texture;
        }
        var emptyTextures = {};
        emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        colorBuffer.setClear(0, 0, 0, 1);
        depthBuffer.setClear(1);
        stencilBuffer.setClear(0);
        enable(gl.DEPTH_TEST);
        depthBuffer.setFunc(LessEqualDepth);
        setFlipSided(false);
        setCullFace(CullFaceBack);
        enable(gl.CULL_FACE);
        enable(gl.BLEND);
        setBlending(NormalBlending);

        function initAttributes() {
            for (var i = 0, l = newAttributes.length; i < l; i++) {
                newAttributes[i] = 0;
            }
        }

        function enableAttribute(attribute) {
            newAttributes[attribute] = 1;
            if (enabledAttributes[attribute] === 0) {
                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
            }
            if (attributeDivisors[attribute] !== 0) {
                var extension = extensions.get('ANGLE_instanced_arrays');
                extension.vertexAttribDivisorANGLE(attribute, 0);
                attributeDivisors[attribute] = 0;
            }
        }

        function enableAttributeAndDivisor(attribute, meshPerAttribute) {
            newAttributes[attribute] = 1;
            if (enabledAttributes[attribute] === 0) {
                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
            }
            if (attributeDivisors[attribute] !== meshPerAttribute) {
                var extension = extensions.get('ANGLE_instanced_arrays');
                extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
                attributeDivisors[attribute] = meshPerAttribute;
            }
        }

        function disableUnusedAttributes() {
            for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
                if (enabledAttributes[i] !== newAttributes[i]) {
                    gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
        }

        function enable(id) {
            if (capabilities[id] !== true) {
                gl.enable(id);
                capabilities[id] = true;
            }
        }

        function disable(id) {
            if (capabilities[id] !== false) {
                gl.disable(id);
                capabilities[id] = false;
            }
        }

        function getCompressedTextureFormats() {
            if (compressedTextureFormats === null) {
                compressedTextureFormats = [];
                if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc') || extensions.get('WEBGL_compressed_texture_etc1')) {
                    var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
                    for (var i = 0; i < formats.length; i++) {
                        compressedTextureFormats.push(formats[i]);
                    }
                }
            }
            return compressedTextureFormats;
        }

        function useProgram(program) {
            if (currentProgram !== program) {
                gl.useProgram(program);
                currentProgram = program;
                return true;
            }
            return false;
        }

        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            if (blending !== NoBlending) {
                enable(gl.BLEND);
            } else {
                disable(gl.BLEND);
            }
            if (blending !== CustomBlending) {
                if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                    switch (blending) {
                        case AdditiveBlending:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
                            } else {
                                gl.blendEquation(gl.FUNC_ADD);
                                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                            }
                            break;
                        case SubtractiveBlending:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                            } else {
                                gl.blendEquation(gl.FUNC_ADD);
                                gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                            }
                            break;
                        case MultiplyBlending:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                            } else {
                                gl.blendEquation(gl.FUNC_ADD);
                                gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                            }
                            break;
                        default:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                            } else {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                            }
                    }
                }
                currentBlendEquation = null;
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendEquationAlpha = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
            } else {
                blendEquationAlpha = blendEquationAlpha || blendEquation;
                blendSrcAlpha = blendSrcAlpha || blendSrc;
                blendDstAlpha = blendDstAlpha || blendDst;
                if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                    gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));
                    currentBlendEquation = blendEquation;
                    currentBlendEquationAlpha = blendEquationAlpha;
                }
                if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                    gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));
                    currentBlendSrc = blendSrc;
                    currentBlendDst = blendDst;
                    currentBlendSrcAlpha = blendSrcAlpha;
                    currentBlendDstAlpha = blendDstAlpha;
                }
            }
            currentBlending = blending;
            currentPremultipledAlpha = premultipliedAlpha;
        }

        function setMaterial(material, frontFaceCW) {
            material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
            var flipSided = (material.side === BackSide);
            if (frontFaceCW) flipSided = !flipSided;
            setFlipSided(flipSided);
            material.transparent === true ? setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : setBlending(NoBlending);
            depthBuffer.setFunc(material.depthFunc);
            depthBuffer.setTest(material.depthTest);
            depthBuffer.setMask(material.depthWrite);
            colorBuffer.setMask(material.colorWrite);
            setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }

        function setFlipSided(flipSided) {
            if (currentFlipSided !== flipSided) {
                if (flipSided) {
                    gl.frontFace(gl.CW);
                } else {
                    gl.frontFace(gl.CCW);
                }
                currentFlipSided = flipSided;
            }
        }

        function setCullFace(cullFace) {
            if (cullFace !== CullFaceNone) {
                enable(gl.CULL_FACE);
                if (cullFace !== currentCullFace) {
                    if (cullFace === CullFaceBack) {
                        gl.cullFace(gl.BACK);
                    } else if (cullFace === CullFaceFront) {
                        gl.cullFace(gl.FRONT);
                    } else {
                        gl.cullFace(gl.FRONT_AND_BACK);
                    }
                }
            } else {
                disable(gl.CULL_FACE);
            }
            currentCullFace = cullFace;
        }

        function setLineWidth(width) {
            if (width !== currentLineWidth) {
                if (lineWidthAvailable) gl.lineWidth(width);
                currentLineWidth = width;
            }
        }

        function setPolygonOffset(polygonOffset, factor, units) {
            if (polygonOffset) {
                enable(gl.POLYGON_OFFSET_FILL);
                if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                    gl.polygonOffset(factor, units);
                    currentPolygonOffsetFactor = factor;
                    currentPolygonOffsetUnits = units;
                }
            } else {
                disable(gl.POLYGON_OFFSET_FILL);
            }
        }

        function setScissorTest(scissorTest) {
            if (scissorTest) {
                enable(gl.SCISSOR_TEST);
            } else {
                disable(gl.SCISSOR_TEST);
            }
        }

        function activeTexture(webglSlot) {
            if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
            if (currentTextureSlot !== webglSlot) {
                gl.activeTexture(webglSlot);
                currentTextureSlot = webglSlot;
            }
        }

        function bindTexture(webglType, webglTexture) {
            if (currentTextureSlot === null) {
                activeTexture();
            }
            var boundTexture = currentBoundTextures[currentTextureSlot];
            if (boundTexture === undefined) {
                boundTexture = {
                    type: undefined,
                    texture: undefined
                };
                currentBoundTextures[currentTextureSlot] = boundTexture;
            }
            if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
            }
        }

        function compressedTexImage2D() {
            try {
                gl.compressedTexImage2D.apply(gl, arguments);
            } catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }

        function texImage2D() {
            try {
                gl.texImage2D.apply(gl, arguments);
            } catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }

        function scissor(scissor) {
            if (currentScissor.equals(scissor) === false) {
                gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                currentScissor.copy(scissor);
            }
        }

        function viewport(viewport) {
            if (currentViewport.equals(viewport) === false) {
                gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                currentViewport.copy(viewport);
            }
        }

        function reset() {
            for (var i = 0; i < enabledAttributes.length; i++) {
                if (enabledAttributes[i] === 1) {
                    gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
            capabilities = {};
            compressedTextureFormats = null;
            currentTextureSlot = null;
            currentBoundTextures = {};
            currentProgram = null;
            currentBlending = null;
            currentFlipSided = null;
            currentCullFace = null;
            colorBuffer.reset();
            depthBuffer.reset();
            stencilBuffer.reset();
        }
        return {
            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            enableAttributeAndDivisor: enableAttributeAndDivisor,
            disableUnusedAttributes: disableUnusedAttributes,
            enable: enable,
            disable: disable,
            getCompressedTextureFormats: getCompressedTextureFormats,
            useProgram: useProgram,
            setBlending: setBlending,
            setMaterial: setMaterial,
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
            setScissorTest: setScissorTest,
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,
            scissor: scissor,
            viewport: viewport,
            reset: reset
        };
    }

    function WebGLCapabilities(gl, extensions, parameters) {
        var maxAnisotropy;

        function getMaxAnisotropy() {
            if (maxAnisotropy !== undefined) return maxAnisotropy;
            var extension = extensions.get('EXT_texture_filter_anisotropic');
            if (extension !== null) {
                maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else {
                maxAnisotropy = 0;
            }
            return maxAnisotropy;
        }

        function getMaxPrecision(precision) {
            if (precision === 'highp') {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                    return 'highp';
                }
                precision = 'mediump';
            }
            if (precision === 'mediump') {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                    return 'mediump';
                }
            }
            return 'lowp';
        }
        var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
        var maxPrecision = getMaxPrecision(precision);
        if (maxPrecision !== precision) {
            console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
            precision = maxPrecision;
        }
        var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
        var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        var vertexTextures = maxVertexTextures > 0;
        var floatFragmentTextures = !!extensions.get('OES_texture_float');
        var floatVertexTextures = vertexTextures && floatFragmentTextures;
        return {
            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: floatVertexTextures
        };
    }

    function PerspectiveCamera(fov, aspect, near, far) {
        Camera.call(this);
        this.type = 'PerspectiveCamera';
        this.fov = fov !== undefined ? fov : 50;
        this.zoom = 1;
        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;
        this.focus = 10;
        this.aspect = aspect !== undefined ? aspect : 1;
        this.view = null;
        this.filmGauge = 35;
        this.filmOffset = 0;
        this.updateProjectionMatrix();
    }
    PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: PerspectiveCamera,
        isPerspectiveCamera: true,
        copy: function(source, recursive) {
            Camera.prototype.copy.call(this, source, recursive);
            this.fov = source.fov;
            this.zoom = source.zoom;
            this.near = source.near;
            this.far = source.far;
            this.focus = source.focus;
            this.aspect = source.aspect;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            this.filmGauge = source.filmGauge;
            this.filmOffset = source.filmOffset;
            return this;
        },
        setFocalLength: function(focalLength) {
            var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
            this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
            this.updateProjectionMatrix();
        },
        getFocalLength: function() {
            var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
            return 0.5 * this.getFilmHeight() / vExtentSlope;
        },
        getEffectiveFOV: function() {
            return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
            this.aspect = fullWidth / fullHeight;
            if (this.view === null) {
                this.view = {
                    enabled: true,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                };
            }
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
            this.updateProjectionMatrix();
        },
        clearViewOffset: function() {
            if (this.view !== null) {
                this.view.enabled = false;
            }
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function() {
            var near = this.near,
                top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom,
                height = 2 * top,
                width = this.aspect * height,
                left = -0.5 * width,
                view = this.view;
            if (this.view !== null && this.view.enabled) {
                var fullWidth = view.fullWidth,
                    fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
            }
            var skew = this.filmOffset;
            if (skew !== 0) left += near * skew / this.getFilmWidth();
            this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.fov = this.fov;
            data.object.zoom = this.zoom;
            data.object.near = this.near;
            data.object.far = this.far;
            data.object.focus = this.focus;
            data.object.aspect = this.aspect;
            if (this.view !== null) data.object.view = Object.assign({}, this.view);
            data.object.filmGauge = this.filmGauge;
            data.object.filmOffset = this.filmOffset;
            return data;
        }
    });

    function ArrayCamera(array) {
        PerspectiveCamera.call(this);
        this.cameras = array || [];
    }
    ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
        constructor: ArrayCamera,
        isArrayCamera: true
    });

    function WebVRManager(renderer) {
        var scope = this;
        var device = null;
        var frameData = null;
        var poseTarget = null;
        if (typeof window !== 'undefined' && 'VRFrameData' in window) {
            frameData = new window.VRFrameData();
        }
        var matrixWorldInverse = new Matrix4();
        var cameraL = new PerspectiveCamera();
        cameraL.bounds = new Vector4(0.0, 0.0, 0.5, 1.0);
        cameraL.layers.enable(1);
        var cameraR = new PerspectiveCamera();
        cameraR.bounds = new Vector4(0.5, 0.0, 0.5, 1.0);
        cameraR.layers.enable(2);
        var cameraVR = new ArrayCamera([cameraL, cameraR]);
        cameraVR.layers.enable(1);
        cameraVR.layers.enable(2);
        var currentSize, currentPixelRatio;

        function onVRDisplayPresentChange() {
            if (device !== null && device.isPresenting) {
                var eyeParameters = device.getEyeParameters('left');
                var renderWidth = eyeParameters.renderWidth;
                var renderHeight = eyeParameters.renderHeight;
                currentPixelRatio = renderer.getPixelRatio();
                currentSize = renderer.getSize();
                renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);
            } else if (scope.enabled) {
                renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
            }
        }
        if (typeof window !== 'undefined') {
            window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);
        }
        this.enabled = false;
        this.getDevice = function() {
            return device;
        };
        this.setDevice = function(value) {
            if (value !== undefined) device = value;
        };
        this.setPoseTarget = function(object) {
            if (object !== undefined) poseTarget = object;
        };
        this.getCamera = function(camera) {
            if (device === null) return camera;
            device.depthNear = camera.near;
            device.depthFar = camera.far;
            device.getFrameData(frameData);
            var pose = frameData.pose;
            var poseObject = poseTarget !== null ? poseTarget : camera;
            if (pose.position !== null) {
                poseObject.position.fromArray(pose.position);
            } else {
                poseObject.position.set(0, 0, 0);
            }
            if (pose.orientation !== null) {
                poseObject.quaternion.fromArray(pose.orientation);
            }
            poseObject.updateMatrixWorld();
            if (device.isPresenting === false) return camera;
            cameraL.near = camera.near;
            cameraR.near = camera.near;
            cameraL.far = camera.far;
            cameraR.far = camera.far;
            cameraVR.matrixWorld.copy(camera.matrixWorld);
            cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse);
            cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
            cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);
            var parent = poseObject.parent;
            if (parent !== null) {
                matrixWorldInverse.getInverse(parent.matrixWorld);
                cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
                cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
            }
            cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
            cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
            cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
            cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);
            cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            var layers = device.getLayers();
            if (layers.length) {
                var layer = layers[0];
                if (layer.leftBounds !== null && layer.leftBounds.length === 4) {
                    cameraL.bounds.fromArray(layer.leftBounds);
                }
                if (layer.rightBounds !== null && layer.rightBounds.length === 4) {
                    cameraR.bounds.fromArray(layer.rightBounds);
                }
            }
            return cameraVR;
        };
        this.submitFrame = function() {
            if (device && device.isPresenting) device.submitFrame();
        };
        this.dispose = function() {
            if (typeof window !== 'undefined') {
                window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);
            }
        };
    }

    function WebGLExtensions(gl) {
        var extensions = {};
        return {
            get: function(name) {
                if (extensions[name] !== undefined) {
                    return extensions[name];
                }
                var extension;
                switch (name) {
                    case 'WEBGL_depth_texture':
                        extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                        break;
                    case 'EXT_texture_filter_anisotropic':
                        extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                        break;
                    case 'WEBGL_compressed_texture_s3tc':
                        extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                        break;
                    case 'WEBGL_compressed_texture_pvrtc':
                        extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                        break;
                    case 'WEBGL_compressed_texture_etc1':
                        extension = gl.getExtension('WEBGL_compressed_texture_etc1');
                        break;
                    default:
                        extension = gl.getExtension(name);
                }
                if (extension === null) {
                    console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
                }
                extensions[name] = extension;
                return extension;
            }
        };
    }

    function WebGLClipping() {
        var scope = this,
            globalState = null,
            numGlobalPlanes = 0,
            localClippingEnabled = false,
            renderingShadows = false,
            plane = new Plane(),
            viewNormalMatrix = new Matrix3(),
            uniform = {
                value: null,
                needsUpdate: false
            };
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function(planes, enableLocalClipping, camera) {
            var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
            localClippingEnabled = enableLocalClipping;
            globalState = projectPlanes(planes, camera, 0);
            numGlobalPlanes = planes.length;
            return enabled;
        };
        this.beginShadows = function() {
            renderingShadows = true;
            projectPlanes(null);
        };
        this.endShadows = function() {
            renderingShadows = false;
            resetGlobalState();
        };
        this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
            if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                if (renderingShadows) {
                    projectPlanes(null);
                } else {
                    resetGlobalState();
                }
            } else {
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                    lGlobal = nGlobal * 4,
                    dstArray = cache.clippingState || null;
                uniform.value = dstArray;
                dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
                for (var i = 0; i !== lGlobal; ++i) {
                    dstArray[i] = globalState[i];
                }
                cache.clippingState = dstArray;
                this.numIntersection = clipIntersection ? this.numPlanes : 0;
                this.numPlanes += nGlobal;
            }
        };

        function resetGlobalState() {
            if (uniform.value !== globalState) {
                uniform.value = globalState;
                uniform.needsUpdate = numGlobalPlanes > 0;
            }
            scope.numPlanes = numGlobalPlanes;
            scope.numIntersection = 0;
        }

        function projectPlanes(planes, camera, dstOffset, skipTransform) {
            var nPlanes = planes !== null ? planes.length : 0,
                dstArray = null;
            if (nPlanes !== 0) {
                dstArray = uniform.value;
                if (skipTransform !== true || dstArray === null) {
                    var flatSize = dstOffset + nPlanes * 4,
                        viewMatrix = camera.matrixWorldInverse;
                    viewNormalMatrix.getNormalMatrix(viewMatrix);
                    if (dstArray === null || dstArray.length < flatSize) {
                        dstArray = new Float32Array(flatSize);
                    }
                    for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                        plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                        plane.normal.toArray(dstArray, i4);
                        dstArray[i4 + 3] = plane.constant;
                    }
                }
                uniform.value = dstArray;
                uniform.needsUpdate = true;
            }
            scope.numPlanes = nPlanes;
            return dstArray;
        }
    }

    function WebGLUtils(gl, extensions) {
        function convert(p) {
            var extension;
            if (p === RepeatWrapping) return gl.REPEAT;
            if (p === ClampToEdgeWrapping) return gl.CLAMP_TO_EDGE;
            if (p === MirroredRepeatWrapping) return gl.MIRRORED_REPEAT;
            if (p === NearestFilter) return gl.NEAREST;
            if (p === NearestMipMapNearestFilter) return gl.NEAREST_MIPMAP_NEAREST;
            if (p === NearestMipMapLinearFilter) return gl.NEAREST_MIPMAP_LINEAR;
            if (p === LinearFilter) return gl.LINEAR;
            if (p === LinearMipMapNearestFilter) return gl.LINEAR_MIPMAP_NEAREST;
            if (p === LinearMipMapLinearFilter) return gl.LINEAR_MIPMAP_LINEAR;
            if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
            if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
            if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
            if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
            if (p === ByteType) return gl.BYTE;
            if (p === ShortType) return gl.SHORT;
            if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
            if (p === IntType) return gl.INT;
            if (p === UnsignedIntType) return gl.UNSIGNED_INT;
            if (p === FloatType) return gl.FLOAT;
            if (p === HalfFloatType) {
                extension = extensions.get('OES_texture_half_float');
                if (extension !== null) return extension.HALF_FLOAT_OES;
            }
            if (p === AlphaFormat) return gl.ALPHA;
            if (p === RGBFormat) return gl.RGB;
            if (p === RGBAFormat) return gl.RGBA;
            if (p === LuminanceFormat) return gl.LUMINANCE;
            if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
            if (p === DepthFormat) return gl.DEPTH_COMPONENT;
            if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
            if (p === AddEquation) return gl.FUNC_ADD;
            if (p === SubtractEquation) return gl.FUNC_SUBTRACT;
            if (p === ReverseSubtractEquation) return gl.FUNC_REVERSE_SUBTRACT;
            if (p === ZeroFactor) return gl.ZERO;
            if (p === OneFactor) return gl.ONE;
            if (p === SrcColorFactor) return gl.SRC_COLOR;
            if (p === OneMinusSrcColorFactor) return gl.ONE_MINUS_SRC_COLOR;
            if (p === SrcAlphaFactor) return gl.SRC_ALPHA;
            if (p === OneMinusSrcAlphaFactor) return gl.ONE_MINUS_SRC_ALPHA;
            if (p === DstAlphaFactor) return gl.DST_ALPHA;
            if (p === OneMinusDstAlphaFactor) return gl.ONE_MINUS_DST_ALPHA;
            if (p === DstColorFactor) return gl.DST_COLOR;
            if (p === OneMinusDstColorFactor) return gl.ONE_MINUS_DST_COLOR;
            if (p === SrcAlphaSaturateFactor) return gl.SRC_ALPHA_SATURATE;
            if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                extension = extensions.get('WEBGL_compressed_texture_s3tc');
                if (extension !== null) {
                    if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
            }
            if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                extension = extensions.get('WEBGL_compressed_texture_pvrtc');
                if (extension !== null) {
                    if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
            }
            if (p === RGB_ETC1_Format) {
                extension = extensions.get('WEBGL_compressed_texture_etc1');
                if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            }
            if (p === MinEquation || p === MaxEquation) {
                extension = extensions.get('EXT_blend_minmax');
                if (extension !== null) {
                    if (p === MinEquation) return extension.MIN_EXT;
                    if (p === MaxEquation) return extension.MAX_EXT;
                }
            }
            if (p === UnsignedInt248Type) {
                extension = extensions.get('WEBGL_depth_texture');
                if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            }
            return 0;
        }
        return {
            convert: convert
        };
    }

    function WebGLRenderer(parameters) {
        console.log('THREE.WebGLRenderer', REVISION);
        parameters = parameters || {};
        var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
            _context = parameters.context !== undefined ? parameters.context : null,
            _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
            _depth = parameters.depth !== undefined ? parameters.depth : true,
            _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
            _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
            _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
            _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
            _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';
        var lightsArray = [];
        var shadowsArray = [];
        var currentRenderList = null;
        var spritesArray = [];
        var flaresArray = [];
        this.domElement = _canvas;
        this.context = null;
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        this.sortObjects = true;
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        this.gammaFactor = 2.0;
        this.gammaInput = false;
        this.gammaOutput = false;
        this.physicallyCorrectLights = false;
        this.toneMapping = LinearToneMapping;
        this.toneMappingExposure = 1.0;
        this.toneMappingWhitePoint = 1.0;
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;
        var _this = this,
            _isContextLost = false,
            _currentRenderTarget = null,
            _currentFramebuffer = null,
            _currentMaterialId = -1,
            _currentGeometryProgram = '',
            _currentCamera = null,
            _currentArrayCamera = null,
            _currentViewport = new Vector4(),
            _currentScissor = new Vector4(),
            _currentScissorTest = null,
            _usedTextureUnits = 0,
            _width = _canvas.width,
            _height = _canvas.height,
            _pixelRatio = 1,
            _viewport = new Vector4(0, 0, _width, _height),
            _scissor = new Vector4(0, 0, _width, _height),
            _scissorTest = false,
            _frustum = new Frustum(),
            _clipping = new WebGLClipping(),
            _clippingEnabled = false,
            _localClippingEnabled = false,
            _projScreenMatrix = new Matrix4(),
            _vector3 = new Vector3(),
            _infoMemory = {
                geometries: 0,
                textures: 0
            },
            _infoRender = {
                frame: 0,
                calls: 0,
                vertices: 0,
                faces: 0,
                points: 0
            };
        this.info = {
            render: _infoRender,
            memory: _infoMemory,
            programs: null
        };

        function getTargetPixelRatio() {
            return _currentRenderTarget === null ? _pixelRatio : 1;
        }
        var _gl;
        try {
            var contextAttributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer,
                powerPreference: _powerPreference
            };
            _canvas.addEventListener('webglcontextlost', onContextLost, false);
            _canvas.addEventListener('webglcontextrestored', onContextRestore, false);
            _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);
            if (_gl === null) {
                if (_canvas.getContext('webgl') !== null) {
                    throw new Error('Error creating WebGL context with your selected attributes.');
                } else {
                    throw new Error('Error creating WebGL context.');
                }
            }
            if (_gl.getShaderPrecisionFormat === undefined) {
                _gl.getShaderPrecisionFormat = function() {
                    return {
                        'rangeMin': 1,
                        'rangeMax': 1,
                        'precision': 1
                    };
                };
            }
        } catch (error) {
            console.error('THREE.WebGLRenderer: ' + error.message);
        }
        var extensions, capabilities, state;
        var properties, textures, attributes, geometries, objects, lights;
        var programCache, renderLists;
        var background, morphtargets, bufferRenderer, indexedBufferRenderer;
        var flareRenderer, spriteRenderer;
        var utils;

        function initGLContext() {
            extensions = new WebGLExtensions(_gl);
            extensions.get('WEBGL_depth_texture');
            extensions.get('OES_texture_float');
            extensions.get('OES_texture_float_linear');
            extensions.get('OES_texture_half_float');
            extensions.get('OES_texture_half_float_linear');
            extensions.get('OES_standard_derivatives');
            extensions.get('OES_element_index_uint');
            extensions.get('ANGLE_instanced_arrays');
            utils = new WebGLUtils(_gl, extensions);
            capabilities = new WebGLCapabilities(_gl, extensions, parameters);
            state = new WebGLState(_gl, extensions, utils);
            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
            properties = new WebGLProperties();
            textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, _infoMemory);
            attributes = new WebGLAttributes(_gl);
            geometries = new WebGLGeometries(_gl, attributes, _infoMemory);
            objects = new WebGLObjects(geometries, _infoRender);
            morphtargets = new WebGLMorphtargets(_gl);
            programCache = new WebGLPrograms(_this, extensions, capabilities);
            lights = new WebGLLights();
            renderLists = new WebGLRenderLists();
            background = new WebGLBackground(_this, state, geometries, _premultipliedAlpha);
            bufferRenderer = new WebGLBufferRenderer(_gl, extensions, _infoRender);
            indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, _infoRender);
            flareRenderer = new WebGLFlareRenderer(_this, _gl, state, textures, capabilities);
            spriteRenderer = new WebGLSpriteRenderer(_this, _gl, state, textures, capabilities);
            _this.info.programs = programCache.programs;
            _this.context = _gl;
            _this.capabilities = capabilities;
            _this.extensions = extensions;
            _this.properties = properties;
            _this.renderLists = renderLists;
            _this.state = state;
        }
        initGLContext();
        var vr = new WebVRManager(_this);
        this.vr = vr;
        var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
        this.shadowMap = shadowMap;
        this.getContext = function() {
            return _gl;
        };
        this.getContextAttributes = function() {
            return _gl.getContextAttributes();
        };
        this.forceContextLoss = function() {
            var extension = extensions.get('WEBGL_lose_context');
            if (extension) extension.loseContext();
        };
        this.forceContextRestore = function() {
            var extension = extensions.get('WEBGL_lose_context');
            if (extension) extension.restoreContext();
        };
        this.getPixelRatio = function() {
            return _pixelRatio;
        };
        this.setPixelRatio = function(value) {
            if (value === undefined) return;
            _pixelRatio = value;
            this.setSize(_width, _height, false);
        };
        this.getSize = function() {
            return {
                width: _width,
                height: _height
            };
        };
        this.setSize = function(width, height, updateStyle) {
            var device = vr.getDevice();
            if (device && device.isPresenting) {
                console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
                return;
            }
            _width = width;
            _height = height;
            _canvas.width = width * _pixelRatio;
            _canvas.height = height * _pixelRatio;
            if (updateStyle !== false) {
                _canvas.style.width = width + 'px';
                _canvas.style.height = height + 'px';
            }
            this.setViewport(0, 0, width, height);
        };
        this.getDrawingBufferSize = function() {
            return {
                width: _width * _pixelRatio,
                height: _height * _pixelRatio
            };
        };
        this.setDrawingBufferSize = function(width, height, pixelRatio) {
            _width = width;
            _height = height;
            _pixelRatio = pixelRatio;
            _canvas.width = width * pixelRatio;
            _canvas.height = height * pixelRatio;
            this.setViewport(0, 0, width, height);
        };
        this.setViewport = function(x, y, width, height) {
            _viewport.set(x, _height - y - height, width, height);
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
        };
        this.setScissor = function(x, y, width, height) {
            _scissor.set(x, _height - y - height, width, height);
            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
        };
        this.setScissorTest = function(boolean) {
            state.setScissorTest(_scissorTest = boolean);
        };
        this.getClearColor = function() {
            return background.getClearColor();
        };
        this.setClearColor = function() {
            background.setClearColor.apply(background, arguments);
        };
        this.getClearAlpha = function() {
            return background.getClearAlpha();
        };
        this.setClearAlpha = function() {
            background.setClearAlpha.apply(background, arguments);
        };
        this.clear = function(color, depth, stencil) {
            var bits = 0;
            if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
            if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
            if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;
            _gl.clear(bits);
        };
        this.clearColor = function() {
            this.clear(true, false, false);
        };
        this.clearDepth = function() {
            this.clear(false, true, false);
        };
        this.clearStencil = function() {
            this.clear(false, false, true);
        };
        this.clearTarget = function(renderTarget, color, depth, stencil) {
            this.setRenderTarget(renderTarget);
            this.clear(color, depth, stencil);
        };
        this.dispose = function() {
            _canvas.removeEventListener('webglcontextlost', onContextLost, false);
            _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
            renderLists.dispose();
            vr.dispose();
        };

        function onContextLost(event) {
            event.preventDefault();
            console.log('THREE.WebGLRenderer: Context Lost.');
            _isContextLost = true;
        }

        function onContextRestore() {
            console.log('THREE.WebGLRenderer: Context Restored.');
            _isContextLost = false;
            initGLContext();
        }

        function onMaterialDispose(event) {
            var material = event.target;
            material.removeEventListener('dispose', onMaterialDispose);
            deallocateMaterial(material);
        }

        function deallocateMaterial(material) {
            releaseMaterialProgramReference(material);
            properties.remove(material);
        }

        function releaseMaterialProgramReference(material) {
            var programInfo = properties.get(material).program;
            material.program = undefined;
            if (programInfo !== undefined) {
                programCache.releaseProgram(programInfo);
            }
        }

        function renderObjectImmediate(object, program, material) {
            object.render(function(object) {
                _this.renderBufferImmediate(object, program, material);
            });
        }
        this.renderBufferImmediate = function(object, program, material) {
            state.initAttributes();
            var buffers = properties.get(object);
            if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
            if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
            if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
            if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
            var programAttributes = program.getAttributes();
            if (object.hasPositions) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(programAttributes.position);
                _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasNormals) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
                if (!material.isMeshPhongMaterial && !material.isMeshStandardMaterial && !material.isMeshNormalMaterial && material.flatShading === true) {
                    for (var i = 0, l = object.count * 3; i < l; i += 9) {
                        var array = object.normalArray;
                        var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                        var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                        var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                        array[i + 0] = nx;
                        array[i + 1] = ny;
                        array[i + 2] = nz;
                        array[i + 3] = nx;
                        array[i + 4] = ny;
                        array[i + 5] = nz;
                        array[i + 6] = nx;
                        array[i + 7] = ny;
                        array[i + 8] = nz;
                    }
                }
                _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(programAttributes.normal);
                _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasUvs && material.map) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(programAttributes.uv);
                _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasColors && material.vertexColors !== NoColors) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(programAttributes.color);
                _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
            }
            state.disableUnusedAttributes();
            _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
            object.count = 0;
        };
        this.renderBufferDirect = function(camera, fog, geometry, material, object, group) {
            var frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
            state.setMaterial(material, frontFaceCW);
            var program = setProgram(camera, fog, material, object);
            var geometryProgram = geometry.id + '_' + program.id + '_' + (material.wireframe === true);
            var updateBuffers = false;
            if (geometryProgram !== _currentGeometryProgram) {
                _currentGeometryProgram = geometryProgram;
                updateBuffers = true;
            }
            if (object.morphTargetInfluences) {
                morphtargets.update(object, geometry, material, program);
                updateBuffers = true;
            }
            var index = geometry.index;
            var position = geometry.attributes.position;
            var rangeFactor = 1;
            if (material.wireframe === true) {
                index = geometries.getWireframeAttribute(geometry);
                rangeFactor = 2;
            }
            var attribute;
            var renderer = bufferRenderer;
            if (index !== null) {
                attribute = attributes.get(index);
                renderer = indexedBufferRenderer;
                renderer.setIndex(attribute);
            }
            if (updateBuffers) {
                setupVertexAttributes(material, program, geometry);
                if (index !== null) {
                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer);
                }
            }
            var dataCount = 0;
            if (index !== null) {
                dataCount = index.count;
            } else if (position !== undefined) {
                dataCount = position.count;
            }
            var rangeStart = geometry.drawRange.start * rangeFactor;
            var rangeCount = geometry.drawRange.count * rangeFactor;
            var groupStart = group !== null ? group.start * rangeFactor : 0;
            var groupCount = group !== null ? group.count * rangeFactor : Infinity;
            var drawStart = Math.max(rangeStart, groupStart);
            var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
            var drawCount = Math.max(0, drawEnd - drawStart + 1);
            if (drawCount === 0) return;
            if (object.isMesh) {
                if (material.wireframe === true) {
                    state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                    renderer.setMode(_gl.LINES);
                } else {
                    switch (object.drawMode) {
                        case TrianglesDrawMode:
                            renderer.setMode(_gl.TRIANGLES);
                            break;
                        case TriangleStripDrawMode:
                            renderer.setMode(_gl.TRIANGLE_STRIP);
                            break;
                        case TriangleFanDrawMode:
                            renderer.setMode(_gl.TRIANGLE_FAN);
                            break;
                    }
                }
            } else if (object.isLine) {
                var lineWidth = material.linewidth;
                if (lineWidth === undefined) lineWidth = 1;
                state.setLineWidth(lineWidth * getTargetPixelRatio());
                if (object.isLineSegments) {
                    renderer.setMode(_gl.LINES);
                } else if (object.isLineLoop) {
                    renderer.setMode(_gl.LINE_LOOP);
                } else {
                    renderer.setMode(_gl.LINE_STRIP);
                }
            } else if (object.isPoints) {
                renderer.setMode(_gl.POINTS);
            }
            if (geometry && geometry.isInstancedBufferGeometry) {
                if (geometry.maxInstancedCount > 0) {
                    renderer.renderInstances(geometry, drawStart, drawCount);
                }
            } else {
                renderer.render(drawStart, drawCount);
            }
        };

        function setupVertexAttributes(material, program, geometry, startIndex) {
            if (geometry && geometry.isInstancedBufferGeometry) {
                if (extensions.get('ANGLE_instanced_arrays') === null) {
                    console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;
                }
            }
            if (startIndex === undefined) startIndex = 0;
            state.initAttributes();
            var geometryAttributes = geometry.attributes;
            var programAttributes = program.getAttributes();
            var materialDefaultAttributeValues = material.defaultAttributeValues;
            for (var name in programAttributes) {
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                    var geometryAttribute = geometryAttributes[name];
                    if (geometryAttribute !== undefined) {
                        var normalized = geometryAttribute.normalized;
                        var size = geometryAttribute.itemSize;
                        var attribute = attributes.get(geometryAttribute);
                        if (attribute === undefined) continue;
                        var buffer = attribute.buffer;
                        var type = attribute.type;
                        var bytesPerElement = attribute.bytesPerElement;
                        if (geometryAttribute.isInterleavedBufferAttribute) {
                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;
                            if (data && data.isInstancedInterleavedBuffer) {
                                state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                                }
                            } else {
                                state.enableAttribute(programAttribute);
                            }
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, (startIndex * stride + offset) * bytesPerElement);
                        } else {
                            if (geometryAttribute.isInstancedBufferAttribute) {
                                state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                }
                            } else {
                                state.enableAttribute(programAttribute);
                            }
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement);
                        }
                    } else if (materialDefaultAttributeValues !== undefined) {
                        var value = materialDefaultAttributeValues[name];
                        if (value !== undefined) {
                            switch (value.length) {
                                case 2:
                                    _gl.vertexAttrib2fv(programAttribute, value);
                                    break;
                                case 3:
                                    _gl.vertexAttrib3fv(programAttribute, value);
                                    break;
                                case 4:
                                    _gl.vertexAttrib4fv(programAttribute, value);
                                    break;
                                default:
                                    _gl.vertexAttrib1fv(programAttribute, value);
                            }
                        }
                    }
                }
            }
            state.disableUnusedAttributes();
        }
        this.compile = function(scene, camera) {
            lightsArray.length = 0;
            shadowsArray.length = 0;
            scene.traverse(function(object) {
                if (object.isLight) {
                    lightsArray.push(object);
                    if (object.castShadow) {
                        shadowsArray.push(object);
                    }
                }
            });
            lights.setup(lightsArray, shadowsArray, camera);
            scene.traverse(function(object) {
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        for (var i = 0; i < object.material.length; i++) {
                            initMaterial(object.material[i], scene.fog, object);
                        }
                    } else {
                        initMaterial(object.material, scene.fog, object);
                    }
                }
            });
        };
        var isAnimating = false;
        var onAnimationFrame = null;

        function start() {
            if (isAnimating) return;
            var device = vr.getDevice();
            if (device && device.isPresenting) {
                device.requestAnimationFrame(loop);
            } else {
                window.requestAnimationFrame(loop);
            }
            isAnimating = true;
        }

        function loop(time) {
            if (onAnimationFrame !== null) onAnimationFrame(time);
            var device = vr.getDevice();
            if (device && device.isPresenting) {
                device.requestAnimationFrame(loop);
            } else {
                window.requestAnimationFrame(loop);
            }
        }
        this.animate = function(callback) {
            onAnimationFrame = callback;
            start();
        };
        this.render = function(scene, camera, renderTarget, forceClear) {
            if (!(camera && camera.isCamera)) {
                console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                return;
            }
            if (_isContextLost) return;
            _currentGeometryProgram = '';
            _currentMaterialId = -1;
            _currentCamera = null;
            if (scene.autoUpdate === true) scene.updateMatrixWorld();
            if (camera.parent === null) camera.updateMatrixWorld();
            if (vr.enabled) {
                camera = vr.getCamera(camera);
            }
            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            _frustum.setFromMatrix(_projScreenMatrix);
            lightsArray.length = 0;
            shadowsArray.length = 0;
            spritesArray.length = 0;
            flaresArray.length = 0;
            _localClippingEnabled = this.localClippingEnabled;
            _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
            currentRenderList = renderLists.get(scene, camera);
            currentRenderList.init();
            projectObject(scene, camera, _this.sortObjects);
            if (_this.sortObjects === true) {
                currentRenderList.sort();
            }
            textures.updateVideoTextures();
            if (_clippingEnabled) _clipping.beginShadows();
            shadowMap.render(shadowsArray, scene, camera);
            lights.setup(lightsArray, shadowsArray, camera);
            if (_clippingEnabled) _clipping.endShadows();
            _infoRender.frame++;
            _infoRender.calls = 0;
            _infoRender.vertices = 0;
            _infoRender.faces = 0;
            _infoRender.points = 0;
            if (renderTarget === undefined) {
                renderTarget = null;
            }
            this.setRenderTarget(renderTarget);
            background.render(currentRenderList, scene, camera, forceClear);
            var opaqueObjects = currentRenderList.opaque;
            var transparentObjects = currentRenderList.transparent;
            if (scene.overrideMaterial) {
                var overrideMaterial = scene.overrideMaterial;
                if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
                if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
            } else {
                if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera);
                if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
            }
            spriteRenderer.render(spritesArray, scene, camera);
            flareRenderer.render(flaresArray, scene, camera, _currentViewport);
            if (renderTarget) {
                textures.updateRenderTargetMipmap(renderTarget);
            }
            state.buffers.depth.setTest(true);
            state.buffers.depth.setMask(true);
            state.buffers.color.setMask(true);
            state.setPolygonOffset(false);
            if (vr.enabled) {
                vr.submitFrame();
            }
        };

        function projectObject(object, camera, sortObjects) {
            if (object.visible === false) return;
            var visible = object.layers.test(camera.layers);
            if (visible) {
                if (object.isLight) {
                    lightsArray.push(object);
                    if (object.castShadow) {
                        shadowsArray.push(object);
                    }
                } else if (object.isSprite) {
                    if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                        spritesArray.push(object);
                    }
                } else if (object.isLensFlare) {
                    flaresArray.push(object);
                } else if (object.isImmediateRenderObject) {
                    if (sortObjects) {
                        _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    }
                    currentRenderList.push(object, null, object.material, _vector3.z, null);
                } else if (object.isMesh || object.isLine || object.isPoints) {
                    if (object.isSkinnedMesh) {
                        object.skeleton.update();
                    }
                    if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                        if (sortObjects) {
                            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                        }
                        var geometry = objects.update(object);
                        var material = object.material;
                        if (Array.isArray(material)) {
                            var groups = geometry.groups;
                            for (var i = 0, l = groups.length; i < l; i++) {
                                var group = groups[i];
                                var groupMaterial = material[group.materialIndex];
                                if (groupMaterial && groupMaterial.visible) {
                                    currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group);
                                }
                            }
                        } else if (material.visible) {
                            currentRenderList.push(object, geometry, material, _vector3.z, null);
                        }
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                projectObject(children[i], camera, sortObjects);
            }
        }

        function renderObjects(renderList, scene, camera, overrideMaterial) {
            for (var i = 0, l = renderList.length; i < l; i++) {
                var renderItem = renderList[i];
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
                if (camera.isArrayCamera) {
                    _currentArrayCamera = camera;
                    var cameras = camera.cameras;
                    for (var j = 0, jl = cameras.length; j < jl; j++) {
                        var camera2 = cameras[j];
                        if (object.layers.test(camera2.layers)) {
                            var bounds = camera2.bounds;
                            var x = bounds.x * _width;
                            var y = bounds.y * _height;
                            var width = bounds.z * _width;
                            var height = bounds.w * _height;
                            state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio));
                            renderObject(object, scene, camera2, geometry, material, group);
                        }
                    }
                } else {
                    _currentArrayCamera = null;
                    renderObject(object, scene, camera, geometry, material, group);
                }
            }
        }

        function renderObject(object, scene, camera, geometry, material, group) {
            object.onBeforeRender(_this, scene, camera, geometry, material, group);
            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            if (object.isImmediateRenderObject) {
                var frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
                state.setMaterial(material, frontFaceCW);
                var program = setProgram(camera, scene.fog, material, object);
                _currentGeometryProgram = '';
                renderObjectImmediate(object, program, material);
            } else {
                _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
            }
            object.onAfterRender(_this, scene, camera, geometry, material, group);
        }

        function initMaterial(material, fog, object) {
            var materialProperties = properties.get(material);
            var parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);
            var code = programCache.getProgramCode(material, parameters);
            var program = materialProperties.program;
            var programChange = true;
            if (program === undefined) {
                material.addEventListener('dispose', onMaterialDispose);
            } else if (program.code !== code) {
                releaseMaterialProgramReference(material);
            } else if (parameters.shaderID !== undefined) {
                return;
            } else {
                programChange = false;
            }
            if (programChange) {
                if (parameters.shaderID) {
                    var shader = ShaderLib[parameters.shaderID];
                    materialProperties.shader = {
                        name: material.type,
                        uniforms: UniformsUtils.clone(shader.uniforms),
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    };
                } else {
                    materialProperties.shader = {
                        name: material.type,
                        uniforms: material.uniforms,
                        vertexShader: material.vertexShader,
                        fragmentShader: material.fragmentShader
                    };
                }
                material.onBeforeCompile(materialProperties.shader);
                program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);
                materialProperties.program = program;
                material.program = program;
            }
            var programAttributes = program.getAttributes();
            if (material.morphTargets) {
                material.numSupportedMorphTargets = 0;
                for (var i = 0; i < _this.maxMorphTargets; i++) {
                    if (programAttributes['morphTarget' + i] >= 0) {
                        material.numSupportedMorphTargets++;
                    }
                }
            }
            if (material.morphNormals) {
                material.numSupportedMorphNormals = 0;
                for (var i = 0; i < _this.maxMorphNormals; i++) {
                    if (programAttributes['morphNormal' + i] >= 0) {
                        material.numSupportedMorphNormals++;
                    }
                }
            }
            var uniforms = materialProperties.shader.uniforms;
            if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
                materialProperties.numClippingPlanes = _clipping.numPlanes;
                materialProperties.numIntersection = _clipping.numIntersection;
                uniforms.clippingPlanes = _clipping.uniform;
            }
            materialProperties.fog = fog;
            materialProperties.lightsHash = lights.state.hash;
            if (material.lights) {
                uniforms.ambientLightColor.value = lights.state.ambient;
                uniforms.directionalLights.value = lights.state.directional;
                uniforms.spotLights.value = lights.state.spot;
                uniforms.rectAreaLights.value = lights.state.rectArea;
                uniforms.pointLights.value = lights.state.point;
                uniforms.hemisphereLights.value = lights.state.hemi;
                uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
            }
            var progUniforms = materialProperties.program.getUniforms(),
                uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
            materialProperties.uniformsList = uniformsList;
        }

        function setProgram(camera, fog, material, object) {
            _usedTextureUnits = 0;
            var materialProperties = properties.get(material);
            if (_clippingEnabled) {
                if (_localClippingEnabled || camera !== _currentCamera) {
                    var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                    _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
                }
            }
            if (material.needsUpdate === false) {
                if (materialProperties.program === undefined) {
                    material.needsUpdate = true;
                } else if (material.fog && materialProperties.fog !== fog) {
                    material.needsUpdate = true;
                } else if (material.lights && materialProperties.lightsHash !== lights.state.hash) {
                    material.needsUpdate = true;
                } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
                    material.needsUpdate = true;
                }
            }
            if (material.needsUpdate) {
                initMaterial(material, fog, object);
                material.needsUpdate = false;
            }
            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;
            var program = materialProperties.program,
                p_uniforms = program.getUniforms(),
                m_uniforms = materialProperties.shader.uniforms;
            if (state.useProgram(program.program)) {
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
            }
            if (material.id !== _currentMaterialId) {
                _currentMaterialId = material.id;
                refreshMaterial = true;
            }
            if (refreshProgram || camera !== _currentCamera) {
                p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
                if (capabilities.logarithmicDepthBuffer) {
                    p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
                }
                if (_currentCamera !== (_currentArrayCamera || camera)) {
                    _currentCamera = (_currentArrayCamera || camera);
                    refreshMaterial = true;
                    refreshLights = true;
                }
                if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    if (uCamPos !== undefined) {
                        uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                    }
                }
                if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
                    p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
                }
            }
            if (material.skinning) {
                p_uniforms.setOptional(_gl, object, 'bindMatrix');
                p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
                var skeleton = object.skeleton;
                if (skeleton) {
                    var bones = skeleton.bones;
                    if (capabilities.floatVertexTextures) {
                        if (skeleton.boneTexture === undefined) {
                            var size = Math.sqrt(bones.length * 4);
                            size = _Math.ceilPowerOfTwo(size);
                            size = Math.max(size, 4);
                            var boneMatrices = new Float32Array(size * size * 4);
                            boneMatrices.set(skeleton.boneMatrices);
                            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                            skeleton.boneMatrices = boneMatrices;
                            skeleton.boneTexture = boneTexture;
                            skeleton.boneTextureSize = size;
                        }
                        p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture);
                        p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                    } else {
                        p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                    }
                }
            }
            if (refreshMaterial) {
                p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);
                if (material.lights) {
                    markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                }
                if (fog && material.fog) {
                    refreshUniformsFog(m_uniforms, fog);
                }
                if (material.isMeshBasicMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                } else if (material.isMeshLambertMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsLambert(m_uniforms, material);
                } else if (material.isMeshPhongMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    if (material.isMeshToonMaterial) {
                        refreshUniformsToon(m_uniforms, material);
                    } else {
                        refreshUniformsPhong(m_uniforms, material);
                    }
                } else if (material.isMeshStandardMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    if (material.isMeshPhysicalMaterial) {
                        refreshUniformsPhysical(m_uniforms, material);
                    } else {
                        refreshUniformsStandard(m_uniforms, material);
                    }
                } else if (material.isMeshDepthMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsDepth(m_uniforms, material);
                } else if (material.isMeshDistanceMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsDistance(m_uniforms, material);
                } else if (material.isMeshNormalMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsNormal(m_uniforms, material);
                } else if (material.isLineBasicMaterial) {
                    refreshUniformsLine(m_uniforms, material);
                    if (material.isLineDashedMaterial) {
                        refreshUniformsDash(m_uniforms, material);
                    }
                } else if (material.isPointsMaterial) {
                    refreshUniformsPoints(m_uniforms, material);
                } else if (material.isShadowMaterial) {
                    m_uniforms.color.value = material.color;
                    m_uniforms.opacity.value = material.opacity;
                }
                if (m_uniforms.ltcMat !== undefined) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;
                if (m_uniforms.ltcMag !== undefined) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;
                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
            }
            p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
            p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
            p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
            return program;
        }

        function refreshUniformsCommon(uniforms, material) {
            uniforms.opacity.value = material.opacity;
            if (material.color) {
                uniforms.diffuse.value = material.color;
            }
            if (material.emissive) {
                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
            }
            if (material.map) {
                uniforms.map.value = material.map;
            }
            if (material.alphaMap) {
                uniforms.alphaMap.value = material.alphaMap;
            }
            if (material.specularMap) {
                uniforms.specularMap.value = material.specularMap;
            }
            if (material.envMap) {
                uniforms.envMap.value = material.envMap;
                uniforms.flipEnvMap.value = (!(material.envMap && material.envMap.isCubeTexture)) ? 1 : -1;
                uniforms.reflectivity.value = material.reflectivity;
                uniforms.refractionRatio.value = material.refractionRatio;
            }
            if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }
            if (material.aoMap) {
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
            }
            var uvScaleMap;
            if (material.map) {
                uvScaleMap = material.map;
            } else if (material.specularMap) {
                uvScaleMap = material.specularMap;
            } else if (material.displacementMap) {
                uvScaleMap = material.displacementMap;
            } else if (material.normalMap) {
                uvScaleMap = material.normalMap;
            } else if (material.bumpMap) {
                uvScaleMap = material.bumpMap;
            } else if (material.roughnessMap) {
                uvScaleMap = material.roughnessMap;
            } else if (material.metalnessMap) {
                uvScaleMap = material.metalnessMap;
            } else if (material.alphaMap) {
                uvScaleMap = material.alphaMap;
            } else if (material.emissiveMap) {
                uvScaleMap = material.emissiveMap;
            }
            if (uvScaleMap !== undefined) {
                if (uvScaleMap.isWebGLRenderTarget) {
                    uvScaleMap = uvScaleMap.texture;
                }
                if (uvScaleMap.matrixAutoUpdate === true) {
                    var offset = uvScaleMap.offset;
                    var repeat = uvScaleMap.repeat;
                    var rotation = uvScaleMap.rotation;
                    var center = uvScaleMap.center;
                    uvScaleMap.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);
                }
                uniforms.uvTransform.value.copy(uvScaleMap.matrix);
            }
        }

        function refreshUniformsLine(uniforms, material) {
            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
        }

        function refreshUniformsDash(uniforms, material) {
            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
        }

        function refreshUniformsPoints(uniforms, material) {
            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * _pixelRatio;
            uniforms.scale.value = _height * 0.5;
            uniforms.map.value = material.map;
            if (material.map !== null) {
                if (material.map.matrixAutoUpdate === true) {
                    var offset = material.map.offset;
                    var repeat = material.map.repeat;
                    var rotation = material.map.rotation;
                    var center = material.map.center;
                    material.map.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);
                }
                uniforms.uvTransform.value.copy(material.map.matrix);
            }
        }

        function refreshUniformsFog(uniforms, fog) {
            uniforms.fogColor.value = fog.color;
            if (fog.isFog) {
                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
            } else if (fog.isFogExp2) {
                uniforms.fogDensity.value = fog.density;
            }
        }

        function refreshUniformsLambert(uniforms, material) {
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
        }

        function refreshUniformsPhong(uniforms, material) {
            uniforms.specular.value = material.specular;
            uniforms.shininess.value = Math.max(material.shininess, 1e-4);
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }

        function refreshUniformsToon(uniforms, material) {
            refreshUniformsPhong(uniforms, material);
            if (material.gradientMap) {
                uniforms.gradientMap.value = material.gradientMap;
            }
        }

        function refreshUniformsStandard(uniforms, material) {
            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;
            if (material.roughnessMap) {
                uniforms.roughnessMap.value = material.roughnessMap;
            }
            if (material.metalnessMap) {
                uniforms.metalnessMap.value = material.metalnessMap;
            }
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            if (material.envMap) {
                uniforms.envMapIntensity.value = material.envMapIntensity;
            }
        }

        function refreshUniformsPhysical(uniforms, material) {
            uniforms.clearCoat.value = material.clearCoat;
            uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
            refreshUniformsStandard(uniforms, material);
        }

        function refreshUniformsDepth(uniforms, material) {
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }

        function refreshUniformsDistance(uniforms, material) {
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            uniforms.referencePosition.value.copy(material.referencePosition);
            uniforms.nearDistance.value = material.nearDistance;
            uniforms.farDistance.value = material.farDistance;
        }

        function refreshUniformsNormal(uniforms, material) {
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }

        function markUniformsLightsNeedsUpdate(uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value;
            uniforms.directionalLights.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
        }
        this.setFaceCulling = function(cullFace, frontFaceDirection) {
            state.setCullFace(cullFace);
            state.setFlipSided(frontFaceDirection === FrontFaceDirectionCW);
        };

        function allocTextureUnit() {
            var textureUnit = _usedTextureUnits;
            if (textureUnit >= capabilities.maxTextures) {
                console.warn('THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
            }
            _usedTextureUnits += 1;
            return textureUnit;
        }
        this.allocTextureUnit = allocTextureUnit;
        this.setTexture2D = (function() {
            var warned = false;
            return function setTexture2D(texture, slot) {
                if (texture && texture.isWebGLRenderTarget) {
                    if (!warned) {
                        console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                        warned = true;
                    }
                    texture = texture.texture;
                }
                textures.setTexture2D(texture, slot);
            };
        }());
        this.setTexture = (function() {
            var warned = false;
            return function setTexture(texture, slot) {
                if (!warned) {
                    console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
                    warned = true;
                }
                textures.setTexture2D(texture, slot);
            };
        }());
        this.setTextureCube = (function() {
            var warned = false;
            return function setTextureCube(texture, slot) {
                if (texture && texture.isWebGLRenderTargetCube) {
                    if (!warned) {
                        console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                        warned = true;
                    }
                    texture = texture.texture;
                }
                if ((texture && texture.isCubeTexture) || (Array.isArray(texture.image) && texture.image.length === 6)) {
                    textures.setTextureCube(texture, slot);
                } else {
                    textures.setTextureCubeDynamic(texture, slot);
                }
            };
        }());
        this.getRenderTarget = function() {
            return _currentRenderTarget;
        };
        this.setRenderTarget = function(renderTarget) {
            _currentRenderTarget = renderTarget;
            if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
                textures.setupRenderTarget(renderTarget);
            }
            var framebuffer = null;
            var isCube = false;
            if (renderTarget) {
                var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                if (renderTarget.isWebGLRenderTargetCube) {
                    framebuffer = __webglFramebuffer[renderTarget.activeCubeFace];
                    isCube = true;
                } else {
                    framebuffer = __webglFramebuffer;
                }
                _currentViewport.copy(renderTarget.viewport);
                _currentScissor.copy(renderTarget.scissor);
                _currentScissorTest = renderTarget.scissorTest;
            } else {
                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
                _currentScissorTest = _scissorTest;
            }
            if (_currentFramebuffer !== framebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                _currentFramebuffer = framebuffer;
            }
            state.viewport(_currentViewport);
            state.scissor(_currentScissor);
            state.setScissorTest(_currentScissorTest);
            if (isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
            }
        };
        this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
            if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                return;
            }
            var framebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (framebuffer) {
                var restore = false;
                if (framebuffer !== _currentFramebuffer) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                    restore = true;
                }
                try {
                    var texture = renderTarget.texture;
                    var textureFormat = texture.format;
                    var textureType = texture.type;
                    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                        return;
                    }
                    if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && !(textureType === HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                        return;
                    }
                    if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                        if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
                            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                        }
                    } else {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                    }
                } finally {
                    if (restore) {
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                    }
                }
            }
        };
    }

    function FogExp2(color, density) {
        this.name = '';
        this.color = new Color(color);
        this.density = (density !== undefined) ? density : 0.00025;
    }
    FogExp2.prototype.isFogExp2 = true;
    FogExp2.prototype.clone = function() {
        return new FogExp2(this.color.getHex(), this.density);
    };
    FogExp2.prototype.toJSON = function() {
        return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density
        };
    };

    function Fog(color, near, far) {
        this.name = '';
        this.color = new Color(color);
        this.near = (near !== undefined) ? near : 1;
        this.far = (far !== undefined) ? far : 1000;
    }
    Fog.prototype.isFog = true;
    Fog.prototype.clone = function() {
        return new Fog(this.color.getHex(), this.near, this.far);
    };
    Fog.prototype.toJSON = function() {
        return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    };

    function Scene() {
        Object3D.call(this);
        this.type = 'Scene';
        this.background = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true;
    }
    Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Scene,
        copy: function(source, recursive) {
            Object3D.prototype.copy.call(this, source, recursive);
            if (source.background !== null) this.background = source.background.clone();
            if (source.fog !== null) this.fog = source.fog.clone();
            if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
            this.autoUpdate = source.autoUpdate;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            return this;
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            if (this.background !== null) data.object.background = this.background.toJSON(meta);
            if (this.fog !== null) data.object.fog = this.fog.toJSON();
            return data;
        }
    });

    function LensFlare(texture, size, distance, blending, color) {
        Object3D.call(this);
        this.lensFlares = [];
        this.positionScreen = new Vector3();
        this.customUpdateCallback = undefined;
        if (texture !== undefined) {
            this.add(texture, size, distance, blending, color);
        }
    }
    LensFlare.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LensFlare,
        isLensFlare: true,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source);
            this.positionScreen.copy(source.positionScreen);
            this.customUpdateCallback = source.customUpdateCallback;
            for (var i = 0, l = source.lensFlares.length; i < l; i++) {
                this.lensFlares.push(source.lensFlares[i]);
            }
            return this;
        },
        add: function(texture, size, distance, blending, color, opacity) {
            if (size === undefined) size = -1;
            if (distance === undefined) distance = 0;
            if (opacity === undefined) opacity = 1;
            if (color === undefined) color = new Color(0xffffff);
            if (blending === undefined) blending = NormalBlending;
            distance = Math.min(distance, Math.max(0, distance));
            this.lensFlares.push({
                texture: texture,
                size: size,
                distance: distance,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: opacity,
                color: color,
                blending: blending
            });
        },
        updateLensFlares: function() {
            var f, fl = this.lensFlares.length;
            var flare;
            var vecX = -this.positionScreen.x * 2;
            var vecY = -this.positionScreen.y * 2;
            for (f = 0; f < fl; f++) {
                flare = this.lensFlares[f];
                flare.x = this.positionScreen.x + vecX * flare.distance;
                flare.y = this.positionScreen.y + vecY * flare.distance;
                flare.wantedRotation = flare.x * Math.PI * 0.25;
                flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
            }
        }
    });

    function SpriteMaterial(parameters) {
        Material.call(this);
        this.type = 'SpriteMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.rotation = 0;
        this.fog = false;
        this.lights = false;
        this.setValues(parameters);
    }
    SpriteMaterial.prototype = Object.create(Material.prototype);
    SpriteMaterial.prototype.constructor = SpriteMaterial;
    SpriteMaterial.prototype.isSpriteMaterial = true;
    SpriteMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.rotation = source.rotation;
        return this;
    };

    function Sprite(material) {
        Object3D.call(this);
        this.type = 'Sprite';
        this.material = (material !== undefined) ? material : new SpriteMaterial();
    }
    Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Sprite,
        isSprite: true,
        raycast: (function() {
            var intersectPoint = new Vector3();
            var worldPosition = new Vector3();
            var worldScale = new Vector3();
            return function raycast(raycaster, intersects) {
                worldPosition.setFromMatrixPosition(this.matrixWorld);
                raycaster.ray.closestPointToPoint(worldPosition, intersectPoint);
                worldScale.setFromMatrixScale(this.matrixWorld);
                var guessSizeSq = worldScale.x * worldScale.y / 4;
                if (worldPosition.distanceToSquared(intersectPoint) > guessSizeSq) return;
                var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                if (distance < raycaster.near || distance > raycaster.far) return;
                intersects.push({
                    distance: distance,
                    point: intersectPoint.clone(),
                    face: null,
                    object: this
                });
            };
        }()),
        clone: function() {
            return new this.constructor(this.material).copy(this);
        }
    });

    function LOD() {
        Object3D.call(this);
        this.type = 'LOD';
        Object.defineProperties(this, {
            levels: {
                enumerable: true,
                value: []
            }
        });
    }
    LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LOD,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source, false);
            var levels = source.levels;
            for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                this.addLevel(level.object.clone(), level.distance);
            }
            return this;
        },
        addLevel: function(object, distance) {
            if (distance === undefined) distance = 0;
            distance = Math.abs(distance);
            var levels = this.levels;
            for (var l = 0; l < levels.length; l++) {
                if (distance < levels[l].distance) {
                    break;
                }
            }
            levels.splice(l, 0, {
                distance: distance,
                object: object
            });
            this.add(object);
        },
        getObjectForDistance: function(distance) {
            var levels = this.levels;
            for (var i = 1, l = levels.length; i < l; i++) {
                if (distance < levels[i].distance) {
                    break;
                }
            }
            return levels[i - 1].object;
        },
        raycast: (function() {
            var matrixPosition = new Vector3();
            return function raycast(raycaster, intersects) {
                matrixPosition.setFromMatrixPosition(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(matrixPosition);
                this.getObjectForDistance(distance).raycast(raycaster, intersects);
            };
        }()),
        update: function() {
            var v1 = new Vector3();
            var v2 = new Vector3();
            return function update(camera) {
                var levels = this.levels;
                if (levels.length > 1) {
                    v1.setFromMatrixPosition(camera.matrixWorld);
                    v2.setFromMatrixPosition(this.matrixWorld);
                    var distance = v1.distanceTo(v2);
                    levels[0].object.visible = true;
                    for (var i = 1, l = levels.length; i < l; i++) {
                        if (distance >= levels[i].distance) {
                            levels[i - 1].object.visible = false;
                            levels[i].object.visible = true;
                        } else {
                            break;
                        }
                    }
                    for (; i < l; i++) {
                        levels[i].object.visible = false;
                    }
                }
            };
        }(),
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.levels = [];
            var levels = this.levels;
            for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance
                });
            }
            return data;
        }
    });

    function Skeleton(bones, boneInverses) {
        bones = bones || [];
        this.bones = bones.slice(0);
        this.boneMatrices = new Float32Array(this.bones.length * 16);
        if (boneInverses === undefined) {
            this.calculateInverses();
        } else {
            if (this.bones.length === boneInverses.length) {
                this.boneInverses = boneInverses.slice(0);
            } else {
                console.warn('THREE.Skeleton boneInverses is the wrong length.');
                this.boneInverses = [];
                for (var i = 0, il = this.bones.length; i < il; i++) {
                    this.boneInverses.push(new Matrix4());
                }
            }
        }
    }
    Object.assign(Skeleton.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var i = 0, il = this.bones.length; i < il; i++) {
                var inverse = new Matrix4();
                if (this.bones[i]) {
                    inverse.getInverse(this.bones[i].matrixWorld);
                }
                this.boneInverses.push(inverse);
            }
        },
        pose: function() {
            var bone, i, il;
            for (i = 0, il = this.bones.length; i < il; i++) {
                bone = this.bones[i];
                if (bone) {
                    bone.matrixWorld.getInverse(this.boneInverses[i]);
                }
            }
            for (i = 0, il = this.bones.length; i < il; i++) {
                bone = this.bones[i];
                if (bone) {
                    if (bone.parent && bone.parent.isBone) {
                        bone.matrix.getInverse(bone.parent.matrixWorld);
                        bone.matrix.multiply(bone.matrixWorld);
                    } else {
                        bone.matrix.copy(bone.matrixWorld);
                    }
                    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                }
            }
        },
        update: (function() {
            var offsetMatrix = new Matrix4();
            var identityMatrix = new Matrix4();
            return function update() {
                var bones = this.bones;
                var boneInverses = this.boneInverses;
                var boneMatrices = this.boneMatrices;
                var boneTexture = this.boneTexture;
                for (var i = 0, il = bones.length; i < il; i++) {
                    var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;
                    offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                    offsetMatrix.toArray(boneMatrices, i * 16);
                }
                if (boneTexture !== undefined) {
                    boneTexture.needsUpdate = true;
                }
            };
        })(),
        clone: function() {
            return new Skeleton(this.bones, this.boneInverses);
        }
    });

    function Bone() {
        Object3D.call(this);
        this.type = 'Bone';
    }
    Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Bone,
        isBone: true
    });

    function SkinnedMesh(geometry, material) {
        Mesh.call(this, geometry, material);
        this.type = 'SkinnedMesh';
        this.bindMode = 'attached';
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
        var bones = this.initBones();
        var skeleton = new Skeleton(bones);
        this.bind(skeleton, this.matrixWorld);
        this.normalizeSkinWeights();
    }
    SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
        constructor: SkinnedMesh,
        isSkinnedMesh: true,
        initBones: function() {
            var bones = [],
                bone, gbone;
            var i, il;
            if (this.geometry && this.geometry.bones !== undefined) {
                for (i = 0, il = this.geometry.bones.length; i < il; i++) {
                    gbone = this.geometry.bones[i];
                    bone = new Bone();
                    bones.push(bone);
                    bone.name = gbone.name;
                    bone.position.fromArray(gbone.pos);
                    bone.quaternion.fromArray(gbone.rotq);
                    if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl);
                }
                for (i = 0, il = this.geometry.bones.length; i < il; i++) {
                    gbone = this.geometry.bones[i];
                    if ((gbone.parent !== -1) && (gbone.parent !== null) && (bones[gbone.parent] !== undefined)) {
                        bones[gbone.parent].add(bones[i]);
                    } else {
                        this.add(bones[i]);
                    }
                }
            }
            this.updateMatrixWorld(true);
            return bones;
        },
        bind: function(skeleton, bindMatrix) {
            this.skeleton = skeleton;
            if (bindMatrix === undefined) {
                this.updateMatrixWorld(true);
                this.skeleton.calculateInverses();
                bindMatrix = this.matrixWorld;
            }
            this.bindMatrix.copy(bindMatrix);
            this.bindMatrixInverse.getInverse(bindMatrix);
        },
        pose: function() {
            this.skeleton.pose();
        },
        normalizeSkinWeights: function() {
            var scale, i;
            if (this.geometry && this.geometry.isGeometry) {
                for (i = 0; i < this.geometry.skinWeights.length; i++) {
                    var sw = this.geometry.skinWeights[i];
                    scale = 1.0 / sw.manhattanLength();
                    if (scale !== Infinity) {
                        sw.multiplyScalar(scale);
                    } else {
                        sw.set(1, 0, 0, 0);
                    }
                }
            } else if (this.geometry && this.geometry.isBufferGeometry) {
                var vec = new Vector4();
                var skinWeight = this.geometry.attributes.skinWeight;
                for (i = 0; i < skinWeight.count; i++) {
                    vec.x = skinWeight.getX(i);
                    vec.y = skinWeight.getY(i);
                    vec.z = skinWeight.getZ(i);
                    vec.w = skinWeight.getW(i);
                    scale = 1.0 / vec.manhattanLength();
                    if (scale !== Infinity) {
                        vec.multiplyScalar(scale);
                    } else {
                        vec.set(1, 0, 0, 0);
                    }
                    skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
                }
            }
        },
        updateMatrixWorld: function(force) {
            Mesh.prototype.updateMatrixWorld.call(this, force);
            if (this.bindMode === 'attached') {
                this.bindMatrixInverse.getInverse(this.matrixWorld);
            } else if (this.bindMode === 'detached') {
                this.bindMatrixInverse.getInverse(this.bindMatrix);
            } else {
                console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
            }
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });

    function LineBasicMaterial(parameters) {
        Material.call(this);
        this.type = 'LineBasicMaterial';
        this.color = new Color(0xffffff);
        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';
        this.lights = false;
        this.setValues(parameters);
    }
    LineBasicMaterial.prototype = Object.create(Material.prototype);
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    LineBasicMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        return this;
    };

    function Line(geometry, material, mode) {
        if (mode === 1) {
            console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
            return new LineSegments(geometry, material);
        }
        Object3D.call(this);
        this.type = 'Line';
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new LineBasicMaterial({
            color: Math.random() * 0xffffff
        });
    }
    Line.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Line,
        isLine: true,
        raycast: (function() {
            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();
            return function raycast(raycaster, intersects) {
                var precision = raycaster.linePrecision;
                var precisionSq = precision * precision;
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                if (raycaster.ray.intersectsSphere(sphere) === false) return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                var vStart = new Vector3();
                var vEnd = new Vector3();
                var interSegment = new Vector3();
                var interRay = new Vector3();
                var step = (this && this.isLineSegments) ? 2 : 1;
                if (geometry.isBufferGeometry) {
                    var index = geometry.index;
                    var attributes = geometry.attributes;
                    var positions = attributes.position.array;
                    if (index !== null) {
                        var indices = index.array;
                        for (var i = 0, l = indices.length - 1; i < l; i += step) {
                            var a = indices[i];
                            var b = indices[i + 1];
                            vStart.fromArray(positions, a * 3);
                            vEnd.fromArray(positions, b * 3);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (distSq > precisionSq) continue;
                            interRay.applyMatrix4(this.matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(interRay);
                            if (distance < raycaster.near || distance > raycaster.far) continue;
                            intersects.push({
                                distance: distance,
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            });
                        }
                    } else {
                        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                            vStart.fromArray(positions, 3 * i);
                            vEnd.fromArray(positions, 3 * i + 3);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (distSq > precisionSq) continue;
                            interRay.applyMatrix4(this.matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(interRay);
                            if (distance < raycaster.near || distance > raycaster.far) continue;
                            intersects.push({
                                distance: distance,
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            });
                        }
                    }
                } else if (geometry.isGeometry) {
                    var vertices = geometry.vertices;
                    var nbVertices = vertices.length;
                    for (var i = 0; i < nbVertices - 1; i += step) {
                        var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                        if (distSq > precisionSq) continue;
                        interRay.applyMatrix4(this.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far) continue;
                        intersects.push({
                            distance: distance,
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                }
            };
        }()),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });

    function LineSegments(geometry, material) {
        Line.call(this, geometry, material);
        this.type = 'LineSegments';
    }
    LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineSegments,
        isLineSegments: true
    });

    function LineLoop(geometry, material) {
        Line.call(this, geometry, material);
        this.type = 'LineLoop';
    }
    LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineLoop,
        isLineLoop: true,
    });

    function PointsMaterial(parameters) {
        Material.call(this);
        this.type = 'PointsMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.lights = false;
        this.setValues(parameters);
    }
    PointsMaterial.prototype = Object.create(Material.prototype);
    PointsMaterial.prototype.constructor = PointsMaterial;
    PointsMaterial.prototype.isPointsMaterial = true;
    PointsMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
    };

    function Points(geometry, material) {
        Object3D.call(this);
        this.type = 'Points';
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new PointsMaterial({
            color: Math.random() * 0xffffff
        });
    }
    Points.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Points,
        isPoints: true,
        raycast: (function() {
            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();
            return function raycast(raycaster, intersects) {
                var object = this;
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                var threshold = raycaster.params.Points.threshold;
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                sphere.radius += threshold;
                if (raycaster.ray.intersectsSphere(sphere) === false) return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                var localThresholdSq = localThreshold * localThreshold;
                var position = new Vector3();

                function testPoint(point, index) {
                    var rayPointDistanceSq = ray.distanceSqToPoint(point);
                    if (rayPointDistanceSq < localThresholdSq) {
                        var intersectPoint = ray.closestPointToPoint(point);
                        intersectPoint.applyMatrix4(matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far) return;
                        intersects.push({
                            distance: distance,
                            distanceToRay: Math.sqrt(rayPointDistanceSq),
                            point: intersectPoint.clone(),
                            index: index,
                            face: null,
                            object: object
                        });
                    }
                }
                if (geometry.isBufferGeometry) {
                    var index = geometry.index;
                    var attributes = geometry.attributes;
                    var positions = attributes.position.array;
                    if (index !== null) {
                        var indices = index.array;
                        for (var i = 0, il = indices.length; i < il; i++) {
                            var a = indices[i];
                            position.fromArray(positions, a * 3);
                            testPoint(position, a);
                        }
                    } else {
                        for (var i = 0, l = positions.length / 3; i < l; i++) {
                            position.fromArray(positions, i * 3);
                            testPoint(position, i);
                        }
                    }
                } else {
                    var vertices = geometry.vertices;
                    for (var i = 0, l = vertices.length; i < l; i++) {
                        testPoint(vertices[i], i);
                    }
                }
            };
        }()),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });

    function Group() {
        Object3D.call(this);
        this.type = 'Group';
    }
    Group.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Group,
        isGroup: true
    });

    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.generateMipmaps = false;
        var scope = this;

        function onLoaded() {
            video.removeEventListener('loadeddata', onLoaded, false);
            scope.needsUpdate = true;
        }
        video.addEventListener('loadeddata', onLoaded, false);
    }
    VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
        constructor: VideoTexture,
        isVideoTexture: true,
        update: function() {
            var video = this.image;
            if (video.readyState >= video.HAVE_CURRENT_DATA) {
                this.needsUpdate = true;
            }
        }
    });

    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = {
            width: width,
            height: height
        };
        this.mipmaps = mipmaps;
        this.flipY = false;
        this.generateMipmaps = false;
    }
    CompressedTexture.prototype = Object.create(Texture.prototype);
    CompressedTexture.prototype.constructor = CompressedTexture;
    CompressedTexture.prototype.isCompressedTexture = true;

    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        format = format !== undefined ? format : DepthFormat;
        if (format !== DepthFormat && format !== DepthStencilFormat) {
            throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
        }
        if (type === undefined && format === DepthFormat) type = UnsignedShortType;
        if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.image = {
            width: width,
            height: height
        };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.flipY = false;
        this.generateMipmaps = false;
    }
    DepthTexture.prototype = Object.create(Texture.prototype);
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;

    function WireframeGeometry(geometry) {
        BufferGeometry.call(this);
        this.type = 'WireframeGeometry';
        var vertices = [];
        var i, j, l, o, ol;
        var edge = [0, 0],
            edges = {},
            e, edge1, edge2;
        var key, keys = ['a', 'b', 'c'];
        var vertex;
        if (geometry && geometry.isGeometry) {
            var faces = geometry.faces;
            for (i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                for (j = 0; j < 3; j++) {
                    edge1 = face[keys[j]];
                    edge2 = face[keys[(j + 1) % 3]];
                    edge[0] = Math.min(edge1, edge2);
                    edge[1] = Math.max(edge1, edge2);
                    key = edge[0] + ',' + edge[1];
                    if (edges[key] === undefined) {
                        edges[key] = {
                            index1: edge[0],
                            index2: edge[1]
                        };
                    }
                }
            }
            for (key in edges) {
                e = edges[key];
                vertex = geometry.vertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z);
                vertex = geometry.vertices[e.index2];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        } else if (geometry && geometry.isBufferGeometry) {
            var position, indices, groups;
            var group, start, count;
            var index1, index2;
            vertex = new Vector3();
            if (geometry.index !== null) {
                position = geometry.attributes.position;
                indices = geometry.index;
                groups = geometry.groups;
                if (groups.length === 0) {
                    groups = [{
                        start: 0,
                        count: indices.count,
                        materialIndex: 0
                    }];
                }
                for (o = 0, ol = groups.length; o < ol; ++o) {
                    group = groups[o];
                    start = group.start;
                    count = group.count;
                    for (i = start, l = (start + count); i < l; i += 3) {
                        for (j = 0; j < 3; j++) {
                            edge1 = indices.getX(i + j);
                            edge2 = indices.getX(i + (j + 1) % 3);
                            edge[0] = Math.min(edge1, edge2);
                            edge[1] = Math.max(edge1, edge2);
                            key = edge[0] + ',' + edge[1];
                            if (edges[key] === undefined) {
                                edges[key] = {
                                    index1: edge[0],
                                    index2: edge[1]
                                };
                            }
                        }
                    }
                }
                for (key in edges) {
                    e = edges[key];
                    vertex.fromBufferAttribute(position, e.index1);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    vertex.fromBufferAttribute(position, e.index2);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            } else {
                position = geometry.attributes.position;
                for (i = 0, l = (position.count / 3); i < l; i++) {
                    for (j = 0; j < 3; j++) {
                        index1 = 3 * i + j;
                        vertex.fromBufferAttribute(position, index1);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        index2 = 3 * i + ((j + 1) % 3);
                        vertex.fromBufferAttribute(position, index2);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                    }
                }
            }
        }
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
    }
    WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
    WireframeGeometry.prototype.constructor = WireframeGeometry;

    function ParametricGeometry(func, slices, stacks) {
        Geometry.call(this);
        this.type = 'ParametricGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
        this.mergeVertices();
    }
    ParametricGeometry.prototype = Object.create(Geometry.prototype);
    ParametricGeometry.prototype.constructor = ParametricGeometry;

    function ParametricBufferGeometry(func, slices, stacks) {
        BufferGeometry.call(this);
        this.type = 'ParametricBufferGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var EPS = 0.00001;
        var normal = new Vector3();
        var p0 = new Vector3(),
            p1 = new Vector3();
        var pu = new Vector3(),
            pv = new Vector3();
        var i, j;
        var sliceCount = slices + 1;
        for (i = 0; i <= stacks; i++) {
            var v = i / stacks;
            for (j = 0; j <= slices; j++) {
                var u = j / slices;
                p0 = func(u, v, p0);
                vertices.push(p0.x, p0.y, p0.z);
                if (u - EPS >= 0) {
                    p1 = func(u - EPS, v, p1);
                    pu.subVectors(p0, p1);
                } else {
                    p1 = func(u + EPS, v, p1);
                    pu.subVectors(p1, p0);
                }
                if (v - EPS >= 0) {
                    p1 = func(u, v - EPS, p1);
                    pv.subVectors(p0, p1);
                } else {
                    p1 = func(u, v + EPS, p1);
                    pv.subVectors(p1, p0);
                }
                normal.crossVectors(pu, pv).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u, v);
            }
        }
        for (i = 0; i < stacks; i++) {
            for (j = 0; j < slices; j++) {
                var a = i * sliceCount + j;
                var b = i * sliceCount + j + 1;
                var c = (i + 1) * sliceCount + j + 1;
                var d = (i + 1) * sliceCount + j;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

    function PolyhedronGeometry(vertices, indices, radius, detail) {
        Geometry.call(this);
        this.type = 'PolyhedronGeometry';
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
        this.mergeVertices();
    }
    PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
        BufferGeometry.call(this);
        this.type = 'PolyhedronBufferGeometry';
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
        radius = radius || 1;
        detail = detail || 0;
        var vertexBuffer = [];
        var uvBuffer = [];
        subdivide(detail);
        appplyRadius(radius);
        generateUVs();
        this.addAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
        this.addAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
        if (detail === 0) {
            this.computeVertexNormals();
        } else {
            this.normalizeNormals();
        }

        function subdivide(detail) {
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
            for (var i = 0; i < indices.length; i += 3) {
                getVertexByIndex(indices[i + 0], a);
                getVertexByIndex(indices[i + 1], b);
                getVertexByIndex(indices[i + 2], c);
                subdivideFace(a, b, c, detail);
            }
        }

        function subdivideFace(a, b, c, detail) {
            var cols = Math.pow(2, detail);
            var v = [];
            var i, j;
            for (i = 0; i <= cols; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols);
                var bj = b.clone().lerp(c, i / cols);
                var rows = cols - i;
                for (j = 0; j <= rows; j++) {
                    if (j === 0 && i === cols) {
                        v[i][j] = aj;
                    } else {
                        v[i][j] = aj.clone().lerp(bj, j / rows);
                    }
                }
            }
            for (i = 0; i < cols; i++) {
                for (j = 0; j < 2 * (cols - i) - 1; j++) {
                    var k = Math.floor(j / 2);
                    if (j % 2 === 0) {
                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k]);
                        pushVertex(v[i][k]);
                    } else {
                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k + 1]);
                        pushVertex(v[i + 1][k]);
                    }
                }
            }
        }

        function appplyRadius(radius) {
            var vertex = new Vector3();
            for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                vertex.normalize().multiplyScalar(radius);
                vertexBuffer[i + 0] = vertex.x;
                vertexBuffer[i + 1] = vertex.y;
                vertexBuffer[i + 2] = vertex.z;
            }
        }

        function generateUVs() {
            var vertex = new Vector3();
            for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                var v = inclination(vertex) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }

        function correctSeam() {
            for (var i = 0; i < uvBuffer.length; i += 6) {
                var x0 = uvBuffer[i + 0];
                var x1 = uvBuffer[i + 2];
                var x2 = uvBuffer[i + 4];
                var max = Math.max(x0, x1, x2);
                var min = Math.min(x0, x1, x2);
                if (max > 0.9 && min < 0.1) {
                    if (x0 < 0.2) uvBuffer[i + 0] += 1;
                    if (x1 < 0.2) uvBuffer[i + 2] += 1;
                    if (x2 < 0.2) uvBuffer[i + 4] += 1;
                }
            }
        }

        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }

        function getVertexByIndex(index, vertex) {
            var stride = index * 3;
            vertex.x = vertices[stride + 0];
            vertex.y = vertices[stride + 1];
            vertex.z = vertices[stride + 2];
        }

        function correctUVs() {
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
            var centroid = new Vector3();
            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();
            for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a).add(b).add(c).divideScalar(3);
                var azi = azimuth(centroid);
                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
            }
        }

        function correctUV(uv, stride, vector, azimuth) {
            if ((azimuth < 0) && (uv.x === 1)) {
                uvBuffer[stride] = uv.x - 1;
            }
            if ((vector.x === 0) && (vector.z === 0)) {
                uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
            }
        }

        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }

        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
        }
    }
    PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

    function TetrahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'TetrahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

    function TetrahedronBufferGeometry(radius, detail) {
        var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
        var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'TetrahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

    function OctahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'OctahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    OctahedronGeometry.prototype = Object.create(Geometry.prototype);
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;

    function OctahedronBufferGeometry(radius, detail) {
        var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
        var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'OctahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

    function IcosahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'IcosahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

    function IcosahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2;
        var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
        var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'IcosahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

    function DodecahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'DodecahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

    function DodecahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2;
        var r = 1 / t;
        var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
        var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'DodecahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
        Geometry.call(this);
        this.type = 'TubeGeometry';
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');
        var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
        this.tangents = bufferGeometry.tangents;
        this.normals = bufferGeometry.normals;
        this.binormals = bufferGeometry.binormals;
        this.fromBufferGeometry(bufferGeometry);
        this.mergeVertices();
    }
    TubeGeometry.prototype = Object.create(Geometry.prototype);
    TubeGeometry.prototype.constructor = TubeGeometry;

    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
        BufferGeometry.call(this);
        this.type = 'TubeBufferGeometry';
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        tubularSegments = tubularSegments || 64;
        radius = radius || 1;
        radialSegments = radialSegments || 8;
        closed = closed || false;
        var frames = path.computeFrenetFrames(tubularSegments, closed);
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        var vertex = new Vector3();
        var normal = new Vector3();
        var uv = new Vector2();
        var P = new Vector3();
        var i, j;
        var vertices = [];
        var normals = [];
        var uvs = [];
        var indices = [];
        generateBufferData();
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        function generateBufferData() {
            for (i = 0; i < tubularSegments; i++) {
                generateSegment(i);
            }
            generateSegment((closed === false) ? tubularSegments : 0);
            generateUVs();
            generateIndices();
        }

        function generateSegment(i) {
            P = path.getPointAt(i / tubularSegments, P);
            var N = frames.normals[i];
            var B = frames.binormals[i];
            for (j = 0; j <= radialSegments; j++) {
                var v = j / radialSegments * Math.PI * 2;
                var sin = Math.sin(v);
                var cos = -Math.cos(v);
                normal.x = (cos * N.x + sin * B.x);
                normal.y = (cos * N.y + sin * B.y);
                normal.z = (cos * N.z + sin * B.z);
                normal.normalize();
                normals.push(normal.x, normal.y, normal.z);
                vertex.x = P.x + radius * normal.x;
                vertex.y = P.y + radius * normal.y;
                vertex.z = P.z + radius * normal.z;
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }

        function generateIndices() {
            for (j = 1; j <= tubularSegments; j++) {
                for (i = 1; i <= radialSegments; i++) {
                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
                    var b = (radialSegments + 1) * j + (i - 1);
                    var c = (radialSegments + 1) * j + i;
                    var d = (radialSegments + 1) * (j - 1) + i;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
        }

        function generateUVs() {
            for (i = 0; i <= tubularSegments; i++) {
                for (j = 0; j <= radialSegments; j++) {
                    uv.x = i / tubularSegments;
                    uv.y = j / radialSegments;
                    uvs.push(uv.x, uv.y);
                }
            }
        }
    }
    TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
        Geometry.call(this);
        this.type = 'TorusKnotGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
        if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
        this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
        this.mergeVertices();
    }
    TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
        BufferGeometry.call(this);
        this.type = 'TorusKnotBufferGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
        radius = radius || 1;
        tube = tube || 0.4;
        tubularSegments = Math.floor(tubularSegments) || 64;
        radialSegments = Math.floor(radialSegments) || 8;
        p = p || 2;
        q = q || 3;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var i, j;
        var vertex = new Vector3();
        var normal = new Vector3();
        var P1 = new Vector3();
        var P2 = new Vector3();
        var B = new Vector3();
        var T = new Vector3();
        var N = new Vector3();
        for (i = 0; i <= tubularSegments; ++i) {
            var u = i / tubularSegments * p * Math.PI * 2;
            calculatePositionOnCurve(u, p, q, radius, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            B.normalize();
            N.normalize();
            for (j = 0; j <= radialSegments; ++j) {
                var v = j / radialSegments * Math.PI * 2;
                var cx = -tube * Math.cos(v);
                var cy = tube * Math.sin(v);
                vertex.x = P1.x + (cx * N.x + cy * B.x);
                vertex.y = P1.y + (cx * N.y + cy * B.y);
                vertex.z = P1.z + (cx * N.z + cy * B.z);
                vertices.push(vertex.x, vertex.y, vertex.z);
                normal.subVectors(vertex, P1).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }
        for (j = 1; j <= tubularSegments; j++) {
            for (i = 1; i <= radialSegments; i++) {
                var a = (radialSegments + 1) * (j - 1) + (i - 1);
                var b = (radialSegments + 1) * j + (i - 1);
                var c = (radialSegments + 1) * j + i;
                var d = (radialSegments + 1) * (j - 1) + i;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        function calculatePositionOnCurve(u, p, q, radius, position) {
            var cu = Math.cos(u);
            var su = Math.sin(u);
            var quOverP = q / p * u;
            var cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * 0.5 * cu;
            position.y = radius * (2 + cs) * su * 0.5;
            position.z = radius * Math.sin(quOverP) * 0.5;
        }
    }
    TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        Geometry.call(this);
        this.type = 'TorusGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
        this.mergeVertices();
    }
    TorusGeometry.prototype = Object.create(Geometry.prototype);
    TorusGeometry.prototype.constructor = TorusGeometry;

    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        BufferGeometry.call(this);
        this.type = 'TorusBufferGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        radius = radius || 1;
        tube = tube || 0.4;
        radialSegments = Math.floor(radialSegments) || 8;
        tubularSegments = Math.floor(tubularSegments) || 6;
        arc = arc || Math.PI * 2;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var center = new Vector3();
        var vertex = new Vector3();
        var normal = new Vector3();
        var j, i;
        for (j = 0; j <= radialSegments; j++) {
            for (i = 0; i <= tubularSegments; i++) {
                var u = i / tubularSegments * arc;
                var v = j / radialSegments * Math.PI * 2;
                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                vertex.z = tube * Math.sin(v);
                vertices.push(vertex.x, vertex.y, vertex.z);
                center.x = radius * Math.cos(u);
                center.y = radius * Math.sin(u);
                normal.subVectors(vertex, center).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }
        for (j = 1; j <= radialSegments; j++) {
            for (i = 1; i <= tubularSegments; i++) {
                var a = (tubularSegments + 1) * j + i - 1;
                var b = (tubularSegments + 1) * (j - 1) + i - 1;
                var c = (tubularSegments + 1) * (j - 1) + i;
                var d = (tubularSegments + 1) * j + i;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
    var Earcut = {
        triangulate: function(data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length,
                outerLen = hasHoles ? holeIndices[0] * dim : data.length,
                outerNode = linkedList(data, 0, outerLen, dim, true),
                triangles = [];
            if (!outerNode) return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                    x = data[i];
                    y = data[i + 1];
                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                }
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
        }
    };

    function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
        } else {
            for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }
        return last;
    }

    function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;
        var p = start,
            again;
        do {
            again = false;
            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next) break;
                again = true;
            } else {
                p = p.next;
            }
        } while (again || p !== end);
        return end;
    }

    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) return;
        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
        var stop = ear,
            prev, next;
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                removeNode(ear);
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            if (ear === stop) {
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                } else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
            }
        }
    }

    function isEar(ear) {
        var a = ear.prev,
            b = ear,
            c = ear.next;
        if (area(a, b, c) >= 0) return false;
        var p = ear.next.next;
        while (p !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.next;
        }
        return true;
    }

    function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev,
            b = ear,
            c = ear.next;
        if (area(a, b, c) >= 0) return false;
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
            minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
            maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
            maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        var minZ = zOrder(minTX, minTY, minX, minY, invSize),
            maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.nextZ;
        while (p && p.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.nextZ;
        }
        p = ear.prevZ;
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
            p = p.prevZ;
        }
        return true;
    }

    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev,
                b = p.next.next;
            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                removeNode(p);
                removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
        return p;
    }

    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    var c = splitPolygon(a, b);
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    earcutLinked(a, triangles, dim, minX, minY, invSize);
                    earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }

    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [],
            i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next) list.steiner = true;
            queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }

    function compareX(a, b) {
        return a.x - b.x;
    }

    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }

    function findHoleBridge(hole, outerNode) {
        var p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = -Infinity,
            m;
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) return p;
                        if (hy === p.next.y) return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m) return null;
        if (hx === qx) return m.prev;
        var stop = m,
            mx = m.x,
            my = m.y,
            tanMin = Infinity,
            tan;
        p = m.next;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x);
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }
        return m;
    }

    function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
    }

    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) break;
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail) tail.nextZ = e;
                    else list = e;
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }

    function zOrder(x, y, minX, minY, invSize) {
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }

    function getLeftmost(start) {
        var p = start,
            leftmost = start;
        do {
            if (p.x < leftmost.x) leftmost = p;
            p = p.next;
        } while (p !== start);
        return leftmost;
    }

    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }

    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }

    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }

    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }

    function intersects(p1, q1, p2, q2) {
        if ((equals(p1, q1) && equals(p2, q2)) || (equals(p1, q2) && equals(p2, q1))) return true;
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }

    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
                return true;
            }
            p = p.next;
        } while (p !== a);
        return false;
    }

    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }

    function middleInside(a, b) {
        var p = a,
            inside = false,
            px = (a.x + b.x) / 2,
            py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
                inside = !inside;
            }
            p = p.next;
        } while (p !== a);
        return inside;
    }

    function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y),
            b2 = new Node(b.i, b.x, b.y),
            an = a.next,
            bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }

    function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }

    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
    }

    function Node(i, x, y) {
        this.i = i;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
    }

    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    var ShapeUtils = {
        area: function(contour) {
            var n = contour.length;
            var a = 0.0;
            for (var p = n - 1, q = 0; q < n; p = q++) {
                a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            }
            return a * 0.5;
        },
        isClockWise: function(pts) {
            return ShapeUtils.area(pts) < 0;
        },
        triangulateShape: function(contour, holes) {
            function removeDupEndPts(points) {
                var l = points.length;
                if (l > 2 && points[l - 1].equals(points[0])) {
                    points.pop();
                }
            }

            function addContour(vertices, contour) {
                for (var i = 0; i < contour.length; i++) {
                    vertices.push(contour[i].x);
                    vertices.push(contour[i].y);
                }
            }
            var vertices = [];
            var holeIndices = [];
            var faces = [];
            removeDupEndPts(contour);
            addContour(vertices, contour);
            var holeIndex = contour.length;
            holes.forEach(removeDupEndPts);
            for (i = 0; i < holes.length; i++) {
                holeIndices.push(holeIndex);
                holeIndex += holes[i].length;
                addContour(vertices, holes[i]);
            }
            var triangles = Earcut.triangulate(vertices, holeIndices);
            for (var i = 0; i < triangles.length; i += 3) {
                faces.push(triangles.slice(i, i + 3));
            }
            return faces;
        }
    };

    function ExtrudeGeometry(shapes, options) {
        Geometry.call(this);
        this.type = 'ExtrudeGeometry';
        this.parameters = {
            shapes: shapes,
            options: options
        };
        this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
        this.mergeVertices();
    }
    ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

    function ExtrudeBufferGeometry(shapes, options) {
        if (typeof(shapes) === "undefined") {
            return;
        }
        BufferGeometry.call(this);
        this.type = 'ExtrudeBufferGeometry';
        shapes = Array.isArray(shapes) ? shapes : [shapes];
        this.addShapeList(shapes, options);
        this.computeVertexNormals();
    }
    ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
    ExtrudeBufferGeometry.prototype.getArrays = function() {
        var positionAttribute = this.getAttribute("position");
        var verticesArray = positionAttribute ? Array.prototype.slice.call(positionAttribute.array) : [];
        var uvAttribute = this.getAttribute("uv");
        var uvArray = uvAttribute ? Array.prototype.slice.call(uvAttribute.array) : [];
        var IndexAttribute = this.index;
        var indicesArray = IndexAttribute ? Array.prototype.slice.call(IndexAttribute.array) : [];
        return {
            position: verticesArray,
            uv: uvArray,
            index: indicesArray
        };
    };
    ExtrudeBufferGeometry.prototype.addShapeList = function(shapes, options) {
        var sl = shapes.length;
        options.arrays = this.getArrays();
        for (var s = 0; s < sl; s++) {
            var shape = shapes[s];
            this.addShape(shape, options);
        }
        this.setIndex(options.arrays.index);
        this.addAttribute('position', new Float32BufferAttribute(options.arrays.position, 3));
        this.addAttribute('uv', new Float32BufferAttribute(options.arrays.uv, 2));
    };
    ExtrudeBufferGeometry.prototype.addShape = function(shape, options) {
        var arrays = options.arrays ? options.arrays : this.getArrays();
        var verticesArray = arrays.position;
        var indicesArray = arrays.index;
        var uvArray = arrays.uv;
        var placeholder = [];
        var amount = options.amount !== undefined ? options.amount : 100;
        var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
        var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
        var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
        var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
        var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
        var steps = options.steps !== undefined ? options.steps : 1;
        var extrudePath = options.extrudePath;
        var extrudePts, extrudeByPath = false;
        var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
        var splineTube, binormal, normal, position2;
        if (extrudePath) {
            extrudePts = extrudePath.getSpacedPoints(steps);
            extrudeByPath = true;
            bevelEnabled = false;
            splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames(steps, false);
            binormal = new Vector3();
            normal = new Vector3();
            position2 = new Vector3();
        }
        if (!bevelEnabled) {
            bevelSegments = 0;
            bevelThickness = 0;
            bevelSize = 0;
        }
        var ahole, h, hl;
        var scope = this;
        var shapePoints = shape.extractPoints(curveSegments);
        var vertices = shapePoints.shape;
        var holes = shapePoints.holes;
        var reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
            vertices = vertices.reverse();
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                if (ShapeUtils.isClockWise(ahole)) {
                    holes[h] = ahole.reverse();
                }
            }
        }
        var faces = ShapeUtils.triangulateShape(vertices, holes);
        var contour = vertices;
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            vertices = vertices.concat(ahole);
        }

        function scalePt2(pt, vec, size) {
            if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
            return vec.clone().multiplyScalar(size).add(pt);
        }
        var b, bs, t, z, vert, vlen = vertices.length,
            face, flen = faces.length;

        function getBevelVec(inPt, inPrev, inNext) {
            var v_trans_x, v_trans_y, shrink_by;
            var v_prev_x = inPt.x - inPrev.x,
                v_prev_y = inPt.y - inPrev.y;
            var v_next_x = inNext.x - inPt.x,
                v_next_y = inNext.y - inPt.y;
            var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
            var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
            if (Math.abs(collinear0) > Number.EPSILON) {
                var v_prev_len = Math.sqrt(v_prev_lensq);
                var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
                var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
                var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                    (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
                var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                if (v_trans_lensq <= 2) {
                    return new Vector2(v_trans_x, v_trans_y);
                } else {
                    shrink_by = Math.sqrt(v_trans_lensq / 2);
                }
            } else {
                var direction_eq = false;
                if (v_prev_x > Number.EPSILON) {
                    if (v_next_x > Number.EPSILON) {
                        direction_eq = true;
                    }
                } else {
                    if (v_prev_x < -Number.EPSILON) {
                        if (v_next_x < -Number.EPSILON) {
                            direction_eq = true;
                        }
                    } else {
                        if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                            direction_eq = true;
                        }
                    }
                }
                if (direction_eq) {
                    v_trans_x = -v_prev_y;
                    v_trans_y = v_prev_x;
                    shrink_by = Math.sqrt(v_prev_lensq);
                } else {
                    v_trans_x = v_prev_x;
                    v_trans_y = v_prev_y;
                    shrink_by = Math.sqrt(v_prev_lensq / 2);
                }
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        var contourMovements = [];
        for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
            if (j === il) j = 0;
            if (k === il) k = 0;
            contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
        }
        var holesMovements = [],
            oneHoleMovements, verticesMovements = contourMovements.concat();
        for (h = 0, hl = holes.length; h < hl; h++) {
            ahole = holes[h];
            oneHoleMovements = [];
            for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                if (j === il) j = 0;
                if (k === il) k = 0;
                oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
            }
            holesMovements.push(oneHoleMovements);
            verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        for (b = 0; b < bevelSegments; b++) {
            t = b / bevelSegments;
            z = bevelThickness * Math.cos(t * Math.PI / 2);
            bs = bevelSize * Math.sin(t * Math.PI / 2);
            for (i = 0, il = contour.length; i < il; i++) {
                vert = scalePt2(contour[i], contourMovements[i], bs);
                v(vert.x, vert.y, -z);
            }
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (i = 0, il = ahole.length; i < il; i++) {
                    vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                    v(vert.x, vert.y, -z);
                }
            }
        }
        bs = bevelSize;
        for (i = 0; i < vlen; i++) {
            vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
            if (!extrudeByPath) {
                v(vert.x, vert.y, 0);
            } else {
                normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                position2.copy(extrudePts[0]).add(normal).add(binormal);
                v(position2.x, position2.y, position2.z);
            }
        }
        var s;
        for (s = 1; s <= steps; s++) {
            for (i = 0; i < vlen; i++) {
                vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                if (!extrudeByPath) {
                    v(vert.x, vert.y, amount / steps * s);
                } else {
                    normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[s]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
        }
        for (b = bevelSegments - 1; b >= 0; b--) {
            t = b / bevelSegments;
            z = bevelThickness * Math.cos(t * Math.PI / 2);
            bs = bevelSize * Math.sin(t * Math.PI / 2);
            for (i = 0, il = contour.length; i < il; i++) {
                vert = scalePt2(contour[i], contourMovements[i], bs);
                v(vert.x, vert.y, amount + z);
            }
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                oneHoleMovements = holesMovements[h];
                for (i = 0, il = ahole.length; i < il; i++) {
                    vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                    if (!extrudeByPath) {
                        v(vert.x, vert.y, amount + z);
                    } else {
                        v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                    }
                }
            }
        }
        buildLidFaces();
        buildSideFaces();

        function buildLidFaces() {
            var start = verticesArray.length / 3;
            if (bevelEnabled) {
                var layer = 0;
                var offset = vlen * layer;
                for (i = 0; i < flen; i++) {
                    face = faces[i];
                    f3(face[2] + offset, face[1] + offset, face[0] + offset);
                }
                layer = steps + bevelSegments * 2;
                offset = vlen * layer;
                for (i = 0; i < flen; i++) {
                    face = faces[i];
                    f3(face[0] + offset, face[1] + offset, face[2] + offset);
                }
            } else {
                for (i = 0; i < flen; i++) {
                    face = faces[i];
                    f3(face[2], face[1], face[0]);
                }
                for (i = 0; i < flen; i++) {
                    face = faces[i];
                    f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                }
            }
            scope.addGroup(start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0);
        }

        function buildSideFaces() {
            var start = verticesArray.length / 3;
            var layeroffset = 0;
            sidewalls(contour, layeroffset);
            layeroffset += contour.length;
            for (h = 0, hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                sidewalls(ahole, layeroffset);
                layeroffset += ahole.length;
            }
            scope.addGroup(start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1);
        }

        function sidewalls(contour, layeroffset) {
            var j, k;
            i = contour.length;
            while (--i >= 0) {
                j = i;
                k = i - 1;
                if (k < 0) k = contour.length - 1;
                var s = 0,
                    sl = steps + bevelSegments * 2;
                for (s = 0; s < sl; s++) {
                    var slen1 = vlen * s;
                    var slen2 = vlen * (s + 1);
                    var a = layeroffset + j + slen1,
                        b = layeroffset + k + slen1,
                        c = layeroffset + k + slen2,
                        d = layeroffset + j + slen2;
                    f4(a, b, c, d);
                }
            }
        }

        function v(x, y, z) {
            placeholder.push(x);
            placeholder.push(y);
            placeholder.push(z);
        }

        function f3(a, b, c) {
            addVertex(a);
            addVertex(b);
            addVertex(c);
            var nextIndex = verticesArray.length / 3;
            var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[2]);
        }

        function f4(a, b, c, d) {
            addVertex(a);
            addVertex(b);
            addVertex(d);
            addVertex(b);
            addVertex(c);
            addVertex(d);
            var nextIndex = verticesArray.length / 3;
            var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[3]);
            addUV(uvs[1]);
            addUV(uvs[2]);
            addUV(uvs[3]);
        }

        function addVertex(index) {
            indicesArray.push(verticesArray.length / 3);
            verticesArray.push(placeholder[index * 3 + 0]);
            verticesArray.push(placeholder[index * 3 + 1]);
            verticesArray.push(placeholder[index * 3 + 2]);
        }

        function addUV(vector2) {
            uvArray.push(vector2.x);
            uvArray.push(vector2.y);
        }
        if (!options.arrays) {
            this.setIndex(indicesArray);
            this.addAttribute('position', new Float32BufferAttribute(verticesArray, 3));
            this.addAttribute('uv', new Float32BufferAttribute(uvArray, 2));
        }
    };
    ExtrudeGeometry.WorldUVGenerator = {
        generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
        },
        generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var a_z = vertices[indexA * 3 + 2];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var b_z = vertices[indexB * 3 + 2];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            var c_z = vertices[indexC * 3 + 2];
            var d_x = vertices[indexD * 3];
            var d_y = vertices[indexD * 3 + 1];
            var d_z = vertices[indexD * 3 + 2];
            if (Math.abs(a_y - b_y) < 0.01) {
                return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
            } else {
                return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
            }
        }
    };

    function TextGeometry(text, parameters) {
        Geometry.call(this);
        this.type = 'TextGeometry';
        this.parameters = {
            text: text,
            parameters: parameters
        };
        this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
        this.mergeVertices();
    }
    TextGeometry.prototype = Object.create(Geometry.prototype);
    TextGeometry.prototype.constructor = TextGeometry;

    function TextBufferGeometry(text, parameters) {
        parameters = parameters || {};
        var font = parameters.font;
        if (!(font && font.isFont)) {
            console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
            return new Geometry();
        }
        var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
        parameters.amount = parameters.height !== undefined ? parameters.height : 50;
        if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
        if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
        if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
        ExtrudeBufferGeometry.call(this, shapes, parameters);
        this.type = 'TextBufferGeometry';
    }
    TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
    TextBufferGeometry.prototype.constructor = TextBufferGeometry;

    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'SphereGeometry';
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
        this.mergeVertices();
    }
    SphereGeometry.prototype = Object.create(Geometry.prototype);
    SphereGeometry.prototype.constructor = SphereGeometry;

    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'SphereBufferGeometry';
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius = radius || 1;
        widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
        heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
        phiStart = phiStart !== undefined ? phiStart : 0;
        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
        var thetaEnd = thetaStart + thetaLength;
        var ix, iy;
        var index = 0;
        var grid = [];
        var vertex = new Vector3();
        var normal = new Vector3();
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        for (iy = 0; iy <= heightSegments; iy++) {
            var verticesRow = [];
            var v = iy / heightSegments;
            for (ix = 0; ix <= widthSegments; ix++) {
                var u = ix / widthSegments;
                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertices.push(vertex.x, vertex.y, vertex.z);
                normal.set(vertex.x, vertex.y, vertex.z).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u, 1 - v);
                verticesRow.push(index++);
            }
            grid.push(verticesRow);
        }
        for (iy = 0; iy < heightSegments; iy++) {
            for (ix = 0; ix < widthSegments; ix++) {
                var a = grid[iy][ix + 1];
                var b = grid[iy][ix];
                var c = grid[iy + 1][ix];
                var d = grid[iy + 1][ix + 1];
                if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
                if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
        this.mergeVertices();
    }
    RingGeometry.prototype = Object.create(Geometry.prototype);
    RingGeometry.prototype.constructor = RingGeometry;

    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'RingBufferGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        innerRadius = innerRadius || 0.5;
        outerRadius = outerRadius || 1;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
        phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var segment;
        var radius = innerRadius;
        var radiusStep = ((outerRadius - innerRadius) / phiSegments);
        var vertex = new Vector3();
        var uv = new Vector2();
        var j, i;
        for (j = 0; j <= phiSegments; j++) {
            for (i = 0; i <= thetaSegments; i++) {
                segment = thetaStart + i / thetaSegments * thetaLength;
                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.push(vertex.x, vertex.y, vertex.z);
                normals.push(0, 0, 1);
                uv.x = (vertex.x / outerRadius + 1) / 2;
                uv.y = (vertex.y / outerRadius + 1) / 2;
                uvs.push(uv.x, uv.y);
            }
            radius += radiusStep;
        }
        for (j = 0; j < phiSegments; j++) {
            var thetaSegmentLevel = j * (thetaSegments + 1);
            for (i = 0; i < thetaSegments; i++) {
                segment = i + thetaSegmentLevel;
                var a = segment;
                var b = segment + thetaSegments + 1;
                var c = segment + thetaSegments + 2;
                var d = segment + 1;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;

    function LatheGeometry(points, segments, phiStart, phiLength) {
        Geometry.call(this);
        this.type = 'LatheGeometry';
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
        this.mergeVertices();
    }
    LatheGeometry.prototype = Object.create(Geometry.prototype);
    LatheGeometry.prototype.constructor = LatheGeometry;

    function LatheBufferGeometry(points, segments, phiStart, phiLength) {
        BufferGeometry.call(this);
        this.type = 'LatheBufferGeometry';
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        segments = Math.floor(segments) || 12;
        phiStart = phiStart || 0;
        phiLength = phiLength || Math.PI * 2;
        phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
        var indices = [];
        var vertices = [];
        var uvs = [];
        var base;
        var inverseSegments = 1.0 / segments;
        var vertex = new Vector3();
        var uv = new Vector2();
        var i, j;
        for (i = 0; i <= segments; i++) {
            var phi = phiStart + i * inverseSegments * phiLength;
            var sin = Math.sin(phi);
            var cos = Math.cos(phi);
            for (j = 0; j <= (points.length - 1); j++) {
                vertex.x = points[j].x * sin;
                vertex.y = points[j].y;
                vertex.z = points[j].x * cos;
                vertices.push(vertex.x, vertex.y, vertex.z);
                uv.x = i / segments;
                uv.y = j / (points.length - 1);
                uvs.push(uv.x, uv.y);
            }
        }
        for (i = 0; i < segments; i++) {
            for (j = 0; j < (points.length - 1); j++) {
                base = j + i * points.length;
                var a = base;
                var b = base + points.length;
                var c = base + points.length + 1;
                var d = base + 1;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
        this.computeVertexNormals();
        if (phiLength === Math.PI * 2) {
            var normals = this.attributes.normal.array;
            var n1 = new Vector3();
            var n2 = new Vector3();
            var n = new Vector3();
            base = segments * points.length * 3;
            for (i = 0, j = 0; i < points.length; i++, j += 3) {
                n1.x = normals[j + 0];
                n1.y = normals[j + 1];
                n1.z = normals[j + 2];
                n2.x = normals[base + j + 0];
                n2.y = normals[base + j + 1];
                n2.z = normals[base + j + 2];
                n.addVectors(n1, n2).normalize();
                normals[j + 0] = normals[base + j + 0] = n.x;
                normals[j + 1] = normals[base + j + 1] = n.y;
                normals[j + 2] = normals[base + j + 2] = n.z;
            }
        }
    }
    LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

    function ShapeGeometry(shapes, curveSegments) {
        Geometry.call(this);
        this.type = 'ShapeGeometry';
        if (typeof curveSegments === 'object') {
            console.warn('THREE.ShapeGeometry: Options parameter has been removed.');
            curveSegments = curveSegments.curveSegments;
        }
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
        this.mergeVertices();
    }
    ShapeGeometry.prototype = Object.create(Geometry.prototype);
    ShapeGeometry.prototype.constructor = ShapeGeometry;
    ShapeGeometry.prototype.toJSON = function() {
        var data = Geometry.prototype.toJSON.call(this);
        var shapes = this.parameters.shapes;
        return toJSON(shapes, data);
    };

    function ShapeBufferGeometry(shapes, curveSegments) {
        BufferGeometry.call(this);
        this.type = 'ShapeBufferGeometry';
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        curveSegments = curveSegments || 12;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var groupStart = 0;
        var groupCount = 0;
        if (Array.isArray(shapes) === false) {
            addShape(shapes);
        } else {
            for (var i = 0; i < shapes.length; i++) {
                addShape(shapes[i]);
                this.addGroup(groupStart, groupCount, i);
                groupStart += groupCount;
                groupCount = 0;
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        function addShape(shape) {
            var i, l, shapeHole;
            var indexOffset = vertices.length / 3;
            var points = shape.extractPoints(curveSegments);
            var shapeVertices = points.shape;
            var shapeHoles = points.holes;
            if (ShapeUtils.isClockWise(shapeVertices) === false) {
                shapeVertices = shapeVertices.reverse();
                for (i = 0, l = shapeHoles.length; i < l; i++) {
                    shapeHole = shapeHoles[i];
                    if (ShapeUtils.isClockWise(shapeHole) === true) {
                        shapeHoles[i] = shapeHole.reverse();
                    }
                }
            }
            var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for (i = 0, l = shapeHoles.length; i < l; i++) {
                shapeHole = shapeHoles[i];
                shapeVertices = shapeVertices.concat(shapeHole);
            }
            for (i = 0, l = shapeVertices.length; i < l; i++) {
                var vertex = shapeVertices[i];
                vertices.push(vertex.x, vertex.y, 0);
                normals.push(0, 0, 1);
                uvs.push(vertex.x, vertex.y);
            }
            for (i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                var a = face[0] + indexOffset;
                var b = face[1] + indexOffset;
                var c = face[2] + indexOffset;
                indices.push(a, b, c);
                groupCount += 3;
            }
        }
    }
    ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
    ShapeBufferGeometry.prototype.toJSON = function() {
        var data = BufferGeometry.prototype.toJSON.call(this);
        var shapes = this.parameters.shapes;
        return toJSON(shapes, data);
    };

    function toJSON(shapes, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
                var shape = shapes[i];
                data.shapes.push(shape.uuid);
            }
        } else {
            data.shapes.push(shapes.uuid);
        }
        return data;
    }

    function EdgesGeometry(geometry, thresholdAngle) {
        BufferGeometry.call(this);
        this.type = 'EdgesGeometry';
        this.parameters = {
            thresholdAngle: thresholdAngle
        };
        thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;
        var vertices = [];
        var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
        var edge = [0, 0],
            edges = {},
            edge1, edge2;
        var key, keys = ['a', 'b', 'c'];
        var geometry2;
        if (geometry.isBufferGeometry) {
            geometry2 = new Geometry();
            geometry2.fromBufferGeometry(geometry);
        } else {
            geometry2 = geometry.clone();
        }
        geometry2.mergeVertices();
        geometry2.computeFaceNormals();
        var sourceVertices = geometry2.vertices;
        var faces = geometry2.faces;
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0; j < 3; j++) {
                edge1 = face[keys[j]];
                edge2 = face[keys[(j + 1) % 3]];
                edge[0] = Math.min(edge1, edge2);
                edge[1] = Math.max(edge1, edge2);
                key = edge[0] + ',' + edge[1];
                if (edges[key] === undefined) {
                    edges[key] = {
                        index1: edge[0],
                        index2: edge[1],
                        face1: i,
                        face2: undefined
                    };
                } else {
                    edges[key].face2 = i;
                }
            }
        }
        for (key in edges) {
            var e = edges[key];
            if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
                var vertex = sourceVertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z);
                vertex = sourceVertices[e.index2];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
    }
    EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
    EdgesGeometry.prototype.constructor = EdgesGeometry;

    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'CylinderGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
        this.mergeVertices();
    }
    CylinderGeometry.prototype = Object.create(Geometry.prototype);
    CylinderGeometry.prototype.constructor = CylinderGeometry;

    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'CylinderBufferGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        var scope = this;
        radiusTop = radiusTop !== undefined ? radiusTop : 1;
        radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
        height = height || 1;
        radialSegments = Math.floor(radialSegments) || 8;
        heightSegments = Math.floor(heightSegments) || 1;
        openEnded = openEnded !== undefined ? openEnded : false;
        thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var index = 0;
        var indexArray = [];
        var halfHeight = height / 2;
        var groupStart = 0;
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0) generateCap(true);
            if (radiusBottom > 0) generateCap(false);
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

        function generateTorso() {
            var x, y;
            var normal = new Vector3();
            var vertex = new Vector3();
            var groupCount = 0;
            var slope = (radiusBottom - radiusTop) / height;
            for (y = 0; y <= heightSegments; y++) {
                var indexRow = [];
                var v = y / heightSegments;
                var radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);
                    vertex.x = radius * sinTheta;
                    vertex.y = -v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    uvs.push(u, 1 - v);
                    indexRow.push(index++);
                }
                indexArray.push(indexRow);
            }
            for (x = 0; x < radialSegments; x++) {
                for (y = 0; y < heightSegments; y++) {
                    var a = indexArray[y][x];
                    var b = indexArray[y + 1][x];
                    var c = indexArray[y + 1][x + 1];
                    var d = indexArray[y][x + 1];
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                    groupCount += 6;
                }
            }
            scope.addGroup(groupStart, groupCount, 0);
            groupStart += groupCount;
        }

        function generateCap(top) {
            var x, centerIndexStart, centerIndexEnd;
            var uv = new Vector2();
            var vertex = new Vector3();
            var groupCount = 0;
            var radius = (top === true) ? radiusTop : radiusBottom;
            var sign = (top === true) ? 1 : -1;
            centerIndexStart = index;
            for (x = 1; x <= radialSegments; x++) {
                vertices.push(0, halfHeight * sign, 0);
                normals.push(0, sign, 0);
                uvs.push(0.5, 0.5);
                index++;
            }
            centerIndexEnd = index;
            for (x = 0; x <= radialSegments; x++) {
                var u = x / radialSegments;
                var theta = u * thetaLength + thetaStart;
                var cosTheta = Math.cos(theta);
                var sinTheta = Math.sin(theta);
                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);
                normals.push(0, sign, 0);
                uv.x = (cosTheta * 0.5) + 0.5;
                uv.y = (sinTheta * 0.5 * sign) + 0.5;
                uvs.push(uv.x, uv.y);
                index++;
            }
            for (x = 0; x < radialSegments; x++) {
                var c = centerIndexStart + x;
                var i = centerIndexEnd + x;
                if (top === true) {
                    indices.push(i, i + 1, c);
                } else {
                    indices.push(i + 1, i, c);
                }
                groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            groupStart += groupCount;
        }
    }
    CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = 'ConeGeometry';
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
    ConeGeometry.prototype.constructor = ConeGeometry;

    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = 'ConeBufferGeometry';
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'CircleGeometry';
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
        this.mergeVertices();
    }
    CircleGeometry.prototype = Object.create(Geometry.prototype);
    CircleGeometry.prototype.constructor = CircleGeometry;

    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'CircleBufferGeometry';
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius = radius || 1;
        segments = segments !== undefined ? Math.max(3, segments) : 8;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var i, s;
        var vertex = new Vector3();
        var uv = new Vector2();
        vertices.push(0, 0, 0);
        normals.push(0, 0, 1);
        uvs.push(0.5, 0.5);
        for (s = 0, i = 3; s <= segments; s++, i += 3) {
            var segment = thetaStart + s / segments * thetaLength;
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            vertices.push(vertex.x, vertex.y, vertex.z);
            normals.push(0, 0, 1);
            uv.x = (vertices[i] / radius + 1) / 2;
            uv.y = (vertices[i + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
        }
        for (i = 1; i <= segments; i++) {
            indices.push(i, i + 1, 0);
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
    var Geometries = Object.freeze({
        WireframeGeometry: WireframeGeometry,
        ParametricGeometry: ParametricGeometry,
        ParametricBufferGeometry: ParametricBufferGeometry,
        TetrahedronGeometry: TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronBufferGeometry,
        OctahedronGeometry: OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronBufferGeometry,
        IcosahedronGeometry: IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronBufferGeometry,
        DodecahedronGeometry: DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronBufferGeometry,
        PolyhedronGeometry: PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronBufferGeometry,
        TubeGeometry: TubeGeometry,
        TubeBufferGeometry: TubeBufferGeometry,
        TorusKnotGeometry: TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotBufferGeometry,
        TorusGeometry: TorusGeometry,
        TorusBufferGeometry: TorusBufferGeometry,
        TextGeometry: TextGeometry,
        TextBufferGeometry: TextBufferGeometry,
        SphereGeometry: SphereGeometry,
        SphereBufferGeometry: SphereBufferGeometry,
        RingGeometry: RingGeometry,
        RingBufferGeometry: RingBufferGeometry,
        PlaneGeometry: PlaneGeometry,
        PlaneBufferGeometry: PlaneBufferGeometry,
        LatheGeometry: LatheGeometry,
        LatheBufferGeometry: LatheBufferGeometry,
        ShapeGeometry: ShapeGeometry,
        ShapeBufferGeometry: ShapeBufferGeometry,
        ExtrudeGeometry: ExtrudeGeometry,
        ExtrudeBufferGeometry: ExtrudeBufferGeometry,
        EdgesGeometry: EdgesGeometry,
        ConeGeometry: ConeGeometry,
        ConeBufferGeometry: ConeBufferGeometry,
        CylinderGeometry: CylinderGeometry,
        CylinderBufferGeometry: CylinderBufferGeometry,
        CircleGeometry: CircleGeometry,
        CircleBufferGeometry: CircleBufferGeometry,
        BoxGeometry: BoxGeometry,
        BoxBufferGeometry: BoxBufferGeometry
    });

    function ShadowMaterial(parameters) {
        Material.call(this);
        this.type = 'ShadowMaterial';
        this.color = new Color(0x000000);
        this.opacity = 1.0;
        this.lights = true;
        this.transparent = true;
        this.setValues(parameters);
    }
    ShadowMaterial.prototype = Object.create(Material.prototype);
    ShadowMaterial.prototype.constructor = ShadowMaterial;
    ShadowMaterial.prototype.isShadowMaterial = true;

    function RawShaderMaterial(parameters) {
        ShaderMaterial.call(this, parameters);
        this.type = 'RawShaderMaterial';
    }
    RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;
    RawShaderMaterial.prototype.isRawShaderMaterial = true;

    function MeshStandardMaterial(parameters) {
        Material.call(this);
        this.defines = {
            'STANDARD': ''
        };
        this.type = 'MeshStandardMaterial';
        this.color = new Color(0xffffff);
        this.roughness = 0.5;
        this.metalness = 0.5;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1.0;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshStandardMaterial.prototype = Object.create(Material.prototype);
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    MeshStandardMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.defines = {
            'STANDARD': ''
        };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };

    function MeshPhysicalMaterial(parameters) {
        MeshStandardMaterial.call(this);
        this.defines = {
            'PHYSICAL': ''
        };
        this.type = 'MeshPhysicalMaterial';
        this.reflectivity = 0.5;
        this.clearCoat = 0.0;
        this.clearCoatRoughness = 0.0;
        this.setValues(parameters);
    }
    MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    MeshPhysicalMaterial.prototype.copy = function(source) {
        MeshStandardMaterial.prototype.copy.call(this, source);
        this.defines = {
            'PHYSICAL': ''
        };
        this.reflectivity = source.reflectivity;
        this.clearCoat = source.clearCoat;
        this.clearCoatRoughness = source.clearCoatRoughness;
        return this;
    };

    function MeshPhongMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshPhongMaterial';
        this.color = new Color(0xffffff);
        this.specular = new Color(0x111111);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshPhongMaterial.prototype = Object.create(Material.prototype);
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    MeshPhongMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };

    function MeshToonMaterial(parameters) {
        MeshPhongMaterial.call(this);
        this.defines = {
            'TOON': ''
        };
        this.type = 'MeshToonMaterial';
        this.gradientMap = null;
        this.setValues(parameters);
    }
    MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
    MeshToonMaterial.prototype.constructor = MeshToonMaterial;
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    MeshToonMaterial.prototype.copy = function(source) {
        MeshPhongMaterial.prototype.copy.call(this, source);
        this.gradientMap = source.gradientMap;
        return this;
    };

    function MeshNormalMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshNormalMaterial';
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshNormalMaterial.prototype = Object.create(Material.prototype);
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    MeshNormalMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };

    function MeshLambertMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshLambertMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshLambertMaterial.prototype = Object.create(Material.prototype);
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    MeshLambertMaterial.prototype.copy = function(source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };

    function LineDashedMaterial(parameters) {
        LineBasicMaterial.call(this);
        this.type = 'LineDashedMaterial';
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters);
    }
    LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    LineDashedMaterial.prototype.copy = function(source) {
        LineBasicMaterial.prototype.copy.call(this, source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
    };
    var Materials = Object.freeze({
        ShadowMaterial: ShadowMaterial,
        SpriteMaterial: SpriteMaterial,
        RawShaderMaterial: RawShaderMaterial,
        ShaderMaterial: ShaderMaterial,
        PointsMaterial: PointsMaterial,
        MeshPhysicalMaterial: MeshPhysicalMaterial,
        MeshStandardMaterial: MeshStandardMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        MeshToonMaterial: MeshToonMaterial,
        MeshNormalMaterial: MeshNormalMaterial,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshDepthMaterial: MeshDepthMaterial,
        MeshDistanceMaterial: MeshDistanceMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        LineDashedMaterial: LineDashedMaterial,
        LineBasicMaterial: LineBasicMaterial,
        Material: Material
    });
    var Cache = {
        enabled: false,
        files: {},
        add: function(key, file) {
            if (this.enabled === false) return;
            this.files[key] = file;
        },
        get: function(key) {
            if (this.enabled === false) return;
            return this.files[key];
        },
        remove: function(key) {
            delete this.files[key];
        },
        clear: function() {
            this.files = {};
        }
    };

    function LoadingManager(onLoad, onProgress, onError) {
        var scope = this;
        var isLoading = false;
        var itemsLoaded = 0;
        var itemsTotal = 0;
        var urlModifier = undefined;
        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
                if (scope.onStart !== undefined) {
                    scope.onStart(url, itemsLoaded, itemsTotal);
                }
            }
            isLoading = true;
        };
        this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope.onProgress !== undefined) {
                scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
                isLoading = false;
                if (scope.onLoad !== undefined) {
                    scope.onLoad();
                }
            }
        };
        this.itemError = function(url) {
            if (scope.onError !== undefined) {
                scope.onError(url);
            }
        };
        this.resolveURL = function(url) {
            if (urlModifier) {
                return urlModifier(url);
            }
            return url;
        };
        this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
        };
    }
    var DefaultLoadingManager = new LoadingManager();
    var loading = {};

    function FileLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(FileLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            if (url === undefined) url = '';
            if (this.path !== undefined) url = this.path + url;
            url = this.manager.resolveURL(url);
            var scope = this;
            var cached = Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function() {
                    if (onLoad) onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            if (loading[url] !== undefined) {
                loading[url].push({
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                });
                return;
            }
            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
            var dataUriRegexResult = url.match(dataUriRegex);
            if (dataUriRegexResult) {
                var mimeType = dataUriRegexResult[1];
                var isBase64 = !!dataUriRegexResult[2];
                var data = dataUriRegexResult[3];
                data = window.decodeURIComponent(data);
                if (isBase64) data = window.atob(data);
                try {
                    var response;
                    var responseType = (this.responseType || '').toLowerCase();
                    switch (responseType) {
                        case 'arraybuffer':
                        case 'blob':
                            var view = new Uint8Array(data.length);
                            for (var i = 0; i < data.length; i++) {
                                view[i] = data.charCodeAt(i);
                            }
                            if (responseType === 'blob') {
                                response = new Blob([view.buffer], {
                                    type: mimeType
                                });
                            } else {
                                response = view.buffer;
                            }
                            break;
                        case 'document':
                            var parser = new DOMParser();
                            response = parser.parseFromString(data, mimeType);
                            break;
                        case 'json':
                            response = JSON.parse(data);
                            break;
                        default:
                            response = data;
                            break;
                    }
                    window.setTimeout(function() {
                        if (onLoad) onLoad(response);
                        scope.manager.itemEnd(url);
                    }, 0);
                } catch (error) {
                    window.setTimeout(function() {
                        if (onError) onError(error);
                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url);
                    }, 0);
                }
            } else {
                loading[url] = [];
                loading[url].push({
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                });
                var request = new XMLHttpRequest();
                request.open('GET', url, true);
                request.addEventListener('load', function(event) {
                    var response = this.response;
                    Cache.add(url, response);
                    var callbacks = loading[url];
                    delete loading[url];
                    if (this.status === 200) {
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            if (callback.onLoad) callback.onLoad(response);
                        }
                        scope.manager.itemEnd(url);
                    } else if (this.status === 0) {
                        console.warn('THREE.FileLoader: HTTP Status 0 received.');
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            if (callback.onLoad) callback.onLoad(response);
                        }
                        scope.manager.itemEnd(url);
                    } else {
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            if (callback.onError) callback.onError(event);
                        }
                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url);
                    }
                }, false);
                request.addEventListener('progress', function(event) {
                    var callbacks = loading[url];
                    for (var i = 0, il = callbacks.length; i < il; i++) {
                        var callback = callbacks[i];
                        if (callback.onProgress) callback.onProgress(event);
                    }
                }, false);
                request.addEventListener('error', function(event) {
                    var callbacks = loading[url];
                    delete loading[url];
                    for (var i = 0, il = callbacks.length; i < il; i++) {
                        var callback = callbacks[i];
                        if (callback.onError) callback.onError(event);
                    }
                    scope.manager.itemEnd(url);
                    scope.manager.itemError(url);
                }, false);
                if (this.responseType !== undefined) request.responseType = this.responseType;
                if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
                if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
                for (var header in this.requestHeader) {
                    request.setRequestHeader(header, this.requestHeader[header]);
                }
                request.send(null);
            }
            scope.manager.itemStart(url);
            return request;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        },
        setResponseType: function(value) {
            this.responseType = value;
            return this;
        },
        setWithCredentials: function(value) {
            this.withCredentials = value;
            return this;
        },
        setMimeType: function(value) {
            this.mimeType = value;
            return this;
        },
        setRequestHeader: function(value) {
            this.requestHeader = value;
            return this;
        }
    });

    function CompressedTextureLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this._parser = null;
    }
    Object.assign(CompressedTextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var images = [];
            var texture = new CompressedTexture();
            texture.image = images;
            var loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setResponseType('arraybuffer');

            function loadTexture(i) {
                loader.load(url[i], function(buffer) {
                    var texDatas = scope._parser(buffer, true);
                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };
                    loaded += 1;
                    if (loaded === 6) {
                        if (texDatas.mipmapCount === 1)
                            texture.minFilter = LinearFilter;
                        texture.format = texDatas.format;
                        texture.needsUpdate = true;
                        if (onLoad) onLoad(texture);
                    }
                }, onProgress, onError);
            }
            if (Array.isArray(url)) {
                var loaded = 0;
                for (var i = 0, il = url.length; i < il; ++i) {
                    loadTexture(i);
                }
            } else {
                loader.load(url, function(buffer) {
                    var texDatas = scope._parser(buffer, true);
                    if (texDatas.isCubemap) {
                        var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                        for (var f = 0; f < faces; f++) {
                            images[f] = {
                                mipmaps: []
                            };
                            for (var i = 0; i < texDatas.mipmapCount; i++) {
                                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                images[f].format = texDatas.format;
                                images[f].width = texDatas.width;
                                images[f].height = texDatas.height;
                            }
                        }
                    } else {
                        texture.image.width = texDatas.width;
                        texture.image.height = texDatas.height;
                        texture.mipmaps = texDatas.mipmaps;
                    }
                    if (texDatas.mipmapCount === 1) {
                        texture.minFilter = LinearFilter;
                    }
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }, onProgress, onError);
            }
            return texture;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        }
    });

    function DataTextureLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this._parser = null;
    }
    Object.assign(DataTextureLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var texture = new DataTexture();
            var loader = new FileLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.load(url, function(buffer) {
                var texData = scope._parser(buffer);
                if (!texData) return;
                if (undefined !== texData.image) {
                    texture.image = texData.image;
                } else if (undefined !== texData.data) {
                    texture.image.width = texData.width;
                    texture.image.height = texData.height;
                    texture.image.data = texData.data;
                }
                texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
                texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
                texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
                texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
                texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
                if (undefined !== texData.format) {
                    texture.format = texData.format;
                }
                if (undefined !== texData.type) {
                    texture.type = texData.type;
                }
                if (undefined !== texData.mipmaps) {
                    texture.mipmaps = texData.mipmaps;
                }
                if (1 === texData.mipmapCount) {
                    texture.minFilter = LinearFilter;
                }
                texture.needsUpdate = true;
                if (onLoad) onLoad(texture, texData);
            }, onProgress, onError);
            return texture;
        }
    });

    function ImageLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(ImageLoader.prototype, {
        crossOrigin: 'Anonymous',
        load: function(url, onLoad, onProgress, onError) {
            if (url === undefined) url = '';
            if (this.path !== undefined) url = this.path + url;
            url = this.manager.resolveURL(url);
            var scope = this;
            var cached = Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function() {
                    if (onLoad) onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
            image.addEventListener('load', function() {
                Cache.add(url, this);
                if (onLoad) onLoad(this);
                scope.manager.itemEnd(url);
            }, false);
            image.addEventListener('error', function(event) {
                if (onError) onError(event);
                scope.manager.itemEnd(url);
                scope.manager.itemError(url);
            }, false);
            if (url.substr(0, 5) !== 'data:') {
                if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
            }
            scope.manager.itemStart(url);
            image.src = url;
            return image;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
            return this;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        }
    });

    function CubeTextureLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(CubeTextureLoader.prototype, {
        crossOrigin: 'Anonymous',
        load: function(urls, onLoad, onProgress, onError) {
            var texture = new CubeTexture();
            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            var loaded = 0;

            function loadTexture(i) {
                loader.load(urls[i], function(image) {
                    texture.images[i] = image;
                    loaded++;
                    if (loaded === 6) {
                        texture.needsUpdate = true;
                        if (onLoad) onLoad(texture);
                    }
                }, undefined, onError);
            }
            for (var i = 0; i < urls.length; ++i) {
                loadTexture(i);
            }
            return texture;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
            return this;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        }
    });

    function TextureLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(TextureLoader.prototype, {
        crossOrigin: 'Anonymous',
        load: function(url, onLoad, onProgress, onError) {
            var texture = new Texture();
            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            loader.load(url, function(image) {
                texture.image = image;
                var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                texture.format = isJPEG ? RGBFormat : RGBAFormat;
                texture.needsUpdate = true;
                if (onLoad !== undefined) {
                    onLoad(texture);
                }
            }, onProgress, onError);
            return texture;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
            return this;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        }
    });

    function Curve() {
        this.type = 'Curve';
        this.arcLengthDivisions = 200;
    }
    Object.assign(Curve.prototype, {
        getPoint: function() {
            console.warn('THREE.Curve: .getPoint() not implemented.');
            return null;
        },
        getPointAt: function(u, optionalTarget) {
            var t = this.getUtoTmapping(u);
            return this.getPoint(t, optionalTarget);
        },
        getPoints: function(divisions) {
            if (divisions === undefined) divisions = 5;
            var points = [];
            for (var d = 0; d <= divisions; d++) {
                points.push(this.getPoint(d / divisions));
            }
            return points;
        },
        getSpacedPoints: function(divisions) {
            if (divisions === undefined) divisions = 5;
            var points = [];
            for (var d = 0; d <= divisions; d++) {
                points.push(this.getPointAt(d / divisions));
            }
            return points;
        },
        getLength: function() {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        },
        getLengths: function(divisions) {
            if (divisions === undefined) divisions = this.arcLengthDivisions;
            if (this.cacheArcLengths && (this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate) {
                return this.cacheArcLengths;
            }
            this.needsUpdate = false;
            var cache = [];
            var current, last = this.getPoint(0);
            var p, sum = 0;
            cache.push(0);
            for (p = 1; p <= divisions; p++) {
                current = this.getPoint(p / divisions);
                sum += current.distanceTo(last);
                cache.push(sum);
                last = current;
            }
            this.cacheArcLengths = cache;
            return cache;
        },
        updateArcLengths: function() {
            this.needsUpdate = true;
            this.getLengths();
        },
        getUtoTmapping: function(u, distance) {
            var arcLengths = this.getLengths();
            var i = 0,
                il = arcLengths.length;
            var targetArcLength;
            if (distance) {
                targetArcLength = distance;
            } else {
                targetArcLength = u * arcLengths[il - 1];
            }
            var low = 0,
                high = il - 1,
                comparison;
            while (low <= high) {
                i = Math.floor(low + (high - low) / 2);
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                    low = i + 1;
                } else if (comparison > 0) {
                    high = i - 1;
                } else {
                    high = i;
                    break;
                }
            }
            i = high;
            if (arcLengths[i] === targetArcLength) {
                return i / (il - 1);
            }
            var lengthBefore = arcLengths[i];
            var lengthAfter = arcLengths[i + 1];
            var segmentLength = lengthAfter - lengthBefore;
            var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
            var t = (i + segmentFraction) / (il - 1);
            return t;
        },
        getTangent: function(t) {
            var delta = 0.0001;
            var t1 = t - delta;
            var t2 = t + delta;
            if (t1 < 0) t1 = 0;
            if (t2 > 1) t2 = 1;
            var pt1 = this.getPoint(t1);
            var pt2 = this.getPoint(t2);
            var vec = pt2.clone().sub(pt1);
            return vec.normalize();
        },
        getTangentAt: function(u) {
            var t = this.getUtoTmapping(u);
            return this.getTangent(t);
        },
        computeFrenetFrames: function(segments, closed) {
            var normal = new Vector3();
            var tangents = [];
            var normals = [];
            var binormals = [];
            var vec = new Vector3();
            var mat = new Matrix4();
            var i, u, theta;
            for (i = 0; i <= segments; i++) {
                u = i / segments;
                tangents[i] = this.getTangentAt(u);
                tangents[i].normalize();
            }
            normals[0] = new Vector3();
            binormals[0] = new Vector3();
            var min = Number.MAX_VALUE;
            var tx = Math.abs(tangents[0].x);
            var ty = Math.abs(tangents[0].y);
            var tz = Math.abs(tangents[0].z);
            if (tx <= min) {
                min = tx;
                normal.set(1, 0, 0);
            }
            if (ty <= min) {
                min = ty;
                normal.set(0, 1, 0);
            }
            if (tz <= min) {
                normal.set(0, 0, 1);
            }
            vec.crossVectors(tangents[0], normal).normalize();
            normals[0].crossVectors(tangents[0], vec);
            binormals[0].crossVectors(tangents[0], normals[0]);
            for (i = 1; i <= segments; i++) {
                normals[i] = normals[i - 1].clone();
                binormals[i] = binormals[i - 1].clone();
                vec.crossVectors(tangents[i - 1], tangents[i]);
                if (vec.length() > Number.EPSILON) {
                    vec.normalize();
                    theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
                    normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }
                binormals[i].crossVectors(tangents[i], normals[i]);
            }
            if (closed === true) {
                theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
                theta /= segments;
                if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                    theta = -theta;
                }
                for (i = 1; i <= segments; i++) {
                    normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                    binormals[i].crossVectors(tangents[i], normals[i]);
                }
            }
            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.arcLengthDivisions = source.arcLengthDivisions;
            return this;
        },
        toJSON: function() {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Curve',
                    generator: 'Curve.toJSON'
                }
            };
            data.arcLengthDivisions = this.arcLengthDivisions;
            data.type = this.type;
            return data;
        },
        fromJSON: function(json) {
            this.arcLengthDivisions = json.arcLengthDivisions;
            return this;
        }
    });

    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        Curve.call(this);
        this.type = 'EllipseCurve';
        this.aX = aX || 0;
        this.aY = aY || 0;
        this.xRadius = xRadius || 1;
        this.yRadius = yRadius || 1;
        this.aStartAngle = aStartAngle || 0;
        this.aEndAngle = aEndAngle || 2 * Math.PI;
        this.aClockwise = aClockwise || false;
        this.aRotation = aRotation || 0;
    }
    EllipseCurve.prototype = Object.create(Curve.prototype);
    EllipseCurve.prototype.constructor = EllipseCurve;
    EllipseCurve.prototype.isEllipseCurve = true;
    EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        var twoPi = Math.PI * 2;
        var deltaAngle = this.aEndAngle - this.aStartAngle;
        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        while (deltaAngle < 0) deltaAngle += twoPi;
        while (deltaAngle > twoPi) deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
                deltaAngle = 0;
            } else {
                deltaAngle = twoPi;
            }
        }
        if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) {
                deltaAngle = -twoPi;
            } else {
                deltaAngle = deltaAngle - twoPi;
            }
        }
        var angle = this.aStartAngle + t * deltaAngle;
        var x = this.aX + this.xRadius * Math.cos(angle);
        var y = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
            var cos = Math.cos(this.aRotation);
            var sin = Math.sin(this.aRotation);
            var tx = x - this.aX;
            var ty = y - this.aY;
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y);
    };
    EllipseCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
    };
    EllipseCurve.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.aX = this.aX;
        data.aY = this.aY;
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
        data.aClockwise = this.aClockwise;
        data.aRotation = this.aRotation;
        return data;
    };
    EllipseCurve.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
    };

    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        this.type = 'ArcCurve';
    }
    ArcCurve.prototype = Object.create(EllipseCurve.prototype);
    ArcCurve.prototype.constructor = ArcCurve;
    ArcCurve.prototype.isArcCurve = true;

    function CubicPoly() {
        var c0 = 0,
            c1 = 0,
            c2 = 0,
            c3 = 0;

        function init(x0, x1, t0, t1) {
            c0 = x0;
            c1 = t0;
            c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
            initCatmullRom: function(x0, x1, x2, x3, tension) {
                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },
            initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
                var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                t1 *= dt1;
                t2 *= dt1;
                init(x1, x2, t1, t2);
            },
            calc: function(t) {
                var t2 = t * t;
                var t3 = t2 * t;
                return c0 + c1 * t + c2 * t2 + c3 * t3;
            }
        };
    }
    var tmp = new Vector3();
    var px = new CubicPoly();
    var py = new CubicPoly();
    var pz = new CubicPoly();

    function CatmullRomCurve3(points, closed, curveType, tension) {
        Curve.call(this);
        this.type = 'CatmullRomCurve3';
        this.points = points || [];
        this.closed = closed || false;
        this.curveType = curveType || 'centripetal';
        this.tension = tension || 0.5;
    }
    CatmullRomCurve3.prototype = Object.create(Curve.prototype);
    CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
    CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector3();
        var points = this.points;
        var l = points.length;
        var p = (l - (this.closed ? 0 : 1)) * t;
        var intPoint = Math.floor(p);
        var weight = p - intPoint;
        if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
        } else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
        }
        var p0, p1, p2, p3;
        if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l];
        } else {
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
        }
        p1 = points[intPoint % l];
        p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) {
            p3 = points[(intPoint + 2) % l];
        } else {
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
        }
        if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
            var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
            var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            if (dt1 < 1e-4) dt1 = 1.0;
            if (dt0 < 1e-4) dt0 = dt1;
            if (dt2 < 1e-4) dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.curveType === 'catmullrom') {
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
        }
        point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
        return point;
    };
    CatmullRomCurve3.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.points = [];
        for (var i = 0, l = source.points.length; i < l; i++) {
            var point = source.points[i];
            this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
    };
    CatmullRomCurve3.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.points = [];
        for (var i = 0, l = this.points.length; i < l; i++) {
            var point = this.points[i];
            data.points.push(point.toArray());
        }
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
        return data;
    };
    CatmullRomCurve3.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.points = [];
        for (var i = 0, l = json.points.length; i < l; i++) {
            var point = json.points[i];
            this.points.push(new Vector3().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
    };

    function CatmullRom(t, p0, p1, p2, p3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }

    function QuadraticBezierP0(t, p) {
        var k = 1 - t;
        return k * k * p;
    }

    function QuadraticBezierP1(t, p) {
        return 2 * (1 - t) * t * p;
    }

    function QuadraticBezierP2(t, p) {
        return t * t * p;
    }

    function QuadraticBezier(t, p0, p1, p2) {
        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) +
            QuadraticBezierP2(t, p2);
    }

    function CubicBezierP0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
    }

    function CubicBezierP1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    }

    function CubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p;
    }

    function CubicBezierP3(t, p) {
        return t * t * t * p;
    }

    function CubicBezier(t, p0, p1, p2, p3) {
        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) +
            CubicBezierP3(t, p3);
    }

    function CubicBezierCurve(v0, v1, v2, v3) {
        Curve.call(this);
        this.type = 'CubicBezierCurve';
        this.v0 = v0 || new Vector2();
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
        this.v3 = v3 || new Vector2();
    }
    CubicBezierCurve.prototype = Object.create(Curve.prototype);
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;
    CubicBezierCurve.prototype.isCubicBezierCurve = true;
    CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        var v0 = this.v0,
            v1 = this.v1,
            v2 = this.v2,
            v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
        return point;
    };
    CubicBezierCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    };
    CubicBezierCurve.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
    };
    CubicBezierCurve.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    };

    function CubicBezierCurve3(v0, v1, v2, v3) {
        Curve.call(this);
        this.type = 'CubicBezierCurve3';
        this.v0 = v0 || new Vector3();
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
        this.v3 = v3 || new Vector3();
    }
    CubicBezierCurve3.prototype = Object.create(Curve.prototype);
    CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
    CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector3();
        var v0 = this.v0,
            v1 = this.v1,
            v2 = this.v2,
            v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
        return point;
    };
    CubicBezierCurve3.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    };
    CubicBezierCurve3.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
    };
    CubicBezierCurve3.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    };

    function LineCurve(v1, v2) {
        Curve.call(this);
        this.type = 'LineCurve';
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
    }
    LineCurve.prototype = Object.create(Curve.prototype);
    LineCurve.prototype.constructor = LineCurve;
    LineCurve.prototype.isLineCurve = true;
    LineCurve.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        if (t === 1) {
            point.copy(this.v2);
        } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    };
    LineCurve.prototype.getPointAt = function(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    };
    LineCurve.prototype.getTangent = function() {
        var tangent = this.v2.clone().sub(this.v1);
        return tangent.normalize();
    };
    LineCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    };
    LineCurve.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    };
    LineCurve.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    };

    function LineCurve3(v1, v2) {
        Curve.call(this);
        this.type = 'LineCurve3';
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
    }
    LineCurve3.prototype = Object.create(Curve.prototype);
    LineCurve3.prototype.constructor = LineCurve3;
    LineCurve3.prototype.isLineCurve3 = true;
    LineCurve3.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector3();
        if (t === 1) {
            point.copy(this.v2);
        } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    };
    LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    };
    LineCurve3.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    };
    LineCurve3.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    };
    LineCurve3.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    };

    function QuadraticBezierCurve(v0, v1, v2) {
        Curve.call(this);
        this.type = 'QuadraticBezierCurve';
        this.v0 = v0 || new Vector2();
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
    }
    QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
    QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        var v0 = this.v0,
            v1 = this.v1,
            v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
        return point;
    };
    QuadraticBezierCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    };
    QuadraticBezierCurve.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    };
    QuadraticBezierCurve.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    };

    function QuadraticBezierCurve3(v0, v1, v2) {
        Curve.call(this);
        this.type = 'QuadraticBezierCurve3';
        this.v0 = v0 || new Vector3();
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
    }
    QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
    QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector3();
        var v0 = this.v0,
            v1 = this.v1,
            v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
        return point;
    };
    QuadraticBezierCurve3.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    };
    QuadraticBezierCurve3.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    };
    QuadraticBezierCurve3.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    };

    function SplineCurve(points) {
        Curve.call(this);
        this.type = 'SplineCurve';
        this.points = points || [];
    }
    SplineCurve.prototype = Object.create(Curve.prototype);
    SplineCurve.prototype.constructor = SplineCurve;
    SplineCurve.prototype.isSplineCurve = true;
    SplineCurve.prototype.getPoint = function(t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        var points = this.points;
        var p = (points.length - 1) * t;
        var intPoint = Math.floor(p);
        var weight = p - intPoint;
        var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        var p1 = points[intPoint];
        var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
        return point;
    };
    SplineCurve.prototype.copy = function(source) {
        Curve.prototype.copy.call(this, source);
        this.points = [];
        for (var i = 0, l = source.points.length; i < l; i++) {
            var point = source.points[i];
            this.points.push(point.clone());
        }
        return this;
    };
    SplineCurve.prototype.toJSON = function() {
        var data = Curve.prototype.toJSON.call(this);
        data.points = [];
        for (var i = 0, l = this.points.length; i < l; i++) {
            var point = this.points[i];
            data.points.push(point.toArray());
        }
        return data;
    };
    SplineCurve.prototype.fromJSON = function(json) {
        Curve.prototype.fromJSON.call(this, json);
        this.points = [];
        for (var i = 0, l = json.points.length; i < l; i++) {
            var point = json.points[i];
            this.points.push(new Vector2().fromArray(point));
        }
        return this;
    };
    var Curves = Object.freeze({
        ArcCurve: ArcCurve,
        CatmullRomCurve3: CatmullRomCurve3,
        CubicBezierCurve: CubicBezierCurve,
        CubicBezierCurve3: CubicBezierCurve3,
        EllipseCurve: EllipseCurve,
        LineCurve: LineCurve,
        LineCurve3: LineCurve3,
        QuadraticBezierCurve: QuadraticBezierCurve,
        QuadraticBezierCurve3: QuadraticBezierCurve3,
        SplineCurve: SplineCurve
    });

    function CurvePath() {
        Curve.call(this);
        this.type = 'CurvePath';
        this.curves = [];
        this.autoClose = false;
    }
    CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
        constructor: CurvePath,
        add: function(curve) {
            this.curves.push(curve);
        },
        closePath: function() {
            var startPoint = this.curves[0].getPoint(0);
            var endPoint = this.curves[this.curves.length - 1].getPoint(1);
            if (!startPoint.equals(endPoint)) {
                this.curves.push(new LineCurve(endPoint, startPoint));
            }
        },
        getPoint: function(t) {
            var d = t * this.getLength();
            var curveLengths = this.getCurveLengths();
            var i = 0;
            while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                    var diff = curveLengths[i] - d;
                    var curve = this.curves[i];
                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u);
                }
                i++;
            }
            return null;
        },
        getLength: function() {
            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
        },
        updateArcLengths: function() {
            this.needsUpdate = true;
            this.cacheLengths = null;
            this.getCurveLengths();
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                return this.cacheLengths;
            }
            var lengths = [],
                sums = 0;
            for (var i = 0, l = this.curves.length; i < l; i++) {
                sums += this.curves[i].getLength();
                lengths.push(sums);
            }
            this.cacheLengths = lengths;
            return lengths;
        },
        getSpacedPoints: function(divisions) {
            if (divisions === undefined) divisions = 40;
            var points = [];
            for (var i = 0; i <= divisions; i++) {
                points.push(this.getPoint(i / divisions));
            }
            if (this.autoClose) {
                points.push(points[0]);
            }
            return points;
        },
        getPoints: function(divisions) {
            divisions = divisions || 12;
            var points = [],
                last;
            for (var i = 0, curves = this.curves; i < curves.length; i++) {
                var curve = curves[i];
                var resolution = (curve && curve.isEllipseCurve) ? divisions * 2 : (curve && curve.isLineCurve) ? 1 : (curve && curve.isSplineCurve) ? divisions * curve.points.length : divisions;
                var pts = curve.getPoints(resolution);
                for (var j = 0; j < pts.length; j++) {
                    var point = pts[j];
                    if (last && last.equals(point)) continue;
                    points.push(point);
                    last = point;
                }
            }
            if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                points.push(points[0]);
            }
            return points;
        },
        copy: function(source) {
            Curve.prototype.copy.call(this, source);
            this.curves = [];
            for (var i = 0, l = source.curves.length; i < l; i++) {
                var curve = source.curves[i];
                this.curves.push(curve.clone());
            }
            this.autoClose = source.autoClose;
            return this;
        },
        toJSON: function() {
            var data = Curve.prototype.toJSON.call(this);
            data.autoClose = this.autoClose;
            data.curves = [];
            for (var i = 0, l = this.curves.length; i < l; i++) {
                var curve = this.curves[i];
                data.curves.push(curve.toJSON());
            }
            return data;
        },
        fromJSON: function(json) {
            Curve.prototype.fromJSON.call(this, json);
            this.autoClose = json.autoClose;
            this.curves = [];
            for (var i = 0, l = json.curves.length; i < l; i++) {
                var curve = json.curves[i];
                this.curves.push(new Curves[curve.type]().fromJSON(curve));
            }
            return this;
        }
    });

    function Path(points) {
        CurvePath.call(this);
        this.type = 'Path';
        this.currentPoint = new Vector2();
        if (points) {
            this.setFromPoints(points);
        }
    }
    Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
        constructor: Path,
        setFromPoints: function(points) {
            this.moveTo(points[0].x, points[0].y);
            for (var i = 1, l = points.length; i < l; i++) {
                this.lineTo(points[i].x, points[i].y);
            }
        },
        moveTo: function(x, y) {
            this.currentPoint.set(x, y);
        },
        lineTo: function(x, y) {
            var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
            this.curves.push(curve);
            this.currentPoint.set(x, y);
        },
        quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
            var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
        },
        bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
        },
        splineThru: function(pts) {
            var npts = [this.currentPoint.clone()].concat(pts);
            var curve = new SplineCurve(npts);
            this.curves.push(curve);
            this.currentPoint.copy(pts[pts.length - 1]);
        },
        arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        },
        absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            if (this.curves.length > 0) {
                var firstPoint = curve.getPoint(0);
                if (!firstPoint.equals(this.currentPoint)) {
                    this.lineTo(firstPoint.x, firstPoint.y);
                }
            }
            this.curves.push(curve);
            var lastPoint = curve.getPoint(1);
            this.currentPoint.copy(lastPoint);
        },
        copy: function(source) {
            CurvePath.prototype.copy.call(this, source);
            this.currentPoint.copy(source.currentPoint);
            return this;
        },
        toJSON: function() {
            var data = CurvePath.prototype.toJSON.call(this);
            data.currentPoint = this.currentPoint.toArray();
            return data;
        },
        fromJSON: function(json) {
            CurvePath.prototype.fromJSON.call(this, json);
            this.currentPoint.fromArray(json.currentPoint);
            return this;
        }
    });

    function Shape(points) {
        Path.call(this, points);
        this.uuid = _Math.generateUUID();
        this.type = 'Shape';
        this.holes = [];
    }
    Shape.prototype = Object.assign(Object.create(Path.prototype), {
        constructor: Shape,
        getPointsHoles: function(divisions) {
            var holesPts = [];
            for (var i = 0, l = this.holes.length; i < l; i++) {
                holesPts[i] = this.holes[i].getPoints(divisions);
            }
            return holesPts;
        },
        extractPoints: function(divisions) {
            return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
            };
        },
        copy: function(source) {
            Path.prototype.copy.call(this, source);
            this.holes = [];
            for (var i = 0, l = source.holes.length; i < l; i++) {
                var hole = source.holes[i];
                this.holes.push(hole.clone());
            }
            return this;
        },
        toJSON: function() {
            var data = Path.prototype.toJSON.call(this);
            data.uuid = this.uuid;
            data.holes = [];
            for (var i = 0, l = this.holes.length; i < l; i++) {
                var hole = this.holes[i];
                data.holes.push(hole.toJSON());
            }
            return data;
        },
        fromJSON: function(json) {
            Path.prototype.fromJSON.call(this, json);
            this.uuid = json.uuid;
            this.holes = [];
            for (var i = 0, l = json.holes.length; i < l; i++) {
                var hole = json.holes[i];
                this.holes.push(new Path().fromJSON(hole));
            }
            return this;
        }
    });

    function Light(color, intensity) {
        Object3D.call(this);
        this.type = 'Light';
        this.color = new Color(color);
        this.intensity = intensity !== undefined ? intensity : 1;
        this.receiveShadow = undefined;
    }
    Light.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Light,
        isLight: true,
        copy: function(source) {
            Object3D.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.intensity = source.intensity;
            return this;
        },
        toJSON: function(meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.color = this.color.getHex();
            data.object.intensity = this.intensity;
            if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
            if (this.distance !== undefined) data.object.distance = this.distance;
            if (this.angle !== undefined) data.object.angle = this.angle;
            if (this.decay !== undefined) data.object.decay = this.decay;
            if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
            if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
            return data;
        }
    });

    function HemisphereLight(skyColor, groundColor, intensity) {
        Light.call(this, skyColor, intensity);
        this.type = 'HemisphereLight';
        this.castShadow = undefined;
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.groundColor = new Color(groundColor);
    }
    HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: HemisphereLight,
        isHemisphereLight: true,
        copy: function(source) {
            Light.prototype.copy.call(this, source);
            this.groundColor.copy(source.groundColor);
            return this;
        }
    });

    function LightShadow(camera) {
        this.camera = camera;
        this.bias = 0;
        this.radius = 1;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.matrix = new Matrix4();
    }
    Object.assign(LightShadow.prototype, {
        copy: function(source) {
            this.camera = source.camera.clone();
            this.bias = source.bias;
            this.radius = source.radius;
            this.mapSize.copy(source.mapSize);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        toJSON: function() {
            var object = {};
            if (this.bias !== 0) object.bias = this.bias;
            if (this.radius !== 1) object.radius = this.radius;
            if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
            object.camera = this.camera.toJSON(false).object;
            delete object.camera.matrix;
            return object;
        }
    });

    function SpotLightShadow() {
        LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
    }
    SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: SpotLightShadow,
        isSpotLightShadow: true,
        update: function(light) {
            var camera = this.camera;
            var fov = _Math.RAD2DEG * 2 * light.angle;
            var aspect = this.mapSize.width / this.mapSize.height;
            var far = light.distance || camera.far;
            if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                camera.fov = fov;
                camera.aspect = aspect;
                camera.far = far;
                camera.updateProjectionMatrix();
            }
        }
    });

    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
        Light.call(this, color, intensity);
        this.type = 'SpotLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        Object.defineProperty(this, 'power', {
            get: function() {
                return this.intensity * Math.PI;
            },
            set: function(power) {
                this.intensity = power / Math.PI;
            }
        });
        this.distance = (distance !== undefined) ? distance : 0;
        this.angle = (angle !== undefined) ? angle : Math.PI / 3;
        this.penumbra = (penumbra !== undefined) ? penumbra : 0;
        this.decay = (decay !== undefined) ? decay : 1;
        this.shadow = new SpotLightShadow();
    }
    SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: SpotLight,
        isSpotLight: true,
        copy: function(source) {
            Light.prototype.copy.call(this, source);
            this.distance = source.distance;
            this.angle = source.angle;
            this.penumbra = source.penumbra;
            this.decay = source.decay;
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    });

    function PointLight(color, intensity, distance, decay) {
        Light.call(this, color, intensity);
        this.type = 'PointLight';
        Object.defineProperty(this, 'power', {
            get: function() {
                return this.intensity * 4 * Math.PI;
            },
            set: function(power) {
                this.intensity = power / (4 * Math.PI);
            }
        });
        this.distance = (distance !== undefined) ? distance : 0;
        this.decay = (decay !== undefined) ? decay : 1;
        this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
    }
    PointLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: PointLight,
        isPointLight: true,
        copy: function(source) {
            Light.prototype.copy.call(this, source);
            this.distance = source.distance;
            this.decay = source.decay;
            this.shadow = source.shadow.clone();
            return this;
        }
    });

    function DirectionalLightShadow() {
        LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
    DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: DirectionalLightShadow
    });

    function DirectionalLight(color, intensity) {
        Light.call(this, color, intensity);
        this.type = 'DirectionalLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.shadow = new DirectionalLightShadow();
    }
    DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: DirectionalLight,
        isDirectionalLight: true,
        copy: function(source) {
            Light.prototype.copy.call(this, source);
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    });

    function AmbientLight(color, intensity) {
        Light.call(this, color, intensity);
        this.type = 'AmbientLight';
        this.castShadow = undefined;
    }
    AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: AmbientLight,
        isAmbientLight: true
    });

    function RectAreaLight(color, intensity, width, height) {
        Light.call(this, color, intensity);
        this.type = 'RectAreaLight';
        this.position.set(0, 1, 0);
        this.updateMatrix();
        this.width = (width !== undefined) ? width : 10;
        this.height = (height !== undefined) ? height : 10;
    }
    RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: RectAreaLight,
        isRectAreaLight: true,
        copy: function(source) {
            Light.prototype.copy.call(this, source);
            this.width = source.width;
            this.height = source.height;
            return this;
        },
        toJSON: function(meta) {
            var data = Light.prototype.toJSON.call(this, meta);
            data.object.width = this.width;
            data.object.height = this.height;
            return data;
        }
    });

    function StringKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: StringKeyframeTrack,
        ValueTypeName: 'string',
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    });

    function BooleanKeyframeTrack(name, times, values) {
        KeyframeTrack.call(this, name, times, values);
    }
    BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: BooleanKeyframeTrack,
        ValueTypeName: 'bool',
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    });

    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
    }
    Object.assign(Interpolant.prototype, {
        evaluate: function(t) {
            var pp = this.parameterPositions,
                i1 = this._cachedIndex,
                t1 = pp[i1],
                t0 = pp[i1 - 1];
            validate_interval: {
                seek: {
                    var right;
                    linear_scan: {
                        forward_scan: if (!(t < t1)) {
                                for (var giveUpAt = i1 + 2;;) {
                                    if (t1 === undefined) {
                                        if (t < t0) break forward_scan;
                                        i1 = pp.length;
                                        this._cachedIndex = i1;
                                        return this.afterEnd_(i1 - 1, t, t0);
                                    }
                                    if (i1 === giveUpAt) break;
                                    t0 = t1;
                                    t1 = pp[++i1];
                                    if (t < t1) {
                                        break seek;
                                    }
                                }
                                right = pp.length;
                                break linear_scan;
                            }
                        if (!(t >= t0)) {
                            var t1global = pp[1];
                            if (t < t1global) {
                                i1 = 2;
                                t0 = t1global;
                            }
                            for (var giveUpAt = i1 - 2;;) {
                                if (t0 === undefined) {
                                    this._cachedIndex = 0;
                                    return this.beforeStart_(0, t, t1);
                                }
                                if (i1 === giveUpAt) break;
                                t1 = t0;
                                t0 = pp[--i1 - 1];
                                if (t >= t0) {
                                    break seek;
                                }
                            }
                            right = i1;
                            i1 = 0;
                            break linear_scan;
                        }
                        break validate_interval;
                    }
                    while (i1 < right) {
                        var mid = (i1 + right) >>> 1;
                        if (t < pp[mid]) {
                            right = mid;
                        } else {
                            i1 = mid + 1;
                        }
                    }
                    t1 = pp[i1];
                    t0 = pp[i1 - 1];
                    if (t0 === undefined) {
                        this._cachedIndex = 0;
                        return this.beforeStart_(0, t, t1);
                    }
                    if (t1 === undefined) {
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t0, t);
                    }
                }
                this._cachedIndex = i1;this.intervalChanged_(i1, t0, t1);
            }
            return this.interpolate_(i1, t0, t, t1);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function(index) {
            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset = index * stride;
            for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset + i];
            }
            return result;
        },
        interpolate_: function() {
            throw new Error('call to abstract method');
        },
        intervalChanged_: function() {}
    });
    Object.assign(Interpolant.prototype, {
        beforeStart_: Interpolant.prototype.copySampleValue_,
        afterEnd_: Interpolant.prototype.copySampleValue_,
    });

    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: QuaternionLinearInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset = i1 * stride,
                alpha = (t - t0) / (t1 - t0);
            for (var end = offset + stride; offset !== end; offset += 4) {
                Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            }
            return result;
        }
    });

    function QuaternionKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: QuaternionKeyframeTrack,
        ValueTypeName: 'quaternion',
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodLinear: function(result) {
            return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: undefined
    });

    function ColorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: ColorKeyframeTrack,
        ValueTypeName: 'color'
    });

    function NumberKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: NumberKeyframeTrack,
        ValueTypeName: 'number'
    });

    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
    }
    CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: CubicInterpolant,
        DefaultSettings_: {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        },
        intervalChanged_: function(i1, t0, t1) {
            var pp = this.parameterPositions,
                iPrev = i1 - 2,
                iNext = i1 + 1,
                tPrev = pp[iPrev],
                tNext = pp[iNext];
            if (tPrev === undefined) {
                switch (this.getSettings_().endingStart) {
                    case ZeroSlopeEnding:
                        iPrev = i1;
                        tPrev = 2 * t0 - t1;
                        break;
                    case WrapAroundEnding:
                        iPrev = pp.length - 2;
                        tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                        break;
                    default:
                        iPrev = i1;
                        tPrev = t1;
                }
            }
            if (tNext === undefined) {
                switch (this.getSettings_().endingEnd) {
                    case ZeroSlopeEnding:
                        iNext = i1;
                        tNext = 2 * t1 - t0;
                        break;
                    case WrapAroundEnding:
                        iNext = 1;
                        tNext = t1 + pp[1] - pp[0];
                        break;
                    default:
                        iNext = i1 - 1;
                        tNext = t0;
                }
            }
            var halfDt = (t1 - t0) * 0.5,
                stride = this.valueSize;
            this._weightPrev = halfDt / (t0 - tPrev);
            this._weightNext = halfDt / (tNext - t1);
            this._offsetPrev = iPrev * stride;
            this._offsetNext = iNext * stride;
        },
        interpolate_: function(i1, t0, t, t1) {
            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                o1 = i1 * stride,
                o0 = o1 - stride,
                oP = this._offsetPrev,
                oN = this._offsetNext,
                wP = this._weightPrev,
                wN = this._weightNext,
                p = (t - t0) / (t1 - t0),
                pp = p * p,
                ppp = pp * p;
            var sP = -wP * ppp + 2 * wP * pp - wP * p;
            var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
            var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
            var sN = wN * ppp - wN * pp;
            for (var i = 0; i !== stride; ++i) {
                result[i] = sP * values[oP + i] +
                    s0 * values[o0 + i] +
                    s1 * values[o1 + i] +
                    sN * values[oN + i];
            }
            return result;
        }
    });

    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: LinearInterpolant,
        interpolate_: function(i1, t0, t, t1) {
            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset1 = i1 * stride,
                offset0 = offset1 - stride,
                weight1 = (t - t0) / (t1 - t0),
                weight0 = 1 - weight1;
            for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset0 + i] * weight0 +
                    values[offset1 + i] * weight1;
            }
            return result;
        }
    });

    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: DiscreteInterpolant,
        interpolate_: function(i1) {
            return this.copySampleValue_(i1 - 1);
        }
    });
    var AnimationUtils = {
        arraySlice: function(array, from, to) {
            if (AnimationUtils.isTypedArray(array)) {
                return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
            }
            return array.slice(from, to);
        },
        convertArray: function(array, type, forceClone) {
            if (!array || !forceClone && array.constructor === type) return array;
            if (typeof type.BYTES_PER_ELEMENT === 'number') {
                return new type(array);
            }
            return Array.prototype.slice.call(array);
        },
        isTypedArray: function(object) {
            return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function(times) {
            function compareTime(i, j) {
                return times[i] - times[j];
            }
            var n = times.length;
            var result = new Array(n);
            for (var i = 0; i !== n; ++i) result[i] = i;
            result.sort(compareTime);
            return result;
        },
        sortedArray: function(values, stride, order) {
            var nValues = values.length;
            var result = new values.constructor(nValues);
            for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
                var srcOffset = order[i] * stride;
                for (var j = 0; j !== stride; ++j) {
                    result[dstOffset++] = values[srcOffset + j];
                }
            }
            return result;
        },
        flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
            var i = 1,
                key = jsonKeys[0];
            while (key !== undefined && key[valuePropertyName] === undefined) {
                key = jsonKeys[i++];
            }
            if (key === undefined) return;
            var value = key[valuePropertyName];
            if (value === undefined) return;
            if (Array.isArray(value)) {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        values.push.apply(values, value);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            } else if (value.toArray !== undefined) {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        value.toArray(values, values.length);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            } else {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        values.push(value);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            }
        }
    };

    function KeyframeTrack(name, times, values, interpolation) {
        if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
        this.name = name;
        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
        this.validate();
        this.optimize();
    }
    Object.assign(KeyframeTrack, {
        parse: function(json) {
            if (json.type === undefined) {
                throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
            }
            var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
            if (json.times === undefined) {
                var times = [],
                    values = [];
                AnimationUtils.flattenJSON(json.keys, times, values, 'value');
                json.times = times;
                json.values = values;
            }
            if (trackType.parse !== undefined) {
                return trackType.parse(json);
            } else {
                return new trackType(json.name, json.times, json.values, json.interpolation);
            }
        },
        toJSON: function(track) {
            var trackType = track.constructor;
            var json;
            if (trackType.toJSON !== undefined) {
                json = trackType.toJSON(track);
            } else {
                json = {
                    'name': track.name,
                    'times': AnimationUtils.convertArray(track.times, Array),
                    'values': AnimationUtils.convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                if (interpolation !== track.DefaultInterpolation) {
                    json.interpolation = interpolation;
                }
            }
            json.type = track.ValueTypeName;
            return json;
        },
        _getTrackTypeForValueTypeName: function(typeName) {
            switch (typeName.toLowerCase()) {
                case 'scalar':
                case 'double':
                case 'float':
                case 'number':
                case 'integer':
                    return NumberKeyframeTrack;
                case 'vector':
                case 'vector2':
                case 'vector3':
                case 'vector4':
                    return VectorKeyframeTrack;
                case 'color':
                    return ColorKeyframeTrack;
                case 'quaternion':
                    return QuaternionKeyframeTrack;
                case 'bool':
                case 'boolean':
                    return BooleanKeyframeTrack;
                case 'string':
                    return StringKeyframeTrack;
            }
            throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
        }
    });
    Object.assign(KeyframeTrack.prototype, {
        constructor: KeyframeTrack,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodDiscrete: function(result) {
            return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodLinear: function(result) {
            return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: function(result) {
            return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        setInterpolation: function(interpolation) {
            var factoryMethod;
            switch (interpolation) {
                case InterpolateDiscrete:
                    factoryMethod = this.InterpolantFactoryMethodDiscrete;
                    break;
                case InterpolateLinear:
                    factoryMethod = this.InterpolantFactoryMethodLinear;
                    break;
                case InterpolateSmooth:
                    factoryMethod = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (factoryMethod === undefined) {
                var message = "unsupported interpolation for " +
                    this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === undefined) {
                    if (interpolation !== this.DefaultInterpolation) {
                        this.setInterpolation(this.DefaultInterpolation);
                    } else {
                        throw new Error(message);
                    }
                }
                console.warn('THREE.KeyframeTrack:', message);
                return;
            }
            this.createInterpolant = factoryMethod;
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                    return InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                    return InterpolateSmooth;
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length;
        },
        shift: function(timeOffset) {
            if (timeOffset !== 0.0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                    times[i] += timeOffset;
                }
            }
            return this;
        },
        scale: function(timeScale) {
            if (timeScale !== 1.0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                    times[i] *= timeScale;
                }
            }
            return this;
        },
        trim: function(startTime, endTime) {
            var times = this.times,
                nKeys = times.length,
                from = 0,
                to = nKeys - 1;
            while (from !== nKeys && times[from] < startTime) {
                ++from;
            }
            while (to !== -1 && times[to] > endTime) {
                --to;
            }
            ++to;
            if (from !== 0 || to !== nKeys) {
                if (from >= to) to = Math.max(to, 1), from = to - 1;
                var stride = this.getValueSize();
                this.times = AnimationUtils.arraySlice(times, from, to);
                this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
            }
            return this;
        },
        validate: function() {
            var valid = true;
            var valueSize = this.getValueSize();
            if (valueSize - Math.floor(valueSize) !== 0) {
                console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
                valid = false;
            }
            var times = this.times,
                values = this.values,
                nKeys = times.length;
            if (nKeys === 0) {
                console.error('THREE.KeyframeTrack: Track is empty.', this);
                valid = false;
            }
            var prevTime = null;
            for (var i = 0; i !== nKeys; i++) {
                var currTime = times[i];
                if (typeof currTime === 'number' && isNaN(currTime)) {
                    console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
                    valid = false;
                    break;
                }
                if (prevTime !== null && prevTime > currTime) {
                    console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
                    valid = false;
                    break;
                }
                prevTime = currTime;
            }
            if (values !== undefined) {
                if (AnimationUtils.isTypedArray(values)) {
                    for (var i = 0, n = values.length; i !== n; ++i) {
                        var value = values[i];
                        if (isNaN(value)) {
                            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
                            valid = false;
                            break;
                        }
                    }
                }
            }
            return valid;
        },
        optimize: function() {
            var times = this.times,
                values = this.values,
                stride = this.getValueSize(),
                smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
                writeIndex = 1,
                lastIndex = times.length - 1;
            for (var i = 1; i < lastIndex; ++i) {
                var keep = false;
                var time = times[i];
                var timeNext = times[i + 1];
                if (time !== timeNext && (i !== 1 || time !== time[0])) {
                    if (!smoothInterpolation) {
                        var offset = i * stride,
                            offsetP = offset - stride,
                            offsetN = offset + stride;
                        for (var j = 0; j !== stride; ++j) {
                            var value = values[offset + j];
                            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                                keep = true;
                                break;
                            }
                        }
                    } else {
                        keep = true;
                    }
                }
                if (keep) {
                    if (i !== writeIndex) {
                        times[writeIndex] = times[i];
                        var readOffset = i * stride,
                            writeOffset = writeIndex * stride;
                        for (var j = 0; j !== stride; ++j) {
                            values[writeOffset + j] = values[readOffset + j];
                        }
                    }
                    ++writeIndex;
                }
            }
            if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
                    values[writeOffset + j] = values[readOffset + j];
                }
                ++writeIndex;
            }
            if (writeIndex !== times.length) {
                this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
                this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
            }
            return this;
        }
    });

    function VectorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: VectorKeyframeTrack,
        ValueTypeName: 'vector'
    });

    function AnimationClip(name, duration, tracks) {
        this.name = name;
        this.tracks = tracks;
        this.duration = (duration !== undefined) ? duration : -1;
        this.uuid = _Math.generateUUID();
        if (this.duration < 0) {
            this.resetDuration();
        }
        this.optimize();
    }
    Object.assign(AnimationClip, {
        parse: function(json) {
            var tracks = [],
                jsonTracks = json.tracks,
                frameTime = 1.0 / (json.fps || 1.0);
            for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
                tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
            }
            return new AnimationClip(json.name, json.duration, tracks);
        },
        toJSON: function(clip) {
            var tracks = [],
                clipTracks = clip.tracks;
            var json = {
                'name': clip.name,
                'duration': clip.duration,
                'tracks': tracks
            };
            for (var i = 0, n = clipTracks.length; i !== n; ++i) {
                tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
            }
            return json;
        },
        CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
            var numMorphTargets = morphTargetSequence.length;
            var tracks = [];
            for (var i = 0; i < numMorphTargets; i++) {
                var times = [];
                var values = [];
                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
                values.push(0, 1, 0);
                var order = AnimationUtils.getKeyframeOrder(times);
                times = AnimationUtils.sortedArray(times, 1, order);
                values = AnimationUtils.sortedArray(values, 1, order);
                if (!noLoop && times[0] === 0) {
                    times.push(numMorphTargets);
                    values.push(values[0]);
                }
                tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
            }
            return new AnimationClip(name, -1, tracks);
        },
        findByName: function(objectOrClipArray, name) {
            var clipArray = objectOrClipArray;
            if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }
            for (var i = 0; i < clipArray.length; i++) {
                if (clipArray[i].name === name) {
                    return clipArray[i];
                }
            }
            return null;
        },
        CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
            var animationToMorphTargets = {};
            var pattern = /^([\w-]*?)([\d]+)$/;
            for (var i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = morphTargets[i];
                var parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                    var name = parts[1];
                    var animationMorphTargets = animationToMorphTargets[name];
                    if (!animationMorphTargets) {
                        animationToMorphTargets[name] = animationMorphTargets = [];
                    }
                    animationMorphTargets.push(morphTarget);
                }
            }
            var clips = [];
            for (var name in animationToMorphTargets) {
                clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
            }
            return clips;
        },
        parseAnimation: function(animation, bones) {
            if (!animation) {
                console.error('THREE.AnimationClip: No animation in JSONLoader data.');
                return null;
            }
            var addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
                if (animationKeys.length !== 0) {
                    var times = [];
                    var values = [];
                    AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                    if (times.length !== 0) {
                        destTracks.push(new trackType(trackName, times, values));
                    }
                }
            };
            var tracks = [];
            var clipName = animation.name || 'default';
            var duration = animation.length || -1;
            var fps = animation.fps || 30;
            var hierarchyTracks = animation.hierarchy || [];
            for (var h = 0; h < hierarchyTracks.length; h++) {
                var animationKeys = hierarchyTracks[h].keys;
                if (!animationKeys || animationKeys.length === 0) continue;
                if (animationKeys[0].morphTargets) {
                    var morphTargetNames = {};
                    for (var k = 0; k < animationKeys.length; k++) {
                        if (animationKeys[k].morphTargets) {
                            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                            }
                        }
                    }
                    for (var morphTargetName in morphTargetNames) {
                        var times = [];
                        var values = [];
                        for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                            var animationKey = animationKeys[k];
                            times.push(animationKey.time);
                            values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
                        }
                        tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                    }
                    duration = morphTargetNames.length * (fps || 1.0);
                } else {
                    var boneName = '.bones[' + bones[h].name + ']';
                    addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                    addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                    addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
                }
            }
            if (tracks.length === 0) {
                return null;
            }
            var clip = new AnimationClip(clipName, duration, tracks);
            return clip;
        }
    });
    Object.assign(AnimationClip.prototype, {
        resetDuration: function() {
            var tracks = this.tracks,
                duration = 0;
            for (var i = 0, n = tracks.length; i !== n; ++i) {
                var track = this.tracks[i];
                duration = Math.max(duration, track.times[track.times.length - 1]);
            }
            this.duration = duration;
        },
        trim: function() {
            for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].trim(0, this.duration);
            }
            return this;
        },
        optimize: function() {
            for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].optimize();
            }
            return this;
        }
    });

    function MaterialLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this.textures = {};
    }
    Object.assign(MaterialLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        setTextures: function(value) {
            this.textures = value;
        },
        parse: function(json) {
            var textures = this.textures;

            function getTexture(name) {
                if (textures[name] === undefined) {
                    console.warn('THREE.MaterialLoader: Undefined texture', name);
                }
                return textures[name];
            }
            var material = new Materials[json.type]();
            if (json.uuid !== undefined) material.uuid = json.uuid;
            if (json.name !== undefined) material.name = json.name;
            if (json.color !== undefined) material.color.setHex(json.color);
            if (json.roughness !== undefined) material.roughness = json.roughness;
            if (json.metalness !== undefined) material.metalness = json.metalness;
            if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
            if (json.specular !== undefined) material.specular.setHex(json.specular);
            if (json.shininess !== undefined) material.shininess = json.shininess;
            if (json.clearCoat !== undefined) material.clearCoat = json.clearCoat;
            if (json.clearCoatRoughness !== undefined) material.clearCoatRoughness = json.clearCoatRoughness;
            if (json.uniforms !== undefined) material.uniforms = json.uniforms;
            if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
            if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
            if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
            if (json.fog !== undefined) material.fog = json.fog;
            if (json.flatShading !== undefined) material.flatShading = json.flatShading;
            if (json.blending !== undefined) material.blending = json.blending;
            if (json.side !== undefined) material.side = json.side;
            if (json.opacity !== undefined) material.opacity = json.opacity;
            if (json.transparent !== undefined) material.transparent = json.transparent;
            if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
            if (json.depthTest !== undefined) material.depthTest = json.depthTest;
            if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
            if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
            if (json.wireframe !== undefined) material.wireframe = json.wireframe;
            if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
            if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
            if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
            if (json.rotation !== undefined) material.rotation = json.rotation;
            if (json.linewidth !== 1) material.linewidth = json.linewidth;
            if (json.dashSize !== undefined) material.dashSize = json.dashSize;
            if (json.gapSize !== undefined) material.gapSize = json.gapSize;
            if (json.scale !== undefined) material.scale = json.scale;
            if (json.skinning !== undefined) material.skinning = json.skinning;
            if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
            if (json.dithering !== undefined) material.dithering = json.dithering;
            if (json.visible !== undefined) material.visible = json.visible;
            if (json.userData !== undefined) material.userData = json.userData;
            if (json.shading !== undefined) material.flatShading = json.shading === 1;
            if (json.size !== undefined) material.size = json.size;
            if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
            if (json.map !== undefined) material.map = getTexture(json.map);
            if (json.alphaMap !== undefined) {
                material.alphaMap = getTexture(json.alphaMap);
                material.transparent = true;
            }
            if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
            if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
            if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
            if (json.normalScale !== undefined) {
                var normalScale = json.normalScale;
                if (Array.isArray(normalScale) === false) {
                    normalScale = [normalScale, normalScale];
                }
                material.normalScale = new Vector2().fromArray(normalScale);
            }
            if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
            if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
            if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
            if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
            if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
            if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
            if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
            if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
            if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
            if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
            if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
            if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
            if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
            if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
            if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
            return material;
        }
    });

    function BufferGeometryLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(BufferGeometryLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.load(url, function(text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        parse: function(json) {
            var geometry = new BufferGeometry();
            var index = json.data.index;
            if (index !== undefined) {
                var typedArray = new TYPED_ARRAYS[index.type](index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
            }
            var attributes = json.data.attributes;
            for (var key in attributes) {
                var attribute = attributes[key];
                var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
            }
            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
            if (groups !== undefined) {
                for (var i = 0, n = groups.length; i !== n; ++i) {
                    var group = groups[i];
                    geometry.addGroup(group.start, group.count, group.materialIndex);
                }
            }
            var boundingSphere = json.data.boundingSphere;
            if (boundingSphere !== undefined) {
                var center = new Vector3();
                if (boundingSphere.center !== undefined) {
                    center.fromArray(boundingSphere.center);
                }
                geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
            }
            return geometry;
        }
    });
    var TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };

    function Loader() {
        this.onLoadStart = function() {};
        this.onLoadProgress = function() {};
        this.onLoadComplete = function() {};
    }
    Loader.Handlers = {
        handlers: [],
        add: function(regex, loader) {
            this.handlers.push(regex, loader);
        },
        get: function(file) {
            var handlers = this.handlers;
            for (var i = 0, l = handlers.length; i < l; i += 2) {
                var regex = handlers[i];
                var loader = handlers[i + 1];
                if (regex.test(file)) {
                    return loader;
                }
            }
            return null;
        }
    };
    Object.assign(Loader.prototype, {
        crossOrigin: undefined,
        initMaterials: function(materials, texturePath, crossOrigin) {
            var array = [];
            for (var i = 0; i < materials.length; ++i) {
                array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
            }
            return array;
        },
        createMaterial: (function() {
            var BlendingMode = {
                NoBlending: NoBlending,
                NormalBlending: NormalBlending,
                AdditiveBlending: AdditiveBlending,
                SubtractiveBlending: SubtractiveBlending,
                MultiplyBlending: MultiplyBlending,
                CustomBlending: CustomBlending
            };
            var color = new Color();
            var textureLoader = new TextureLoader();
            var materialLoader = new MaterialLoader();
            return function createMaterial(m, texturePath, crossOrigin) {
                var textures = {};

                function loadTexture(path, repeat, offset, wrap, anisotropy) {
                    var fullPath = texturePath + path;
                    var loader = Loader.Handlers.get(fullPath);
                    var texture;
                    if (loader !== null) {
                        texture = loader.load(fullPath);
                    } else {
                        textureLoader.setCrossOrigin(crossOrigin);
                        texture = textureLoader.load(fullPath);
                    }
                    if (repeat !== undefined) {
                        texture.repeat.fromArray(repeat);
                        if (repeat[0] !== 1) texture.wrapS = RepeatWrapping;
                        if (repeat[1] !== 1) texture.wrapT = RepeatWrapping;
                    }
                    if (offset !== undefined) {
                        texture.offset.fromArray(offset);
                    }
                    if (wrap !== undefined) {
                        if (wrap[0] === 'repeat') texture.wrapS = RepeatWrapping;
                        if (wrap[0] === 'mirror') texture.wrapS = MirroredRepeatWrapping;
                        if (wrap[1] === 'repeat') texture.wrapT = RepeatWrapping;
                        if (wrap[1] === 'mirror') texture.wrapT = MirroredRepeatWrapping;
                    }
                    if (anisotropy !== undefined) {
                        texture.anisotropy = anisotropy;
                    }
                    var uuid = _Math.generateUUID();
                    textures[uuid] = texture;
                    return uuid;
                }
                var json = {
                    uuid: _Math.generateUUID(),
                    type: 'MeshLambertMaterial'
                };
                for (var name in m) {
                    var value = m[name];
                    switch (name) {
                        case 'DbgColor':
                        case 'DbgIndex':
                        case 'opticalDensity':
                        case 'illumination':
                            break;
                        case 'DbgName':
                            json.name = value;
                            break;
                        case 'blending':
                            json.blending = BlendingMode[value];
                            break;
                        case 'colorAmbient':
                        case 'mapAmbient':
                            console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
                            break;
                        case 'colorDiffuse':
                            json.color = color.fromArray(value).getHex();
                            break;
                        case 'colorSpecular':
                            json.specular = color.fromArray(value).getHex();
                            break;
                        case 'colorEmissive':
                            json.emissive = color.fromArray(value).getHex();
                            break;
                        case 'specularCoef':
                            json.shininess = value;
                            break;
                        case 'shading':
                            if (value.toLowerCase() === 'basic') json.type = 'MeshBasicMaterial';
                            if (value.toLowerCase() === 'phong') json.type = 'MeshPhongMaterial';
                            if (value.toLowerCase() === 'standard') json.type = 'MeshStandardMaterial';
                            break;
                        case 'mapDiffuse':
                            json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                            break;
                        case 'mapDiffuseRepeat':
                        case 'mapDiffuseOffset':
                        case 'mapDiffuseWrap':
                        case 'mapDiffuseAnisotropy':
                            break;
                        case 'mapEmissive':
                            json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                            break;
                        case 'mapEmissiveRepeat':
                        case 'mapEmissiveOffset':
                        case 'mapEmissiveWrap':
                        case 'mapEmissiveAnisotropy':
                            break;
                        case 'mapLight':
                            json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                            break;
                        case 'mapLightRepeat':
                        case 'mapLightOffset':
                        case 'mapLightWrap':
                        case 'mapLightAnisotropy':
                            break;
                        case 'mapAO':
                            json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                            break;
                        case 'mapAORepeat':
                        case 'mapAOOffset':
                        case 'mapAOWrap':
                        case 'mapAOAnisotropy':
                            break;
                        case 'mapBump':
                            json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                            break;
                        case 'mapBumpScale':
                            json.bumpScale = value;
                            break;
                        case 'mapBumpRepeat':
                        case 'mapBumpOffset':
                        case 'mapBumpWrap':
                        case 'mapBumpAnisotropy':
                            break;
                        case 'mapNormal':
                            json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                            break;
                        case 'mapNormalFactor':
                            json.normalScale = [value, value];
                            break;
                        case 'mapNormalRepeat':
                        case 'mapNormalOffset':
                        case 'mapNormalWrap':
                        case 'mapNormalAnisotropy':
                            break;
                        case 'mapSpecular':
                            json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                            break;
                        case 'mapSpecularRepeat':
                        case 'mapSpecularOffset':
                        case 'mapSpecularWrap':
                        case 'mapSpecularAnisotropy':
                            break;
                        case 'mapMetalness':
                            json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                            break;
                        case 'mapMetalnessRepeat':
                        case 'mapMetalnessOffset':
                        case 'mapMetalnessWrap':
                        case 'mapMetalnessAnisotropy':
                            break;
                        case 'mapRoughness':
                            json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                            break;
                        case 'mapRoughnessRepeat':
                        case 'mapRoughnessOffset':
                        case 'mapRoughnessWrap':
                        case 'mapRoughnessAnisotropy':
                            break;
                        case 'mapAlpha':
                            json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                            break;
                        case 'mapAlphaRepeat':
                        case 'mapAlphaOffset':
                        case 'mapAlphaWrap':
                        case 'mapAlphaAnisotropy':
                            break;
                        case 'flipSided':
                            json.side = BackSide;
                            break;
                        case 'doubleSided':
                            json.side = DoubleSide;
                            break;
                        case 'transparency':
                            console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
                            json.opacity = value;
                            break;
                        case 'depthTest':
                        case 'depthWrite':
                        case 'colorWrite':
                        case 'opacity':
                        case 'reflectivity':
                        case 'transparent':
                        case 'visible':
                        case 'wireframe':
                            json[name] = value;
                            break;
                        case 'vertexColors':
                            if (value === true) json.vertexColors = VertexColors;
                            if (value === 'face') json.vertexColors = FaceColors;
                            break;
                        default:
                            console.error('THREE.Loader.createMaterial: Unsupported', name, value);
                            break;
                    }
                }
                if (json.type === 'MeshBasicMaterial') delete json.emissive;
                if (json.type !== 'MeshPhongMaterial') delete json.specular;
                if (json.opacity < 1) json.transparent = true;
                materialLoader.setTextures(textures);
                return materialLoader.parse(json);
            };
        })()
    });
    var LoaderUtils = {
        decodeText: function(array) {
            if (typeof TextDecoder !== 'undefined') {
                return new TextDecoder().decode(array);
            }
            var s = '';
            for (var i = 0, il = array.length; i < il; i++) {
                s += String.fromCharCode(array[i]);
            }
            return s;
        },
        extractUrlBase: function(url) {
            var parts = url.split('/');
            if (parts.length === 1) return './';
            parts.pop();
            return parts.join('/') + '/';
        }
    };

    function JSONLoader(manager) {
        if (typeof manager === 'boolean') {
            console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
            manager = undefined;
        }
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this.withCredentials = false;
    }
    Object.assign(JSONLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var texturePath = this.texturePath && (typeof this.texturePath === 'string') ? this.texturePath : LoaderUtils.extractUrlBase(url);
            var loader = new FileLoader(this.manager);
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function(text) {
                var json = JSON.parse(text);
                var metadata = json.metadata;
                if (metadata !== undefined) {
                    var type = metadata.type;
                    if (type !== undefined) {
                        if (type.toLowerCase() === 'object') {
                            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                            return;
                        }
                        if (type.toLowerCase() === 'scene') {
                            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.');
                            return;
                        }
                    }
                }
                var object = scope.parse(json, texturePath);
                onLoad(object.geometry, object.materials);
            }, onProgress, onError);
        },
        setTexturePath: function(value) {
            this.texturePath = value;
        },
        parse: (function() {
            function parseModel(json, geometry) {
                function isBitSet(value, position) {
                    return value & (1 << position);
                }
                var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces,
                    vertices = json.vertices,
                    normals = json.normals,
                    colors = json.colors,
                    scale = json.scale,
                    nUvLayers = 0;
                if (json.uvs !== undefined) {
                    for (i = 0; i < json.uvs.length; i++) {
                        if (json.uvs[i].length) nUvLayers++;
                    }
                    for (i = 0; i < nUvLayers; i++) {
                        geometry.faceVertexUvs[i] = [];
                    }
                }
                offset = 0;
                zLength = vertices.length;
                while (offset < zLength) {
                    vertex = new Vector3();
                    vertex.x = vertices[offset++] * scale;
                    vertex.y = vertices[offset++] * scale;
                    vertex.z = vertices[offset++] * scale;
                    geometry.vertices.push(vertex);
                }
                offset = 0;
                zLength = faces.length;
                while (offset < zLength) {
                    type = faces[offset++];
                    isQuad = isBitSet(type, 0);
                    hasMaterial = isBitSet(type, 1);
                    hasFaceVertexUv = isBitSet(type, 3);
                    hasFaceNormal = isBitSet(type, 4);
                    hasFaceVertexNormal = isBitSet(type, 5);
                    hasFaceColor = isBitSet(type, 6);
                    hasFaceVertexColor = isBitSet(type, 7);
                    if (isQuad) {
                        faceA = new Face3();
                        faceA.a = faces[offset];
                        faceA.b = faces[offset + 1];
                        faceA.c = faces[offset + 3];
                        faceB = new Face3();
                        faceB.a = faces[offset + 1];
                        faceB.b = faces[offset + 2];
                        faceB.c = faces[offset + 3];
                        offset += 4;
                        if (hasMaterial) {
                            materialIndex = faces[offset++];
                            faceA.materialIndex = materialIndex;
                            faceB.materialIndex = materialIndex;
                        }
                        fi = geometry.faces.length;
                        if (hasFaceVertexUv) {
                            for (i = 0; i < nUvLayers; i++) {
                                uvLayer = json.uvs[i];
                                geometry.faceVertexUvs[i][fi] = [];
                                geometry.faceVertexUvs[i][fi + 1] = [];
                                for (j = 0; j < 4; j++) {
                                    uvIndex = faces[offset++];
                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];
                                    uv = new Vector2(u, v);
                                    if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);
                                    if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);
                                }
                            }
                        }
                        if (hasFaceNormal) {
                            normalIndex = faces[offset++] * 3;
                            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                            faceB.normal.copy(faceA.normal);
                        }
                        if (hasFaceVertexNormal) {
                            for (i = 0; i < 4; i++) {
                                normalIndex = faces[offset++] * 3;
                                normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                if (i !== 2) faceA.vertexNormals.push(normal);
                                if (i !== 0) faceB.vertexNormals.push(normal);
                            }
                        }
                        if (hasFaceColor) {
                            colorIndex = faces[offset++];
                            hex = colors[colorIndex];
                            faceA.color.setHex(hex);
                            faceB.color.setHex(hex);
                        }
                        if (hasFaceVertexColor) {
                            for (i = 0; i < 4; i++) {
                                colorIndex = faces[offset++];
                                hex = colors[colorIndex];
                                if (i !== 2) faceA.vertexColors.push(new Color(hex));
                                if (i !== 0) faceB.vertexColors.push(new Color(hex));
                            }
                        }
                        geometry.faces.push(faceA);
                        geometry.faces.push(faceB);
                    } else {
                        face = new Face3();
                        face.a = faces[offset++];
                        face.b = faces[offset++];
                        face.c = faces[offset++];
                        if (hasMaterial) {
                            materialIndex = faces[offset++];
                            face.materialIndex = materialIndex;
                        }
                        fi = geometry.faces.length;
                        if (hasFaceVertexUv) {
                            for (i = 0; i < nUvLayers; i++) {
                                uvLayer = json.uvs[i];
                                geometry.faceVertexUvs[i][fi] = [];
                                for (j = 0; j < 3; j++) {
                                    uvIndex = faces[offset++];
                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];
                                    uv = new Vector2(u, v);
                                    geometry.faceVertexUvs[i][fi].push(uv);
                                }
                            }
                        }
                        if (hasFaceNormal) {
                            normalIndex = faces[offset++] * 3;
                            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                        }
                        if (hasFaceVertexNormal) {
                            for (i = 0; i < 3; i++) {
                                normalIndex = faces[offset++] * 3;
                                normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                face.vertexNormals.push(normal);
                            }
                        }
                        if (hasFaceColor) {
                            colorIndex = faces[offset++];
                            face.color.setHex(colors[colorIndex]);
                        }
                        if (hasFaceVertexColor) {
                            for (i = 0; i < 3; i++) {
                                colorIndex = faces[offset++];
                                face.vertexColors.push(new Color(colors[colorIndex]));
                            }
                        }
                        geometry.faces.push(face);
                    }
                }
            }

            function parseSkin(json, geometry) {
                var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
                if (json.skinWeights) {
                    for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                        var x = json.skinWeights[i];
                        var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
                        var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
                        var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
                        geometry.skinWeights.push(new Vector4(x, y, z, w));
                    }
                }
                if (json.skinIndices) {
                    for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                        var a = json.skinIndices[i];
                        var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
                        var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
                        var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
                        geometry.skinIndices.push(new Vector4(a, b, c, d));
                    }
                }
                geometry.bones = json.bones;
                if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
                    console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
                        geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
                }
            }

            function parseMorphing(json, geometry) {
                var scale = json.scale;
                if (json.morphTargets !== undefined) {
                    for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                        geometry.morphTargets[i] = {};
                        geometry.morphTargets[i].name = json.morphTargets[i].name;
                        geometry.morphTargets[i].vertices = [];
                        var dstVertices = geometry.morphTargets[i].vertices;
                        var srcVertices = json.morphTargets[i].vertices;
                        for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                            var vertex = new Vector3();
                            vertex.x = srcVertices[v] * scale;
                            vertex.y = srcVertices[v + 1] * scale;
                            vertex.z = srcVertices[v + 2] * scale;
                            dstVertices.push(vertex);
                        }
                    }
                }
                if (json.morphColors !== undefined && json.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    var faces = geometry.faces;
                    var morphColors = json.morphColors[0].colors;
                    for (var i = 0, l = faces.length; i < l; i++) {
                        faces[i].color.fromArray(morphColors, i * 3);
                    }
                }
            }

            function parseAnimations(json, geometry) {
                var outputAnimations = [];
                var animations = [];
                if (json.animation !== undefined) {
                    animations.push(json.animation);
                }
                if (json.animations !== undefined) {
                    if (json.animations.length) {
                        animations = animations.concat(json.animations);
                    } else {
                        animations.push(json.animations);
                    }
                }
                for (var i = 0; i < animations.length; i++) {
                    var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                    if (clip) outputAnimations.push(clip);
                }
                if (geometry.morphTargets) {
                    var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                    outputAnimations = outputAnimations.concat(morphAnimationClips);
                }
                if (outputAnimations.length > 0) geometry.animations = outputAnimations;
            }
            return function(json, texturePath) {
                if (json.data !== undefined) {
                    json = json.data;
                }
                if (json.scale !== undefined) {
                    json.scale = 1.0 / json.scale;
                } else {
                    json.scale = 1.0;
                }
                var geometry = new Geometry();
                parseModel(json, geometry);
                parseSkin(json, geometry);
                parseMorphing(json, geometry);
                parseAnimations(json, geometry);
                geometry.computeFaceNormals();
                geometry.computeBoundingSphere();
                if (json.materials === undefined || json.materials.length === 0) {
                    return {
                        geometry: geometry
                    };
                } else {
                    var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
                    return {
                        geometry: geometry,
                        materials: materials
                    };
                }
            };
        })()
    });

    function ObjectLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this.texturePath = '';
    }
    Object.assign(ObjectLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            if (this.texturePath === '') {
                this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
            }
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.load(url, function(text) {
                var json = null;
                try {
                    json = JSON.parse(text);
                } catch (error) {
                    if (onError !== undefined) onError(error);
                    console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                    return;
                }
                var metadata = json.metadata;
                if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                    console.error('THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.');
                    return;
                }
                scope.parse(json, onLoad);
            }, onProgress, onError);
        },
        setTexturePath: function(value) {
            this.texturePath = value;
        },
        setCrossOrigin: function(value) {
            this.crossOrigin = value;
        },
        parse: function(json, onLoad) {
            var shapes = this.parseShape(json.shapes);
            var geometries = this.parseGeometries(json.geometries, shapes);
            var images = this.parseImages(json.images, function() {
                if (onLoad !== undefined) onLoad(object);
            });
            var textures = this.parseTextures(json.textures, images);
            var materials = this.parseMaterials(json.materials, textures);
            var object = this.parseObject(json.object, geometries, materials);
            if (json.animations) {
                object.animations = this.parseAnimations(json.animations);
            }
            if (json.images === undefined || json.images.length === 0) {
                if (onLoad !== undefined) onLoad(object);
            }
            return object;
        },
        parseShape: function(json) {
            var shapes = {};
            if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                    var shape = new Shape().fromJSON(json[i]);
                    shapes[shape.uuid] = shape;
                }
            }
            return shapes;
        },
        parseGeometries: function(json, shapes) {
            var geometries = {};
            if (json !== undefined) {
                var geometryLoader = new JSONLoader();
                var bufferGeometryLoader = new BufferGeometryLoader();
                for (var i = 0, l = json.length; i < l; i++) {
                    var geometry;
                    var data = json[i];
                    switch (data.type) {
                        case 'PlaneGeometry':
                        case 'PlaneBufferGeometry':
                            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                            break;
                        case 'BoxGeometry':
                        case 'BoxBufferGeometry':
                        case 'CubeGeometry':
                            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                            break;
                        case 'CircleGeometry':
                        case 'CircleBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                            break;
                        case 'CylinderGeometry':
                        case 'CylinderBufferGeometry':
                            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                            break;
                        case 'ConeGeometry':
                        case 'ConeBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                            break;
                        case 'SphereGeometry':
                        case 'SphereBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                            break;
                        case 'DodecahedronGeometry':
                        case 'DodecahedronBufferGeometry':
                        case 'IcosahedronGeometry':
                        case 'IcosahedronBufferGeometry':
                        case 'OctahedronGeometry':
                        case 'OctahedronBufferGeometry':
                        case 'TetrahedronGeometry':
                        case 'TetrahedronBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.detail);
                            break;
                        case 'RingGeometry':
                        case 'RingBufferGeometry':
                            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                            break;
                        case 'TorusGeometry':
                        case 'TorusBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                            break;
                        case 'TorusKnotGeometry':
                        case 'TorusKnotBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                            break;
                        case 'LatheGeometry':
                        case 'LatheBufferGeometry':
                            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                            break;
                        case 'PolyhedronGeometry':
                        case 'PolyhedronBufferGeometry':
                            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                            break;
                        case 'ShapeGeometry':
                        case 'ShapeBufferGeometry':
                            var geometryShapes = [];
                            for (var i = 0, l = data.shapes.length; i < l; i++) {
                                var shape = shapes[data.shapes[i]];
                                geometryShapes.push(shape);
                            }
                            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                            break;
                        case 'BufferGeometry':
                            geometry = bufferGeometryLoader.parse(data);
                            break;
                        case 'Geometry':
                            geometry = geometryLoader.parse(data, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                            continue;
                    }
                    geometry.uuid = data.uuid;
                    if (data.name !== undefined) geometry.name = data.name;
                    geometries[data.uuid] = geometry;
                }
            }
            return geometries;
        },
        parseMaterials: function(json, textures) {
            var materials = {};
            if (json !== undefined) {
                var loader = new MaterialLoader();
                loader.setTextures(textures);
                for (var i = 0, l = json.length; i < l; i++) {
                    var data = json[i];
                    if (data.type === 'MultiMaterial') {
                        var array = [];
                        for (var j = 0; j < data.materials.length; j++) {
                            array.push(loader.parse(data.materials[j]));
                        }
                        materials[data.uuid] = array;
                    } else {
                        materials[data.uuid] = loader.parse(data);
                    }
                }
            }
            return materials;
        },
        parseAnimations: function(json) {
            var animations = [];
            for (var i = 0; i < json.length; i++) {
                var clip = AnimationClip.parse(json[i]);
                animations.push(clip);
            }
            return animations;
        },
        parseImages: function(json, onLoad) {
            var scope = this;
            var images = {};

            function loadImage(url) {
                scope.manager.itemStart(url);
                return loader.load(url, function() {
                    scope.manager.itemEnd(url);
                }, undefined, function() {
                    scope.manager.itemEnd(url);
                    scope.manager.itemError(url);
                });
            }
            if (json !== undefined && json.length > 0) {
                var manager = new LoadingManager(onLoad);
                var loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (var i = 0, l = json.length; i < l; i++) {
                    var image = json[i];
                    var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                    images[image.uuid] = loadImage(path);
                }
            }
            return images;
        },
        parseTextures: function(json, images) {
            function parseConstant(value, type) {
                if (typeof value === 'number') return value;
                console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
                return type[value];
            }
            var textures = {};
            if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                    var data = json[i];
                    if (data.image === undefined) {
                        console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                    }
                    if (images[data.image] === undefined) {
                        console.warn('THREE.ObjectLoader: Undefined image', data.image);
                    }
                    var texture = new Texture(images[data.image]);
                    texture.needsUpdate = true;
                    texture.uuid = data.uuid;
                    if (data.name !== undefined) texture.name = data.name;
                    if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
                    if (data.offset !== undefined) texture.offset.fromArray(data.offset);
                    if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
                    if (data.center !== undefined) texture.center.fromArray(data.center);
                    if (data.rotation !== undefined) texture.rotation = data.rotation;
                    if (data.wrap !== undefined) {
                        texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                        texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
                    }
                    if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                    if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                    if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
                    if (data.flipY !== undefined) texture.flipY = data.flipY;
                    textures[data.uuid] = texture;
                }
            }
            return textures;
        },
        parseObject: function() {
            var matrix = new Matrix4();
            return function parseObject(data, geometries, materials) {
                var object;

                function getGeometry(name) {
                    if (geometries[name] === undefined) {
                        console.warn('THREE.ObjectLoader: Undefined geometry', name);
                    }
                    return geometries[name];
                }

                function getMaterial(name) {
                    if (name === undefined) return undefined;
                    if (Array.isArray(name)) {
                        var array = [];
                        for (var i = 0, l = name.length; i < l; i++) {
                            var uuid = name[i];
                            if (materials[uuid] === undefined) {
                                console.warn('THREE.ObjectLoader: Undefined material', uuid);
                            }
                            array.push(materials[uuid]);
                        }
                        return array;
                    }
                    if (materials[name] === undefined) {
                        console.warn('THREE.ObjectLoader: Undefined material', name);
                    }
                    return materials[name];
                }
                switch (data.type) {
                    case 'Scene':
                        object = new Scene();
                        if (data.background !== undefined) {
                            if (Number.isInteger(data.background)) {
                                object.background = new Color(data.background);
                            }
                        }
                        if (data.fog !== undefined) {
                            if (data.fog.type === 'Fog') {
                                object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                            } else if (data.fog.type === 'FogExp2') {
                                object.fog = new FogExp2(data.fog.color, data.fog.density);
                            }
                        }
                        break;
                    case 'PerspectiveCamera':
                        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                        if (data.focus !== undefined) object.focus = data.focus;
                        if (data.zoom !== undefined) object.zoom = data.zoom;
                        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                        if (data.view !== undefined) object.view = Object.assign({}, data.view);
                        break;
                    case 'OrthographicCamera':
                        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                        break;
                    case 'AmbientLight':
                        object = new AmbientLight(data.color, data.intensity);
                        break;
                    case 'DirectionalLight':
                        object = new DirectionalLight(data.color, data.intensity);
                        break;
                    case 'PointLight':
                        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                        break;
                    case 'RectAreaLight':
                        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                        break;
                    case 'SpotLight':
                        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                        break;
                    case 'HemisphereLight':
                        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                        break;
                    case 'SkinnedMesh':
                        console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');
                    case 'Mesh':
                        var geometry = getGeometry(data.geometry);
                        var material = getMaterial(data.material);
                        if (geometry.bones && geometry.bones.length > 0) {
                            object = new SkinnedMesh(geometry, material);
                        } else {
                            object = new Mesh(geometry, material);
                        }
                        break;
                    case 'LOD':
                        object = new LOD();
                        break;
                    case 'Line':
                        object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                        break;
                    case 'LineLoop':
                        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                        break;
                    case 'LineSegments':
                        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                        break;
                    case 'PointCloud':
                    case 'Points':
                        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                        break;
                    case 'Sprite':
                        object = new Sprite(getMaterial(data.material));
                        break;
                    case 'Group':
                        object = new Group();
                        break;
                    default:
                        object = new Object3D();
                }
                object.uuid = data.uuid;
                if (data.name !== undefined) object.name = data.name;
                if (data.matrix !== undefined) {
                    matrix.fromArray(data.matrix);
                    matrix.decompose(object.position, object.quaternion, object.scale);
                } else {
                    if (data.position !== undefined) object.position.fromArray(data.position);
                    if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
                    if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
                    if (data.scale !== undefined) object.scale.fromArray(data.scale);
                }
                if (data.castShadow !== undefined) object.castShadow = data.castShadow;
                if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
                if (data.shadow) {
                    if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
                    if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
                    if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
                    if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
                }
                if (data.visible !== undefined) object.visible = data.visible;
                if (data.userData !== undefined) object.userData = data.userData;
                if (data.children !== undefined) {
                    var children = data.children;
                    for (var i = 0; i < children.length; i++) {
                        object.add(this.parseObject(children[i], geometries, materials));
                    }
                }
                if (data.type === 'LOD') {
                    var levels = data.levels;
                    for (var l = 0; l < levels.length; l++) {
                        var level = levels[l];
                        var child = object.getObjectByProperty('uuid', level.object);
                        if (child !== undefined) {
                            object.addLevel(child, level.distance);
                        }
                    }
                }
                return object;
            };
        }()
    });
    var TEXTURE_MAPPING = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    };
    var TEXTURE_WRAPPING = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    };
    var TEXTURE_FILTER = {
        NearestFilter: NearestFilter,
        NearestMipMapNearestFilter: NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: NearestMipMapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipMapNearestFilter: LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: LinearMipMapLinearFilter
    };

    function ImageBitmapLoader(manager) {
        if (typeof createImageBitmap === 'undefined') {
            console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
        }
        if (typeof fetch === 'undefined') {
            console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
        }
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this.options = undefined;
    }
    ImageBitmapLoader.prototype = {
        constructor: ImageBitmapLoader,
        setOptions: function setOptions(options) {
            this.options = options;
            return this;
        },
        load: function load(url, onLoad, onProgress, onError) {
            if (url === undefined) url = '';
            if (this.path !== undefined) url = this.path + url;
            var scope = this;
            var cached = Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function() {
                    if (onLoad) onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            fetch(url).then(function(res) {
                return res.blob();
            }).then(function(blob) {
                return createImageBitmap(blob, scope.options);
            }).then(function(imageBitmap) {
                Cache.add(url, imageBitmap);
                if (onLoad) onLoad(imageBitmap);
                scope.manager.itemEnd(url);
            }).catch(function(e) {
                if (onError) onError(e);
                scope.manager.itemEnd(url);
                scope.manager.itemError(url);
            });
        },
        setCrossOrigin: function() {
            return this;
        },
        setPath: function(value) {
            this.path = value;
            return this;
        }
    };

    function ShapePath() {
        this.type = 'ShapePath';
        this.subPaths = [];
        this.currentPath = null;
    }
    Object.assign(ShapePath.prototype, {
        moveTo: function(x, y) {
            this.currentPath = new Path();
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(x, y);
        },
        lineTo: function(x, y) {
            this.currentPath.lineTo(x, y);
        },
        quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        },
        bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        },
        splineThru: function(pts) {
            this.currentPath.splineThru(pts);
        },
        toShapes: function(isCCW, noHoles) {
            function toShapesNoHoles(inSubpaths) {
                var shapes = [];
                for (var i = 0, l = inSubpaths.length; i < l; i++) {
                    var tmpPath = inSubpaths[i];
                    var tmpShape = new Shape();
                    tmpShape.curves = tmpPath.curves;
                    shapes.push(tmpShape);
                }
                return shapes;
            }

            function isPointInsidePolygon(inPt, inPolygon) {
                var polyLen = inPolygon.length;
                var inside = false;
                for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                    var edgeLowPt = inPolygon[p];
                    var edgeHighPt = inPolygon[q];
                    var edgeDx = edgeHighPt.x - edgeLowPt.x;
                    var edgeDy = edgeHighPt.y - edgeLowPt.y;
                    if (Math.abs(edgeDy) > Number.EPSILON) {
                        if (edgeDy < 0) {
                            edgeLowPt = inPolygon[q];
                            edgeDx = -edgeDx;
                            edgeHighPt = inPolygon[p];
                            edgeDy = -edgeDy;
                        }
                        if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y)) continue;
                        if (inPt.y === edgeLowPt.y) {
                            if (inPt.x === edgeLowPt.x) return true;
                        } else {
                            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                            if (perpEdge === 0) return true;
                            if (perpEdge < 0) continue;
                            inside = !inside;
                        }
                    } else {
                        if (inPt.y !== edgeLowPt.y) continue;
                        if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) || ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x))) return true;
                    }
                }
                return inside;
            }
            var isClockWise = ShapeUtils.isClockWise;
            var subPaths = this.subPaths;
            if (subPaths.length === 0) return [];
            if (noHoles === true) return toShapesNoHoles(subPaths);
            var solid, tmpPath, tmpShape, shapes = [];
            if (subPaths.length === 1) {
                tmpPath = subPaths[0];
                tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
                return shapes;
            }
            var holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst;
            var betterShapeHoles = [];
            var newShapes = [];
            var newShapeHoles = [];
            var mainIdx = 0;
            var tmpPoints;
            newShapes[mainIdx] = undefined;
            newShapeHoles[mainIdx] = [];
            for (var i = 0, l = subPaths.length; i < l; i++) {
                tmpPath = subPaths[i];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise(tmpPoints);
                solid = isCCW ? !solid : solid;
                if (solid) {
                    if ((!holesFirst) && (newShapes[mainIdx])) mainIdx++;
                    newShapes[mainIdx] = {
                        s: new Shape(),
                        p: tmpPoints
                    };
                    newShapes[mainIdx].s.curves = tmpPath.curves;
                    if (holesFirst) mainIdx++;
                    newShapeHoles[mainIdx] = [];
                } else {
                    newShapeHoles[mainIdx].push({
                        h: tmpPath,
                        p: tmpPoints[0]
                    });
                }
            }
            if (!newShapes[0]) return toShapesNoHoles(subPaths);
            if (newShapes.length > 1) {
                var ambiguous = false;
                var toChange = [];
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    betterShapeHoles[sIdx] = [];
                }
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    var sho = newShapeHoles[sIdx];
                    for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                        var ho = sho[hIdx];
                        var hole_unassigned = true;
                        for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                                if (sIdx !== s2Idx) toChange.push({
                                    froms: sIdx,
                                    tos: s2Idx,
                                    hole: hIdx
                                });
                                if (hole_unassigned) {
                                    hole_unassigned = false;
                                    betterShapeHoles[s2Idx].push(ho);
                                } else {
                                    ambiguous = true;
                                }
                            }
                        }
                        if (hole_unassigned) {
                            betterShapeHoles[sIdx].push(ho);
                        }
                    }
                }
                if (toChange.length > 0) {
                    if (!ambiguous) newShapeHoles = betterShapeHoles;
                }
            }
            var tmpHoles;
            for (var i = 0, il = newShapes.length; i < il; i++) {
                tmpShape = newShapes[i].s;
                shapes.push(tmpShape);
                tmpHoles = newShapeHoles[i];
                for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                    tmpShape.holes.push(tmpHoles[j].h);
                }
            }
            return shapes;
        }
    });

    function Font(data) {
        this.type = 'Font';
        this.data = data;
    }
    Object.assign(Font.prototype, {
        isFont: true,
        generateShapes: function(text, size, divisions) {
            function createPaths(text) {
                var chars = String(text).split('');
                var scale = size / data.resolution;
                var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
                var offsetX = 0,
                    offsetY = 0;
                var paths = [];
                for (var i = 0; i < chars.length; i++) {
                    var char = chars[i];
                    if (char === '\n') {
                        offsetX = 0;
                        offsetY -= line_height;
                    } else {
                        var ret = createPath(char, scale, offsetX, offsetY);
                        offsetX += ret.offsetX;
                        paths.push(ret.path);
                    }
                }
                return paths;
            }

            function createPath(c, scale, offsetX, offsetY) {
                var glyph = data.glyphs[c] || data.glyphs['?'];
                if (!glyph) return;
                var path = new ShapePath();
                var pts = [];
                var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
                if (glyph.o) {
                    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
                    for (var i = 0, l = outline.length; i < l;) {
                        var action = outline[i++];
                        switch (action) {
                            case 'm':
                                x = outline[i++] * scale + offsetX;
                                y = outline[i++] * scale + offsetY;
                                path.moveTo(x, y);
                                break;
                            case 'l':
                                x = outline[i++] * scale + offsetX;
                                y = outline[i++] * scale + offsetY;
                                path.lineTo(x, y);
                                break;
                            case 'q':
                                cpx = outline[i++] * scale + offsetX;
                                cpy = outline[i++] * scale + offsetY;
                                cpx1 = outline[i++] * scale + offsetX;
                                cpy1 = outline[i++] * scale + offsetY;
                                path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                                laste = pts[pts.length - 1];
                                if (laste) {
                                    cpx0 = laste.x;
                                    cpy0 = laste.y;
                                }
                                break;
                            case 'b':
                                cpx = outline[i++] * scale + offsetX;
                                cpy = outline[i++] * scale + offsetY;
                                cpx1 = outline[i++] * scale + offsetX;
                                cpy1 = outline[i++] * scale + offsetY;
                                cpx2 = outline[i++] * scale + offsetX;
                                cpy2 = outline[i++] * scale + offsetY;
                                path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                                laste = pts[pts.length - 1];
                                if (laste) {
                                    cpx0 = laste.x;
                                    cpy0 = laste.y;
                                }
                                break;
                        }
                    }
                }
                return {
                    offsetX: glyph.ha * scale,
                    path: path
                };
            }
            if (size === undefined) size = 100;
            if (divisions === undefined) divisions = 4;
            var data = this.data;
            var paths = createPaths(text);
            var shapes = [];
            for (var p = 0, pl = paths.length; p < pl; p++) {
                Array.prototype.push.apply(shapes, paths[p].toShapes());
            }
            return shapes;
        }
    });

    function FontLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(FontLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.load(url, function(text) {
                var json;
                try {
                    json = JSON.parse(text);
                } catch (e) {
                    console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                    json = JSON.parse(text.substring(65, text.length - 2));
                }
                var font = scope.parse(json);
                if (onLoad) onLoad(font);
            }, onProgress, onError);
        },
        parse: function(json) {
            return new Font(json);
        },
        setPath: function(value) {
            this.path = value;
            return this;
        }
    });
    var context;
    var AudioContext = {
        getContext: function() {
            if (context === undefined) {
                context = new(window.AudioContext || window.webkitAudioContext)();
            }
            return context;
        },
        setContext: function(value) {
            context = value;
        }
    };

    function AudioLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(AudioLoader.prototype, {
        load: function(url, onLoad, onProgress, onError) {
            var loader = new FileLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.load(url, function(buffer) {
                var context = AudioContext.getContext();
                context.decodeAudioData(buffer, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            }, onProgress, onError);
        }
    });

    function StereoCamera() {
        this.type = 'StereoCamera';
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
    }
    Object.assign(StereoCamera.prototype, {
        update: (function() {
            var instance, focus, fov, aspect, near, far, zoom, eyeSep;
            var eyeRight = new Matrix4();
            var eyeLeft = new Matrix4();
            return function update(camera) {
                var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;
                if (needsUpdate) {
                    instance = this;
                    focus = camera.focus;
                    fov = camera.fov;
                    aspect = camera.aspect * this.aspect;
                    near = camera.near;
                    far = camera.far;
                    zoom = camera.zoom;
                    var projectionMatrix = camera.projectionMatrix.clone();
                    eyeSep = this.eyeSep / 2;
                    var eyeSepOnProjection = eyeSep * near / focus;
                    var ymax = (near * Math.tan(_Math.DEG2RAD * fov * 0.5)) / zoom;
                    var xmin, xmax;
                    eyeLeft.elements[12] = -eyeSep;
                    eyeRight.elements[12] = eyeSep;
                    xmin = -ymax * aspect + eyeSepOnProjection;
                    xmax = ymax * aspect + eyeSepOnProjection;
                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                    this.cameraL.projectionMatrix.copy(projectionMatrix);
                    xmin = -ymax * aspect - eyeSepOnProjection;
                    xmax = ymax * aspect - eyeSepOnProjection;
                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                    this.cameraR.projectionMatrix.copy(projectionMatrix);
                }
                this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
                this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
            };
        })()
    });

    function CubeCamera(near, far, cubeResolution) {
        Object3D.call(this);
        this.type = 'CubeCamera';
        var fov = 90,
            aspect = 1;
        var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new Vector3(1, 0, 0));
        this.add(cameraPX);
        var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new Vector3(-1, 0, 0));
        this.add(cameraNX);
        var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new Vector3(0, 1, 0));
        this.add(cameraPY);
        var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new Vector3(0, -1, 0));
        this.add(cameraNY);
        var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new Vector3(0, 0, 1));
        this.add(cameraPZ);
        var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new Vector3(0, 0, -1));
        this.add(cameraNZ);
        var options = {
            format: RGBFormat,
            magFilter: LinearFilter,
            minFilter: LinearFilter
        };
        this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
        this.renderTarget.texture.name = "CubeCamera";
        this.update = function(renderer, scene) {
            if (this.parent === null) this.updateMatrixWorld();
            var renderTarget = this.renderTarget;
            var generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = false;
            renderTarget.activeCubeFace = 0;
            renderer.render(scene, cameraPX, renderTarget);
            renderTarget.activeCubeFace = 1;
            renderer.render(scene, cameraNX, renderTarget);
            renderTarget.activeCubeFace = 2;
            renderer.render(scene, cameraPY, renderTarget);
            renderTarget.activeCubeFace = 3;
            renderer.render(scene, cameraNY, renderTarget);
            renderTarget.activeCubeFace = 4;
            renderer.render(scene, cameraPZ, renderTarget);
            renderTarget.texture.generateMipmaps = generateMipmaps;
            renderTarget.activeCubeFace = 5;
            renderer.render(scene, cameraNZ, renderTarget);
            renderer.setRenderTarget(null);
        };
        this.clear = function(renderer, color, depth, stencil) {
            var renderTarget = this.renderTarget;
            for (var i = 0; i < 6; i++) {
                renderTarget.activeCubeFace = i;
                renderer.setRenderTarget(renderTarget);
                renderer.clear(color, depth, stencil);
            }
            renderer.setRenderTarget(null);
        };
    }
    CubeCamera.prototype = Object.create(Object3D.prototype);
    CubeCamera.prototype.constructor = CubeCamera;

    function AudioListener() {
        Object3D.call(this);
        this.type = 'AudioListener';
        this.context = AudioContext.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
    }
    AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: AudioListener,
        getInput: function() {
            return this.gain;
        },
        removeFilter: function() {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
                this.gain.connect(this.context.destination);
                this.filter = null;
            }
        },
        getFilter: function() {
            return this.filter;
        },
        setFilter: function(value) {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
            } else {
                this.gain.disconnect(this.context.destination);
            }
            this.filter = value;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination);
        },
        getMasterVolume: function() {
            return this.gain.gain.value;
        },
        setMasterVolume: function(value) {
            this.gain.gain.value = value;
        },
        updateMatrixWorld: (function() {
            var position = new Vector3();
            var quaternion = new Quaternion();
            var scale = new Vector3();
            var orientation = new Vector3();
            return function updateMatrixWorld(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                var listener = this.context.listener;
                var up = this.up;
                this.matrixWorld.decompose(position, quaternion, scale);
                orientation.set(0, 0, -1).applyQuaternion(quaternion);
                if (listener.positionX) {
                    listener.positionX.setValueAtTime(position.x, this.context.currentTime);
                    listener.positionY.setValueAtTime(position.y, this.context.currentTime);
                    listener.positionZ.setValueAtTime(position.z, this.context.currentTime);
                    listener.forwardX.setValueAtTime(orientation.x, this.context.currentTime);
                    listener.forwardY.setValueAtTime(orientation.y, this.context.currentTime);
                    listener.forwardZ.setValueAtTime(orientation.z, this.context.currentTime);
                    listener.upX.setValueAtTime(up.x, this.context.currentTime);
                    listener.upY.setValueAtTime(up.y, this.context.currentTime);
                    listener.upZ.setValueAtTime(up.z, this.context.currentTime);
                } else {
                    listener.setPosition(position.x, position.y, position.z);
                    listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
                }
            };
        })()
    });

    function Audio(listener) {
        Object3D.call(this);
        this.type = 'Audio';
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.loop = false;
        this.startTime = 0;
        this.offset = 0;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.sourceType = 'empty';
        this.filters = [];
    }
    Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Audio,
        getOutput: function() {
            return this.gain;
        },
        setNodeSource: function(audioNode) {
            this.hasPlaybackControl = false;
            this.sourceType = 'audioNode';
            this.source = audioNode;
            this.connect();
            return this;
        },
        setBuffer: function(audioBuffer) {
            this.buffer = audioBuffer;
            this.sourceType = 'buffer';
            if (this.autoplay) this.play();
            return this;
        },
        play: function() {
            if (this.isPlaying === true) {
                console.warn('THREE.Audio: Audio is already playing.');
                return;
            }
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            var source = this.context.createBufferSource();
            source.buffer = this.buffer;
            source.loop = this.loop;
            source.onended = this.onEnded.bind(this);
            source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
            this.startTime = this.context.currentTime;
            source.start(this.startTime, this.offset);
            this.isPlaying = true;
            this.source = source;
            return this.connect();
        },
        pause: function() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            if (this.isPlaying === true) {
                this.source.stop();
                this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
                this.isPlaying = false;
            }
            return this;
        },
        stop: function() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.source.stop();
            this.offset = 0;
            this.isPlaying = false;
            return this;
        },
        connect: function() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].connect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else {
                this.source.connect(this.getOutput());
            }
            return this;
        },
        disconnect: function() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].disconnect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else {
                this.source.disconnect(this.getOutput());
            }
            return this;
        },
        getFilters: function() {
            return this.filters;
        },
        setFilters: function(value) {
            if (!value) value = [];
            if (this.isPlaying === true) {
                this.disconnect();
                this.filters = value;
                this.connect();
            } else {
                this.filters = value;
            }
            return this;
        },
        getFilter: function() {
            return this.getFilters()[0];
        },
        setFilter: function(filter) {
            return this.setFilters(filter ? [filter] : []);
        },
        setPlaybackRate: function(value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.playbackRate = value;
            if (this.isPlaying === true) {
                this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime);
            }
            return this;
        },
        getPlaybackRate: function() {
            return this.playbackRate;
        },
        onEnded: function() {
            this.isPlaying = false;
        },
        getLoop: function() {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return false;
            }
            return this.loop;
        },
        setLoop: function(value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.loop = value;
            if (this.isPlaying === true) {
                this.source.loop = this.loop;
            }
            return this;
        },
        getVolume: function() {
            return this.gain.gain.value;
        },
        setVolume: function(value) {
            this.gain.gain.value = value;
            return this;
        }
    });

    function PositionalAudio(listener) {
        Audio.call(this, listener);
        this.panner = this.context.createPanner();
        this.panner.connect(this.gain);
    }
    PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
        constructor: PositionalAudio,
        getOutput: function() {
            return this.panner;
        },
        getRefDistance: function() {
            return this.panner.refDistance;
        },
        setRefDistance: function(value) {
            this.panner.refDistance = value;
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor;
        },
        setRolloffFactor: function(value) {
            this.panner.rolloffFactor = value;
        },
        getDistanceModel: function() {
            return this.panner.distanceModel;
        },
        setDistanceModel: function(value) {
            this.panner.distanceModel = value;
        },
        getMaxDistance: function() {
            return this.panner.maxDistance;
        },
        setMaxDistance: function(value) {
            this.panner.maxDistance = value;
        },
        updateMatrixWorld: (function() {
            var position = new Vector3();
            return function updateMatrixWorld(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                position.setFromMatrixPosition(this.matrixWorld);
                this.panner.setPosition(position.x, position.y, position.z);
            };
        })()
    });

    function AudioAnalyser(audio, fftSize) {
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
    Object.assign(AudioAnalyser.prototype, {
        getFrequencyData: function() {
            this.analyser.getByteFrequencyData(this.data);
            return this.data;
        },
        getAverageFrequency: function() {
            var value = 0,
                data = this.getFrequencyData();
            for (var i = 0; i < data.length; i++) {
                value += data[i];
            }
            return value / data.length;
        }
    });

    function PropertyMixer(binding, typeName, valueSize) {
        this.binding = binding;
        this.valueSize = valueSize;
        var bufferType = Float64Array,
            mixFunction;
        switch (typeName) {
            case 'quaternion':
                mixFunction = this._slerp;
                break;
            case 'string':
            case 'bool':
                bufferType = Array;
                mixFunction = this._select;
                break;
            default:
                mixFunction = this._lerp;
        }
        this.buffer = new bufferType(valueSize * 4);
        this._mixBufferRegion = mixFunction;
        this.cumulativeWeight = 0;
        this.useCount = 0;
        this.referenceCount = 0;
    }
    Object.assign(PropertyMixer.prototype, {
        accumulate: function(accuIndex, weight) {
            var buffer = this.buffer,
                stride = this.valueSize,
                offset = accuIndex * stride + stride,
                currentWeight = this.cumulativeWeight;
            if (currentWeight === 0) {
                for (var i = 0; i !== stride; ++i) {
                    buffer[offset + i] = buffer[i];
                }
                currentWeight = weight;
            } else {
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }
            this.cumulativeWeight = currentWeight;
        },
        apply: function(accuIndex) {
            var stride = this.valueSize,
                buffer = this.buffer,
                offset = accuIndex * stride + stride,
                weight = this.cumulativeWeight,
                binding = this.binding;
            this.cumulativeWeight = 0;
            if (weight < 1) {
                var originalValueOffset = stride * 3;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
            }
            for (var i = stride, e = stride + stride; i !== e; ++i) {
                if (buffer[i] !== buffer[i + stride]) {
                    binding.setValue(buffer, offset);
                    break;
                }
            }
        },
        saveOriginalState: function() {
            var binding = this.binding;
            var buffer = this.buffer,
                stride = this.valueSize,
                originalValueOffset = stride * 3;
            binding.getValue(buffer, originalValueOffset);
            for (var i = stride, e = originalValueOffset; i !== e; ++i) {
                buffer[i] = buffer[originalValueOffset + (i % stride)];
            }
            this.cumulativeWeight = 0;
        },
        restoreOriginalState: function() {
            var originalValueOffset = this.valueSize * 3;
            this.binding.setValue(this.buffer, originalValueOffset);
        },
        _select: function(buffer, dstOffset, srcOffset, t, stride) {
            if (t >= 0.5) {
                for (var i = 0; i !== stride; ++i) {
                    buffer[dstOffset + i] = buffer[srcOffset + i];
                }
            }
        },
        _slerp: function(buffer, dstOffset, srcOffset, t) {
            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        },
        _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
            var s = 1 - t;
            for (var i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
            }
        }
    });

    function Composite(targetGroup, path, optionalParsedPath) {
        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    Object.assign(Composite.prototype, {
        getValue: function(array, offset) {
            this.bind();
            var firstValidIndex = this._targetGroup.nCachedObjects_,
                binding = this._bindings[firstValidIndex];
            if (binding !== undefined) binding.getValue(array, offset);
        },
        setValue: function(array, offset) {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].setValue(array, offset);
            }
        },
        bind: function() {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].bind();
            }
        },
        unbind: function() {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].unbind();
            }
        }
    });

    function PropertyBinding(rootNode, path, parsedPath) {
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
    }
    Object.assign(PropertyBinding, {
        Composite: Composite,
        create: function(root, path, parsedPath) {
            if (!(root && root.isAnimationObjectGroup)) {
                return new PropertyBinding(root, path, parsedPath);
            } else {
                return new PropertyBinding.Composite(root, path, parsedPath);
            }
        },
        sanitizeNodeName: function(name) {
            return name.replace(/\s/g, '_').replace(/[^\w-]/g, '');
        },
        parseTrackName: function() {
            var directoryRe = /((?:[\w-]+[\/:])*)/;
            var nodeRe = /([\w-\.]+)?/;
            var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;
            var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;
            var trackRe = new RegExp('' + '^' + directoryRe.source + nodeRe.source + objectRe.source + propertyRe.source + '$');
            var supportedObjectNames = ['material', 'materials', 'bones'];
            return function(trackName) {
                var matches = trackRe.exec(trackName);
                if (!matches) {
                    throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
                }
                var results = {
                    nodeName: matches[2],
                    objectName: matches[3],
                    objectIndex: matches[4],
                    propertyName: matches[5],
                    propertyIndex: matches[6]
                };
                var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
                if (lastDot !== undefined && lastDot !== -1) {
                    var objectName = results.nodeName.substring(lastDot + 1);
                    if (supportedObjectNames.indexOf(objectName) !== -1) {
                        results.nodeName = results.nodeName.substring(0, lastDot);
                        results.objectName = objectName;
                    }
                }
                if (results.propertyName === null || results.propertyName.length === 0) {
                    throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
                }
                return results;
            };
        }(),
        findNode: function(root, nodeName) {
            if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
                return root;
            }
            if (root.skeleton) {
                var searchSkeleton = function(skeleton) {
                    for (var i = 0; i < skeleton.bones.length; i++) {
                        var bone = skeleton.bones[i];
                        if (bone.name === nodeName) {
                            return bone;
                        }
                    }
                    return null;
                };
                var bone = searchSkeleton(root.skeleton);
                if (bone) {
                    return bone;
                }
            }
            if (root.children) {
                var searchNodeSubtree = function(children) {
                    for (var i = 0; i < children.length; i++) {
                        var childNode = children[i];
                        if (childNode.name === nodeName || childNode.uuid === nodeName) {
                            return childNode;
                        }
                        var result = searchNodeSubtree(childNode.children);
                        if (result) return result;
                    }
                    return null;
                };
                var subTreeNode = searchNodeSubtree(root.children);
                if (subTreeNode) {
                    return subTreeNode;
                }
            }
            return null;
        }
    });
    Object.assign(PropertyBinding.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function getValue_direct(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        }, function getValue_array(buffer, offset) {
            var source = this.resolvedProperty;
            for (var i = 0, n = source.length; i !== n; ++i) {
                buffer[offset++] = source[i];
            }
        }, function getValue_arrayElement(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        }, function getValue_toArray(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        }],
        SetterByBindingTypeAndVersioning: [
            [function setValue_direct(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
            }, function setValue_direct_setNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.needsUpdate = true;
            }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }],
            [function setValue_array(buffer, offset) {
                var dest = this.resolvedProperty;
                for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                }
            }, function setValue_array_setNeedsUpdate(buffer, offset) {
                var dest = this.resolvedProperty;
                for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                }
                this.targetObject.needsUpdate = true;
            }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                var dest = this.resolvedProperty;
                for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                }
                this.targetObject.matrixWorldNeedsUpdate = true;
            }],
            [function setValue_arrayElement(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
            }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.needsUpdate = true;
            }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }],
            [function setValue_fromArray(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
            }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.needsUpdate = true;
            }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.matrixWorldNeedsUpdate = true;
            }]
        ],
        getValue: function getValue_unbound(targetArray, offset) {
            this.bind();
            this.getValue(targetArray, offset);
        },
        setValue: function getValue_unbound(sourceArray, offset) {
            this.bind();
            this.setValue(sourceArray, offset);
        },
        bind: function() {
            var targetObject = this.node,
                parsedPath = this.parsedPath,
                objectName = parsedPath.objectName,
                propertyName = parsedPath.propertyName,
                propertyIndex = parsedPath.propertyIndex;
            if (!targetObject) {
                targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
                this.node = targetObject;
            }
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;
            if (!targetObject) {
                console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
                return;
            }
            if (objectName) {
                var objectIndex = parsedPath.objectIndex;
                switch (objectName) {
                    case 'materials':
                        if (!targetObject.material) {
                            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                            return;
                        }
                        if (!targetObject.material.materials) {
                            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                            return;
                        }
                        targetObject = targetObject.material.materials;
                        break;
                    case 'bones':
                        if (!targetObject.skeleton) {
                            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                            return;
                        }
                        targetObject = targetObject.skeleton.bones;
                        for (var i = 0; i < targetObject.length; i++) {
                            if (targetObject[i].name === objectIndex) {
                                objectIndex = i;
                                break;
                            }
                        }
                        break;
                    default:
                        if (targetObject[objectName] === undefined) {
                            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                            return;
                        }
                        targetObject = targetObject[objectName];
                }
                if (objectIndex !== undefined) {
                    if (targetObject[objectIndex] === undefined) {
                        console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                        return;
                    }
                    targetObject = targetObject[objectIndex];
                }
            }
            var nodeProperty = targetObject[propertyName];
            if (nodeProperty === undefined) {
                var nodeName = parsedPath.nodeName;
                console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
                    '.' + propertyName + ' but it wasn\'t found.', targetObject);
                return;
            }
            var versioning = this.Versioning.None;
            if (targetObject.needsUpdate !== undefined) {
                versioning = this.Versioning.NeedsUpdate;
                this.targetObject = targetObject;
            } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
                versioning = this.Versioning.MatrixWorldNeedsUpdate;
                this.targetObject = targetObject;
            }
            var bindingType = this.BindingType.Direct;
            if (propertyIndex !== undefined) {
                if (propertyName === "morphTargetInfluences") {
                    if (!targetObject.geometry) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                        return;
                    }
                    if (targetObject.geometry.isBufferGeometry) {
                        if (!targetObject.geometry.morphAttributes) {
                            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                            return;
                        }
                        for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
                            if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
                                propertyIndex = i;
                                break;
                            }
                        }
                    } else {
                        if (!targetObject.geometry.morphTargets) {
                            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this);
                            return;
                        }
                        for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
                            if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                                propertyIndex = i;
                                break;
                            }
                        }
                    }
                }
                bindingType = this.BindingType.ArrayElement;
                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
            } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                bindingType = this.BindingType.HasFromToArray;
                this.resolvedProperty = nodeProperty;
            } else if (Array.isArray(nodeProperty)) {
                bindingType = this.BindingType.EntireArray;
                this.resolvedProperty = nodeProperty;
            } else {
                this.propertyName = propertyName;
            }
            this.getValue = this.GetterByBindingType[bindingType];
            this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        },
        unbind: function() {
            this.node = null;
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
        }
    });
    Object.assign(PropertyBinding.prototype, {
        _getValue_unbound: PropertyBinding.prototype.getValue,
        _setValue_unbound: PropertyBinding.prototype.setValue,
    });

    function AnimationObjectGroup() {
        this.uuid = _Math.generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        var indices = {};
        this._indicesByUUID = indices;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            indices[arguments[i].uuid] = i;
        }
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        var scope = this;
        this.stats = {
            objects: {get total() {
                    return scope._objects.length;
                },
                get inUse() {
                    return this.total - scope.nCachedObjects_;
                }
            },
            get bindingsPerObject() {
                return scope._bindings.length;
            }
        };
    }
    Object.assign(AnimationObjectGroup.prototype, {
        isAnimationObjectGroup: true,
        add: function() {
            var objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                indicesByUUID = this._indicesByUUID,
                paths = this._paths,
                parsedPaths = this._parsedPaths,
                bindings = this._bindings,
                nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i],
                    uuid = object.uuid,
                    index = indicesByUUID[uuid],
                    knownObject = undefined;
                if (index === undefined) {
                    index = nObjects++;
                    indicesByUUID[uuid] = index;
                    objects.push(object);
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                    }
                } else if (index < nCachedObjects) {
                    knownObject = objects[index];
                    var firstActiveIndex = --nCachedObjects,
                        lastCachedObject = objects[firstActiveIndex];
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    indicesByUUID[uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j],
                            lastCached = bindingsForPath[firstActiveIndex],
                            binding = bindingsForPath[index];
                        bindingsForPath[index] = lastCached;
                        if (binding === undefined) {
                            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                        }
                        bindingsForPath[firstActiveIndex] = binding;
                    }
                } else if (objects[index] !== knownObject) {
                    console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' +
                        'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        remove: function() {
            var objects = this._objects,
                nCachedObjects = this.nCachedObjects_,
                indicesByUUID = this._indicesByUUID,
                bindings = this._bindings,
                nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i],
                    uuid = object.uuid,
                    index = indicesByUUID[uuid];
                if (index !== undefined && index >= nCachedObjects) {
                    var lastCachedIndex = nCachedObjects++,
                        firstActiveObject = objects[lastCachedIndex];
                    indicesByUUID[firstActiveObject.uuid] = index;
                    objects[index] = firstActiveObject;
                    indicesByUUID[uuid] = lastCachedIndex;
                    objects[lastCachedIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j],
                            firstActive = bindingsForPath[lastCachedIndex],
                            binding = bindingsForPath[index];
                        bindingsForPath[index] = firstActive;
                        bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        uncache: function() {
            var objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                indicesByUUID = this._indicesByUUID,
                bindings = this._bindings,
                nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i],
                    uuid = object.uuid,
                    index = indicesByUUID[uuid];
                if (index !== undefined) {
                    delete indicesByUUID[uuid];
                    if (index < nCachedObjects) {
                        var firstActiveIndex = --nCachedObjects,
                            lastCachedObject = objects[firstActiveIndex],
                            lastIndex = --nObjects,
                            lastObject = objects[lastIndex];
                        indicesByUUID[lastCachedObject.uuid] = index;
                        objects[index] = lastCachedObject;
                        indicesByUUID[lastObject.uuid] = firstActiveIndex;
                        objects[firstActiveIndex] = lastObject;
                        objects.pop();
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j],
                                lastCached = bindingsForPath[firstActiveIndex],
                                last = bindingsForPath[lastIndex];
                            bindingsForPath[index] = lastCached;
                            bindingsForPath[firstActiveIndex] = last;
                            bindingsForPath.pop();
                        }
                    } else {
                        var lastIndex = --nObjects,
                            lastObject = objects[lastIndex];
                        indicesByUUID[lastObject.uuid] = index;
                        objects[index] = lastObject;
                        objects.pop();
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j];
                            bindingsForPath[index] = bindingsForPath[lastIndex];
                            bindingsForPath.pop();
                        }
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        subscribe_: function(path, parsedPath) {
            var indicesByPath = this._bindingsIndicesByPath,
                index = indicesByPath[path],
                bindings = this._bindings;
            if (index !== undefined) return bindings[index];
            var paths = this._paths,
                parsedPaths = this._parsedPaths,
                objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                bindingsForPath = new Array(nObjects);
            index = bindings.length;
            indicesByPath[path] = index;
            paths.push(path);
            parsedPaths.push(parsedPath);
            bindings.push(bindingsForPath);
            for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                var object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
            }
            return bindingsForPath;
        },
        unsubscribe_: function(path) {
            var indicesByPath = this._bindingsIndicesByPath,
                index = indicesByPath[path];
            if (index !== undefined) {
                var paths = this._paths,
                    parsedPaths = this._parsedPaths,
                    bindings = this._bindings,
                    lastBindingsIndex = bindings.length - 1,
                    lastBindings = bindings[lastBindingsIndex],
                    lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index;
                bindings[index] = lastBindings;
                bindings.pop();
                parsedPaths[index] = parsedPaths[lastBindingsIndex];
                parsedPaths.pop();
                paths[index] = paths[lastBindingsIndex];
                paths.pop();
            }
        }
    });

    function AnimationAction(mixer, clip, localRoot) {
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot || null;
        var tracks = clip.tracks,
            nTracks = tracks.length,
            interpolants = new Array(nTracks);
        var interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
        for (var i = 0; i !== nTracks; ++i) {
            var interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants;
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null;
        this._byClipCacheIndex = null;
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity;
        this.paused = false;
        this.enabled = true;
        this.clampWhenFinished = false;
        this.zeroSlopeAtStart = true;
        this.zeroSlopeAtEnd = true;
    }
    Object.assign(AnimationAction.prototype, {
        play: function() {
            this._mixer._activateAction(this);
            return this;
        },
        stop: function() {
            this._mixer._deactivateAction(this);
            return this.reset();
        },
        reset: function() {
            this.paused = false;
            this.enabled = true;
            this.time = 0;
            this._loopCount = -1;
            this._startTime = null;
            return this.stopFading().stopWarping();
        },
        isRunning: function() {
            return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this);
        },
        startAt: function(time) {
            this._startTime = time;
            return this;
        },
        setLoop: function(mode, repetitions) {
            this.loop = mode;
            this.repetitions = repetitions;
            return this;
        },
        setEffectiveWeight: function(weight) {
            this.weight = weight;
            this._effectiveWeight = this.enabled ? weight : 0;
            return this.stopFading();
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight;
        },
        fadeIn: function(duration) {
            return this._scheduleFading(duration, 0, 1);
        },
        fadeOut: function(duration) {
            return this._scheduleFading(duration, 1, 0);
        },
        crossFadeFrom: function(fadeOutAction, duration, warp) {
            fadeOutAction.fadeOut(duration);
            this.fadeIn(duration);
            if (warp) {
                var fadeInDuration = this._clip.duration,
                    fadeOutDuration = fadeOutAction._clip.duration,
                    startEndRatio = fadeOutDuration / fadeInDuration,
                    endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1.0, startEndRatio, duration);
                this.warp(endStartRatio, 1.0, duration);
            }
            return this;
        },
        crossFadeTo: function(fadeInAction, duration, warp) {
            return fadeInAction.crossFadeFrom(this, duration, warp);
        },
        stopFading: function() {
            var weightInterpolant = this._weightInterpolant;
            if (weightInterpolant !== null) {
                this._weightInterpolant = null;
                this._mixer._takeBackControlInterpolant(weightInterpolant);
            }
            return this;
        },
        setEffectiveTimeScale: function(timeScale) {
            this.timeScale = timeScale;
            this._effectiveTimeScale = this.paused ? 0 : timeScale;
            return this.stopWarping();
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale;
        },
        setDuration: function(duration) {
            this.timeScale = this._clip.duration / duration;
            return this.stopWarping();
        },
        syncWith: function(action) {
            this.time = action.time;
            this.timeScale = action.timeScale;
            return this.stopWarping();
        },
        halt: function(duration) {
            return this.warp(this._effectiveTimeScale, 0, duration);
        },
        warp: function(startTimeScale, endTimeScale, duration) {
            var mixer = this._mixer,
                now = mixer.time,
                interpolant = this._timeScaleInterpolant,
                timeScale = this.timeScale;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._timeScaleInterpolant = interpolant;
            }
            var times = interpolant.parameterPositions,
                values = interpolant.sampleValues;
            times[0] = now;
            times[1] = now + duration;
            values[0] = startTimeScale / timeScale;
            values[1] = endTimeScale / timeScale;
            return this;
        },
        stopWarping: function() {
            var timeScaleInterpolant = this._timeScaleInterpolant;
            if (timeScaleInterpolant !== null) {
                this._timeScaleInterpolant = null;
                this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
            }
            return this;
        },
        getMixer: function() {
            return this._mixer;
        },
        getClip: function() {
            return this._clip;
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root;
        },
        _update: function(time, deltaTime, timeDirection, accuIndex) {
            if (!this.enabled) {
                this._updateWeight(time);
                return;
            }
            var startTime = this._startTime;
            if (startTime !== null) {
                var timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || timeDirection === 0) {
                    return;
                }
                this._startTime = null;
                deltaTime = timeDirection * timeRunning;
            }
            deltaTime *= this._updateTimeScale(time);
            var clipTime = this._updateTime(deltaTime);
            var weight = this._updateWeight(time);
            if (weight > 0) {
                var interpolants = this._interpolants;
                var propertyMixers = this._propertyBindings;
                for (var j = 0, m = interpolants.length; j !== m; ++j) {
                    interpolants[j].evaluate(clipTime);
                    propertyMixers[j].accumulate(accuIndex, weight);
                }
            }
        },
        _updateWeight: function(time) {
            var weight = 0;
            if (this.enabled) {
                weight = this.weight;
                var interpolant = this._weightInterpolant;
                if (interpolant !== null) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    weight *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopFading();
                        if (interpolantValue === 0) {
                            this.enabled = false;
                        }
                    }
                }
            }
            this._effectiveWeight = weight;
            return weight;
        },
        _updateTimeScale: function(time) {
            var timeScale = 0;
            if (!this.paused) {
                timeScale = this.timeScale;
                var interpolant = this._timeScaleInterpolant;
                if (interpolant !== null) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    timeScale *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopWarping();
                        if (timeScale === 0) {
                            this.paused = true;
                        } else {
                            this.timeScale = timeScale;
                        }
                    }
                }
            }
            this._effectiveTimeScale = timeScale;
            return timeScale;
        },
        _updateTime: function(deltaTime) {
            var time = this.time + deltaTime;
            if (deltaTime === 0) return time;
            var duration = this._clip.duration,
                loop = this.loop,
                loopCount = this._loopCount;
            if (loop === LoopOnce) {
                if (loopCount === -1) {
                    this._loopCount = 0;
                    this._setEndings(true, true, false);
                }
                handle_stop: {
                    if (time >= duration) {
                        time = duration;
                    } else if (time < 0) {
                        time = 0;
                    } else break handle_stop;
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: deltaTime < 0 ? -1 : 1
                    });
                }
            } else {
                var pingPong = (loop === LoopPingPong);
                if (loopCount === -1) {
                    if (deltaTime >= 0) {
                        loopCount = 0;
                        this._setEndings(true, this.repetitions === 0, pingPong);
                    } else {
                        this._setEndings(this.repetitions === 0, true, pingPong);
                    }
                }
                if (time >= duration || time < 0) {
                    var loopDelta = Math.floor(time / duration);
                    time -= duration * loopDelta;
                    loopCount += Math.abs(loopDelta);
                    var pending = this.repetitions - loopCount;
                    if (pending < 0) {
                        if (this.clampWhenFinished) this.paused = true;
                        else this.enabled = false;
                        time = deltaTime > 0 ? duration : 0;
                        this._mixer.dispatchEvent({
                            type: 'finished',
                            action: this,
                            direction: deltaTime > 0 ? 1 : -1
                        });
                    } else {
                        if (pending === 0) {
                            var atStart = deltaTime < 0;
                            this._setEndings(atStart, !atStart, pingPong);
                        } else {
                            this._setEndings(false, false, pingPong);
                        }
                        this._loopCount = loopCount;
                        this._mixer.dispatchEvent({
                            type: 'loop',
                            action: this,
                            loopDelta: loopDelta
                        });
                    }
                }
                if (pingPong && (loopCount & 1) === 1) {
                    this.time = time;
                    return duration - time;
                }
            }
            this.time = time;
            return time;
        },
        _setEndings: function(atStart, atEnd, pingPong) {
            var settings = this._interpolantSettings;
            if (pingPong) {
                settings.endingStart = ZeroSlopeEnding;
                settings.endingEnd = ZeroSlopeEnding;
            } else {
                if (atStart) {
                    settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                    settings.endingStart = WrapAroundEnding;
                }
                if (atEnd) {
                    settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                    settings.endingEnd = WrapAroundEnding;
                }
            }
        },
        _scheduleFading: function(duration, weightNow, weightThen) {
            var mixer = this._mixer,
                now = mixer.time,
                interpolant = this._weightInterpolant;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._weightInterpolant = interpolant;
            }
            var times = interpolant.parameterPositions,
                values = interpolant.sampleValues;
            times[0] = now;
            values[0] = weightNow;
            times[1] = now + duration;
            values[1] = weightThen;
            return this;
        }
    });

    function AnimationMixer(root) {
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1.0;
    }
    AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: AnimationMixer,
        _bindAction: function(action, prototypeAction) {
            var root = action._localRoot || this._root,
                tracks = action._clip.tracks,
                nTracks = tracks.length,
                bindings = action._propertyBindings,
                interpolants = action._interpolants,
                rootUuid = root.uuid,
                bindingsByRoot = this._bindingsByRootAndName,
                bindingsByName = bindingsByRoot[rootUuid];
            if (bindingsByName === undefined) {
                bindingsByName = {};
                bindingsByRoot[rootUuid] = bindingsByName;
            }
            for (var i = 0; i !== nTracks; ++i) {
                var track = tracks[i],
                    trackName = track.name,
                    binding = bindingsByName[trackName];
                if (binding !== undefined) {
                    bindings[i] = binding;
                } else {
                    binding = bindings[i];
                    if (binding !== undefined) {
                        if (binding._cacheIndex === null) {
                            ++binding.referenceCount;
                            this._addInactiveBinding(binding, rootUuid, trackName);
                        }
                        continue;
                    }
                    var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                    binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                    ++binding.referenceCount;
                    this._addInactiveBinding(binding, rootUuid, trackName);
                    bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
            }
        },
        _activateAction: function(action) {
            if (!this._isActiveAction(action)) {
                if (action._cacheIndex === null) {
                    var rootUuid = (action._localRoot || this._root).uuid,
                        clipUuid = action._clip.uuid,
                        actionsForClip = this._actionsByClip[clipUuid];
                    this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                    this._addInactiveAction(action, clipUuid, rootUuid);
                }
                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    if (binding.useCount++ === 0) {
                        this._lendBinding(binding);
                        binding.saveOriginalState();
                    }
                }
                this._lendAction(action);
            }
        },
        _deactivateAction: function(action) {
            if (this._isActiveAction(action)) {
                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    if (--binding.useCount === 0) {
                        binding.restoreOriginalState();
                        this._takeBackBinding(binding);
                    }
                }
                this._takeBackAction(action);
            }
        },
        _initMemoryManager: function() {
            this._actions = [];
            this._nActiveActions = 0;
            this._actionsByClip = {};
            this._bindings = [];
            this._nActiveBindings = 0;
            this._bindingsByRootAndName = {};
            this._controlInterpolants = [];
            this._nActiveControlInterpolants = 0;
            var scope = this;
            this.stats = {
                actions: {get total() {
                        return scope._actions.length;
                    },
                    get inUse() {
                        return scope._nActiveActions;
                    }
                },
                bindings: {get total() {
                        return scope._bindings.length;
                    },
                    get inUse() {
                        return scope._nActiveBindings;
                    }
                },
                controlInterpolants: {get total() {
                        return scope._controlInterpolants.length;
                    },
                    get inUse() {
                        return scope._nActiveControlInterpolants;
                    }
                }
            };
        },
        _isActiveAction: function(action) {
            var index = action._cacheIndex;
            return index !== null && index < this._nActiveActions;
        },
        _addInactiveAction: function(action, clipUuid, rootUuid) {
            var actions = this._actions,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip === undefined) {
                actionsForClip = {
                    knownActions: [action],
                    actionByRoot: {}
                };
                action._byClipCacheIndex = 0;
                actionsByClip[clipUuid] = actionsForClip;
            } else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length;
                knownActions.push(action);
            }
            action._cacheIndex = actions.length;
            actions.push(action);
            actionsForClip.actionByRoot[rootUuid] = action;
        },
        _removeInactiveAction: function(action) {
            var actions = this._actions,
                lastInactiveAction = actions[actions.length - 1],
                cacheIndex = action._cacheIndex;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            action._cacheIndex = null;
            var clipUuid = action._clip.uuid,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[clipUuid],
                knownActionsForClip = actionsForClip.knownActions,
                lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
                byClipCacheIndex = action._byClipCacheIndex;
            lastKnownAction._byClipCacheIndex = byClipCacheIndex;
            knownActionsForClip[byClipCacheIndex] = lastKnownAction;
            knownActionsForClip.pop();
            action._byClipCacheIndex = null;
            var actionByRoot = actionsForClip.actionByRoot,
                rootUuid = (action._localRoot || this._root).uuid;
            delete actionByRoot[rootUuid];
            if (knownActionsForClip.length === 0) {
                delete actionsByClip[clipUuid];
            }
            this._removeInactiveBindingsForAction(action);
        },
        _removeInactiveBindingsForAction: function(action) {
            var bindings = action._propertyBindings;
            for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (--binding.referenceCount === 0) {
                    this._removeInactiveBinding(binding);
                }
            }
        },
        _lendAction: function(action) {
            var actions = this._actions,
                prevIndex = action._cacheIndex,
                lastActiveIndex = this._nActiveActions++,
                firstInactiveAction = actions[lastActiveIndex];
            action._cacheIndex = lastActiveIndex;
            actions[lastActiveIndex] = action;
            firstInactiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = firstInactiveAction;
        },
        _takeBackAction: function(action) {
            var actions = this._actions,
                prevIndex = action._cacheIndex,
                firstInactiveIndex = --this._nActiveActions,
                lastActiveAction = actions[firstInactiveIndex];
            action._cacheIndex = firstInactiveIndex;
            actions[firstInactiveIndex] = action;
            lastActiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = lastActiveAction;
        },
        _addInactiveBinding: function(binding, rootUuid, trackName) {
            var bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[rootUuid],
                bindings = this._bindings;
            if (bindingByName === undefined) {
                bindingByName = {};
                bindingsByRoot[rootUuid] = bindingByName;
            }
            bindingByName[trackName] = binding;
            binding._cacheIndex = bindings.length;
            bindings.push(binding);
        },
        _removeInactiveBinding: function(binding) {
            var bindings = this._bindings,
                propBinding = binding.binding,
                rootUuid = propBinding.rootNode.uuid,
                trackName = propBinding.path,
                bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[rootUuid],
                lastInactiveBinding = bindings[bindings.length - 1],
                cacheIndex = binding._cacheIndex;
            lastInactiveBinding._cacheIndex = cacheIndex;
            bindings[cacheIndex] = lastInactiveBinding;
            bindings.pop();
            delete bindingByName[trackName];
            remove_empty_map: {
                for (var _ in bindingByName) break remove_empty_map;
                delete bindingsByRoot[rootUuid];
            }
        },
        _lendBinding: function(binding) {
            var bindings = this._bindings,
                prevIndex = binding._cacheIndex,
                lastActiveIndex = this._nActiveBindings++,
                firstInactiveBinding = bindings[lastActiveIndex];
            binding._cacheIndex = lastActiveIndex;
            bindings[lastActiveIndex] = binding;
            firstInactiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = firstInactiveBinding;
        },
        _takeBackBinding: function(binding) {
            var bindings = this._bindings,
                prevIndex = binding._cacheIndex,
                firstInactiveIndex = --this._nActiveBindings,
                lastActiveBinding = bindings[firstInactiveIndex];
            binding._cacheIndex = firstInactiveIndex;
            bindings[firstInactiveIndex] = binding;
            lastActiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = lastActiveBinding;
        },
        _lendControlInterpolant: function() {
            var interpolants = this._controlInterpolants,
                lastActiveIndex = this._nActiveControlInterpolants++,
                interpolant = interpolants[lastActiveIndex];
            if (interpolant === undefined) {
                interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[lastActiveIndex] = interpolant;
            }
            return interpolant;
        },
        _takeBackControlInterpolant: function(interpolant) {
            var interpolants = this._controlInterpolants,
                prevIndex = interpolant.__cacheIndex,
                firstInactiveIndex = --this._nActiveControlInterpolants,
                lastActiveInterpolant = interpolants[firstInactiveIndex];
            interpolant.__cacheIndex = firstInactiveIndex;
            interpolants[firstInactiveIndex] = interpolant;
            lastActiveInterpolant.__cacheIndex = prevIndex;
            interpolants[prevIndex] = lastActiveInterpolant;
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(clip, optionalRoot) {
            var root = optionalRoot || this._root,
                rootUuid = root.uuid,
                clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
                clipUuid = clipObject !== null ? clipObject.uuid : clip,
                actionsForClip = this._actionsByClip[clipUuid],
                prototypeAction = null;
            if (actionsForClip !== undefined) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (existingAction !== undefined) {
                    return existingAction;
                }
                prototypeAction = actionsForClip.knownActions[0];
                if (clipObject === null)
                    clipObject = prototypeAction._clip;
            }
            if (clipObject === null) return null;
            var newAction = new AnimationAction(this, clipObject, optionalRoot);
            this._bindAction(newAction, prototypeAction);
            this._addInactiveAction(newAction, clipUuid, rootUuid);
            return newAction;
        },
        existingAction: function(clip, optionalRoot) {
            var root = optionalRoot || this._root,
                rootUuid = root.uuid,
                clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
                clipUuid = clipObject ? clipObject.uuid : clip,
                actionsForClip = this._actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                return actionsForClip.actionByRoot[rootUuid] || null;
            }
            return null;
        },
        stopAllAction: function() {
            var actions = this._actions,
                nActions = this._nActiveActions,
                bindings = this._bindings,
                nBindings = this._nActiveBindings;
            this._nActiveActions = 0;
            this._nActiveBindings = 0;
            for (var i = 0; i !== nActions; ++i) {
                actions[i].reset();
            }
            for (var i = 0; i !== nBindings; ++i) {
                bindings[i].useCount = 0;
            }
            return this;
        },
        update: function(deltaTime) {
            deltaTime *= this.timeScale;
            var actions = this._actions,
                nActions = this._nActiveActions,
                time = this.time += deltaTime,
                timeDirection = Math.sign(deltaTime),
                accuIndex = this._accuIndex ^= 1;
            for (var i = 0; i !== nActions; ++i) {
                var action = actions[i];
                action._update(time, deltaTime, timeDirection, accuIndex);
            }
            var bindings = this._bindings,
                nBindings = this._nActiveBindings;
            for (var i = 0; i !== nBindings; ++i) {
                bindings[i].apply(accuIndex);
            }
            return this;
        },
        getRoot: function() {
            return this._root;
        },
        uncacheClip: function(clip) {
            var actions = this._actions,
                clipUuid = clip.uuid,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                var actionsToRemove = actionsForClip.knownActions;
                for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                    var action = actionsToRemove[i];
                    this._deactivateAction(action);
                    var cacheIndex = action._cacheIndex,
                        lastInactiveAction = actions[actions.length - 1];
                    action._cacheIndex = null;
                    action._byClipCacheIndex = null;
                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[cacheIndex] = lastInactiveAction;
                    actions.pop();
                    this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
            }
        },
        uncacheRoot: function(root) {
            var rootUuid = root.uuid,
                actionsByClip = this._actionsByClip;
            for (var clipUuid in actionsByClip) {
                var actionByRoot = actionsByClip[clipUuid].actionByRoot,
                    action = actionByRoot[rootUuid];
                if (action !== undefined) {
                    this._deactivateAction(action);
                    this._removeInactiveAction(action);
                }
            }
            var bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[rootUuid];
            if (bindingByName !== undefined) {
                for (var trackName in bindingByName) {
                    var binding = bindingByName[trackName];
                    binding.restoreOriginalState();
                    this._removeInactiveBinding(binding);
                }
            }
        },
        uncacheAction: function(clip, optionalRoot) {
            var action = this.existingAction(clip, optionalRoot);
            if (action !== null) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
    });

    function Uniform(value) {
        if (typeof value === 'string') {
            console.warn('THREE.Uniform: Type parameter is no longer needed.');
            value = arguments[1];
        }
        this.value = value;
    }
    Uniform.prototype.clone = function() {
        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
    };

    function InstancedBufferGeometry() {
        BufferGeometry.call(this);
        this.type = 'InstancedBufferGeometry';
        this.maxInstancedCount = undefined;
    }
    InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
        constructor: InstancedBufferGeometry,
        isInstancedBufferGeometry: true,
        copy: function(source) {
            BufferGeometry.prototype.copy.call(this, source);
            this.maxInstancedCount = source.maxInstancedCount;
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        }
    });

    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
        this.uuid = _Math.generateUUID();
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized === true;
    }
    Object.defineProperties(InterleavedBufferAttribute.prototype, {
        count: {
            get: function() {
                return this.data.count;
            }
        },
        array: {
            get: function() {
                return this.data.array;
            }
        }
    });
    Object.assign(InterleavedBufferAttribute.prototype, {
        isInterleavedBufferAttribute: true,
        setX: function(index, x) {
            this.data.array[index * this.data.stride + this.offset] = x;
            return this;
        },
        setY: function(index, y) {
            this.data.array[index * this.data.stride + this.offset + 1] = y;
            return this;
        },
        setZ: function(index, z) {
            this.data.array[index * this.data.stride + this.offset + 2] = z;
            return this;
        },
        setW: function(index, w) {
            this.data.array[index * this.data.stride + this.offset + 3] = w;
            return this;
        },
        getX: function(index) {
            return this.data.array[index * this.data.stride + this.offset];
        },
        getY: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 1];
        },
        getZ: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 2];
        },
        getW: function(index) {
            return this.data.array[index * this.data.stride + this.offset + 3];
        },
        setXY: function(index, x, y) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            return this;
        },
        setXYZ: function(index, x, y, z) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            return this;
        },
        setXYZW: function(index, x, y, z, w) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            this.data.array[index + 3] = w;
            return this;
        }
    });

    function InterleavedBuffer(array, stride) {
        this.uuid = _Math.generateUUID();
        this.array = array;
        this.stride = stride;
        this.count = array !== undefined ? array.length / stride : 0;
        this.dynamic = false;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.onUploadCallback = function() {};
        this.version = 0;
    }
    Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
        set: function(value) {
            if (value === true) this.version++;
        }
    });
    Object.assign(InterleavedBuffer.prototype, {
        isInterleavedBuffer: true,
        setArray: function(array) {
            if (Array.isArray(array)) {
                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }
            this.count = array !== undefined ? array.length / this.stride : 0;
            this.array = array;
        },
        setDynamic: function(value) {
            this.dynamic = value;
            return this;
        },
        copy: function(source) {
            this.array = new source.array.constructor(source.array);
            this.count = source.count;
            this.stride = source.stride;
            this.dynamic = source.dynamic;
            return this;
        },
        copyAt: function(index1, attribute, index2) {
            index1 *= this.stride;
            index2 *= attribute.stride;
            for (var i = 0, l = this.stride; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        },
        set: function(value, offset) {
            if (offset === undefined) offset = 0;
            this.array.set(value, offset);
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        onUpload: function(callback) {
            this.onUploadCallback = callback;
            return this;
        }
    });

    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
        InterleavedBuffer.call(this, array, stride);
        this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
        constructor: InstancedInterleavedBuffer,
        isInstancedInterleavedBuffer: true,
        copy: function(source) {
            InterleavedBuffer.prototype.copy.call(this, source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        }
    });

    function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
        BufferAttribute.call(this, array, itemSize);
        this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
        constructor: InstancedBufferAttribute,
        isInstancedBufferAttribute: true,
        copy: function(source) {
            BufferAttribute.prototype.copy.call(this, source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        }
    });

    function Raycaster(origin, direction, near, far) {
        this.ray = new Ray(origin, direction);
        this.near = near || 0;
        this.far = far || Infinity;
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                    return this.Points;
                }
            }
        });
    }

    function ascSort(a, b) {
        return a.distance - b.distance;
    }

    function intersectObject(object, raycaster, intersects, recursive) {
        if (object.visible === false) return;
        object.raycast(raycaster, intersects);
        if (recursive === true) {
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                intersectObject(children[i], raycaster, intersects, true);
            }
        }
    }
    Object.assign(Raycaster.prototype, {
        linePrecision: 1,
        set: function(origin, direction) {
            this.ray.set(origin, direction);
        },
        setFromCamera: function(coords, camera) {
            if ((camera && camera.isPerspectiveCamera)) {
                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            } else if ((camera && camera.isOrthographicCamera)) {
                this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            } else {
                console.error('THREE.Raycaster: Unsupported camera type.');
            }
        },
        intersectObject: function(object, recursive) {
            var intersects = [];
            intersectObject(object, this, intersects, recursive);
            intersects.sort(ascSort);
            return intersects;
        },
        intersectObjects: function(objects, recursive) {
            var intersects = [];
            if (Array.isArray(objects) === false) {
                console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
                return intersects;
            }
            for (var i = 0, l = objects.length; i < l; i++) {
                intersectObject(objects[i], this, intersects, recursive);
            }
            intersects.sort(ascSort);
            return intersects;
        }
    });

    function Clock(autoStart) {
        this.autoStart = (autoStart !== undefined) ? autoStart : true;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
    }
    Object.assign(Clock.prototype, {
        start: function() {
            this.startTime = (typeof performance === 'undefined' ? Date : performance).now();
            this.oldTime = this.startTime;
            this.elapsedTime = 0;
            this.running = true;
        },
        stop: function() {
            this.getElapsedTime();
            this.running = false;
            this.autoStart = false;
        },
        getElapsedTime: function() {
            this.getDelta();
            return this.elapsedTime;
        },
        getDelta: function() {
            var diff = 0;
            if (this.autoStart && !this.running) {
                this.start();
                return 0;
            }
            if (this.running) {
                var newTime = (typeof performance === 'undefined' ? Date : performance).now();
                diff = (newTime - this.oldTime) / 1000;
                this.oldTime = newTime;
                this.elapsedTime += diff;
            }
            return diff;
        }
    });

    function Spherical(radius, phi, theta) {
        this.radius = (radius !== undefined) ? radius : 1.0;
        this.phi = (phi !== undefined) ? phi : 0;
        this.theta = (theta !== undefined) ? theta : 0;
        return this;
    }
    Object.assign(Spherical.prototype, {
        set: function(radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(other) {
            this.radius = other.radius;
            this.phi = other.phi;
            this.theta = other.theta;
            return this;
        },
        makeSafe: function() {
            var EPS = 0.000001;
            this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
            return this;
        },
        setFromVector3: function(vec3) {
            this.radius = vec3.length();
            if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
            } else {
                this.theta = Math.atan2(vec3.x, vec3.z);
                this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1));
            }
            return this;
        }
    });

    function Cylindrical(radius, theta, y) {
        this.radius = (radius !== undefined) ? radius : 1.0;
        this.theta = (theta !== undefined) ? theta : 0;
        this.y = (y !== undefined) ? y : 0;
        return this;
    }
    Object.assign(Cylindrical.prototype, {
        set: function(radius, theta, y) {
            this.radius = radius;
            this.theta = theta;
            this.y = y;
            return this;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(other) {
            this.radius = other.radius;
            this.theta = other.theta;
            this.y = other.y;
            return this;
        },
        setFromVector3: function(vec3) {
            this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z);
            this.theta = Math.atan2(vec3.x, vec3.z);
            this.y = vec3.y;
            return this;
        }
    });

    function ImmediateRenderObject(material) {
        Object3D.call(this);
        this.material = material;
        this.render = function() {};
    }
    ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
    ImmediateRenderObject.prototype.isImmediateRenderObject = true;

    function VertexNormalsHelper(object, size, hex, linewidth) {
        this.object = object;
        this.size = (size !== undefined) ? size : 1;
        var color = (hex !== undefined) ? hex : 0xff0000;
        var width = (linewidth !== undefined) ? linewidth : 1;
        var nNormals = 0;
        var objGeometry = this.object.geometry;
        if (objGeometry && objGeometry.isGeometry) {
            nNormals = objGeometry.faces.length * 3;
        } else if (objGeometry && objGeometry.isBufferGeometry) {
            nNormals = objGeometry.attributes.normal.count;
        }
        var geometry = new BufferGeometry();
        var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
        geometry.addAttribute('position', positions);
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        }));
        this.matrixAutoUpdate = false;
        this.update();
    }
    VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
    VertexNormalsHelper.prototype.update = (function() {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var normalMatrix = new Matrix3();
        return function update() {
            var keys = ['a', 'b', 'c'];
            this.object.updateMatrixWorld(true);
            normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld;
            var position = this.geometry.attributes.position;
            var objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) {
                var vertices = objGeometry.vertices;
                var faces = objGeometry.faces;
                var idx = 0;
                for (var i = 0, l = faces.length; i < l; i++) {
                    var face = faces[i];
                    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                        var vertex = vertices[face[keys[j]]];
                        var normal = face.vertexNormals[j];
                        v1.copy(vertex).applyMatrix4(matrixWorld);
                        v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                        position.setXYZ(idx, v1.x, v1.y, v1.z);
                        idx = idx + 1;
                        position.setXYZ(idx, v2.x, v2.y, v2.z);
                        idx = idx + 1;
                    }
                }
            } else if (objGeometry && objGeometry.isBufferGeometry) {
                var objPos = objGeometry.attributes.position;
                var objNorm = objGeometry.attributes.normal;
                var idx = 0;
                for (var j = 0, jl = objPos.count; j < jl; j++) {
                    v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
                    v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
                    v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                    position.setXYZ(idx, v1.x, v1.y, v1.z);
                    idx = idx + 1;
                    position.setXYZ(idx, v2.x, v2.y, v2.z);
                    idx = idx + 1;
                }
            }
            position.needsUpdate = true;
        };
    }());

    function SpotLightHelper(light, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        var geometry = new BufferGeometry();
        var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
            var p1 = (i / l) * Math.PI * 2;
            var p2 = (j / l) * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
        var material = new LineBasicMaterial({
            fog: false
        });
        this.cone = new LineSegments(geometry, material);
        this.add(this.cone);
        this.update();
    }
    SpotLightHelper.prototype = Object.create(Object3D.prototype);
    SpotLightHelper.prototype.constructor = SpotLightHelper;
    SpotLightHelper.prototype.dispose = function() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
    };
    SpotLightHelper.prototype.update = function() {
        var vector = new Vector3();
        var vector2 = new Vector3();
        return function update() {
            this.light.updateMatrixWorld();
            var coneLength = this.light.distance ? this.light.distance : 1000;
            var coneWidth = coneLength * Math.tan(this.light.angle);
            this.cone.scale.set(coneWidth, coneWidth, coneLength);
            vector.setFromMatrixPosition(this.light.matrixWorld);
            vector2.setFromMatrixPosition(this.light.target.matrixWorld);
            this.cone.lookAt(vector2.sub(vector));
            if (this.color !== undefined) {
                this.cone.material.color.set(this.color);
            } else {
                this.cone.material.color.copy(this.light.color);
            }
        };
    }();

    function getBoneList(object) {
        var boneList = [];
        if (object && object.isBone) {
            boneList.push(object);
        }
        for (var i = 0; i < object.children.length; i++) {
            boneList.push.apply(boneList, getBoneList(object.children[i]));
        }
        return boneList;
    }

    function SkeletonHelper(object) {
        var bones = getBoneList(object);
        var geometry = new BufferGeometry();
        var vertices = [];
        var colors = [];
        var color1 = new Color(0, 0, 1);
        var color2 = new Color(0, 1, 0);
        for (var i = 0; i < bones.length; i++) {
            var bone = bones[i];
            if (bone.parent && bone.parent.isBone) {
                vertices.push(0, 0, 0);
                vertices.push(0, 0, 0);
                colors.push(color1.r, color1.g, color1.b);
                colors.push(color2.r, color2.g, color2.b);
            }
        }
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        LineSegments.call(this, geometry, material);
        this.root = object;
        this.bones = bones;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
    }
    SkeletonHelper.prototype = Object.create(LineSegments.prototype);
    SkeletonHelper.prototype.constructor = SkeletonHelper;
    SkeletonHelper.prototype.updateMatrixWorld = function() {
        var vector = new Vector3();
        var boneMatrix = new Matrix4();
        var matrixWorldInv = new Matrix4();
        return function updateMatrixWorld(force) {
            var bones = this.bones;
            var geometry = this.geometry;
            var position = geometry.getAttribute('position');
            matrixWorldInv.getInverse(this.root.matrixWorld);
            for (var i = 0, j = 0; i < bones.length; i++) {
                var bone = bones[i];
                if (bone.parent && bone.parent.isBone) {
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                    vector.setFromMatrixPosition(boneMatrix);
                    position.setXYZ(j, vector.x, vector.y, vector.z);
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                    vector.setFromMatrixPosition(boneMatrix);
                    position.setXYZ(j + 1, vector.x, vector.y, vector.z);
                    j += 2;
                }
            }
            geometry.getAttribute('position').needsUpdate = true;
            Object3D.prototype.updateMatrixWorld.call(this, force);
        };
    }();

    function PointLightHelper(light, sphereSize, color) {
        this.light = light;
        this.light.updateMatrixWorld();
        this.color = color;
        var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
        var material = new MeshBasicMaterial({
            wireframe: true,
            fog: false
        });
        Mesh.call(this, geometry, material);
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
    }
    PointLightHelper.prototype = Object.create(Mesh.prototype);
    PointLightHelper.prototype.constructor = PointLightHelper;
    PointLightHelper.prototype.dispose = function() {
        this.geometry.dispose();
        this.material.dispose();
    };
    PointLightHelper.prototype.update = function() {
        if (this.color !== undefined) {
            this.material.color.set(this.color);
        } else {
            this.material.color.copy(this.light.color);
        }
    };

    function RectAreaLightHelper(light, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        var material = new LineBasicMaterial({
            fog: false
        });
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new BufferAttribute(new Float32Array(5 * 3), 3));
        this.line = new Line(geometry, material);
        this.add(this.line);
        this.update();
    }
    RectAreaLightHelper.prototype = Object.create(Object3D.prototype);
    RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
    RectAreaLightHelper.prototype.dispose = function() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    };
    RectAreaLightHelper.prototype.update = function() {
        var hx = this.light.width * 0.5;
        var hy = this.light.height * 0.5;
        var position = this.line.geometry.attributes.position;
        var array = position.array;
        array[0] = hx;
        array[1] = -hy;
        array[2] = 0;
        array[3] = hx;
        array[4] = hy;
        array[5] = 0;
        array[6] = -hx;
        array[7] = hy;
        array[8] = 0;
        array[9] = -hx;
        array[10] = -hy;
        array[11] = 0;
        array[12] = hx;
        array[13] = -hy;
        array[14] = 0;
        position.needsUpdate = true;
        if (this.color !== undefined) {
            this.line.material.color.set(this.color);
        } else {
            this.line.material.color.copy(this.light.color);
        }
    };

    function HemisphereLightHelper(light, size, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        var geometry = new OctahedronBufferGeometry(size);
        geometry.rotateY(Math.PI * 0.5);
        this.material = new MeshBasicMaterial({
            wireframe: true,
            fog: false
        });
        if (this.color === undefined) this.material.vertexColors = VertexColors;
        var position = geometry.getAttribute('position');
        var colors = new Float32Array(position.count * 3);
        geometry.addAttribute('color', new BufferAttribute(colors, 3));
        this.add(new Mesh(geometry, this.material));
        this.update();
    }
    HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
    HemisphereLightHelper.prototype.dispose = function() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    };
    HemisphereLightHelper.prototype.update = function() {
        var vector = new Vector3();
        var color1 = new Color();
        var color2 = new Color();
        return function update() {
            var mesh = this.children[0];
            if (this.color !== undefined) {
                this.material.color.set(this.color);
            } else {
                var colors = mesh.geometry.getAttribute('color');
                color1.copy(this.light.color);
                color2.copy(this.light.groundColor);
                for (var i = 0, l = colors.count; i < l; i++) {
                    var color = (i < (l / 2)) ? color1 : color2;
                    colors.setXYZ(i, color.r, color.g, color.b);
                }
                colors.needsUpdate = true;
            }
            mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        };
    }();

    function GridHelper(size, divisions, color1, color2) {
        size = size || 10;
        divisions = divisions || 10;
        color1 = new Color(color1 !== undefined ? color1 : 0x444444);
        color2 = new Color(color2 !== undefined ? color2 : 0x888888);
        var center = divisions / 2;
        var step = size / divisions;
        var halfSize = size / 2;
        var vertices = [],
            colors = [];
        for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            var color = i === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
        }
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    GridHelper.prototype = Object.create(LineSegments.prototype);
    GridHelper.prototype.constructor = GridHelper;

    function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
        radius = radius || 10;
        radials = radials || 16;
        circles = circles || 8;
        divisions = divisions || 64;
        color1 = new Color(color1 !== undefined ? color1 : 0x444444);
        color2 = new Color(color2 !== undefined ? color2 : 0x888888);
        var vertices = [];
        var colors = [];
        var x, z;
        var v, i, j, r, color;
        for (i = 0; i <= radials; i++) {
            v = (i / radials) * (Math.PI * 2);
            x = Math.sin(v) * radius;
            z = Math.cos(v) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x, 0, z);
            color = (i & 1) ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
        }
        for (i = 0; i <= circles; i++) {
            color = (i & 1) ? color1 : color2;
            r = radius - (radius / circles * i);
            for (j = 0; j < divisions; j++) {
                v = (j / divisions) * (Math.PI * 2);
                x = Math.sin(v) * r;
                z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
                v = ((j + 1) / divisions) * (Math.PI * 2);
                x = Math.sin(v) * r;
                z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
            }
        }
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    PolarGridHelper.prototype = Object.create(LineSegments.prototype);
    PolarGridHelper.prototype.constructor = PolarGridHelper;

    function FaceNormalsHelper(object, size, hex, linewidth) {
        this.object = object;
        this.size = (size !== undefined) ? size : 1;
        var color = (hex !== undefined) ? hex : 0xffff00;
        var width = (linewidth !== undefined) ? linewidth : 1;
        var nNormals = 0;
        var objGeometry = this.object.geometry;
        if (objGeometry && objGeometry.isGeometry) {
            nNormals = objGeometry.faces.length;
        } else {
            console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
        }
        var geometry = new BufferGeometry();
        var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
        geometry.addAttribute('position', positions);
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        }));
        this.matrixAutoUpdate = false;
        this.update();
    }
    FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
    FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
    FaceNormalsHelper.prototype.update = (function() {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var normalMatrix = new Matrix3();
        return function update() {
            this.object.updateMatrixWorld(true);
            normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld;
            var position = this.geometry.attributes.position;
            var objGeometry = this.object.geometry;
            var vertices = objGeometry.vertices;
            var faces = objGeometry.faces;
            var idx = 0;
            for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                var normal = face.normal;
                v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                position.setXYZ(idx, v1.x, v1.y, v1.z);
                idx = idx + 1;
                position.setXYZ(idx, v2.x, v2.y, v2.z);
                idx = idx + 1;
            }
            position.needsUpdate = true;
        };
    }());

    function DirectionalLightHelper(light, size, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        if (size === undefined) size = 1;
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
        var material = new LineBasicMaterial({
            fog: false
        });
        this.lightPlane = new Line(geometry, material);
        this.add(this.lightPlane);
        geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
        this.targetLine = new Line(geometry, material);
        this.add(this.targetLine);
        this.update();
    }
    DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
    DirectionalLightHelper.prototype.dispose = function() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
    };
    DirectionalLightHelper.prototype.update = function() {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var v3 = new Vector3();
        return function update() {
            v1.setFromMatrixPosition(this.light.matrixWorld);
            v2.setFromMatrixPosition(this.light.target.matrixWorld);
            v3.subVectors(v2, v1);
            this.lightPlane.lookAt(v3);
            if (this.color !== undefined) {
                this.lightPlane.material.color.set(this.color);
                this.targetLine.material.color.set(this.color);
            } else {
                this.lightPlane.material.color.copy(this.light.color);
                this.targetLine.material.color.copy(this.light.color);
            }
            this.targetLine.lookAt(v3);
            this.targetLine.scale.z = v3.length();
        };
    }();

    function CameraHelper(camera) {
        var geometry = new BufferGeometry();
        var material = new LineBasicMaterial({
            color: 0xffffff,
            vertexColors: FaceColors
        });
        var vertices = [];
        var colors = [];
        var pointMap = {};
        var colorFrustum = new Color(0xffaa00);
        var colorCone = new Color(0xff0000);
        var colorUp = new Color(0x00aaff);
        var colorTarget = new Color(0xffffff);
        var colorCross = new Color(0x333333);
        addLine('n1', 'n2', colorFrustum);
        addLine('n2', 'n4', colorFrustum);
        addLine('n4', 'n3', colorFrustum);
        addLine('n3', 'n1', colorFrustum);
        addLine('f1', 'f2', colorFrustum);
        addLine('f2', 'f4', colorFrustum);
        addLine('f4', 'f3', colorFrustum);
        addLine('f3', 'f1', colorFrustum);
        addLine('n1', 'f1', colorFrustum);
        addLine('n2', 'f2', colorFrustum);
        addLine('n3', 'f3', colorFrustum);
        addLine('n4', 'f4', colorFrustum);
        addLine('p', 'n1', colorCone);
        addLine('p', 'n2', colorCone);
        addLine('p', 'n3', colorCone);
        addLine('p', 'n4', colorCone);
        addLine('u1', 'u2', colorUp);
        addLine('u2', 'u3', colorUp);
        addLine('u3', 'u1', colorUp);
        addLine('c', 't', colorTarget);
        addLine('p', 'c', colorCross);
        addLine('cn1', 'cn2', colorCross);
        addLine('cn3', 'cn4', colorCross);
        addLine('cf1', 'cf2', colorCross);
        addLine('cf3', 'cf4', colorCross);

        function addLine(a, b, color) {
            addPoint(a, color);
            addPoint(b, color);
        }

        function addPoint(id, color) {
            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);
            if (pointMap[id] === undefined) {
                pointMap[id] = [];
            }
            pointMap[id].push((vertices.length / 3) - 1);
        }
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
        LineSegments.call(this, geometry, material);
        this.camera = camera;
        if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
    }
    CameraHelper.prototype = Object.create(LineSegments.prototype);
    CameraHelper.prototype.constructor = CameraHelper;
    CameraHelper.prototype.update = function() {
        var geometry, pointMap;
        var vector = new Vector3();
        var camera = new Camera();

        function setPoint(point, x, y, z) {
            vector.set(x, y, z).unproject(camera);
            var points = pointMap[point];
            if (points !== undefined) {
                var position = geometry.getAttribute('position');
                for (var i = 0, l = points.length; i < l; i++) {
                    position.setXYZ(points[i], vector.x, vector.y, vector.z);
                }
            }
        }
        return function update() {
            geometry = this.geometry;
            pointMap = this.pointMap;
            var w = 1,
                h = 1;
            camera.projectionMatrix.copy(this.camera.projectionMatrix);
            setPoint('c', 0, 0, -1);
            setPoint('t', 0, 0, 1);
            setPoint('n1', -w, -h, -1);
            setPoint('n2', w, -h, -1);
            setPoint('n3', -w, h, -1);
            setPoint('n4', w, h, -1);
            setPoint('f1', -w, -h, 1);
            setPoint('f2', w, -h, 1);
            setPoint('f3', -w, h, 1);
            setPoint('f4', w, h, 1);
            setPoint('u1', w * 0.7, h * 1.1, -1);
            setPoint('u2', -w * 0.7, h * 1.1, -1);
            setPoint('u3', 0, h * 2, -1);
            setPoint('cf1', -w, 0, 1);
            setPoint('cf2', w, 0, 1);
            setPoint('cf3', 0, -h, 1);
            setPoint('cf4', 0, h, 1);
            setPoint('cn1', -w, 0, -1);
            setPoint('cn2', w, 0, -1);
            setPoint('cn3', 0, -h, -1);
            setPoint('cn4', 0, h, -1);
            geometry.getAttribute('position').needsUpdate = true;
        };
    }();

    function BoxHelper(object, color) {
        this.object = object;
        if (color === undefined) color = 0xffff00;
        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var positions = new Float32Array(8 * 3);
        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.addAttribute('position', new BufferAttribute(positions, 3));
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        }));
        this.matrixAutoUpdate = false;
        this.update();
    }
    BoxHelper.prototype = Object.create(LineSegments.prototype);
    BoxHelper.prototype.constructor = BoxHelper;
    BoxHelper.prototype.update = (function() {
        var box = new Box3();
        return function update(object) {
            if (object !== undefined) {
                console.warn('THREE.BoxHelper: .update() has no longer arguments.');
            }
            if (this.object !== undefined) {
                box.setFromObject(this.object);
            }
            if (box.isEmpty()) return;
            var min = box.min;
            var max = box.max;
            var position = this.geometry.attributes.position;
            var array = position.array;
            array[0] = max.x;
            array[1] = max.y;
            array[2] = max.z;
            array[3] = min.x;
            array[4] = max.y;
            array[5] = max.z;
            array[6] = min.x;
            array[7] = min.y;
            array[8] = max.z;
            array[9] = max.x;
            array[10] = min.y;
            array[11] = max.z;
            array[12] = max.x;
            array[13] = max.y;
            array[14] = min.z;
            array[15] = min.x;
            array[16] = max.y;
            array[17] = min.z;
            array[18] = min.x;
            array[19] = min.y;
            array[20] = min.z;
            array[21] = max.x;
            array[22] = min.y;
            array[23] = min.z;
            position.needsUpdate = true;
            this.geometry.computeBoundingSphere();
        };
    })();
    BoxHelper.prototype.setFromObject = function(object) {
        this.object = object;
        this.update();
        return this;
    };

    function Box3Helper(box, hex) {
        this.type = 'Box3Helper';
        this.box = box;
        var color = (hex !== undefined) ? hex : 0xffff00;
        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        }));
        this.geometry.computeBoundingSphere();
    }
    Box3Helper.prototype = Object.create(LineSegments.prototype);
    Box3Helper.prototype.constructor = Box3Helper;
    Box3Helper.prototype.updateMatrixWorld = function(force) {
        var box = this.box;
        if (box.isEmpty()) return;
        box.getCenter(this.position);
        box.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        Object3D.prototype.updateMatrixWorld.call(this, force);
    };

    function PlaneHelper(plane, size, hex) {
        this.type = 'PlaneHelper';
        this.plane = plane;
        this.size = (size === undefined) ? 1 : size;
        var color = (hex !== undefined) ? hex : 0xffff00;
        var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
        geometry.computeBoundingSphere();
        Line.call(this, geometry, new LineBasicMaterial({
            color: color
        }));
        var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
        var geometry2 = new BufferGeometry();
        geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));
        geometry2.computeBoundingSphere();
        this.add(new Mesh(geometry2, new MeshBasicMaterial({
            color: color,
            opacity: 0.2,
            transparent: true,
            depthWrite: false
        })));
    }
    PlaneHelper.prototype = Object.create(Line.prototype);
    PlaneHelper.prototype.constructor = PlaneHelper;
    PlaneHelper.prototype.updateMatrixWorld = function(force) {
        var scale = -this.plane.constant;
        if (Math.abs(scale) < 1e-8) scale = 1e-8;
        this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
        this.lookAt(this.plane.normal);
        Object3D.prototype.updateMatrixWorld.call(this, force);
    };
    var lineGeometry;
    var coneGeometry;

    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
        Object3D.call(this);
        if (color === undefined) color = 0xffff00;
        if (length === undefined) length = 1;
        if (headLength === undefined) headLength = 0.2 * length;
        if (headWidth === undefined) headWidth = 0.2 * headLength;
        if (lineGeometry === undefined) {
            lineGeometry = new BufferGeometry();
            lineGeometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
            coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
            coneGeometry.translate(0, -0.5, 0);
        }
        this.position.copy(origin);
        this.line = new Line(lineGeometry, new LineBasicMaterial({
            color: color
        }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
            color: color
        }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
    }
    ArrowHelper.prototype = Object.create(Object3D.prototype);
    ArrowHelper.prototype.constructor = ArrowHelper;
    ArrowHelper.prototype.setDirection = (function() {
        var axis = new Vector3();
        var radians;
        return function setDirection(dir) {
            if (dir.y > 0.99999) {
                this.quaternion.set(0, 0, 0, 1);
            } else if (dir.y < -0.99999) {
                this.quaternion.set(1, 0, 0, 0);
            } else {
                axis.set(dir.z, 0, -dir.x).normalize();
                radians = Math.acos(dir.y);
                this.quaternion.setFromAxisAngle(axis, radians);
            }
        };
    }());
    ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
        if (headLength === undefined) headLength = 0.2 * length;
        if (headWidth === undefined) headWidth = 0.2 * headLength;
        this.line.scale.set(1, Math.max(0, length - headLength), 1);
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
    };
    ArrowHelper.prototype.setColor = function(color) {
        this.line.material.color.copy(color);
        this.cone.material.color.copy(color);
    };

    function AxesHelper(size) {
        size = size || 1;
        var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
        var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    AxesHelper.prototype = Object.create(LineSegments.prototype);
    AxesHelper.prototype.constructor = AxesHelper;
    var SceneUtils = {
        createMultiMaterialObject: function(geometry, materials) {
            var group = new Group();
            for (var i = 0, l = materials.length; i < l; i++) {
                group.add(new Mesh(geometry, materials[i]));
            }
            return group;
        },
        detach: function(child, parent, scene) {
            child.applyMatrix(parent.matrixWorld);
            parent.remove(child);
            scene.add(child);
        },
        attach: function(child, scene, parent) {
            child.applyMatrix(new Matrix4().getInverse(parent.matrixWorld));
            scene.remove(child);
            parent.add(child);
        }
    };

    function Face4(a, b, c, d, normal, color, materialIndex) {
        console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
        return new Face3(a, b, c, normal, color, materialIndex);
    }
    var LineStrip = 0;
    var LinePieces = 1;

    function MeshFaceMaterial(materials) {
        console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
        return materials;
    }

    function MultiMaterial(materials) {
        if (materials === undefined) materials = [];
        console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
        materials.isMultiMaterial = true;
        materials.materials = materials;
        materials.clone = function() {
            return materials.slice();
        };
        return materials;
    }

    function PointCloud(geometry, material) {
        console.warn('THREE.PointCloud has been renamed to THREE.Points.');
        return new Points(geometry, material);
    }

    function Particle(material) {
        console.warn('THREE.Particle has been renamed to THREE.Sprite.');
        return new Sprite(material);
    }

    function ParticleSystem(geometry, material) {
        console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
        return new Points(geometry, material);
    }

    function PointCloudMaterial(parameters) {
        console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }

    function ParticleBasicMaterial(parameters) {
        console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }

    function ParticleSystemMaterial(parameters) {
        console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }

    function Vertex(x, y, z) {
        console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
        return new Vector3(x, y, z);
    }

    function DynamicBufferAttribute(array, itemSize) {
        console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
        return new BufferAttribute(array, itemSize).setDynamic(true);
    }

    function Int8Attribute(array, itemSize) {
        console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
        return new Int8BufferAttribute(array, itemSize);
    }

    function Uint8Attribute(array, itemSize) {
        console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
        return new Uint8BufferAttribute(array, itemSize);
    }

    function Uint8ClampedAttribute(array, itemSize) {
        console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
        return new Uint8ClampedBufferAttribute(array, itemSize);
    }

    function Int16Attribute(array, itemSize) {
        console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
        return new Int16BufferAttribute(array, itemSize);
    }

    function Uint16Attribute(array, itemSize) {
        console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
        return new Uint16BufferAttribute(array, itemSize);
    }

    function Int32Attribute(array, itemSize) {
        console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
        return new Int32BufferAttribute(array, itemSize);
    }

    function Uint32Attribute(array, itemSize) {
        console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
        return new Uint32BufferAttribute(array, itemSize);
    }

    function Float32Attribute(array, itemSize) {
        console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
        return new Float32BufferAttribute(array, itemSize);
    }

    function Float64Attribute(array, itemSize) {
        console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
        return new Float64BufferAttribute(array, itemSize);
    }
    Curve.create = function(construct, getPoint) {
        console.log('THREE.Curve.create() has been deprecated');
        construct.prototype = Object.create(Curve.prototype);
        construct.prototype.constructor = construct;
        construct.prototype.getPoint = getPoint;
        return construct;
    };
    Object.assign(CurvePath.prototype, {
        createPointsGeometry: function(divisions) {
            console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
            var pts = this.getPoints(divisions);
            return this.createGeometry(pts);
        },
        createSpacedPointsGeometry: function(divisions) {
            console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
            var pts = this.getSpacedPoints(divisions);
            return this.createGeometry(pts);
        },
        createGeometry: function(points) {
            console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
            var geometry = new Geometry();
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
            }
            return geometry;
        }
    });
    Object.assign(Path.prototype, {
        fromPoints: function(points) {
            console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
            this.setFromPoints(points);
        }
    });

    function ClosedSplineCurve3(points) {
        console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
        this.closed = true;
    }
    ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

    function SplineCurve3(points) {
        console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
    }
    SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

    function Spline(points) {
        console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
    }
    Spline.prototype = Object.create(CatmullRomCurve3.prototype);
    Object.assign(Spline.prototype, {
        initFromArray: function() {
            console.error('THREE.Spline: .initFromArray() has been removed.');
        },
        getControlPointsArray: function() {
            console.error('THREE.Spline: .getControlPointsArray() has been removed.');
        },
        reparametrizeByArcLength: function() {
            console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
        }
    });

    function AxisHelper(size) {
        console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
        return new AxesHelper(size);
    }

    function BoundingBoxHelper(object, color) {
        console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
        return new BoxHelper(object, color);
    }

    function EdgesHelper(object, hex) {
        console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
        return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
            color: hex !== undefined ? hex : 0xffffff
        }));
    }
    GridHelper.prototype.setColors = function() {
        console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
    };
    SkeletonHelper.prototype.update = function() {
        console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
    };

    function WireframeHelper(object, hex) {
        console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
        return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
            color: hex !== undefined ? hex : 0xffffff
        }));
    }
    Object.assign(Loader.prototype, {
        extractUrlBase: function(url) {
            console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
            return LoaderUtils.extractUrlBase(url);
        }
    });

    function XHRLoader(manager) {
        console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
        return new FileLoader(manager);
    }

    function BinaryTextureLoader(manager) {
        console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
        return new DataTextureLoader(manager);
    }
    Object.assign(Box2.prototype, {
        center: function(optionalTarget) {
            console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
            return this.getCenter(optionalTarget);
        },
        empty: function() {
            console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        },
        isIntersectionBox: function(box) {
            console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        size: function(optionalTarget) {
            console.warn('THREE.Box2: .size() has been renamed to .getSize().');
            return this.getSize(optionalTarget);
        }
    });
    Object.assign(Box3.prototype, {
        center: function(optionalTarget) {
            console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
            return this.getCenter(optionalTarget);
        },
        empty: function() {
            console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        },
        isIntersectionBox: function(box) {
            console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        isIntersectionSphere: function(sphere) {
            console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(sphere);
        },
        size: function(optionalTarget) {
            console.warn('THREE.Box3: .size() has been renamed to .getSize().');
            return this.getSize(optionalTarget);
        }
    });
    Line3.prototype.center = function(optionalTarget) {
        console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
        return this.getCenter(optionalTarget);
    };
    Object.assign(_Math, {
        random16: function() {
            console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
            return Math.random();
        },
        nearestPowerOfTwo: function(value) {
            console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
            return _Math.floorPowerOfTwo(value);
        },
        nextPowerOfTwo: function(value) {
            console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
            return _Math.ceilPowerOfTwo(value);
        }
    });
    Object.assign(Matrix3.prototype, {
        flattenToArrayOffset: function(array, offset) {
            console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
            return this.toArray(array, offset);
        },
        multiplyVector3: function(vector) {
            console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
            return vector.applyMatrix3(this);
        },
        multiplyVector3Array: function() {
            console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
        },
        applyToBuffer: function(buffer) {
            console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
            return this.applyToBufferAttribute(buffer);
        },
        applyToVector3Array: function() {
            console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
        }
    });
    Object.assign(Matrix4.prototype, {
        extractPosition: function(m) {
            console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
            return this.copyPosition(m);
        },
        flattenToArrayOffset: function(array, offset) {
            console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
            return this.toArray(array, offset);
        },
        getPosition: function() {
            var v1;
            return function getPosition() {
                if (v1 === undefined) v1 = new Vector3();
                console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
                return v1.setFromMatrixColumn(this, 3);
            };
        }(),
        setRotationFromQuaternion: function(q) {
            console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
            return this.makeRotationFromQuaternion(q);
        },
        multiplyToArray: function() {
            console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
        },
        multiplyVector3: function(vector) {
            console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        multiplyVector4: function(vector) {
            console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        multiplyVector3Array: function() {
            console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
        },
        rotateAxis: function(v) {
            console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
            v.transformDirection(this);
        },
        crossVector: function(vector) {
            console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        translate: function() {
            console.error('THREE.Matrix4: .translate() has been removed.');
        },
        rotateX: function() {
            console.error('THREE.Matrix4: .rotateX() has been removed.');
        },
        rotateY: function() {
            console.error('THREE.Matrix4: .rotateY() has been removed.');
        },
        rotateZ: function() {
            console.error('THREE.Matrix4: .rotateZ() has been removed.');
        },
        rotateByAxis: function() {
            console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
        },
        applyToBuffer: function(buffer) {
            console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
            return this.applyToBufferAttribute(buffer);
        },
        applyToVector3Array: function() {
            console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
        },
        makeFrustum: function(left, right, bottom, top, near, far) {
            console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
            return this.makePerspective(left, right, top, bottom, near, far);
        }
    });
    Plane.prototype.isIntersectionLine = function(line) {
        console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
        return this.intersectsLine(line);
    };
    Quaternion.prototype.multiplyVector3 = function(vector) {
        console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
        return vector.applyQuaternion(this);
    };
    Object.assign(Ray.prototype, {
        isIntersectionBox: function(box) {
            console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        isIntersectionPlane: function(plane) {
            console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
            return this.intersectsPlane(plane);
        },
        isIntersectionSphere: function(sphere) {
            console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(sphere);
        }
    });
    Object.assign(Shape.prototype, {
        extractAllPoints: function(divisions) {
            console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
            return this.extractPoints(divisions);
        },
        extrude: function(options) {
            console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
            return new ExtrudeGeometry(this, options);
        },
        makeGeometry: function(options) {
            console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
            return new ShapeGeometry(this, options);
        }
    });
    Object.assign(Vector2.prototype, {
        fromAttribute: function(attribute, index, offset) {
            console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        },
        distanceToManhattan: function(v) {
            console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
            return this.manhattanDistanceTo(v);
        },
        lengthManhattan: function() {
            console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
            return this.manhattanLength();
        }
    });
    Object.assign(Vector3.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
        },
        setEulerFromQuaternion: function() {
            console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
        },
        getPositionFromMatrix: function(m) {
            console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
            return this.setFromMatrixPosition(m);
        },
        getScaleFromMatrix: function(m) {
            console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
            return this.setFromMatrixScale(m);
        },
        getColumnFromMatrix: function(index, matrix) {
            console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
            return this.setFromMatrixColumn(matrix, index);
        },
        applyProjection: function(m) {
            console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
            return this.applyMatrix4(m);
        },
        fromAttribute: function(attribute, index, offset) {
            console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        },
        distanceToManhattan: function(v) {
            console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
            return this.manhattanDistanceTo(v);
        },
        lengthManhattan: function() {
            console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
            return this.manhattanLength();
        }
    });
    Object.assign(Vector4.prototype, {
        fromAttribute: function(attribute, index, offset) {
            console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        },
        lengthManhattan: function() {
            console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
            return this.manhattanLength();
        }
    });
    Geometry.prototype.computeTangents = function() {
        console.warn('THREE.Geometry: .computeTangents() has been removed.');
    };
    Object.assign(Object3D.prototype, {
        getChildByName: function(name) {
            console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
            return this.getObjectByName(name);
        },
        renderDepth: function() {
            console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
        },
        translate: function(distance, axis) {
            console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
            return this.translateOnAxis(axis, distance);
        }
    });
    Object.defineProperties(Object3D.prototype, {
        eulerOrder: {
            get: function() {
                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                return this.rotation.order;
            },
            set: function(value) {
                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                this.rotation.order = value;
            }
        },
        useQuaternion: {
            get: function() {
                console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
            },
            set: function() {
                console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
            }
        }
    });
    Object.defineProperties(LOD.prototype, {
        objects: {
            get: function() {
                console.warn('THREE.LOD: .objects has been renamed to .levels.');
                return this.levels;
            }
        }
    });
    Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
        get: function() {
            console.warn('THREE.Skeleton: useVertexTexture has been removed.');
        },
        set: function() {
            console.warn('THREE.Skeleton: useVertexTexture has been removed.');
        }
    });
    Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
        get: function() {
            console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
            return this.arcLengthDivisions;
        },
        set: function(value) {
            console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
            this.arcLengthDivisions = value;
        }
    });
    PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. " +
            "Use .setFocalLength and .filmGauge for a photographic setup.");
        if (filmGauge !== undefined) this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
    };
    Object.defineProperties(Light.prototype, {
        onlyShadow: {
            set: function() {
                console.warn('THREE.Light: .onlyShadow has been removed.');
            }
        },
        shadowCameraFov: {
            set: function(value) {
                console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
                this.shadow.camera.fov = value;
            }
        },
        shadowCameraLeft: {
            set: function(value) {
                console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
                this.shadow.camera.left = value;
            }
        },
        shadowCameraRight: {
            set: function(value) {
                console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
                this.shadow.camera.right = value;
            }
        },
        shadowCameraTop: {
            set: function(value) {
                console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
                this.shadow.camera.top = value;
            }
        },
        shadowCameraBottom: {
            set: function(value) {
                console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
                this.shadow.camera.bottom = value;
            }
        },
        shadowCameraNear: {
            set: function(value) {
                console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
                this.shadow.camera.near = value;
            }
        },
        shadowCameraFar: {
            set: function(value) {
                console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
                this.shadow.camera.far = value;
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
            }
        },
        shadowBias: {
            set: function(value) {
                console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
                this.shadow.bias = value;
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn('THREE.Light: .shadowDarkness has been removed.');
            }
        },
        shadowMapWidth: {
            set: function(value) {
                console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
                this.shadow.mapSize.width = value;
            }
        },
        shadowMapHeight: {
            set: function(value) {
                console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
                this.shadow.mapSize.height = value;
            }
        }
    });
    Object.defineProperties(BufferAttribute.prototype, {
        length: {
            get: function() {
                console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
                return this.array.length;
            }
        }
    });
    Object.assign(BufferGeometry.prototype, {
        addIndex: function(index) {
            console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
            this.setIndex(index);
        },
        addDrawCall: function(start, count, indexOffset) {
            if (indexOffset !== undefined) {
                console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
            }
            console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
            this.addGroup(start, count);
        },
        clearDrawCalls: function() {
            console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
            this.clearGroups();
        },
        computeTangents: function() {
            console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
        },
        computeOffsets: function() {
            console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
        }
    });
    Object.defineProperties(BufferGeometry.prototype, {
        drawcalls: {
            get: function() {
                console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
                return this.groups;
            }
        },
        offsets: {
            get: function() {
                console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
                return this.groups;
            }
        }
    });
    Object.defineProperties(Uniform.prototype, {
        dynamic: {
            set: function() {
                console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
            }
        },
        onUpdate: {
            value: function() {
                console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
                return this;
            }
        }
    });
    Object.defineProperties(Material.prototype, {
        wrapAround: {
            get: function() {
                console.warn('THREE.Material: .wrapAround has been removed.');
            },
            set: function() {
                console.warn('THREE.Material: .wrapAround has been removed.');
            }
        },
        wrapRGB: {
            get: function() {
                console.warn('THREE.Material: .wrapRGB has been removed.');
                return new Color();
            }
        },
        shading: {
            get: function() {
                console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
            },
            set: function(value) {
                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                this.flatShading = (value === FlatShading);
            }
        }
    });
    Object.defineProperties(MeshPhongMaterial.prototype, {
        metal: {
            get: function() {
                console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
                return false;
            },
            set: function() {
                console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
            }
        }
    });
    Object.defineProperties(ShaderMaterial.prototype, {
        derivatives: {
            get: function() {
                console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                return this.extensions.derivatives;
            },
            set: function(value) {
                console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                this.extensions.derivatives = value;
            }
        }
    });
    Object.assign(WebGLRenderer.prototype, {
        getCurrentRenderTarget: function() {
            console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
            return this.getRenderTarget();
        },
        getMaxAnisotropy: function() {
            console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
            return this.capabilities.getMaxAnisotropy();
        },
        getPrecision: function() {
            console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
            return this.capabilities.precision;
        },
        resetGLState: function() {
            console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
            return this.state.reset();
        },
        supportsFloatTextures: function() {
            console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
            return this.extensions.get('OES_texture_float');
        },
        supportsHalfFloatTextures: function() {
            console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
            return this.extensions.get('OES_texture_half_float');
        },
        supportsStandardDerivatives: function() {
            console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
            return this.extensions.get('OES_standard_derivatives');
        },
        supportsCompressedTextureS3TC: function() {
            console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_s3tc');
        },
        supportsCompressedTexturePVRTC: function() {
            console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_pvrtc');
        },
        supportsBlendMinMax: function() {
            console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
            return this.extensions.get('EXT_blend_minmax');
        },
        supportsVertexTextures: function() {
            console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
            return this.capabilities.vertexTextures;
        },
        supportsInstancedArrays: function() {
            console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
            return this.extensions.get('ANGLE_instanced_arrays');
        },
        enableScissorTest: function(boolean) {
            console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
            this.setScissorTest(boolean);
        },
        initMaterial: function() {
            console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
        },
        addPrePlugin: function() {
            console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
        },
        addPostPlugin: function() {
            console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
        },
        updateShadowMap: function() {
            console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
        }
    });
    Object.defineProperties(WebGLRenderer.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
                this.shadowMap.enabled = value;
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
                this.shadowMap.type = value;
            }
        },
        shadowMapCullFace: {
            get: function() {
                return this.shadowMap.cullFace;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');
                this.shadowMap.cullFace = value;
            }
        }
    });
    Object.defineProperties(WebGLShadowMap.prototype, {
        cullFace: {
            get: function() {
                return this.renderReverseSided ? CullFaceFront : CullFaceBack;
            },
            set: function(cullFace) {
                var value = (cullFace !== CullFaceBack);
                console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + ".");
                this.renderReverseSided = value;
            }
        }
    });
    Object.defineProperties(WebGLRenderTarget.prototype, {
        wrapS: {
            get: function() {
                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                return this.texture.wrapS;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                this.texture.wrapS = value;
            }
        },
        wrapT: {
            get: function() {
                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                return this.texture.wrapT;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                this.texture.wrapT = value;
            }
        },
        magFilter: {
            get: function() {
                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                return this.texture.magFilter;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                this.texture.magFilter = value;
            }
        },
        minFilter: {
            get: function() {
                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                return this.texture.minFilter;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                this.texture.minFilter = value;
            }
        },
        anisotropy: {
            get: function() {
                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                return this.texture.anisotropy;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                this.texture.anisotropy = value;
            }
        },
        offset: {
            get: function() {
                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                return this.texture.offset;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                this.texture.offset = value;
            }
        },
        repeat: {
            get: function() {
                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                return this.texture.repeat;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                this.texture.repeat = value;
            }
        },
        format: {
            get: function() {
                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                return this.texture.format;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                this.texture.format = value;
            }
        },
        type: {
            get: function() {
                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                return this.texture.type;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                this.texture.type = value;
            }
        },
        generateMipmaps: {
            get: function() {
                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                return this.texture.generateMipmaps;
            },
            set: function(value) {
                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                this.texture.generateMipmaps = value;
            }
        }
    });
    Object.assign(WebVRManager.prototype, {
        getStandingMatrix: function() {
            console.warn('THREE.WebVRManager: .getStandingMatrix() has been removed.');
        }
    });
    Object.defineProperties(WebVRManager.prototype, {
        standing: {
            set: function() {
                console.warn('THREE.WebVRManager: .standing has been removed.');
            }
        }
    });
    Audio.prototype.load = function(file) {
        console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
        var scope = this;
        var audioLoader = new AudioLoader();
        audioLoader.load(file, function(buffer) {
            scope.setBuffer(buffer);
        });
        return this;
    };
    AudioAnalyser.prototype.getData = function() {
        console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
        return this.getFrequencyData();
    };
    CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
        console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
        return this.update(renderer, scene);
    };
    var GeometryUtils = {
        merge: function(geometry1, geometry2, materialIndexOffset) {
            console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
            var matrix;
            if (geometry2.isMesh) {
                geometry2.matrixAutoUpdate && geometry2.updateMatrix();
                matrix = geometry2.matrix;
                geometry2 = geometry2.geometry;
            }
            geometry1.merge(geometry2, matrix, materialIndexOffset);
        },
        center: function(geometry) {
            console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
            return geometry.center();
        }
    };
    var ImageUtils = {
        crossOrigin: undefined,
        loadTexture: function(url, mapping, onLoad, onError) {
            console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
            var loader = new TextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(url, onLoad, undefined, onError);
            if (mapping) texture.mapping = mapping;
            return texture;
        },
        loadTextureCube: function(urls, mapping, onLoad, onError) {
            console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
            var loader = new CubeTextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(urls, onLoad, undefined, onError);
            if (mapping) texture.mapping = mapping;
            return texture;
        },
        loadCompressedTexture: function() {
            console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
        },
        loadCompressedTextureCube: function() {
            console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
        }
    };

    function Projector() {
        console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
        this.projectVector = function(vector, camera) {
            console.warn('THREE.Projector: .projectVector() is now vector.project().');
            vector.project(camera);
        };
        this.unprojectVector = function(vector, camera) {
            console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
            vector.unproject(camera);
        };
        this.pickingRay = function() {
            console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
        };
    }

    function CanvasRenderer() {
        console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
        this.domElement = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        this.clear = function() {};
        this.render = function() {};
        this.setClearColor = function() {};
        this.setSize = function() {};
    }
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _get = function get(object, property, receiver) {
        if (object === null) object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);
            if (parent === null) {
                return undefined;
            } else {
                return get(parent, property, receiver);
            }
        } else if ("value" in desc) {
            return desc.value;
        } else {
            var getter = desc.get;
            if (getter === undefined) {
                return undefined;
            }
            return getter.call(receiver);
        }
    };
    var _eventemitter = __webpack_require__(29);
    var _eventemitter2 = _interopRequireDefault(_eventemitter);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Events = function(_EventEmitter) {
        _inherits(Events, _EventEmitter);

        function Events() {
            _classCallCheck(this, Events);
            return _possibleConstructorReturn(this, (Events.__proto__ || Object.getPrototypeOf(Events)).apply(this, arguments));
        }
        _createClass(Events, [{
            key: 'emit',
            value: function emit() {
                var _get2;
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }
                var name = args[0],
                    params = args.slice(1);
                (_get2 = _get(Events.prototype.__proto__ || Object.getPrototypeOf(Events.prototype), 'emit', this)).call.apply(_get2, [this].concat(args));
            }
        }]);
        return Events;
    }(_eventemitter2.default);
    var instance = new Events();
    instance.logBlacklist = [];
    instance.RAF = Symbol('raf');
    instance.logBlacklist.push(instance.RAF);
    instance.POINTER_START = Symbol('pointerStart');
    instance.POINTER_MOVE = Symbol('pointerMove');
    instance.POINTER_DRAG = Symbol('pointerDrag');
    instance.POINTER_END = Symbol('pointerEnd');
    instance.logBlacklist.push(instance.POINTER_START);
    instance.logBlacklist.push(instance.POINTER_MOVE);
    instance.logBlacklist.push(instance.POINTER_DRAG);
    instance.logBlacklist.push(instance.POINTER_END);
    exports.default = instance;
}), (function(module, exports) {
    var g;
    g = (function() {
        return this;
    })();
    try {
        g = g || Function("return this")() || (1, eval)("this");
    } catch (e) {
        if (typeof window === "object")
            g = window;
    }
    module.exports = g;
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
    });
    __webpack_require__.d(__webpack_exports__, "default", function() {
        return CSSPlugin;
    });
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    /*!
     * VERSION: 1.20.5
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     */
    __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function() {
        var CSSPlugin = function() {
                __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["TweenPlugin"].call(this, "css");
                this._overwriteProps.length = 0;
                this.setRatio = CSSPlugin.prototype.setRatio;
            },
            _globals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine.globals,
            _hasPriority, _suffixMap, _cs, _overwriteProps, _specialProps = {},
            p = CSSPlugin.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["TweenPlugin"]("css");
        p.constructor = CSSPlugin;
        CSSPlugin.version = "1.20.5";
        CSSPlugin.API = 2;
        CSSPlugin.defaultTransformPerspective = 0;
        CSSPlugin.defaultSkewType = "compensated";
        CSSPlugin.defaultSmoothOrigin = true;
        p = "px";
        CSSPlugin.suffixMap = {
            top: p,
            right: p,
            bottom: p,
            left: p,
            width: p,
            height: p,
            fontSize: p,
            padding: p,
            margin: p,
            perspective: p,
            lineHeight: ""
        };
        var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
            _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
            _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
            _NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
            _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
            _opacityExp = /opacity *= *([^)]*)/i,
            _opacityValExp = /opacity:([^;]*)/i,
            _alphaFilterExp = /alpha\(opacity *=.+?\)/i,
            _rgbhslExp = /^(rgb|hsl)/,
            _capsExp = /([A-Z])/g,
            _camelExp = /-([a-z])/gi,
            _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
            _camelFunc = function(s, g) {
                return g.toUpperCase();
            },
            _horizExp = /(?:Left|Right|Width)/i,
            _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
            _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
            _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi,
            _complexExp = /[\s,\(]/i,
            _DEG2RAD = Math.PI / 180,
            _RAD2DEG = 180 / Math.PI,
            _forcePT = {},
            _dummyElement = {
                style: {}
            },
            _doc = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].document || {
                createElement: function() {
                    return _dummyElement;
                }
            },
            _createElement = function(type, ns) {
                return _doc.createElementNS ? _doc.createElementNS(ns || "http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
            },
            _tempDiv = _createElement("div"),
            _tempImg = _createElement("img"),
            _internals = CSSPlugin._internals = {
                _specialProps: _specialProps
            },
            _agent = (__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].navigator || {}).userAgent || "",
            _autoRound, _reqSafariFix, _isSafari, _isFirefox, _isSafariLT6, _ieVers, _supportsOpacity = (function() {
                var i = _agent.indexOf("Android"),
                    a = _createElement("a");
                _isSafari = (_agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || parseFloat(_agent.substr(i + 8, 2)) > 3));
                _isSafariLT6 = (_isSafari && (parseFloat(_agent.substr(_agent.indexOf("Version/") + 8, 2)) < 6));
                _isFirefox = (_agent.indexOf("Firefox") !== -1);
                if ((/MSIE ([0-9]{1,}[\.0-9]{0,})/).exec(_agent) || (/Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/).exec(_agent)) {
                    _ieVers = parseFloat(RegExp.$1);
                }
                if (!a) {
                    return false;
                }
                a.style.cssText = "top:1px;opacity:.55;";
                return /^0.55/.test(a.style.opacity);
            }()),
            _getIEOpacity = function(v) {
                return (_opacityExp.test(((typeof(v) === "string") ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "")) ? (parseFloat(RegExp.$1) / 100) : 1);
            },
            _log = function(s) {
                if (__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].console) {
                    console.log(s);
                }
            },
            _target, _index, _prefixCSS = "",
            _prefix = "",
            _checkPropPrefix = function(p, e) {
                e = e || _tempDiv;
                var s = e.style,
                    a, i;
                if (s[p] !== undefined) {
                    return p;
                }
                p = p.charAt(0).toUpperCase() + p.substr(1);
                a = ["O", "Moz", "ms", "Ms", "Webkit"];
                i = 5;
                while (--i > -1 && s[a[i] + p] === undefined) {}
                if (i >= 0) {
                    _prefix = (i === 3) ? "ms" : a[i];
                    _prefixCSS = "-" + _prefix.toLowerCase() + "-";
                    return _prefix + p;
                }
                return null;
            },
            _getComputedStyle = (typeof(window) !== "undefined" ? window : _doc.defaultView || {
                getComputedStyle: function() {}
            }).getComputedStyle,
            _getStyle = CSSPlugin.getStyle = function(t, p, cs, calc, dflt) {
                var rv;
                if (!_supportsOpacity)
                    if (p === "opacity") {
                        return _getIEOpacity(t);
                    }
                if (!calc && t.style[p]) {
                    rv = t.style[p];
                } else if ((cs = cs || _getComputedStyle(t))) {
                    rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
                } else if (t.currentStyle) {
                    rv = t.currentStyle[p];
                }
                return (dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto")) ? dflt : rv;
            },
            _convertToPixels = _internals.convertToPixels = function(t, p, v, sfx, recurse) {
                if (sfx === "px" || (!sfx && p !== "lineHeight")) {
                    return v;
                }
                if (sfx === "auto" || !v) {
                    return 0;
                }
                var horiz = _horizExp.test(p),
                    node = t,
                    style = _tempDiv.style,
                    neg = (v < 0),
                    precise = (v === 1),
                    pix, cache, time;
                if (neg) {
                    v = -v;
                }
                if (precise) {
                    v *= 100;
                }
                if (p === "lineHeight" && !sfx) {
                    cache = _getComputedStyle(t).lineHeight;
                    t.style.lineHeight = v;
                    pix = parseFloat(_getComputedStyle(t).lineHeight);
                    t.style.lineHeight = cache;
                } else if (sfx === "%" && p.indexOf("border") !== -1) {
                    pix = (v / 100) * (horiz ? t.clientWidth : t.clientHeight);
                } else {
                    style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
                    if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
                        node = t.parentNode || _doc.body;
                        if (_getStyle(node, "display").indexOf("flex") !== -1) {
                            style.position = "absolute";
                        }
                        cache = node._gsCache;
                        time = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].ticker.frame;
                        if (cache && horiz && cache.time === time) {
                            return cache.width * v / 100;
                        }
                        style[(horiz ? "width" : "height")] = v + sfx;
                    } else {
                        style[(horiz ? "borderLeftWidth" : "borderTopWidth")] = v + sfx;
                    }
                    node.appendChild(_tempDiv);
                    pix = parseFloat(_tempDiv[(horiz ? "offsetWidth" : "offsetHeight")]);
                    node.removeChild(_tempDiv);
                    if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
                        cache = node._gsCache = node._gsCache || {};
                        cache.time = time;
                        cache.width = pix / v * 100;
                    }
                    if (pix === 0 && !recurse) {
                        pix = _convertToPixels(t, p, v, sfx, true);
                    }
                }
                if (precise) {
                    pix /= 100;
                }
                return neg ? -pix : pix;
            },
            _calculateOffset = _internals.calculateOffset = function(t, p, cs) {
                if (_getStyle(t, "position", cs) !== "absolute") {
                    return 0;
                }
                var dim = ((p === "left") ? "Left" : "Top"),
                    v = _getStyle(t, "margin" + dim, cs);
                return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
            },
            _getAllStyles = function(t, cs) {
                var s = {},
                    i, tr, p;
                if ((cs = cs || _getComputedStyle(t, null))) {
                    if ((i = cs.length)) {
                        while (--i > -1) {
                            p = cs[i];
                            if (p.indexOf("-transform") === -1 || _transformPropCSS === p) {
                                s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
                            }
                        }
                    } else {
                        for (i in cs) {
                            if (i.indexOf("Transform") === -1 || _transformProp === i) {
                                s[i] = cs[i];
                            }
                        }
                    }
                } else if ((cs = t.currentStyle || t.style)) {
                    for (i in cs) {
                        if (typeof(i) === "string" && s[i] === undefined) {
                            s[i.replace(_camelExp, _camelFunc)] = cs[i];
                        }
                    }
                }
                if (!_supportsOpacity) {
                    s.opacity = _getIEOpacity(t);
                }
                tr = _getTransform(t, cs, false);
                s.rotation = tr.rotation;
                s.skewX = tr.skewX;
                s.scaleX = tr.scaleX;
                s.scaleY = tr.scaleY;
                s.x = tr.x;
                s.y = tr.y;
                if (_supports3D) {
                    s.z = tr.z;
                    s.rotationX = tr.rotationX;
                    s.rotationY = tr.rotationY;
                    s.scaleZ = tr.scaleZ;
                }
                if (s.filters) {
                    delete s.filters;
                }
                return s;
            },
            _cssDif = function(t, s1, s2, vars, forceLookup) {
                var difs = {},
                    style = t.style,
                    val, p, mpt;
                for (p in s2) {
                    if (p !== "cssText")
                        if (p !== "length")
                            if (isNaN(p))
                                if (s1[p] !== (val = s2[p]) || (forceLookup && forceLookup[p]))
                                    if (p.indexOf("Origin") === -1)
                                        if (typeof(val) === "number" || typeof(val) === "string") {
                                            difs[p] = (val === "auto" && (p === "left" || p === "top")) ? _calculateOffset(t, p) : ((val === "" || val === "auto" || val === "none") && typeof(s1[p]) === "string" && s1[p].replace(_NaNExp, "") !== "") ? 0 : val;
                                            if (style[p] !== undefined) {
                                                mpt = new MiniPropTween(style, p, style[p], mpt);
                                            }
                                        }
                }
                if (vars) {
                    for (p in vars) {
                        if (p !== "className") {
                            difs[p] = vars[p];
                        }
                    }
                }
                return {
                    difs: difs,
                    firstMPT: mpt
                };
            },
            _dimensions = {
                width: ["Left", "Right"],
                height: ["Top", "Bottom"]
            },
            _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
            _getDimension = function(t, p, cs) {
                if ((t.nodeName + "").toLowerCase() === "svg") {
                    return (cs || _getComputedStyle(t))[p] || 0;
                } else if (t.getCTM && _isSVG(t)) {
                    return t.getBBox()[p] || 0;
                }
                var v = parseFloat((p === "width") ? t.offsetWidth : t.offsetHeight),
                    a = _dimensions[p],
                    i = a.length;
                cs = cs || _getComputedStyle(t, null);
                while (--i > -1) {
                    v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
                    v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0;
                }
                return v;
            },
            _parsePosition = function(v, recObj) {
                if (v === "contain" || v === "auto" || v === "auto auto") {
                    return v + " ";
                }
                if (v == null || v === "") {
                    v = "0 0";
                }
                var a = v.split(" "),
                    x = (v.indexOf("left") !== -1) ? "0%" : (v.indexOf("right") !== -1) ? "100%" : a[0],
                    y = (v.indexOf("top") !== -1) ? "0%" : (v.indexOf("bottom") !== -1) ? "100%" : a[1],
                    i;
                if (a.length > 3 && !recObj) {
                    a = v.split(", ").join(",").split(",");
                    v = [];
                    for (i = 0; i < a.length; i++) {
                        v.push(_parsePosition(a[i]));
                    }
                    return v.join(",");
                }
                if (y == null) {
                    y = (x === "center") ? "50%" : "0";
                } else if (y === "center") {
                    y = "50%";
                }
                if (x === "center" || (isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1)) {
                    x = "50%";
                }
                v = x + " " + y + ((a.length > 2) ? " " + a[2] : "");
                if (recObj) {
                    recObj.oxp = (x.indexOf("%") !== -1);
                    recObj.oyp = (y.indexOf("%") !== -1);
                    recObj.oxr = (x.charAt(1) === "=");
                    recObj.oyr = (y.charAt(1) === "=");
                    recObj.ox = parseFloat(x.replace(_NaNExp, ""));
                    recObj.oy = parseFloat(y.replace(_NaNExp, ""));
                    recObj.v = v;
                }
                return recObj || v;
            },
            _parseChange = function(e, b) {
                if (typeof(e) === "function") {
                    e = e(_index, _target);
                }
                return (typeof(e) === "string" && e.charAt(1) === "=") ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : (parseFloat(e) - parseFloat(b)) || 0;
            },
            _parseVal = function(v, d) {
                if (typeof(v) === "function") {
                    v = v(_index, _target);
                }
                return (v == null) ? d : (typeof(v) === "string" && v.charAt(1) === "=") ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
            },
            _parseAngle = function(v, d, p, directionalEnd) {
                var min = 0.000001,
                    cap, split, dif, result, isRelative;
                if (typeof(v) === "function") {
                    v = v(_index, _target);
                }
                if (v == null) {
                    result = d;
                } else if (typeof(v) === "number") {
                    result = v;
                } else {
                    cap = 360;
                    split = v.split("_");
                    isRelative = (v.charAt(1) === "=");
                    dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * ((v.indexOf("rad") === -1) ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
                    if (split.length) {
                        if (directionalEnd) {
                            directionalEnd[p] = d + dif;
                        }
                        if (v.indexOf("short") !== -1) {
                            dif = dif % cap;
                            if (dif !== dif % (cap / 2)) {
                                dif = (dif < 0) ? dif + cap : dif - cap;
                            }
                        }
                        if (v.indexOf("_cw") !== -1 && dif < 0) {
                            dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
                        } else if (v.indexOf("ccw") !== -1 && dif > 0) {
                            dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
                        }
                    }
                    result = d + dif;
                }
                if (result < min && result > -min) {
                    result = 0;
                }
                return result;
            },
            _colorLookup = {
                aqua: [0, 255, 255],
                lime: [0, 255, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, 255],
                navy: [0, 0, 128],
                white: [255, 255, 255],
                fuchsia: [255, 0, 255],
                olive: [128, 128, 0],
                yellow: [255, 255, 0],
                orange: [255, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [255, 0, 0],
                pink: [255, 192, 203],
                cyan: [0, 255, 255],
                transparent: [255, 255, 255, 0]
            },
            _hue = function(h, m1, m2) {
                h = (h < 0) ? h + 1 : (h > 1) ? h - 1 : h;
                return ((((h * 6 < 1) ? m1 + (m2 - m1) * h * 6 : (h < 0.5) ? m2 : (h * 3 < 2) ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255) + 0.5) | 0;
            },
            _parseColor = CSSPlugin.parseColor = function(v, toHSL) {
                var a, r, g, b, h, s, l, max, min, d, wasHSL;
                if (!v) {
                    a = _colorLookup.black;
                } else if (typeof(v) === "number") {
                    a = [v >> 16, (v >> 8) & 255, v & 255];
                } else {
                    if (v.charAt(v.length - 1) === ",") {
                        v = v.substr(0, v.length - 1);
                    }
                    if (_colorLookup[v]) {
                        a = _colorLookup[v];
                    } else if (v.charAt(0) === "#") {
                        if (v.length === 4) {
                            r = v.charAt(1);
                            g = v.charAt(2);
                            b = v.charAt(3);
                            v = "#" + r + r + g + g + b + b;
                        }
                        v = parseInt(v.substr(1), 16);
                        a = [v >> 16, (v >> 8) & 255, v & 255];
                    } else if (v.substr(0, 3) === "hsl") {
                        a = wasHSL = v.match(_numExp);
                        if (!toHSL) {
                            h = (Number(a[0]) % 360) / 360;
                            s = Number(a[1]) / 100;
                            l = Number(a[2]) / 100;
                            g = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
                            r = l * 2 - g;
                            if (a.length > 3) {
                                a[3] = Number(a[3]);
                            }
                            a[0] = _hue(h + 1 / 3, r, g);
                            a[1] = _hue(h, r, g);
                            a[2] = _hue(h - 1 / 3, r, g);
                        } else if (v.indexOf("=") !== -1) {
                            return v.match(_relNumExp);
                        }
                    } else {
                        a = v.match(_numExp) || _colorLookup.transparent;
                    }
                    a[0] = Number(a[0]);
                    a[1] = Number(a[1]);
                    a[2] = Number(a[2]);
                    if (a.length > 3) {
                        a[3] = Number(a[3]);
                    }
                }
                if (toHSL && !wasHSL) {
                    r = a[0] / 255;
                    g = a[1] / 255;
                    b = a[2] / 255;
                    max = Math.max(r, g, b);
                    min = Math.min(r, g, b);
                    l = (max + min) / 2;
                    if (max === min) {
                        h = s = 0;
                    } else {
                        d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        h = (max === r) ? (g - b) / d + (g < b ? 6 : 0) : (max === g) ? (b - r) / d + 2 : (r - g) / d + 4;
                        h *= 60;
                    }
                    a[0] = (h + 0.5) | 0;
                    a[1] = (s * 100 + 0.5) | 0;
                    a[2] = (l * 100 + 0.5) | 0;
                }
                return a;
            },
            _formatColors = function(s, toHSL) {
                var colors = s.match(_colorExp) || [],
                    charIndex = 0,
                    parsed = "",
                    i, color, temp;
                if (!colors.length) {
                    return s;
                }
                for (i = 0; i < colors.length; i++) {
                    color = colors[i];
                    temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
                    charIndex += temp.length + color.length;
                    color = _parseColor(color, toHSL);
                    if (color.length === 3) {
                        color.push(1);
                    }
                    parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
                }
                return parsed + s.substr(charIndex);
            },
            _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
        for (p in _colorLookup) {
            _colorExp += "|" + p + "\\b";
        }
        _colorExp = new RegExp(_colorExp + ")", "gi");
        CSSPlugin.colorStringFilter = function(a) {
            var combined = a[0] + " " + a[1],
                toHSL;
            if (_colorExp.test(combined)) {
                toHSL = (combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1);
                a[0] = _formatColors(a[0], toHSL);
                a[1] = _formatColors(a[1], toHSL);
            }
            _colorExp.lastIndex = 0;
        };
        if (!__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].defaultStringFilter) {
            __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].defaultStringFilter = CSSPlugin.colorStringFilter;
        }
        var _getFormatter = function(dflt, clr, collapsible, multi) {
                if (dflt == null) {
                    return function(v) {
                        return v;
                    };
                }
                var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
                    dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
                    pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
                    sfx = (dflt.charAt(dflt.length - 1) === ")") ? ")" : "",
                    delim = (dflt.indexOf(" ") !== -1) ? " " : ",",
                    numVals = dVals.length,
                    dSfx = (numVals > 0) ? dVals[0].replace(_numExp, "") : "",
                    formatter;
                if (!numVals) {
                    return function(v) {
                        return v;
                    };
                }
                if (clr) {
                    formatter = function(v) {
                        var color, vals, i, a;
                        if (typeof(v) === "number") {
                            v += dSfx;
                        } else if (multi && _commasOutsideParenExp.test(v)) {
                            a = v.replace(_commasOutsideParenExp, "|").split("|");
                            for (i = 0; i < a.length; i++) {
                                a[i] = formatter(a[i]);
                            }
                            return a.join(",");
                        }
                        color = (v.match(_colorExp) || [dColor])[0];
                        vals = v.split(color).join("").match(_valuesExp) || [];
                        i = vals.length;
                        if (numVals > i--) {
                            while (++i < numVals) {
                                vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
                            }
                        }
                        return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
                    };
                    return formatter;
                }
                formatter = function(v) {
                    var vals, a, i;
                    if (typeof(v) === "number") {
                        v += dSfx;
                    } else if (multi && _commasOutsideParenExp.test(v)) {
                        a = v.replace(_commasOutsideParenExp, "|").split("|");
                        for (i = 0; i < a.length; i++) {
                            a[i] = formatter(a[i]);
                        }
                        return a.join(",");
                    }
                    vals = v.match(_valuesExp) || [];
                    i = vals.length;
                    if (numVals > i--) {
                        while (++i < numVals) {
                            vals[i] = collapsible ? vals[(((i - 1) / 2) | 0)] : dVals[i];
                        }
                    }
                    return pfx + vals.join(delim) + sfx;
                };
                return formatter;
            },
            _getEdgeParser = function(props) {
                props = props.split(",");
                return function(t, e, p, cssp, pt, plugin, vars) {
                    var a = (e + "").split(" "),
                        i;
                    vars = {};
                    for (i = 0; i < 4; i++) {
                        vars[props[i]] = a[i] = a[i] || a[(((i - 1) / 2) >> 0)];
                    }
                    return cssp.parse(t, vars, pt, plugin);
                };
            },
            _setPluginRatio = _internals._setPluginRatio = function(v) {
                this.plugin.setRatio(v);
                var d = this.data,
                    proxy = d.proxy,
                    mpt = d.firstMPT,
                    min = 0.000001,
                    val, pt, i, str, p;
                while (mpt) {
                    val = proxy[mpt.v];
                    if (mpt.r) {
                        val = mpt.r(val);
                    } else if (val < min && val > -min) {
                        val = 0;
                    }
                    mpt.t[mpt.p] = val;
                    mpt = mpt._next;
                }
                if (d.autoRotate) {
                    d.autoRotate.rotation = d.mod ? d.mod.call(this._tween, proxy.rotation, this.t, this._tween) : proxy.rotation;
                }
                if (v === 1 || v === 0) {
                    mpt = d.firstMPT;
                    p = (v === 1) ? "e" : "b";
                    while (mpt) {
                        pt = mpt.t;
                        if (!pt.type) {
                            pt[p] = pt.s + pt.xs0;
                        } else if (pt.type === 1) {
                            str = pt.xs0 + pt.s + pt.xs1;
                            for (i = 1; i < pt.l; i++) {
                                str += pt["xn" + i] + pt["xs" + (i + 1)];
                            }
                            pt[p] = str;
                        }
                        mpt = mpt._next;
                    }
                }
            },
            MiniPropTween = function(t, p, v, next, r) {
                this.t = t;
                this.p = p;
                this.v = v;
                this.r = r;
                if (next) {
                    next._prev = this;
                    this._next = next;
                }
            },
            _parseToProxy = _internals._parseToProxy = function(t, vars, cssp, pt, plugin, shallow) {
                var bpt = pt,
                    start = {},
                    end = {},
                    transform = cssp._transform,
                    oldForce = _forcePT,
                    i, p, xp, mpt, firstPT;
                cssp._transform = null;
                _forcePT = vars;
                pt = firstPT = cssp.parse(t, vars, pt, plugin);
                _forcePT = oldForce;
                if (shallow) {
                    cssp._transform = transform;
                    if (bpt) {
                        bpt._prev = null;
                        if (bpt._prev) {
                            bpt._prev._next = null;
                        }
                    }
                }
                while (pt && pt !== bpt) {
                    if (pt.type <= 1) {
                        p = pt.p;
                        end[p] = pt.s + pt.c;
                        start[p] = pt.s;
                        if (!shallow) {
                            mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
                            pt.c = 0;
                        }
                        if (pt.type === 1) {
                            i = pt.l;
                            while (--i > 0) {
                                xp = "xn" + i;
                                p = pt.p + "_" + xp;
                                end[p] = pt.data[xp];
                                start[p] = pt[xp];
                                if (!shallow) {
                                    mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
                                }
                            }
                        }
                    }
                    pt = pt._next;
                }
                return {
                    proxy: start,
                    end: end,
                    firstMPT: mpt,
                    pt: firstPT
                };
            },
            CSSPropTween = _internals.CSSPropTween = function(t, p, s, c, next, type, n, r, pr, b, e) {
                this.t = t;
                this.p = p;
                this.s = s;
                this.c = c;
                this.n = n || p;
                if (!(t instanceof CSSPropTween)) {
                    _overwriteProps.push(this.n);
                }
                this.r = !r ? r : (typeof(r) === "function") ? r : Math.round;
                this.type = type || 0;
                if (pr) {
                    this.pr = pr;
                    _hasPriority = true;
                }
                this.b = (b === undefined) ? s : b;
                this.e = (e === undefined) ? s + c : e;
                if (next) {
                    this._next = next;
                    next._prev = this;
                }
            },
            _addNonTweeningNumericPT = function(target, prop, start, end, next, overwriteProp) {
                var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
                pt.b = start;
                pt.e = pt.xs0 = end;
                return pt;
            },
            _parseComplex = CSSPlugin.parseComplex = function(t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
                b = b || dflt || "";
                if (typeof(e) === "function") {
                    e = e(_index, _target);
                }
                pt = new CSSPropTween(t, p, 0, 0, pt, (setRatio ? 2 : 1), null, false, pr, b, e);
                e += "";
                if (clrs && _colorExp.test(e + b)) {
                    e = [b, e];
                    CSSPlugin.colorStringFilter(e);
                    b = e[0];
                    e = e[1];
                }
                var ba = b.split(", ").join(",").split(" "),
                    ea = e.split(", ").join(",").split(" "),
                    l = ba.length,
                    autoRound = (_autoRound !== false),
                    i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL;
                if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
                    if ((e + b).indexOf("rgb") !== -1 || (e + b).indexOf("hsl") !== -1) {
                        ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
                        ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
                    } else {
                        ba = ba.join(" ").split(",").join(", ").split(" ");
                        ea = ea.join(" ").split(",").join(", ").split(" ");
                    }
                    l = ba.length;
                }
                if (l !== ea.length) {
                    ba = (dflt || "").split(" ");
                    l = ba.length;
                }
                pt.plugin = plugin;
                pt.setRatio = setRatio;
                _colorExp.lastIndex = 0;
                for (i = 0; i < l; i++) {
                    bv = ba[i];
                    ev = ea[i] + "";
                    bn = parseFloat(bv);
                    if (bn || bn === 0) {
                        pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), (autoRound && ev.indexOf("px") !== -1) ? Math.round : false, true);
                    } else if (clrs && _colorExp.test(bv)) {
                        str = ev.indexOf(")") + 1;
                        str = ")" + (str ? ev.substr(str) : "");
                        useHSL = (ev.indexOf("hsl") !== -1 && _supportsOpacity);
                        temp = ev;
                        bv = _parseColor(bv, useHSL);
                        ev = _parseColor(ev, useHSL);
                        hasAlpha = (bv.length + ev.length > 6);
                        if (hasAlpha && !_supportsOpacity && ev[3] === 0) {
                            pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
                            pt.e = pt.e.split(ea[i]).join("transparent");
                        } else {
                            if (!_supportsOpacity) {
                                hasAlpha = false;
                            }
                            if (useHSL) {
                                pt.appendXtra(temp.substr(0, temp.indexOf("hsl")) + (hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true).appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false).appendXtra("", bv[2], _parseChange(ev[2], bv[2]), (hasAlpha ? "%," : "%" + str), false);
                            } else {
                                pt.appendXtra(temp.substr(0, temp.indexOf("rgb")) + (hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", Math.round, true).appendXtra("", bv[1], ev[1] - bv[1], ",", Math.round).appendXtra("", bv[2], ev[2] - bv[2], (hasAlpha ? "," : str), Math.round);
                            }
                            if (hasAlpha) {
                                bv = (bv.length < 4) ? 1 : bv[3];
                                pt.appendXtra("", bv, ((ev.length < 4) ? 1 : ev[3]) - bv, str, false);
                            }
                        }
                        _colorExp.lastIndex = 0;
                    } else {
                        bnums = bv.match(_numExp);
                        if (!bnums) {
                            pt["xs" + pt.l] += (pt.l || pt["xs" + pt.l]) ? " " + ev : ev;
                        } else {
                            enums = ev.match(_relNumExp);
                            if (!enums || enums.length !== bnums.length) {
                                return pt;
                            }
                            ni = 0;
                            for (xi = 0; xi < bnums.length; xi++) {
                                cv = bnums[xi];
                                temp = bv.indexOf(cv, ni);
                                pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", (autoRound && bv.substr(temp + cv.length, 2) === "px") ? Math.round : false, (xi === 0));
                                ni = temp + cv.length;
                            }
                            pt["xs" + pt.l] += bv.substr(ni);
                        }
                    }
                }
                if (e.indexOf("=") !== -1)
                    if (pt.data) {
                        str = pt.xs0 + pt.data.s;
                        for (i = 1; i < pt.l; i++) {
                            str += pt["xs" + i] + pt.data["xn" + i];
                        }
                        pt.e = str + pt["xs" + i];
                    }
                if (!pt.l) {
                    pt.type = -1;
                    pt.xs0 = pt.e;
                }
                return pt.xfirst || pt;
            },
            i = 9;
        p = CSSPropTween.prototype;
        p.l = p.pr = 0;
        while (--i > 0) {
            p["xn" + i] = 0;
            p["xs" + i] = "";
        }
        p.xs0 = "";
        p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;
        p.appendXtra = function(pfx, s, c, sfx, r, pad) {
            var pt = this,
                l = pt.l;
            pt["xs" + l] += (pad && (l || pt["xs" + l])) ? " " + pfx : pfx || "";
            if (!c)
                if (l !== 0 && !pt.plugin) {
                    pt["xs" + l] += s + (sfx || "");
                    return pt;
                }
            pt.l++;
            pt.type = pt.setRatio ? 2 : 1;
            pt["xs" + pt.l] = sfx || "";
            if (l > 0) {
                pt.data["xn" + l] = s + c;
                pt.rxp["xn" + l] = r;
                pt["xn" + l] = s;
                if (!pt.plugin) {
                    pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
                    pt.xfirst.xs0 = 0;
                }
                return pt;
            }
            pt.data = {
                s: s + c
            };
            pt.rxp = {};
            pt.s = s;
            pt.c = c;
            pt.r = r;
            return pt;
        };
        var SpecialProp = function(p, options) {
                options = options || {};
                this.p = options.prefix ? _checkPropPrefix(p) || p : p;
                _specialProps[p] = _specialProps[this.p] = this;
                this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
                if (options.parser) {
                    this.parse = options.parser;
                }
                this.clrs = options.color;
                this.multi = options.multi;
                this.keyword = options.keyword;
                this.dflt = options.defaultValue;
                this.pr = options.priority || 0;
            },
            _registerComplexSpecialProp = _internals._registerComplexSpecialProp = function(p, options, defaults) {
                if (typeof(options) !== "object") {
                    options = {
                        parser: defaults
                    };
                }
                var a = p.split(","),
                    d = options.defaultValue,
                    i, temp;
                defaults = defaults || [d];
                for (i = 0; i < a.length; i++) {
                    options.prefix = (i === 0 && options.prefix);
                    options.defaultValue = defaults[i] || d;
                    temp = new SpecialProp(a[i], options);
                }
            },
            _registerPluginProp = _internals._registerPluginProp = function(p) {
                if (!_specialProps[p]) {
                    var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
                    _registerComplexSpecialProp(p, {
                        parser: function(t, e, p, cssp, pt, plugin, vars) {
                            var pluginClass = _globals.com.greensock.plugins[pluginName];
                            if (!pluginClass) {
                                _log("Error: " + pluginName + " js file not loaded.");
                                return pt;
                            }
                            pluginClass._cssRegister();
                            return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
                        }
                    });
                }
            };
        p = SpecialProp.prototype;
        p.parseComplex = function(t, b, e, pt, plugin, setRatio) {
            var kwd = this.keyword,
                i, ba, ea, l, bi, ei;
            if (this.multi)
                if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
                    ba = b.replace(_commasOutsideParenExp, "|").split("|");
                    ea = e.replace(_commasOutsideParenExp, "|").split("|");
                } else if (kwd) {
                ba = [b];
                ea = [e];
            }
            if (ea) {
                l = (ea.length > ba.length) ? ea.length : ba.length;
                for (i = 0; i < l; i++) {
                    b = ba[i] = ba[i] || this.dflt;
                    e = ea[i] = ea[i] || this.dflt;
                    if (kwd) {
                        bi = b.indexOf(kwd);
                        ei = e.indexOf(kwd);
                        if (bi !== ei) {
                            if (ei === -1) {
                                ba[i] = ba[i].split(kwd).join("");
                            } else if (bi === -1) {
                                ba[i] += " " + kwd;
                            }
                        }
                    }
                }
                b = ba.join(", ");
                e = ea.join(", ");
            }
            return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
        };
        p.parse = function(t, e, p, cssp, pt, plugin, vars) {
            return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
        };
        CSSPlugin.registerSpecialProp = function(name, onInitTween, priority) {
            _registerComplexSpecialProp(name, {
                parser: function(t, e, p, cssp, pt, plugin, vars) {
                    var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
                    rv.plugin = plugin;
                    rv.setRatio = onInitTween(t, e, cssp._tween, p);
                    return rv;
                },
                priority: priority
            });
        };
        CSSPlugin.useSVGTransformAttr = true;
        var _transformProps = ("scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent").split(","),
            _transformProp = _checkPropPrefix("transform"),
            _transformPropCSS = _prefixCSS + "transform",
            _transformOriginProp = _checkPropPrefix("transformOrigin"),
            _supports3D = (_checkPropPrefix("perspective") !== null),
            Transform = _internals.Transform = function() {
                this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
                this.force3D = (CSSPlugin.defaultForce3D === false || !_supports3D) ? false : CSSPlugin.defaultForce3D || "auto";
            },
            _SVGElement = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].SVGElement,
            _useSVGTransformAttr, _createSVG = function(type, container, attributes) {
                var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
                    reg = /([a-z])([A-Z])/g,
                    p;
                for (p in attributes) {
                    element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
                }
                container.appendChild(element);
                return element;
            },
            _docElement = _doc.documentElement || {},
            _forceSVGTransformAttr = (function() {
                var force = _ieVers || (/Android/i.test(_agent) && !__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].chrome),
                    svg, rect, width;
                if (_doc.createElementNS && !force) {
                    svg = _createSVG("svg", _docElement);
                    rect = _createSVG("rect", svg, {
                        width: 100,
                        height: 50,
                        x: 100
                    });
                    width = rect.getBoundingClientRect().width;
                    rect.style[_transformOriginProp] = "50% 50%";
                    rect.style[_transformProp] = "scaleX(0.5)";
                    force = (width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D));
                    _docElement.removeChild(svg);
                }
                return force;
            })(),
            _parseSVGOrigin = function(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
                var tm = e._gsTransform,
                    m = _getMatrix(e, true),
                    v, x, y, xOrigin, yOrigin, a, b, c, d, tx, ty, determinant, xOriginOld, yOriginOld;
                if (tm) {
                    xOriginOld = tm.xOrigin;
                    yOriginOld = tm.yOrigin;
                }
                if (!absolute || (v = absolute.split(" ")).length < 2) {
                    b = e.getBBox();
                    if (b.x === 0 && b.y === 0 && b.width + b.height === 0) {
                        b = {
                            x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0,
                            y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0,
                            width: 0,
                            height: 0
                        };
                    }
                    local = _parsePosition(local).split(" ");
                    v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x, (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
                }
                decoratee.xOrigin = xOrigin = parseFloat(v[0]);
                decoratee.yOrigin = yOrigin = parseFloat(v[1]);
                if (absolute && m !== _identity2DMatrix) {
                    a = m[0];
                    b = m[1];
                    c = m[2];
                    d = m[3];
                    tx = m[4];
                    ty = m[5];
                    determinant = (a * d - b * c);
                    if (determinant) {
                        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + ((c * ty - d * tx) / determinant);
                        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - ((a * ty - b * tx) / determinant);
                        xOrigin = decoratee.xOrigin = v[0] = x;
                        yOrigin = decoratee.yOrigin = v[1] = y;
                    }
                }
                if (tm) {
                    if (skipRecord) {
                        decoratee.xOffset = tm.xOffset;
                        decoratee.yOffset = tm.yOffset;
                        tm = decoratee;
                    }
                    if (smoothOrigin || (smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false)) {
                        x = xOrigin - xOriginOld;
                        y = yOrigin - yOriginOld;
                        tm.xOffset += (x * m[0] + y * m[2]) - x;
                        tm.yOffset += (x * m[1] + y * m[3]) - y;
                    } else {
                        tm.xOffset = tm.yOffset = 0;
                    }
                }
                if (!skipRecord) {
                    e.setAttribute("data-svg-origin", v.join(" "));
                }
            },
            _getBBoxHack = function(swapIfPossible) {
                var svg = _createElement("svg", (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) || "http://www.w3.org/2000/svg"),
                    oldParent = this.parentNode,
                    oldSibling = this.nextSibling,
                    oldCSS = this.style.cssText,
                    bbox;
                _docElement.appendChild(svg);
                svg.appendChild(this);
                this.style.display = "block";
                if (swapIfPossible) {
                    try {
                        bbox = this.getBBox();
                        this._originalGetBBox = this.getBBox;
                        this.getBBox = _getBBoxHack;
                    } catch (e) {}
                } else if (this._originalGetBBox) {
                    bbox = this._originalGetBBox();
                }
                if (oldSibling) {
                    oldParent.insertBefore(this, oldSibling);
                } else {
                    oldParent.appendChild(this);
                }
                _docElement.removeChild(svg);
                this.style.cssText = oldCSS;
                return bbox;
            },
            _getBBox = function(e) {
                try {
                    return e.getBBox();
                } catch (error) {
                    return _getBBoxHack.call(e, true);
                }
            },
            _isSVG = function(e) {
                return !!(_SVGElement && e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
            },
            _identity2DMatrix = [1, 0, 0, 1, 0, 0],
            _getMatrix = function(e, force2D) {
                var tm = e._gsTransform || new Transform(),
                    rnd = 100000,
                    style = e.style,
                    isDefault, s, m, n, dec, none;
                if (_transformProp) {
                    s = _getStyle(e, _transformPropCSS, null, true);
                } else if (e.currentStyle) {
                    s = e.currentStyle.filter.match(_ieGetMatrixExp);
                    s = (s && s.length === 4) ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), (tm.x || 0), (tm.y || 0)].join(",") : "";
                }
                isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
                if (_transformProp && ((none = (!_getComputedStyle(e) || _getComputedStyle(e).display === "none")) || !e.parentNode)) {
                    if (none) {
                        n = style.display;
                        style.display = "block";
                    }
                    if (!e.parentNode) {
                        dec = 1;
                        _docElement.appendChild(e);
                    }
                    s = _getStyle(e, _transformPropCSS, null, true);
                    isDefault = (!s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)");
                    if (n) {
                        style.display = n;
                    } else if (none) {
                        _removeProp(style, "display");
                    }
                    if (dec) {
                        _docElement.removeChild(e);
                    }
                }
                if (tm.svg || (e.getCTM && _isSVG(e))) {
                    if (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) {
                        s = style[_transformProp];
                        isDefault = 0;
                    }
                    m = e.getAttribute("transform");
                    if (isDefault && m) {
                        m = e.transform.baseVal.consolidate().matrix;
                        s = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
                        isDefault = 0;
                    }
                }
                if (isDefault) {
                    return _identity2DMatrix;
                }
                m = (s || "").match(_numExp) || [];
                i = m.length;
                while (--i > -1) {
                    n = Number(m[i]);
                    m[i] = (dec = n - (n |= 0)) ? ((dec * rnd + (dec < 0 ? -0.5 : 0.5)) | 0) / rnd + n : n;
                }
                return (force2D && m.length > 6) ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
            },
            _getTransform = _internals.getTransform = function(t, cs, rec, parse) {
                if (t._gsTransform && rec && !parse) {
                    return t._gsTransform;
                }
                var tm = rec ? t._gsTransform || new Transform() : new Transform(),
                    invX = (tm.scaleX < 0),
                    min = 0.00002,
                    rnd = 100000,
                    zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
                    defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
                    m, i, scaleX, scaleY, rotation, skewX;
                tm.svg = !!(t.getCTM && _isSVG(t));
                if (tm.svg) {
                    _parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
                    _useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
                }
                m = _getMatrix(t);
                if (m !== _identity2DMatrix) {
                    if (m.length === 16) {
                        var a11 = m[0],
                            a21 = m[1],
                            a31 = m[2],
                            a41 = m[3],
                            a12 = m[4],
                            a22 = m[5],
                            a32 = m[6],
                            a42 = m[7],
                            a13 = m[8],
                            a23 = m[9],
                            a33 = m[10],
                            a14 = m[12],
                            a24 = m[13],
                            a34 = m[14],
                            a43 = m[11],
                            angle = Math.atan2(a32, a33),
                            t1, t2, t3, t4, cos, sin;
                        if (tm.zOrigin) {
                            a34 = -tm.zOrigin;
                            a14 = a13 * a34 - m[12];
                            a24 = a23 * a34 - m[13];
                            a34 = a33 * a34 + tm.zOrigin - m[14];
                        }
                        tm.rotationX = angle * _RAD2DEG;
                        if (angle) {
                            cos = Math.cos(-angle);
                            sin = Math.sin(-angle);
                            t1 = a12 * cos + a13 * sin;
                            t2 = a22 * cos + a23 * sin;
                            t3 = a32 * cos + a33 * sin;
                            a13 = a12 * -sin + a13 * cos;
                            a23 = a22 * -sin + a23 * cos;
                            a33 = a32 * -sin + a33 * cos;
                            a43 = a42 * -sin + a43 * cos;
                            a12 = t1;
                            a22 = t2;
                            a32 = t3;
                        }
                        angle = Math.atan2(-a31, a33);
                        tm.rotationY = angle * _RAD2DEG;
                        if (angle) {
                            cos = Math.cos(-angle);
                            sin = Math.sin(-angle);
                            t1 = a11 * cos - a13 * sin;
                            t2 = a21 * cos - a23 * sin;
                            t3 = a31 * cos - a33 * sin;
                            a23 = a21 * sin + a23 * cos;
                            a33 = a31 * sin + a33 * cos;
                            a43 = a41 * sin + a43 * cos;
                            a11 = t1;
                            a21 = t2;
                            a31 = t3;
                        }
                        angle = Math.atan2(a21, a11);
                        tm.rotation = angle * _RAD2DEG;
                        if (angle) {
                            cos = Math.cos(angle);
                            sin = Math.sin(angle);
                            t1 = a11 * cos + a21 * sin;
                            t2 = a12 * cos + a22 * sin;
                            t3 = a13 * cos + a23 * sin;
                            a21 = a21 * cos - a11 * sin;
                            a22 = a22 * cos - a12 * sin;
                            a23 = a23 * cos - a13 * sin;
                            a11 = t1;
                            a12 = t2;
                            a13 = t3;
                        }
                        if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) {
                            tm.rotationX = tm.rotation = 0;
                            tm.rotationY = 180 - tm.rotationY;
                        }
                        angle = Math.atan2(a12, a22);
                        tm.scaleX = ((Math.sqrt(a11 * a11 + a21 * a21 + a31 * a31) * rnd + 0.5) | 0) / rnd;
                        tm.scaleY = ((Math.sqrt(a22 * a22 + a32 * a32) * rnd + 0.5) | 0) / rnd;
                        tm.scaleZ = ((Math.sqrt(a13 * a13 + a23 * a23 + a33 * a33) * rnd + 0.5) | 0) / rnd;
                        a11 /= tm.scaleX;
                        a12 /= tm.scaleY;
                        a21 /= tm.scaleX;
                        a22 /= tm.scaleY;
                        if (Math.abs(angle) > min) {
                            tm.skewX = angle * _RAD2DEG;
                            a12 = 0;
                            if (tm.skewType !== "simple") {
                                tm.scaleY *= 1 / Math.cos(angle);
                            }
                        } else {
                            tm.skewX = 0;
                        }
                        tm.perspective = a43 ? 1 / ((a43 < 0) ? -a43 : a43) : 0;
                        tm.x = a14;
                        tm.y = a24;
                        tm.z = a34;
                        if (tm.svg) {
                            tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
                            tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
                        }
                    } else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || (!tm.rotationX && !tm.rotationY))) {
                        var k = (m.length >= 6),
                            a = k ? m[0] : 1,
                            b = m[1] || 0,
                            c = m[2] || 0,
                            d = k ? m[3] : 1;
                        tm.x = m[4] || 0;
                        tm.y = m[5] || 0;
                        scaleX = Math.sqrt(a * a + b * b);
                        scaleY = Math.sqrt(d * d + c * c);
                        rotation = (a || b) ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0;
                        skewX = (c || d) ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
                        tm.scaleX = scaleX;
                        tm.scaleY = scaleY;
                        tm.rotation = rotation;
                        tm.skewX = skewX;
                        if (_supports3D) {
                            tm.rotationX = tm.rotationY = tm.z = 0;
                            tm.perspective = defaultTransformPerspective;
                            tm.scaleZ = 1;
                        }
                        if (tm.svg) {
                            tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
                            tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
                        }
                    }
                    if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
                        if (invX) {
                            tm.scaleX *= -1;
                            tm.skewX += (tm.rotation <= 0) ? 180 : -180;
                            tm.rotation += (tm.rotation <= 0) ? 180 : -180;
                        } else {
                            tm.scaleY *= -1;
                            tm.skewX += (tm.skewX <= 0) ? 180 : -180;
                        }
                    }
                    tm.zOrigin = zOrigin;
                    for (i in tm) {
                        if (tm[i] < min)
                            if (tm[i] > -min) {
                                tm[i] = 0;
                            }
                    }
                }
                if (rec) {
                    t._gsTransform = tm;
                    if (tm.svg) {
                        if (_useSVGTransformAttr && t.style[_transformProp]) {
                            __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].delayedCall(0.001, function() {
                                _removeProp(t.style, _transformProp);
                            });
                        } else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
                            __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].delayedCall(0.001, function() {
                                t.removeAttribute("transform");
                            });
                        }
                    }
                }
                return tm;
            },
            _setIETransformRatio = function(v) {
                var t = this.data,
                    ang = -t.rotation * _DEG2RAD,
                    skew = ang + t.skewX * _DEG2RAD,
                    rnd = 100000,
                    a = ((Math.cos(ang) * t.scaleX * rnd) | 0) / rnd,
                    b = ((Math.sin(ang) * t.scaleX * rnd) | 0) / rnd,
                    c = ((Math.sin(skew) * -t.scaleY * rnd) | 0) / rnd,
                    d = ((Math.cos(skew) * t.scaleY * rnd) | 0) / rnd,
                    style = this.t.style,
                    cs = this.t.currentStyle,
                    filters, val;
                if (!cs) {
                    return;
                }
                val = b;
                b = -c;
                c = -val;
                filters = cs.filter;
                style.filter = "";
                var w = this.t.offsetWidth,
                    h = this.t.offsetHeight,
                    clip = (cs.position !== "absolute"),
                    m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
                    ox = t.x + (w * t.xPercent / 100),
                    oy = t.y + (h * t.yPercent / 100),
                    dx, dy;
                if (t.ox != null) {
                    dx = ((t.oxp) ? w * t.ox * 0.01 : t.ox) - w / 2;
                    dy = ((t.oyp) ? h * t.oy * 0.01 : t.oy) - h / 2;
                    ox += dx - (dx * a + dy * b);
                    oy += dy - (dx * c + dy * d);
                }
                if (!clip) {
                    m += ", sizingMethod='auto expand')";
                } else {
                    dx = (w / 2);
                    dy = (h / 2);
                    m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
                }
                if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
                    style.filter = filters.replace(_ieSetMatrixExp, m);
                } else {
                    style.filter = m + " " + filters;
                }
                if (v === 0 || v === 1)
                    if (a === 1)
                        if (b === 0)
                            if (c === 0)
                                if (d === 1)
                                    if (!clip || m.indexOf("Dx=0, Dy=0") !== -1)
                                        if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100)
                                            if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
                                                style.removeAttribute("filter");
                                            }
                if (!clip) {
                    var mult = (_ieVers < 8) ? 1 : -1,
                        marg, prop, dif;
                    dx = t.ieOffsetX || 0;
                    dy = t.ieOffsetY || 0;
                    t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
                    t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
                    for (i = 0; i < 4; i++) {
                        prop = _margins[i];
                        marg = cs[prop];
                        val = (marg.indexOf("px") !== -1) ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
                        if (val !== t[prop]) {
                            dif = (i < 2) ? -t.ieOffsetX : -t.ieOffsetY;
                        } else {
                            dif = (i < 2) ? dx - t.ieOffsetX : dy - t.ieOffsetY;
                        }
                        style[prop] = (t[prop] = Math.round(val - dif * ((i === 0 || i === 2) ? 1 : mult))) + "px";
                    }
                }
            },
            _setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function(v) {
                var t = this.data,
                    style = this.t.style,
                    angle = t.rotation,
                    rotationX = t.rotationX,
                    rotationY = t.rotationY,
                    sx = t.scaleX,
                    sy = t.scaleY,
                    sz = t.scaleZ,
                    x = t.x,
                    y = t.y,
                    z = t.z,
                    isSVG = t.svg,
                    perspective = t.perspective,
                    force3D = t.force3D,
                    skewY = t.skewY,
                    skewX = t.skewX,
                    t1, a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43, zOrigin, min, cos, sin, t2, transform, comma, zero, skew, rnd;
                if (skewY) {
                    skewX += skewY;
                    angle += skewY;
                }
                if (((((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime)) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1) || (_useSVGTransformAttr && isSVG) || !_supports3D) {
                    if (angle || skewX || isSVG) {
                        angle *= _DEG2RAD;
                        skew = skewX * _DEG2RAD;
                        rnd = 100000;
                        a11 = Math.cos(angle) * sx;
                        a21 = Math.sin(angle) * sx;
                        a12 = Math.sin(angle - skew) * -sy;
                        a22 = Math.cos(angle - skew) * sy;
                        if (skew && t.skewType === "simple") {
                            t1 = Math.tan(skew - skewY * _DEG2RAD);
                            t1 = Math.sqrt(1 + t1 * t1);
                            a12 *= t1;
                            a22 *= t1;
                            if (skewY) {
                                t1 = Math.tan(skewY * _DEG2RAD);
                                t1 = Math.sqrt(1 + t1 * t1);
                                a11 *= t1;
                                a21 *= t1;
                            }
                        }
                        if (isSVG) {
                            x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
                            y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
                            if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) {
                                min = this.t.getBBox();
                                x += t.xPercent * 0.01 * min.width;
                                y += t.yPercent * 0.01 * min.height;
                            }
                            min = 0.000001;
                            if (x < min)
                                if (x > -min) {
                                    x = 0;
                                }
                            if (y < min)
                                if (y > -min) {
                                    y = 0;
                                }
                        }
                        transform = (((a11 * rnd) | 0) / rnd) + "," + (((a21 * rnd) | 0) / rnd) + "," + (((a12 * rnd) | 0) / rnd) + "," + (((a22 * rnd) | 0) / rnd) + "," + x + "," + y + ")";
                        if (isSVG && _useSVGTransformAttr) {
                            this.t.setAttribute("transform", "matrix(" + transform);
                        } else {
                            style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
                        }
                    } else {
                        style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
                    }
                    return;
                }
                if (_isFirefox) {
                    min = 0.0001;
                    if (sx < min && sx > -min) {
                        sx = sz = 0.00002;
                    }
                    if (sy < min && sy > -min) {
                        sy = sz = 0.00002;
                    }
                    if (perspective && !t.z && !t.rotationX && !t.rotationY) {
                        perspective = 0;
                    }
                }
                if (angle || skewX) {
                    angle *= _DEG2RAD;
                    cos = a11 = Math.cos(angle);
                    sin = a21 = Math.sin(angle);
                    if (skewX) {
                        angle -= skewX * _DEG2RAD;
                        cos = Math.cos(angle);
                        sin = Math.sin(angle);
                        if (t.skewType === "simple") {
                            t1 = Math.tan((skewX - skewY) * _DEG2RAD);
                            t1 = Math.sqrt(1 + t1 * t1);
                            cos *= t1;
                            sin *= t1;
                            if (t.skewY) {
                                t1 = Math.tan(skewY * _DEG2RAD);
                                t1 = Math.sqrt(1 + t1 * t1);
                                a11 *= t1;
                                a21 *= t1;
                            }
                        }
                    }
                    a12 = -sin;
                    a22 = cos;
                } else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) {
                    style[_transformProp] = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + ((sx !== 1 || sy !== 1) ? " scale(" + sx + "," + sy + ")" : "");
                    return;
                } else {
                    a11 = a22 = 1;
                    a12 = a21 = 0;
                }
                a33 = 1;
                a13 = a23 = a31 = a32 = a41 = a42 = 0;
                a43 = (perspective) ? -1 / perspective : 0;
                zOrigin = t.zOrigin;
                min = 0.000001;
                comma = ",";
                zero = "0";
                angle = rotationY * _DEG2RAD;
                if (angle) {
                    cos = Math.cos(angle);
                    sin = Math.sin(angle);
                    a31 = -sin;
                    a41 = a43 * -sin;
                    a13 = a11 * sin;
                    a23 = a21 * sin;
                    a33 = cos;
                    a43 *= cos;
                    a11 *= cos;
                    a21 *= cos;
                }
                angle = rotationX * _DEG2RAD;
                if (angle) {
                    cos = Math.cos(angle);
                    sin = Math.sin(angle);
                    t1 = a12 * cos + a13 * sin;
                    t2 = a22 * cos + a23 * sin;
                    a32 = a33 * sin;
                    a42 = a43 * sin;
                    a13 = a12 * -sin + a13 * cos;
                    a23 = a22 * -sin + a23 * cos;
                    a33 = a33 * cos;
                    a43 = a43 * cos;
                    a12 = t1;
                    a22 = t2;
                }
                if (sz !== 1) {
                    a13 *= sz;
                    a23 *= sz;
                    a33 *= sz;
                    a43 *= sz;
                }
                if (sy !== 1) {
                    a12 *= sy;
                    a22 *= sy;
                    a32 *= sy;
                    a42 *= sy;
                }
                if (sx !== 1) {
                    a11 *= sx;
                    a21 *= sx;
                    a31 *= sx;
                    a41 *= sx;
                }
                if (zOrigin || isSVG) {
                    if (zOrigin) {
                        x += a13 * -zOrigin;
                        y += a23 * -zOrigin;
                        z += a33 * -zOrigin + zOrigin;
                    }
                    if (isSVG) {
                        x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
                        y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
                    }
                    if (x < min && x > -min) {
                        x = zero;
                    }
                    if (y < min && y > -min) {
                        y = zero;
                    }
                    if (z < min && z > -min) {
                        z = 0;
                    }
                }
                transform = ((t.xPercent || t.yPercent) ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(");
                transform += ((a11 < min && a11 > -min) ? zero : a11) + comma + ((a21 < min && a21 > -min) ? zero : a21) + comma + ((a31 < min && a31 > -min) ? zero : a31);
                transform += comma + ((a41 < min && a41 > -min) ? zero : a41) + comma + ((a12 < min && a12 > -min) ? zero : a12) + comma + ((a22 < min && a22 > -min) ? zero : a22);
                if (rotationX || rotationY || sz !== 1) {
                    transform += comma + ((a32 < min && a32 > -min) ? zero : a32) + comma + ((a42 < min && a42 > -min) ? zero : a42) + comma + ((a13 < min && a13 > -min) ? zero : a13);
                    transform += comma + ((a23 < min && a23 > -min) ? zero : a23) + comma + ((a33 < min && a33 > -min) ? zero : a33) + comma + ((a43 < min && a43 > -min) ? zero : a43) + comma;
                } else {
                    transform += ",0,0,0,0,1,0,";
                }
                transform += x + comma + y + comma + z + comma + (perspective ? (1 + (-z / perspective)) : 1) + ")";
                style[_transformProp] = transform;
            };
        p = Transform.prototype;
        p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
        p.scaleX = p.scaleY = p.scaleZ = 1;
        _registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
            parser: function(t, e, parsingProp, cssp, pt, plugin, vars) {
                if (cssp._lastParsedTransform === vars) {
                    return pt;
                }
                cssp._lastParsedTransform = vars;
                var scaleFunc = (vars.scale && typeof(vars.scale) === "function") ? vars.scale : 0,
                    swapFunc;
                if (typeof(vars[parsingProp]) === "function") {
                    swapFunc = vars[parsingProp];
                    vars[parsingProp] = e;
                }
                if (scaleFunc) {
                    vars.scale = scaleFunc(_index, t);
                }
                var originalGSTransform = t._gsTransform,
                    style = t.style,
                    min = 0.000001,
                    i = _transformProps.length,
                    v = vars,
                    endRotations = {},
                    transformOriginString = "transformOrigin",
                    m1 = _getTransform(t, _cs, true, v.parseTransform),
                    orig = v.transform && ((typeof(v.transform) === "function") ? v.transform(_index, _target) : v.transform),
                    m2, copy, has3D, hasChange, dr, x, y, matrix, p;
                m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;
                cssp._transform = m1;
                if (orig && typeof(orig) === "string" && _transformProp) {
                    copy = _tempDiv.style;
                    copy[_transformProp] = orig;
                    copy.display = "block";
                    copy.position = "absolute";
                    if (orig.indexOf("%") !== -1) {
                        copy.width = _getStyle(t, "width");
                        copy.height = _getStyle(t, "height");
                    }
                    _doc.body.appendChild(_tempDiv);
                    m2 = _getTransform(_tempDiv, null, false);
                    if (m1.skewType === "simple") {
                        m2.scaleY *= Math.cos(m2.skewX * _DEG2RAD);
                    }
                    if (m1.svg) {
                        x = m1.xOrigin;
                        y = m1.yOrigin;
                        m2.x -= m1.xOffset;
                        m2.y -= m1.yOffset;
                        if (v.transformOrigin || v.svgOrigin) {
                            orig = {};
                            _parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
                            x = orig.xOrigin;
                            y = orig.yOrigin;
                            m2.x -= orig.xOffset - m1.xOffset;
                            m2.y -= orig.yOffset - m1.yOffset;
                        }
                        if (x || y) {
                            matrix = _getMatrix(_tempDiv, true);
                            m2.x -= x - (x * matrix[0] + y * matrix[2]);
                            m2.y -= y - (x * matrix[1] + y * matrix[3]);
                        }
                    }
                    _doc.body.removeChild(_tempDiv);
                    if (!m2.perspective) {
                        m2.perspective = m1.perspective;
                    }
                    if (v.xPercent != null) {
                        m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
                    }
                    if (v.yPercent != null) {
                        m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
                    }
                } else if (typeof(v) === "object") {
                    m2 = {
                        scaleX: _parseVal((v.scaleX != null) ? v.scaleX : v.scale, m1.scaleX),
                        scaleY: _parseVal((v.scaleY != null) ? v.scaleY : v.scale, m1.scaleY),
                        scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
                        x: _parseVal(v.x, m1.x),
                        y: _parseVal(v.y, m1.y),
                        z: _parseVal(v.z, m1.z),
                        xPercent: _parseVal(v.xPercent, m1.xPercent),
                        yPercent: _parseVal(v.yPercent, m1.yPercent),
                        perspective: _parseVal(v.transformPerspective, m1.perspective)
                    };
                    dr = v.directionalRotation;
                    if (dr != null) {
                        if (typeof(dr) === "object") {
                            for (copy in dr) {
                                v[copy] = dr[copy];
                            }
                        } else {
                            v.rotation = dr;
                        }
                    }
                    if (typeof(v.x) === "string" && v.x.indexOf("%") !== -1) {
                        m2.x = 0;
                        m2.xPercent = _parseVal(v.x, m1.xPercent);
                    }
                    if (typeof(v.y) === "string" && v.y.indexOf("%") !== -1) {
                        m2.y = 0;
                        m2.yPercent = _parseVal(v.y, m1.yPercent);
                    }
                    m2.rotation = _parseAngle(("rotation" in v) ? v.rotation : ("shortRotation" in v) ? v.shortRotation + "_short" : ("rotationZ" in v) ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
                    if (_supports3D) {
                        m2.rotationX = _parseAngle(("rotationX" in v) ? v.rotationX : ("shortRotationX" in v) ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
                        m2.rotationY = _parseAngle(("rotationY" in v) ? v.rotationY : ("shortRotationY" in v) ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
                    }
                    m2.skewX = _parseAngle(v.skewX, m1.skewX);
                    m2.skewY = _parseAngle(v.skewY, m1.skewY);
                }
                if (_supports3D && v.force3D != null) {
                    m1.force3D = v.force3D;
                    hasChange = true;
                }
                has3D = (m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective);
                if (!has3D && v.scale != null) {
                    m2.scaleZ = 1;
                }
                while (--i > -1) {
                    p = _transformProps[i];
                    orig = m2[p] - m1[p];
                    if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
                        hasChange = true;
                        pt = new CSSPropTween(m1, p, m1[p], orig, pt);
                        if (p in endRotations) {
                            pt.e = endRotations[p];
                        }
                        pt.xs0 = 0;
                        pt.plugin = plugin;
                        cssp._overwriteProps.push(pt.n);
                    }
                }
                orig = v.transformOrigin;
                if (m1.svg && (orig || v.svgOrigin)) {
                    x = m1.xOffset;
                    y = m1.yOffset;
                    _parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
                    pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString);
                    pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
                    if (x !== m1.xOffset || y !== m1.yOffset) {
                        pt = _addNonTweeningNumericPT(m1, "xOffset", (originalGSTransform ? x : m1.xOffset), m1.xOffset, pt, transformOriginString);
                        pt = _addNonTweeningNumericPT(m1, "yOffset", (originalGSTransform ? y : m1.yOffset), m1.yOffset, pt, transformOriginString);
                    }
                    orig = "0px 0px";
                }
                if (orig || (_supports3D && has3D && m1.zOrigin)) {
                    if (_transformProp) {
                        hasChange = true;
                        p = _transformOriginProp;
                        orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + "";
                        pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
                        pt.b = style[p];
                        pt.plugin = plugin;
                        if (_supports3D) {
                            copy = m1.zOrigin;
                            orig = orig.split(" ");
                            m1.zOrigin = ((orig.length > 2 && !(copy !== 0 && orig[2] === "0px")) ? parseFloat(orig[2]) : copy) || 0;
                            pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px";
                            pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n);
                            pt.b = copy;
                            pt.xs0 = pt.e = m1.zOrigin;
                        } else {
                            pt.xs0 = pt.e = orig;
                        }
                    } else {
                        _parsePosition(orig + "", m1);
                    }
                }
                if (hasChange) {
                    cssp._transformType = (!(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3)) ? 3 : 2;
                }
                if (swapFunc) {
                    vars[parsingProp] = swapFunc;
                }
                if (scaleFunc) {
                    vars.scale = scaleFunc;
                }
                return pt;
            },
            prefix: true
        });
        _registerComplexSpecialProp("boxShadow", {
            defaultValue: "0px 0px 0px 0px #999",
            prefix: true,
            color: true,
            multi: true,
            keyword: "inset"
        });
        _registerComplexSpecialProp("borderRadius", {
            defaultValue: "0px",
            parser: function(t, e, p, cssp, pt, plugin) {
                e = this.format(e);
                var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                    style = t.style,
                    ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
                w = parseFloat(t.offsetWidth);
                h = parseFloat(t.offsetHeight);
                ea1 = e.split(" ");
                for (i = 0; i < props.length; i++) {
                    if (this.p.indexOf("border")) {
                        props[i] = _checkPropPrefix(props[i]);
                    }
                    bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
                    if (bs.indexOf(" ") !== -1) {
                        bs2 = bs.split(" ");
                        bs = bs2[0];
                        bs2 = bs2[1];
                    }
                    es = es2 = ea1[i];
                    bn = parseFloat(bs);
                    bsfx = bs.substr((bn + "").length);
                    rel = (es.charAt(1) === "=");
                    if (rel) {
                        en = parseInt(es.charAt(0) + "1", 10);
                        es = es.substr(2);
                        en *= parseFloat(es);
                        esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
                    } else {
                        en = parseFloat(es);
                        esfx = es.substr((en + "").length);
                    }
                    if (esfx === "") {
                        esfx = _suffixMap[p] || bsfx;
                    }
                    if (esfx !== bsfx) {
                        hn = _convertToPixels(t, "borderLeft", bn, bsfx);
                        vn = _convertToPixels(t, "borderTop", bn, bsfx);
                        if (esfx === "%") {
                            bs = (hn / w * 100) + "%";
                            bs2 = (vn / h * 100) + "%";
                        } else if (esfx === "em") {
                            em = _convertToPixels(t, "borderLeft", 1, "em");
                            bs = (hn / em) + "em";
                            bs2 = (vn / em) + "em";
                        } else {
                            bs = hn + "px";
                            bs2 = vn + "px";
                        }
                        if (rel) {
                            es = (parseFloat(bs) + en) + esfx;
                            es2 = (parseFloat(bs2) + en) + esfx;
                        }
                    }
                    pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
                }
                return pt;
            },
            prefix: true,
            formatter: _getFormatter("0px 0px 0px 0px", false, true)
        });
        _registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
            defaultValue: "0px",
            parser: function(t, e, p, cssp, pt, plugin) {
                return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
            },
            prefix: true,
            formatter: _getFormatter("0px 0px", false, true)
        });
        _registerComplexSpecialProp("backgroundPosition", {
            defaultValue: "0 0",
            parser: function(t, e, p, cssp, pt, plugin) {
                var bp = "background-position",
                    cs = (_cs || _getComputedStyle(t, null)),
                    bs = this.format(((cs) ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                    es = this.format(e),
                    ba, ea, i, pct, overlap, src;
                if ((bs.indexOf("%") !== -1) !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
                    src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
                    if (src && src !== "none") {
                        ba = bs.split(" ");
                        ea = es.split(" ");
                        _tempImg.setAttribute("src", src);
                        i = 2;
                        while (--i > -1) {
                            bs = ba[i];
                            pct = (bs.indexOf("%") !== -1);
                            if (pct !== (ea[i].indexOf("%") !== -1)) {
                                overlap = (i === 0) ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
                                ba[i] = pct ? (parseFloat(bs) / 100 * overlap) + "px" : (parseFloat(bs) / overlap * 100) + "%";
                            }
                        }
                        bs = ba.join(" ");
                    }
                }
                return this.parseComplex(t.style, bs, es, pt, plugin);
            },
            formatter: _parsePosition
        });
        _registerComplexSpecialProp("backgroundSize", {
            defaultValue: "0 0",
            formatter: function(v) {
                v += "";
                return (v.substr(0, 2) === "co") ? v : _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v);
            }
        });
        _registerComplexSpecialProp("perspective", {
            defaultValue: "0px",
            prefix: true
        });
        _registerComplexSpecialProp("perspectiveOrigin", {
            defaultValue: "50% 50%",
            prefix: true
        });
        _registerComplexSpecialProp("transformStyle", {
            prefix: true
        });
        _registerComplexSpecialProp("backfaceVisibility", {
            prefix: true
        });
        _registerComplexSpecialProp("userSelect", {
            prefix: true
        });
        _registerComplexSpecialProp("margin", {
            parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")
        });
        _registerComplexSpecialProp("padding", {
            parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")
        });
        _registerComplexSpecialProp("clip", {
            defaultValue: "rect(0px,0px,0px,0px)",
            parser: function(t, e, p, cssp, pt, plugin) {
                var b, cs, delim;
                if (_ieVers < 9) {
                    cs = t.currentStyle;
                    delim = _ieVers < 8 ? " " : ",";
                    b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
                    e = this.format(e).split(",").join(delim);
                } else {
                    b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
                    e = this.format(e);
                }
                return this.parseComplex(t.style, b, e, pt, plugin);
            }
        });
        _registerComplexSpecialProp("textShadow", {
            defaultValue: "0px 0px 0px #999",
            color: true,
            multi: true
        });
        _registerComplexSpecialProp("autoRound,strictUnits", {
            parser: function(t, e, p, cssp, pt) {
                return pt;
            }
        });
        _registerComplexSpecialProp("border", {
            defaultValue: "0px solid #000",
            parser: function(t, e, p, cssp, pt, plugin) {
                var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
                    end = this.format(e).split(" "),
                    esfx = end[0].replace(_suffixExp, "");
                if (esfx !== "px") {
                    bw = (parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx)) + esfx;
                }
                return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin);
            },
            color: true,
            formatter: function(v) {
                var a = v.split(" ");
                return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
            }
        });
        _registerComplexSpecialProp("borderWidth", {
            parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
        });
        _registerComplexSpecialProp("float,cssFloat,styleFloat", {
            parser: function(t, e, p, cssp, pt, plugin) {
                var s = t.style,
                    prop = ("cssFloat" in s) ? "cssFloat" : "styleFloat";
                return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
            }
        });
        var _setIEOpacityRatio = function(v) {
            var t = this.t,
                filters = t.filter || _getStyle(this.data, "filter") || "",
                val = (this.s + this.c * v) | 0,
                skip;
            if (val === 100) {
                if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
                    t.removeAttribute("filter");
                    skip = (!_getStyle(this.data, "filter"));
                } else {
                    t.filter = filters.replace(_alphaFilterExp, "");
                    skip = true;
                }
            }
            if (!skip) {
                if (this.xn1) {
                    t.filter = filters = filters || ("alpha(opacity=" + val + ")");
                }
                if (filters.indexOf("pacity") === -1) {
                    if (val !== 0 || !this.xn1) {
                        t.filter = filters + " alpha(opacity=" + val + ")";
                    }
                } else {
                    t.filter = filters.replace(_opacityExp, "opacity=" + val);
                }
            }
        };
        _registerComplexSpecialProp("opacity,alpha,autoAlpha", {
            defaultValue: "1",
            parser: function(t, e, p, cssp, pt, plugin) {
                var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
                    style = t.style,
                    isAutoAlpha = (p === "autoAlpha");
                if (typeof(e) === "string" && e.charAt(1) === "=") {
                    e = ((e.charAt(0) === "-") ? -1 : 1) * parseFloat(e.substr(2)) + b;
                }
                if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
                    b = 0;
                }
                if (_supportsOpacity) {
                    pt = new CSSPropTween(style, "opacity", b, e - b, pt);
                } else {
                    pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
                    pt.xn1 = isAutoAlpha ? 1 : 0;
                    style.zoom = 1;
                    pt.type = 2;
                    pt.b = "alpha(opacity=" + pt.s + ")";
                    pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
                    pt.data = t;
                    pt.plugin = plugin;
                    pt.setRatio = _setIEOpacityRatio;
                }
                if (isAutoAlpha) {
                    pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, ((b !== 0) ? "inherit" : "hidden"), ((e === 0) ? "hidden" : "inherit"));
                    pt.xs0 = "inherit";
                    cssp._overwriteProps.push(pt.n);
                    cssp._overwriteProps.push(p);
                }
                return pt;
            }
        });
        var _removeProp = function(s, p) {
                if (p) {
                    if (s.removeProperty) {
                        if (p.substr(0, 2) === "ms" || p.substr(0, 6) === "webkit") {
                            p = "-" + p;
                        }
                        s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
                    } else {
                        s.removeAttribute(p);
                    }
                }
            },
            _setClassNameRatio = function(v) {
                this.t._gsClassPT = this;
                if (v === 1 || v === 0) {
                    this.t.setAttribute("class", (v === 0) ? this.b : this.e);
                    var mpt = this.data,
                        s = this.t.style;
                    while (mpt) {
                        if (!mpt.v) {
                            _removeProp(s, mpt.p);
                        } else {
                            s[mpt.p] = mpt.v;
                        }
                        mpt = mpt._next;
                    }
                    if (v === 1 && this.t._gsClassPT === this) {
                        this.t._gsClassPT = null;
                    }
                } else if (this.t.getAttribute("class") !== this.e) {
                    this.t.setAttribute("class", this.e);
                }
            };
        _registerComplexSpecialProp("className", {
            parser: function(t, e, p, cssp, pt, plugin, vars) {
                var b = t.getAttribute("class") || "",
                    cssText = t.style.cssText,
                    difData, bs, cnpt, cnptLookup, mpt;
                pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
                pt.setRatio = _setClassNameRatio;
                pt.pr = -11;
                _hasPriority = true;
                pt.b = b;
                bs = _getAllStyles(t, _cs);
                cnpt = t._gsClassPT;
                if (cnpt) {
                    cnptLookup = {};
                    mpt = cnpt.data;
                    while (mpt) {
                        cnptLookup[mpt.p] = 1;
                        mpt = mpt._next;
                    }
                    cnpt.setRatio(1);
                }
                t._gsClassPT = pt;
                pt.e = (e.charAt(1) !== "=") ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ((e.charAt(0) === "+") ? " " + e.substr(2) : "");
                t.setAttribute("class", pt.e);
                difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
                t.setAttribute("class", b);
                pt.data = difData.firstMPT;
                t.style.cssText = cssText;
                pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin);
                return pt;
            }
        });
        var _setClearPropsRatio = function(v) {
            if (v === 1 || v === 0)
                if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
                    var s = this.t.style,
                        transformParse = _specialProps.transform.parse,
                        a, p, i, clearTransform, transform;
                    if (this.e === "all") {
                        s.cssText = "";
                        clearTransform = true;
                    } else {
                        a = this.e.split(" ").join("").split(",");
                        i = a.length;
                        while (--i > -1) {
                            p = a[i];
                            if (_specialProps[p]) {
                                if (_specialProps[p].parse === transformParse) {
                                    clearTransform = true;
                                } else {
                                    p = (p === "transformOrigin") ? _transformOriginProp : _specialProps[p].p;
                                }
                            }
                            _removeProp(s, p);
                        }
                    }
                    if (clearTransform) {
                        _removeProp(s, _transformProp);
                        transform = this.t._gsTransform;
                        if (transform) {
                            if (transform.svg) {
                                this.t.removeAttribute("data-svg-origin");
                                this.t.removeAttribute("transform");
                            }
                            delete this.t._gsTransform;
                        }
                    }
                }
        };
        _registerComplexSpecialProp("clearProps", {
            parser: function(t, e, p, cssp, pt) {
                pt = new CSSPropTween(t, p, 0, 0, pt, 2);
                pt.setRatio = _setClearPropsRatio;
                pt.e = e;
                pt.pr = -10;
                pt.data = cssp._tween;
                _hasPriority = true;
                return pt;
            }
        });
        p = "bezier,throwProps,physicsProps,physics2D".split(",");
        i = p.length;
        while (i--) {
            _registerPluginProp(p[i]);
        }
        p = CSSPlugin.prototype;
        p._firstPT = p._lastParsedTransform = p._transform = null;
        p._onInitTween = function(target, vars, tween, index) {
            if (!target.nodeType) {
                return false;
            }
            this._target = _target = target;
            this._tween = tween;
            this._vars = vars;
            _index = index;
            _autoRound = vars.autoRound;
            _hasPriority = false;
            _suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
            _cs = _getComputedStyle(target, "");
            _overwriteProps = this._overwriteProps;
            var style = target.style,
                v, pt, pt2, first, last, next, zIndex, tpt, threeD;
            if (_reqSafariFix)
                if (style.zIndex === "") {
                    v = _getStyle(target, "zIndex", _cs);
                    if (v === "auto" || v === "") {
                        this._addLazySet(style, "zIndex", 0);
                    }
                }
            if (typeof(vars) === "string") {
                first = style.cssText;
                v = _getAllStyles(target, _cs);
                style.cssText = first + ";" + vars;
                v = _cssDif(target, v, _getAllStyles(target)).difs;
                if (!_supportsOpacity && _opacityValExp.test(vars)) {
                    v.opacity = parseFloat(RegExp.$1);
                }
                vars = v;
                style.cssText = first;
            }
            if (vars.className) {
                this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
            } else {
                this._firstPT = pt = this.parse(target, vars, null);
            }
            if (this._transformType) {
                threeD = (this._transformType === 3);
                if (!_transformProp) {
                    style.zoom = 1;
                } else if (_isSafari) {
                    _reqSafariFix = true;
                    if (style.zIndex === "") {
                        zIndex = _getStyle(target, "zIndex", _cs);
                        if (zIndex === "auto" || zIndex === "") {
                            this._addLazySet(style, "zIndex", 0);
                        }
                    }
                    if (_isSafariLT6) {
                        this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
                    }
                }
                pt2 = pt;
                while (pt2 && pt2._next) {
                    pt2 = pt2._next;
                }
                tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
                this._linkCSSP(tpt, null, pt2);
                tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
                tpt.data = this._transform || _getTransform(target, _cs, true);
                tpt.tween = tween;
                tpt.pr = -1;
                _overwriteProps.pop();
            }
            if (_hasPriority) {
                while (pt) {
                    next = pt._next;
                    pt2 = first;
                    while (pt2 && pt2.pr > pt.pr) {
                        pt2 = pt2._next;
                    }
                    if ((pt._prev = pt2 ? pt2._prev : last)) {
                        pt._prev._next = pt;
                    } else {
                        first = pt;
                    }
                    if ((pt._next = pt2)) {
                        pt2._prev = pt;
                    } else {
                        last = pt;
                    }
                    pt = next;
                }
                this._firstPT = first;
            }
            return true;
        };
        p.parse = function(target, vars, pt, plugin) {
            var style = target.style,
                p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
            for (p in vars) {
                es = vars[p];
                if (typeof(es) === "function") {
                    es = es(_index, _target);
                }
                sp = _specialProps[p];
                if (sp) {
                    pt = sp.parse(target, es, p, this, pt, plugin, vars);
                } else if (p.substr(0, 2) === "--") {
                    this._tween._propLookup[p] = this._addTween.call(this._tween, target.style, "setProperty", _getComputedStyle(target).getPropertyValue(p) + "", es + "", p, false, p);
                    continue;
                } else {
                    bs = _getStyle(target, p, _cs) + "";
                    isStr = (typeof(es) === "string");
                    if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || (isStr && _rgbhslExp.test(es))) {
                        if (!isStr) {
                            es = _parseColor(es);
                            es = ((es.length > 3) ? "rgba(" : "rgb(") + es.join(",") + ")";
                        }
                        pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);
                    } else if (isStr && _complexExp.test(es)) {
                        pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);
                    } else {
                        bn = parseFloat(bs);
                        bsfx = (bn || bn === 0) ? bs.substr((bn + "").length) : "";
                        if (bs === "" || bs === "auto") {
                            if (p === "width" || p === "height") {
                                bn = _getDimension(target, p, _cs);
                                bsfx = "px";
                            } else if (p === "left" || p === "top") {
                                bn = _calculateOffset(target, p, _cs);
                                bsfx = "px";
                            } else {
                                bn = (p !== "opacity") ? 0 : 1;
                                bsfx = "";
                            }
                        }
                        rel = (isStr && es.charAt(1) === "=");
                        if (rel) {
                            en = parseInt(es.charAt(0) + "1", 10);
                            es = es.substr(2);
                            en *= parseFloat(es);
                            esfx = es.replace(_suffixExp, "");
                        } else {
                            en = parseFloat(es);
                            esfx = isStr ? es.replace(_suffixExp, "") : "";
                        }
                        if (esfx === "") {
                            esfx = (p in _suffixMap) ? _suffixMap[p] : bsfx;
                        }
                        es = (en || en === 0) ? (rel ? en + bn : en) + esfx : vars[p];
                        if (bsfx !== esfx)
                            if (esfx !== "" || p === "lineHeight")
                                if (en || en === 0)
                                    if (bn) {
                                        bn = _convertToPixels(target, p, bn, bsfx);
                                        if (esfx === "%") {
                                            bn /= _convertToPixels(target, p, 100, "%") / 100;
                                            if (vars.strictUnits !== true) {
                                                bs = bn + "%";
                                            }
                                        } else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
                                            bn /= _convertToPixels(target, p, 1, esfx);
                                        } else if (esfx !== "px") {
                                            en = _convertToPixels(target, p, en, esfx);
                                            esfx = "px";
                                        }
                                        if (rel)
                                            if (en || en === 0) {
                                                es = (en + bn) + esfx;
                                            }
                                    }
                        if (rel) {
                            en += bn;
                        }
                        if ((bn || bn === 0) && (en || en === 0)) {
                            pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, (_autoRound !== false && (esfx === "px" || p === "zIndex")), 0, bs, es);
                            pt.xs0 = esfx;
                        } else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
                            _log("invalid " + p + " tween value: " + vars[p]);
                        } else {
                            pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
                            pt.xs0 = (es === "none" && (p === "display" || p.indexOf("Style") !== -1)) ? bs : es;
                        }
                    }
                }
                if (plugin)
                    if (pt && !pt.plugin) {
                        pt.plugin = plugin;
                    }
            }
            return pt;
        };
        p.setRatio = function(v) {
            var pt = this._firstPT,
                min = 0.000001,
                val, str, i;
            if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
                while (pt) {
                    if (pt.type !== 2) {
                        if (pt.r && pt.type !== -1) {
                            val = pt.r(pt.s + pt.c);
                            if (!pt.type) {
                                pt.t[pt.p] = val + pt.xs0;
                            } else if (pt.type === 1) {
                                i = pt.l;
                                str = pt.xs0 + val + pt.xs1;
                                for (i = 1; i < pt.l; i++) {
                                    str += pt["xn" + i] + pt["xs" + (i + 1)];
                                }
                                pt.t[pt.p] = str;
                            }
                        } else {
                            pt.t[pt.p] = pt.e;
                        }
                    } else {
                        pt.setRatio(v);
                    }
                    pt = pt._next;
                }
            } else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
                while (pt) {
                    val = pt.c * v + pt.s;
                    if (pt.r) {
                        val = pt.r(val);
                    } else if (val < min)
                        if (val > -min) {
                            val = 0;
                        }
                    if (!pt.type) {
                        pt.t[pt.p] = val + pt.xs0;
                    } else if (pt.type === 1) {
                        i = pt.l;
                        if (i === 2) {
                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
                        } else if (i === 3) {
                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
                        } else if (i === 4) {
                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
                        } else if (i === 5) {
                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
                        } else {
                            str = pt.xs0 + val + pt.xs1;
                            for (i = 1; i < pt.l; i++) {
                                str += pt["xn" + i] + pt["xs" + (i + 1)];
                            }
                            pt.t[pt.p] = str;
                        }
                    } else if (pt.type === -1) {
                        pt.t[pt.p] = pt.xs0;
                    } else if (pt.setRatio) {
                        pt.setRatio(v);
                    }
                    pt = pt._next;
                }
            } else {
                while (pt) {
                    if (pt.type !== 2) {
                        pt.t[pt.p] = pt.b;
                    } else {
                        pt.setRatio(v);
                    }
                    pt = pt._next;
                }
            }
        };
        p._enableTransforms = function(threeD) {
            this._transform = this._transform || _getTransform(this._target, _cs, true);
            this._transformType = (!(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3)) ? 3 : 2;
        };
        var lazySet = function(v) {
            this.t[this.p] = this.e;
            this.data._linkCSSP(this, this._next, null, true);
        };
        p._addLazySet = function(t, p, v) {
            var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
            pt.e = v;
            pt.setRatio = lazySet;
            pt.data = this;
        };
        p._linkCSSP = function(pt, next, prev, remove) {
            if (pt) {
                if (next) {
                    next._prev = pt;
                }
                if (pt._next) {
                    pt._next._prev = pt._prev;
                }
                if (pt._prev) {
                    pt._prev._next = pt._next;
                } else if (this._firstPT === pt) {
                    this._firstPT = pt._next;
                    remove = true;
                }
                if (prev) {
                    prev._next = pt;
                } else if (!remove && this._firstPT === null) {
                    this._firstPT = pt;
                }
                pt._next = next;
                pt._prev = prev;
            }
            return pt;
        };
        p._mod = function(lookup) {
            var pt = this._firstPT;
            while (pt) {
                if (typeof(lookup[pt.p]) === "function") {
                    pt.r = lookup[pt.p];
                }
                pt = pt._next;
            }
        };
        p._kill = function(lookup) {
            var copy = lookup,
                pt, p, xfirst;
            if (lookup.autoAlpha || lookup.alpha) {
                copy = {};
                for (p in lookup) {
                    copy[p] = lookup[p];
                }
                copy.opacity = 1;
                if (copy.autoAlpha) {
                    copy.visibility = 1;
                }
            }
            if (lookup.className && (pt = this._classNamePT)) {
                xfirst = pt.xfirst;
                if (xfirst && xfirst._prev) {
                    this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev);
                } else if (xfirst === this._firstPT) {
                    this._firstPT = pt._next;
                }
                if (pt._next) {
                    this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
                }
                this._classNamePT = null;
            }
            pt = this._firstPT;
            while (pt) {
                if (pt.plugin && pt.plugin !== p && pt.plugin._kill) {
                    pt.plugin._kill(lookup);
                    p = pt.plugin;
                }
                pt = pt._next;
            }
            return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["TweenPlugin"].prototype._kill.call(this, copy);
        };
        var _getChildStyles = function(e, props, targets) {
            var children, i, child, type;
            if (e.slice) {
                i = e.length;
                while (--i > -1) {
                    _getChildStyles(e[i], props, targets);
                }
                return;
            }
            children = e.childNodes;
            i = children.length;
            while (--i > -1) {
                child = children[i];
                type = child.type;
                if (child.style) {
                    props.push(_getAllStyles(child));
                    if (targets) {
                        targets.push(child);
                    }
                }
                if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
                    _getChildStyles(child, props, targets);
                }
            }
        };
        CSSPlugin.cascadeTo = function(target, duration, vars) {
            var tween = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].to(target, duration, vars),
                results = [tween],
                b = [],
                e = [],
                targets = [],
                _reservedProps = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"]._internals.reservedProps,
                i, difs, p, from;
            target = tween._targets || tween.target;
            _getChildStyles(target, b, targets);
            tween.render(duration, true, true);
            _getChildStyles(target, e);
            tween.render(0, true, true);
            tween._enabled(true);
            i = targets.length;
            while (--i > -1) {
                difs = _cssDif(targets[i], b[i], e[i]);
                if (difs.firstMPT) {
                    difs = difs.difs;
                    for (p in vars) {
                        if (_reservedProps[p]) {
                            difs[p] = vars[p];
                        }
                    }
                    from = {};
                    for (p in difs) {
                        from[p] = b[i][p];
                    }
                    results.push(__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].fromTo(targets[i], duration, from, difs));
                }
            }
            return results;
        };
        __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["TweenPlugin"].activate([CSSPlugin]);
        return CSSPlugin;
    }, true);
    const CSSPlugin = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].CSSPlugin;
    __webpack_exports__["CSSPlugin"] = CSSPlugin;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var TOUCH_EVENT = exports.TOUCH_EVENT = "ontouchstart" in window ? "touchend" : "click";
    var BUFFA_EASE_CURVE = exports.BUFFA_EASE_CURVE = "M0,0 C0,0 -0.018,0 0,0 0.396,0 0.407,0.142 0.5,0.5 0.574,0.806 0.6,1 1,1 1.029,1 1,1 1,1";
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _utils = __webpack_require__(2);
    var _gsap = __webpack_require__(0);
    __webpack_require__(55);

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var BuffaCursor = function() {
        function BuffaCursor() {
            _classCallCheck(this, BuffaCursor);
            this.target = (0, _utils.qs)(".cursor");
            this.coords = {};
            this.path = (0, _utils.qs)(".cursor__path", this.target);
            this.shapes = {
                octagon: "M25,7.5411961 L12.6547614,12.6547614 L7.5411961,25 L12.6547614,37.3452386 L25,42.4588039 L37.3452386,37.3452386 L42.4588039,25 L37.3452386,12.6547614 L25,7.5411961 Z",
                octagonWide: "M25,3.5411961 L9.82633425,9.82633425 L3.5411961,25 L9.82633425,40.1736658 L25,46.4588039 L40.1736658,40.1736658 L46.4588039,25 L40.1736658,9.82633425 L25,3.5411961 Z",
                circle: "M0,25a25,25 0 1,0 50,0a25,25 0 1,0 -50,0"
            };
            this.state = "octagon";
            this.canAnimate = true;
            this.targetMiddle = {
                x: this.target.clientWidth / 2,
                y: this.target.clientHeight / 2
            };
            this.links = [];
            this.vertices = {
                idle: [],
                hover: [],
                current: []
            };
            this.randomVerticesIndexes = [5, 2, 4, 1, 3, 8, 7, 0, 6];
        }
        _createClass(BuffaCursor, [{
            key: "init",
            value: function init() {
                var _this = this;
                (0, _utils.handleEvent)("mousemove", {
                    onElement: window,
                    withCallback: function withCallback(e) {
                        _gsap.TweenMax.to(_this.target, 0.8, {
                            x: e.x - _this.targetMiddle.x,
                            y: e.y - _this.targetMiddle.y,
                            scale: 1
                        });
                        _this.coords = {
                            x: e.x,
                            y: e.y
                        };
                    }
                });
                this.populatePointsArrays();
            }
        }, {
            key: "populatePointsArrays",
            value: function populatePointsArrays() {
                var _this2 = this;
                var states = ["idle", "current"];
                states.forEach(function(state) {
                    _this2.shapes.octagon.split(" ").slice(0, -1).forEach(function(p) {
                        var point = p.split(",");
                        _this2.vertices[state].push({
                            x: point[0].replace(/[^\d.-]/g, ""),
                            y: point[1].replace(/[^\d.-]/g, "")
                        });
                    });
                });
                this.shapes.octagonWide.split(" ").slice(0, -1).forEach(function(p) {
                    var point = p.split(",");
                    _this2.vertices.hover.push({
                        x: point[0].replace(/[^\d.-]/g, ""),
                        y: point[1].replace(/[^\d.-]/g, "")
                    });
                });
            }
        }, {
            key: "hoverIn",
            value: function hoverIn(e) {
                if (this.state === "octagon") this.animateOctagon("hover");
                if (e.currentTarget.classList.contains("work__inner") && this.state === "circle") {
                    this.target.classList.remove("cursor--drag");
                    this.target.classList.add("cursor--go");
                }
            }
        }, {
            key: "hoverOut",
            value: function hoverOut(e) {
                if (this.state === "octagon") this.animateOctagon("idle");
                if (e.currentTarget.classList.contains("work__inner") && this.state === "circle") {
                    this.target.classList.add("cursor--drag");
                    this.target.classList.remove("cursor--go");
                }
            }
        }, {
            key: "animateOctagon",
            value: function animateOctagon(state) {
                var _this3 = this;
                if (!this.canAnimate) return;
                var tl = new _gsap.TimelineMax({
                    onUpdate: function onUpdate(_) {
                        var vertices = _this3.vertices.current;
                        _gsap.TweenMax.set(_this3.path, {
                            attr: {
                                d: "M" + vertices[0].x + "," + vertices[0].y + "\n                L" + vertices[1].x + "," + vertices[1].y + "\n                L" + vertices[2].x + "," + vertices[2].y + "\n                L" + vertices[3].x + "," + vertices[3].y + "\n                L" + vertices[4].x + "," + vertices[4].y + "\n                L" + vertices[5].x + "," + vertices[5].y + "\n                L" + vertices[6].x + "," + vertices[6].y + "\n                L" + vertices[7].x + "," + vertices[7].y + "\n                L" + vertices[8].x + "," + vertices[0].y + " Z"
                            }
                        });
                    }
                });
                var staggerTime = 0.03;
                var iterations = 0;
                tl.add("start").to(this.path, 0.7, {
                    "stroke-opacity": function strokeOpacity(_) {
                        return state === "hover" ? 0.6 : 1;
                    }
                }, "start");
                this.randomVerticesIndexes.forEach(function(index) {
                    tl.to(_this3.vertices.current[index], 0.18, {
                        x: function x(_) {
                            return _this3.vertices[state][index].x;
                        },
                        y: function y(_) {
                            return _this3.vertices[state][index].y;
                        }
                    }, "start+=" + staggerTime * iterations);
                    iterations++;
                });
            }
        }, {
            key: "morph",
            value: function morph(shape) {
                var _this4 = this;
                var tl = new _gsap.TimelineMax({
                    onStart: function onStart(_) {
                        if (shape === "circle") {
                            _this4.target.classList.add("blend");
                            _this4.target.classList.add("cursor--drag");
                        } else if (shape === "octagon") {
                            _this4.target.classList.remove("blend");
                            _this4.target.classList.remove("cursor--drag");
                            _this4.target.classList.remove("cursor--go");
                        }
                        _this4.state = shape;
                    }
                });
                var morphMap = [];
                morphMap["octagon"] = function(_) {
                    tl.add("start").to(_this4.path, 0.3, {
                        morphSVG: _this4.shapes.octagon,
                        fillOpacity: 0,
                        strokeOpacity: 1
                    }, "start");
                };
                morphMap["circle"] = function(_) {
                    tl.add("start").to(_this4.path, 0.6, {
                        morphSVG: _this4.shapes.circle,
                        fillOpacity: 1,
                        strokeOpacity: 0
                    }, "start");
                };
                eval(morphMap[shape]());
            }
        }, {
            key: "addHoverEvents",
            value: function addHoverEvents() {
                var _this5 = this;
                this.links = (0, _utils.qsa)("a, .hamburger, .tooltip__text");
                this.links.forEach(function(link) {
                    (0, _utils.handleEvent)("mouseenter", {
                        onElement: link,
                        withCallback: function withCallback(e) {
                            return _this5.hoverIn(e);
                        }
                    });
                    (0, _utils.handleEvent)("mouseleave", {
                        onElement: link,
                        withCallback: function withCallback(e) {
                            return _this5.hoverOut(e);
                        }
                    });
                });
            }
        }, {
            key: "removeHoverEvents",
            value: function removeHoverEvents() {
                this.links.forEach(function(link) {
                    var oldElem = link;
                    var newElem = oldElem.cloneNode(oldElem);
                    oldElem.parentNode.replaceChild(newElem, oldElem);
                });
            }
        }]);
        return BuffaCursor;
    }();
    var buffaCursor = new BuffaCursor();
    exports.default = buffaCursor;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _events = __webpack_require__(5);
    var _events2 = _interopRequireDefault(_events);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var delta = 0.6;
    var Viewport = function() {
        function Viewport() {
            _classCallCheck(this, Viewport);
            this.width = Viewport.calculateWidth();
            this.height = Viewport.calculateHeight();
            this.canvasWidth = this.width * delta;
            this.canvasHeight = this.height * delta;
            this.ratio = this.width / this.height;
            this.bind();
        }
        _createClass(Viewport, [{
            key: 'bind',
            value: function bind() {
                this.onResize = this.onResize.bind(this);
                window.addEventListener('resize', this.onResize);
            }
        }, {
            key: 'onResize',
            value: function onResize() {
                this.width = Viewport.calculateWidth();
                this.height = Viewport.calculateHeight();
                this.canvasWidth = this.width * delta;
                this.canvasHeight = this.height * delta;
                this.ratio = this.width / this.height;
                _events2.default.emit(_events2.default.RESIZE, this.width, this.height, this.ratio);
            }
        }], [{
            key: 'calculateWidth',
            value: function calculateWidth() {
                return window.innerWidth;
            }
        }, {
            key: 'calculateHeight',
            value: function calculateHeight() {
                return window.innerHeight;
            }
        }]);
        return Viewport;
    }();
    exports.default = new Viewport();
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return TimelineLite;
    });
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    /*!
     * VERSION: 2.0.1
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     */
    __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function() {
        var TimelineLite = function(vars) {
                __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["SimpleTimeline"].call(this, vars);
                this._labels = {};
                this.autoRemoveChildren = (this.vars.autoRemoveChildren === true);
                this.smoothChildTiming = (this.vars.smoothChildTiming === true);
                this._sortChildren = true;
                this._onUpdate = this.vars.onUpdate;
                var v = this.vars,
                    val, p;
                for (p in v) {
                    val = v[p];
                    if (_isArray(val))
                        if (val.join("").indexOf("{self}") !== -1) {
                            v[p] = this._swapSelfInParams(val);
                        }
                }
                if (_isArray(v.tweens)) {
                    this.add(v.tweens, 0, v.align, v.stagger);
                }
            },
            _tinyNum = 0.0000000001,
            TweenLiteInternals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"]._internals,
            _internals = TimelineLite._internals = {},
            _isSelector = TweenLiteInternals.isSelector,
            _isArray = TweenLiteInternals.isArray,
            _lazyTweens = TweenLiteInternals.lazyTweens,
            _lazyRender = TweenLiteInternals.lazyRender,
            _globals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine.globals,
            _copy = function(vars) {
                var copy = {},
                    p;
                for (p in vars) {
                    copy[p] = vars[p];
                }
                return copy;
            },
            _applyCycle = function(vars, targets, i) {
                var alt = vars.cycle,
                    p, val;
                for (p in alt) {
                    val = alt[p];
                    vars[p] = (typeof(val) === "function") ? val(i, targets[i]) : val[i % val.length];
                }
                delete vars.cycle;
            },
            _pauseCallback = _internals.pauseCallback = function() {},
            _slice = function(a) {
                var b = [],
                    l = a.length,
                    i;
                for (i = 0; i !== l; b.push(a[i++]));
                return b;
            },
            p = TimelineLite.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["SimpleTimeline"]();
        TimelineLite.version = "2.0.1";
        p.constructor = TimelineLite;
        p.kill()._gc = p._forcingPlayhead = p._hasPause = false;
        p.to = function(target, duration, vars, position) {
            var Engine = (vars.repeat && _globals.TweenMax) || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"];
            return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
        };
        p.from = function(target, duration, vars, position) {
            return this.add(((vars.repeat && _globals.TweenMax) || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"]).from(target, duration, vars), position);
        };
        p.fromTo = function(target, duration, fromVars, toVars, position) {
            var Engine = (toVars.repeat && _globals.TweenMax) || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"];
            return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
        };
        p.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            var tl = new TimelineLite({
                    onComplete: onCompleteAll,
                    onCompleteParams: onCompleteAllParams,
                    callbackScope: onCompleteAllScope,
                    smoothChildTiming: this.smoothChildTiming
                }),
                cycle = vars.cycle,
                copy, i;
            if (typeof(targets) === "string") {
                targets = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].selector(targets) || targets;
            }
            targets = targets || [];
            if (_isSelector(targets)) {
                targets = _slice(targets);
            }
            stagger = stagger || 0;
            if (stagger < 0) {
                targets = _slice(targets);
                targets.reverse();
                stagger *= -1;
            }
            for (i = 0; i < targets.length; i++) {
                copy = _copy(vars);
                if (copy.startAt) {
                    copy.startAt = _copy(copy.startAt);
                    if (copy.startAt.cycle) {
                        _applyCycle(copy.startAt, targets, i);
                    }
                }
                if (cycle) {
                    _applyCycle(copy, targets, i);
                    if (copy.duration != null) {
                        duration = copy.duration;
                        delete copy.duration;
                    }
                }
                tl.to(targets[i], duration, copy, i * stagger);
            }
            return this.add(tl, position);
        };
        p.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            vars.immediateRender = (vars.immediateRender != false);
            vars.runBackwards = true;
            return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        };
        p.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            toVars.startAt = fromVars;
            toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
            return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        };
        p.call = function(callback, params, scope, position) {
            return this.add(__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].delayedCall(0, callback, params, scope), position);
        };
        p.set = function(target, vars, position) {
            position = this._parseTimeOrLabel(position, 0, true);
            if (vars.immediateRender == null) {
                vars.immediateRender = (position === this._time && !this._paused);
            }
            return this.add(new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"](target, 0, vars), position);
        };
        TimelineLite.exportRoot = function(vars, ignoreDelayedCalls) {
            vars = vars || {};
            if (vars.smoothChildTiming == null) {
                vars.smoothChildTiming = true;
            }
            var tl = new TimelineLite(vars),
                root = tl._timeline,
                hasNegativeStart, time, tween, next;
            if (ignoreDelayedCalls == null) {
                ignoreDelayedCalls = true;
            }
            root._remove(tl, true);
            tl._startTime = 0;
            tl._rawPrevTime = tl._time = tl._totalTime = root._time;
            tween = root._first;
            while (tween) {
                next = tween._next;
                if (!ignoreDelayedCalls || !(tween instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"] && tween.target === tween.vars.onComplete)) {
                    time = tween._startTime - tween._delay;
                    if (time < 0) {
                        hasNegativeStart = 1;
                    }
                    tl.add(tween, time);
                }
                tween = next;
            }
            root.add(tl, 0);
            if (hasNegativeStart) {
                tl.totalDuration();
            }
            return tl;
        };
        p.add = function(value, position, align, stagger) {
            var curTime, l, i, child, tl, beforeRawTime;
            if (typeof(position) !== "number") {
                position = this._parseTimeOrLabel(position, 0, true, value);
            }
            if (!(value instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"])) {
                if ((value instanceof Array) || (value && value.push && _isArray(value))) {
                    align = align || "normal";
                    stagger = stagger || 0;
                    curTime = position;
                    l = value.length;
                    for (i = 0; i < l; i++) {
                        if (_isArray(child = value[i])) {
                            child = new TimelineLite({
                                tweens: child
                            });
                        }
                        this.add(child, curTime);
                        if (typeof(child) !== "string" && typeof(child) !== "function") {
                            if (align === "sequence") {
                                curTime = child._startTime + (child.totalDuration() / child._timeScale);
                            } else if (align === "start") {
                                child._startTime -= child.delay();
                            }
                        }
                        curTime += stagger;
                    }
                    return this._uncache(true);
                } else if (typeof(value) === "string") {
                    return this.addLabel(value, position);
                } else if (typeof(value) === "function") {
                    value = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].delayedCall(0, value);
                } else {
                    throw ("Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.");
                }
            }
            __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["SimpleTimeline"].prototype.add.call(this, value, position);
            if (value._time) {
                value.render((this.rawTime() - value._startTime) * value._timeScale, false, false);
            }
            if (this._gc || this._time === this._duration)
                if (!this._paused)
                    if (this._duration < this.duration()) {
                        tl = this;
                        beforeRawTime = (tl.rawTime() > value._startTime);
                        while (tl._timeline) {
                            if (beforeRawTime && tl._timeline.smoothChildTiming) {
                                tl.totalTime(tl._totalTime, true);
                            } else if (tl._gc) {
                                tl._enabled(true, false);
                            }
                            tl = tl._timeline;
                        }
                    }
            return this;
        };
        p.remove = function(value) {
            if (value instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"]) {
                this._remove(value, false);
                var tl = value._timeline = value.vars.useFrames ? __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"]._rootFramesTimeline : __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"]._rootTimeline;
                value._startTime = (value._paused ? value._pauseTime : tl._time) - ((!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale);
                return this;
            } else if (value instanceof Array || (value && value.push && _isArray(value))) {
                var i = value.length;
                while (--i > -1) {
                    this.remove(value[i]);
                }
                return this;
            } else if (typeof(value) === "string") {
                return this.removeLabel(value);
            }
            return this.kill(null, value);
        };
        p._remove = function(tween, skipDisable) {
            __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["SimpleTimeline"].prototype._remove.call(this, tween, skipDisable);
            var last = this._last;
            if (!last) {
                this._time = this._totalTime = this._duration = this._totalDuration = 0;
            } else if (this._time > this.duration()) {
                this._time = this._duration;
                this._totalTime = this._totalDuration;
            }
            return this;
        };
        p.append = function(value, offsetOrLabel) {
            return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
        };
        p.insert = p.insertMultiple = function(value, position, align, stagger) {
            return this.add(value, position || 0, align, stagger);
        };
        p.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
            return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
        };
        p.addLabel = function(label, position) {
            this._labels[label] = this._parseTimeOrLabel(position);
            return this;
        };
        p.addPause = function(position, callback, params, scope) {
            var t = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].delayedCall(0, _pauseCallback, params, scope || this);
            t.vars.onComplete = t.vars.onReverseComplete = callback;
            t.data = "isPause";
            this._hasPause = true;
            return this.add(t, position);
        };
        p.removeLabel = function(label) {
            delete this._labels[label];
            return this;
        };
        p.getLabelTime = function(label) {
            return (this._labels[label] != null) ? this._labels[label] : -1;
        };
        p._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
            var clippedDuration, i;
            if (ignore instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"] && ignore.timeline === this) {
                this.remove(ignore);
            } else if (ignore && ((ignore instanceof Array) || (ignore.push && _isArray(ignore)))) {
                i = ignore.length;
                while (--i > -1) {
                    if (ignore[i] instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"] && ignore[i].timeline === this) {
                        this.remove(ignore[i]);
                    }
                }
            }
            clippedDuration = (typeof(timeOrLabel) === "number" && !offsetOrLabel) ? 0 : (this.duration() > 99999999999) ? this.recent().endTime(false) : this._duration;
            if (typeof(offsetOrLabel) === "string") {
                return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && this._labels[offsetOrLabel] == null) ? timeOrLabel - clippedDuration : 0, appendIfAbsent);
            }
            offsetOrLabel = offsetOrLabel || 0;
            if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
                i = timeOrLabel.indexOf("=");
                if (i === -1) {
                    if (this._labels[timeOrLabel] == null) {
                        return appendIfAbsent ? (this._labels[timeOrLabel] = clippedDuration + offsetOrLabel) : offsetOrLabel;
                    }
                    return this._labels[timeOrLabel] + offsetOrLabel;
                }
                offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
                timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : clippedDuration;
            } else if (timeOrLabel == null) {
                timeOrLabel = clippedDuration;
            }
            return Number(timeOrLabel) + offsetOrLabel;
        };
        p.seek = function(position, suppressEvents) {
            return this.totalTime((typeof(position) === "number") ? position : this._parseTimeOrLabel(position), (suppressEvents !== false));
        };
        p.stop = function() {
            return this.paused(true);
        };
        p.gotoAndPlay = function(position, suppressEvents) {
            return this.play(position, suppressEvents);
        };
        p.gotoAndStop = function(position, suppressEvents) {
            return this.pause(position, suppressEvents);
        };
        p.render = function(time, suppressEvents, force) {
            if (this._gc) {
                this._enabled(true, false);
            }
            var prevTime = this._time,
                totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
                prevStart = this._startTime,
                prevTimeScale = this._timeScale,
                prevPaused = this._paused,
                tween, isComplete, next, callback, internalForce, pauseTween, curTime;
            if (prevTime !== this._time) {
                time += this._time - prevTime;
            }
            if (time >= totalDur - 0.0000001 && time >= 0) {
                this._totalTime = this._time = totalDur;
                if (!this._reversed)
                    if (!this._hasPausedChild()) {
                        isComplete = true;
                        callback = "onComplete";
                        internalForce = !!this._timeline.autoRemoveChildren;
                        if (this._duration === 0)
                            if ((time <= 0 && time >= -0.0000001) || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum)
                                if (this._rawPrevTime !== time && this._first) {
                                    internalForce = true;
                                    if (this._rawPrevTime > _tinyNum) {
                                        callback = "onReverseComplete";
                                    }
                                }
                    }
                this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum;
                time = totalDur + 0.0001;
            } else if (time < 0.0000001) {
                this._totalTime = this._time = 0;
                if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
                    callback = "onReverseComplete";
                    isComplete = this._reversed;
                }
                if (time < 0) {
                    this._active = false;
                    if (this._timeline.autoRemoveChildren && this._reversed) {
                        internalForce = isComplete = true;
                        callback = "onReverseComplete";
                    } else if (this._rawPrevTime >= 0 && this._first) {
                        internalForce = true;
                    }
                    this._rawPrevTime = time;
                } else {
                    this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum;
                    if (time === 0 && isComplete) {
                        tween = this._first;
                        while (tween && tween._startTime === 0) {
                            if (!tween._duration) {
                                isComplete = false;
                            }
                            tween = tween._next;
                        }
                    }
                    time = 0;
                    if (!this._initted) {
                        internalForce = true;
                    }
                }
            } else {
                if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
                    if (time >= prevTime) {
                        tween = this._first;
                        while (tween && tween._startTime <= time && !pauseTween) {
                            if (!tween._duration)
                                if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
                                    pauseTween = tween;
                                }
                            tween = tween._next;
                        }
                    } else {
                        tween = this._last;
                        while (tween && tween._startTime >= time && !pauseTween) {
                            if (!tween._duration)
                                if (tween.data === "isPause" && tween._rawPrevTime > 0) {
                                    pauseTween = tween;
                                }
                            tween = tween._prev;
                        }
                    }
                    if (pauseTween) {
                        this._time = time = pauseTween._startTime;
                        this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
                    }
                }
                this._totalTime = this._time = this._rawPrevTime = time;
            }
            if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
                return;
            } else if (!this._initted) {
                this._initted = true;
            }
            if (!this._active)
                if (!this._paused && this._time !== prevTime && time > 0) {
                    this._active = true;
                }
            if (prevTime === 0)
                if (this.vars.onStart)
                    if (this._time !== 0 || !this._duration)
                        if (!suppressEvents) {
                            this._callback("onStart");
                        }
            curTime = this._time;
            if (curTime >= prevTime) {
                tween = this._first;
                while (tween) {
                    next = tween._next;
                    if (curTime !== this._time || (this._paused && !prevPaused)) {
                        break;
                    } else if (tween._active || (tween._startTime <= curTime && !tween._paused && !tween._gc)) {
                        if (pauseTween === tween) {
                            this.pause();
                        }
                        if (!tween._reversed) {
                            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
                        } else {
                            tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
                        }
                    }
                    tween = next;
                }
            } else {
                tween = this._last;
                while (tween) {
                    next = tween._prev;
                    if (curTime !== this._time || (this._paused && !prevPaused)) {
                        break;
                    } else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
                        if (pauseTween === tween) {
                            pauseTween = tween._prev;
                            while (pauseTween && pauseTween.endTime() > this._time) {
                                pauseTween.render((pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
                                pauseTween = pauseTween._prev;
                            }
                            pauseTween = null;
                            this.pause();
                        }
                        if (!tween._reversed) {
                            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
                        } else {
                            tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
                        }
                    }
                    tween = next;
                }
            }
            if (this._onUpdate)
                if (!suppressEvents) {
                    if (_lazyTweens.length) {
                        _lazyRender();
                    }
                    this._callback("onUpdate");
                }
            if (callback)
                if (!this._gc)
                    if (prevStart === this._startTime || prevTimeScale !== this._timeScale)
                        if (this._time === 0 || totalDur >= this.totalDuration()) {
                            if (isComplete) {
                                if (_lazyTweens.length) {
                                    _lazyRender();
                                }
                                if (this._timeline.autoRemoveChildren) {
                                    this._enabled(false, false);
                                }
                                this._active = false;
                            }
                            if (!suppressEvents && this.vars[callback]) {
                                this._callback(callback);
                            }
                        }
        };
        p._hasPausedChild = function() {
            var tween = this._first;
            while (tween) {
                if (tween._paused || ((tween instanceof TimelineLite) && tween._hasPausedChild())) {
                    return true;
                }
                tween = tween._next;
            }
            return false;
        };
        p.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
            ignoreBeforeTime = ignoreBeforeTime || -9999999999;
            var a = [],
                tween = this._first,
                cnt = 0;
            while (tween) {
                if (tween._startTime < ignoreBeforeTime) {} else if (tween instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"]) {
                    if (tweens !== false) {
                        a[cnt++] = tween;
                    }
                } else {
                    if (timelines !== false) {
                        a[cnt++] = tween;
                    }
                    if (nested !== false) {
                        a = a.concat(tween.getChildren(true, tweens, timelines));
                        cnt = a.length;
                    }
                }
                tween = tween._next;
            }
            return a;
        };
        p.getTweensOf = function(target, nested) {
            var disabled = this._gc,
                a = [],
                cnt = 0,
                tweens, i;
            if (disabled) {
                this._enabled(true, true);
            }
            tweens = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].getTweensOf(target);
            i = tweens.length;
            while (--i > -1) {
                if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
                    a[cnt++] = tweens[i];
                }
            }
            if (disabled) {
                this._enabled(false, true);
            }
            return a;
        };
        p.recent = function() {
            return this._recent;
        };
        p._contains = function(tween) {
            var tl = tween.timeline;
            while (tl) {
                if (tl === this) {
                    return true;
                }
                tl = tl.timeline;
            }
            return false;
        };
        p.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
            ignoreBeforeTime = ignoreBeforeTime || 0;
            var tween = this._first,
                labels = this._labels,
                p;
            while (tween) {
                if (tween._startTime >= ignoreBeforeTime) {
                    tween._startTime += amount;
                }
                tween = tween._next;
            }
            if (adjustLabels) {
                for (p in labels) {
                    if (labels[p] >= ignoreBeforeTime) {
                        labels[p] += amount;
                    }
                }
            }
            return this._uncache(true);
        };
        p._kill = function(vars, target) {
            if (!vars && !target) {
                return this._enabled(false, false);
            }
            var tweens = (!target) ? this.getChildren(true, true, false) : this.getTweensOf(target),
                i = tweens.length,
                changed = false;
            while (--i > -1) {
                if (tweens[i]._kill(vars, target)) {
                    changed = true;
                }
            }
            return changed;
        };
        p.clear = function(labels) {
            var tweens = this.getChildren(false, true, true),
                i = tweens.length;
            this._time = this._totalTime = 0;
            while (--i > -1) {
                tweens[i]._enabled(false, false);
            }
            if (labels !== false) {
                this._labels = {};
            }
            return this._uncache(true);
        };
        p.invalidate = function() {
            var tween = this._first;
            while (tween) {
                tween.invalidate();
                tween = tween._next;
            }
            return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"].prototype.invalidate.call(this);;
        };
        p._enabled = function(enabled, ignoreTimeline) {
            if (enabled === this._gc) {
                var tween = this._first;
                while (tween) {
                    tween._enabled(enabled, true);
                    tween = tween._next;
                }
            }
            return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["SimpleTimeline"].prototype._enabled.call(this, enabled, ignoreTimeline);
        };
        p.totalTime = function(time, suppressEvents, uncapped) {
            this._forcingPlayhead = true;
            var val = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"].prototype.totalTime.apply(this, arguments);
            this._forcingPlayhead = false;
            return val;
        };
        p.duration = function(value) {
            if (!arguments.length) {
                if (this._dirty) {
                    this.totalDuration();
                }
                return this._duration;
            }
            if (this.duration() !== 0 && value !== 0) {
                this.timeScale(this._duration / value);
            }
            return this;
        };
        p.totalDuration = function(value) {
            if (!arguments.length) {
                if (this._dirty) {
                    var max = 0,
                        tween = this._last,
                        prevStart = 999999999999,
                        prev, end;
                    while (tween) {
                        prev = tween._prev;
                        if (tween._dirty) {
                            tween.totalDuration();
                        }
                        if (tween._startTime > prevStart && this._sortChildren && !tween._paused && !this._calculatingDuration) {
                            this._calculatingDuration = 1;
                            this.add(tween, tween._startTime - tween._delay);
                            this._calculatingDuration = 0;
                        } else {
                            prevStart = tween._startTime;
                        }
                        if (tween._startTime < 0 && !tween._paused) {
                            max -= tween._startTime;
                            if (this._timeline.smoothChildTiming) {
                                this._startTime += tween._startTime / this._timeScale;
                                this._time -= tween._startTime;
                                this._totalTime -= tween._startTime;
                                this._rawPrevTime -= tween._startTime;
                            }
                            this.shiftChildren(-tween._startTime, false, -9999999999);
                            prevStart = 0;
                        }
                        end = tween._startTime + (tween._totalDuration / tween._timeScale);
                        if (end > max) {
                            max = end;
                        }
                        tween = prev;
                    }
                    this._duration = this._totalDuration = max;
                    this._dirty = false;
                }
                return this._totalDuration;
            }
            return (value && this.totalDuration()) ? this.timeScale(this._totalDuration / value) : this;
        };
        p.paused = function(value) {
            if (!value) {
                var tween = this._first,
                    time = this._time;
                while (tween) {
                    if (tween._startTime === time && tween.data === "isPause") {
                        tween._rawPrevTime = 0;
                    }
                    tween = tween._next;
                }
            }
            return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"].prototype.paused.apply(this, arguments);
        };
        p.usesFrames = function() {
            var tl = this._timeline;
            while (tl._timeline) {
                tl = tl._timeline;
            }
            return (tl === __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"]._rootFramesTimeline);
        };
        p.rawTime = function(wrapRepeats) {
            return (wrapRepeats && (this._paused || (this._repeat && this.time() > 0 && this.totalProgress() < 1))) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
        };
        return TimelineLite;
    }, true);
    const TimelineLite = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].TimelineLite;
}), (function(module, exports, __webpack_require__) {
    (function webpackUniversalModuleDefinition(root, factory) {
        if (true)
            module.exports = factory();
        else if (typeof define === 'function' && define.amd)
            define("Barba", [], factory);
        else if (typeof exports === 'object')
            exports["Barba"] = factory();
        else
            root["Barba"] = factory();
    })(this, function() {
        return (function(modules) {
                var installedModules = {};

                function __webpack_require__(moduleId) {
                    if (installedModules[moduleId])
                        return installedModules[moduleId].exports;
                    var module = installedModules[moduleId] = {
                        exports: {},
                        id: moduleId,
                        loaded: false
                    };
                    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                    module.loaded = true;
                    return module.exports;
                }
                __webpack_require__.m = modules;
                __webpack_require__.c = installedModules;
                __webpack_require__.p = "http://localhost:8080/dist";
                return __webpack_require__(0);
            })
            ([function(module, exports, __webpack_require__) {
                if (typeof Promise !== 'function') {
                    window.Promise = __webpack_require__(1);
                }
                var Barba = {
                    version: '1.0.0',
                    BaseTransition: __webpack_require__(4),
                    BaseView: __webpack_require__(6),
                    BaseCache: __webpack_require__(8),
                    Dispatcher: __webpack_require__(7),
                    HistoryManager: __webpack_require__(9),
                    Pjax: __webpack_require__(10),
                    Prefetch: __webpack_require__(13),
                    Utils: __webpack_require__(5)
                };
                module.exports = Barba;
            }, function(module, exports, __webpack_require__) {
                (function(setImmediate) {
                    (function(root) {
                        var setTimeoutFunc = setTimeout;

                        function noop() {}
                        var asap = (typeof setImmediate === 'function' && setImmediate) || function(fn) {
                            setTimeoutFunc(fn, 0);
                        };
                        var onUnhandledRejection = function onUnhandledRejection(err) {
                            if (typeof console !== 'undefined' && console) {
                                console.warn('Possible Unhandled Promise Rejection:', err);
                            }
                        };

                        function bind(fn, thisArg) {
                            return function() {
                                fn.apply(thisArg, arguments);
                            };
                        }

                        function Promise(fn) {
                            if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
                            if (typeof fn !== 'function') throw new TypeError('not a function');
                            this._state = 0;
                            this._handled = false;
                            this._value = undefined;
                            this._deferreds = [];
                            doResolve(fn, this);
                        }

                        function handle(self, deferred) {
                            while (self._state === 3) {
                                self = self._value;
                            }
                            if (self._state === 0) {
                                self._deferreds.push(deferred);
                                return;
                            }
                            self._handled = true;
                            asap(function() {
                                var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
                                if (cb === null) {
                                    (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
                                    return;
                                }
                                var ret;
                                try {
                                    ret = cb(self._value);
                                } catch (e) {
                                    reject(deferred.promise, e);
                                    return;
                                }
                                resolve(deferred.promise, ret);
                            });
                        }

                        function resolve(self, newValue) {
                            try {
                                if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
                                if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
                                    var then = newValue.then;
                                    if (newValue instanceof Promise) {
                                        self._state = 3;
                                        self._value = newValue;
                                        finale(self);
                                        return;
                                    } else if (typeof then === 'function') {
                                        doResolve(bind(then, newValue), self);
                                        return;
                                    }
                                }
                                self._state = 1;
                                self._value = newValue;
                                finale(self);
                            } catch (e) {
                                reject(self, e);
                            }
                        }

                        function reject(self, newValue) {
                            self._state = 2;
                            self._value = newValue;
                            finale(self);
                        }

                        function finale(self) {
                            if (self._state === 2 && self._deferreds.length === 0) {
                                asap(function() {
                                    if (!self._handled) {
                                        onUnhandledRejection(self._value);
                                    }
                                });
                            }
                            for (var i = 0, len = self._deferreds.length; i < len; i++) {
                                handle(self, self._deferreds[i]);
                            }
                            self._deferreds = null;
                        }

                        function Handler(onFulfilled, onRejected, promise) {
                            this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
                            this.onRejected = typeof onRejected === 'function' ? onRejected : null;
                            this.promise = promise;
                        }

                        function doResolve(fn, self) {
                            var done = false;
                            try {
                                fn(function(value) {
                                    if (done) return;
                                    done = true;
                                    resolve(self, value);
                                }, function(reason) {
                                    if (done) return;
                                    done = true;
                                    reject(self, reason);
                                });
                            } catch (ex) {
                                if (done) return;
                                done = true;
                                reject(self, ex);
                            }
                        }
                        Promise.prototype['catch'] = function(onRejected) {
                            return this.then(null, onRejected);
                        };
                        Promise.prototype.then = function(onFulfilled, onRejected) {
                            var prom = new(this.constructor)(noop);
                            handle(this, new Handler(onFulfilled, onRejected, prom));
                            return prom;
                        };
                        Promise.all = function(arr) {
                            var args = Array.prototype.slice.call(arr);
                            return new Promise(function(resolve, reject) {
                                if (args.length === 0) return resolve([]);
                                var remaining = args.length;

                                function res(i, val) {
                                    try {
                                        if (val && (typeof val === 'object' || typeof val === 'function')) {
                                            var then = val.then;
                                            if (typeof then === 'function') {
                                                then.call(val, function(val) {
                                                    res(i, val);
                                                }, reject);
                                                return;
                                            }
                                        }
                                        args[i] = val;
                                        if (--remaining === 0) {
                                            resolve(args);
                                        }
                                    } catch (ex) {
                                        reject(ex);
                                    }
                                }
                                for (var i = 0; i < args.length; i++) {
                                    res(i, args[i]);
                                }
                            });
                        };
                        Promise.resolve = function(value) {
                            if (value && typeof value === 'object' && value.constructor === Promise) {
                                return value;
                            }
                            return new Promise(function(resolve) {
                                resolve(value);
                            });
                        };
                        Promise.reject = function(value) {
                            return new Promise(function(resolve, reject) {
                                reject(value);
                            });
                        };
                        Promise.race = function(values) {
                            return new Promise(function(resolve, reject) {
                                for (var i = 0, len = values.length; i < len; i++) {
                                    values[i].then(resolve, reject);
                                }
                            });
                        };
                        Promise._setImmediateFn = function _setImmediateFn(fn) {
                            asap = fn;
                        };
                        Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
                            onUnhandledRejection = fn;
                        };
                        if (typeof module !== 'undefined' && module.exports) {
                            module.exports = Promise;
                        } else if (!root.Promise) {
                            root.Promise = Promise;
                        }
                    })(this);
                }.call(exports, __webpack_require__(2).setImmediate))
            }, function(module, exports, __webpack_require__) {
                (function(setImmediate, clearImmediate) {
                    var nextTick = __webpack_require__(3).nextTick;
                    var apply = Function.prototype.apply;
                    var slice = Array.prototype.slice;
                    var immediateIds = {};
                    var nextImmediateId = 0;
                    exports.setTimeout = function() {
                        return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
                    };
                    exports.setInterval = function() {
                        return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
                    };
                    exports.clearTimeout = exports.clearInterval = function(timeout) {
                        timeout.close();
                    };

                    function Timeout(id, clearFn) {
                        this._id = id;
                        this._clearFn = clearFn;
                    }
                    Timeout.prototype.unref = Timeout.prototype.ref = function() {};
                    Timeout.prototype.close = function() {
                        this._clearFn.call(window, this._id);
                    };
                    exports.enroll = function(item, msecs) {
                        clearTimeout(item._idleTimeoutId);
                        item._idleTimeout = msecs;
                    };
                    exports.unenroll = function(item) {
                        clearTimeout(item._idleTimeoutId);
                        item._idleTimeout = -1;
                    };
                    exports._unrefActive = exports.active = function(item) {
                        clearTimeout(item._idleTimeoutId);
                        var msecs = item._idleTimeout;
                        if (msecs >= 0) {
                            item._idleTimeoutId = setTimeout(function onTimeout() {
                                if (item._onTimeout)
                                    item._onTimeout();
                            }, msecs);
                        }
                    };
                    exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
                        var id = nextImmediateId++;
                        var args = arguments.length < 2 ? false : slice.call(arguments, 1);
                        immediateIds[id] = true;
                        nextTick(function onNextTick() {
                            if (immediateIds[id]) {
                                if (args) {
                                    fn.apply(null, args);
                                } else {
                                    fn.call(null);
                                }
                                exports.clearImmediate(id);
                            }
                        });
                        return id;
                    };
                    exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
                        delete immediateIds[id];
                    };
                }.call(exports, __webpack_require__(2).setImmediate, __webpack_require__(2).clearImmediate))
            }, function(module, exports) {
                var process = module.exports = {};
                var cachedSetTimeout;
                var cachedClearTimeout;
                (function() {
                    try {
                        cachedSetTimeout = setTimeout;
                    } catch (e) {
                        cachedSetTimeout = function() {
                            throw new Error('setTimeout is not defined');
                        }
                    }
                    try {
                        cachedClearTimeout = clearTimeout;
                    } catch (e) {
                        cachedClearTimeout = function() {
                            throw new Error('clearTimeout is not defined');
                        }
                    }
                }())
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;

                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }

                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = cachedSetTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while (len) {
                        currentQueue = queue;
                        queue = [];
                        while (++queueIndex < len) {
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    cachedClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for (var i = 1; i < arguments.length; i++) {
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        cachedSetTimeout(drainQueue, 0);
                    }
                };

                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = '';
                process.versions = {};

                function noop() {}
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function() {
                    return '/'
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function() {
                    return 0;
                };
            }, function(module, exports, __webpack_require__) {
                var Utils = __webpack_require__(5);
                var BaseTransition = {
                    oldContainer: undefined,
                    newContainer: undefined,
                    newContainerLoading: undefined,
                    extend: function(obj) {
                        return Utils.extend(this, obj);
                    },
                    init: function(oldContainer, newContainer) {
                        var _this = this;
                        this.oldContainer = oldContainer;
                        this._newContainerPromise = newContainer;
                        this.deferred = Utils.deferred();
                        this.newContainerReady = Utils.deferred();
                        this.newContainerLoading = this.newContainerReady.promise;
                        this.start();
                        this._newContainerPromise.then(function(newContainer) {
                            _this.newContainer = newContainer;
                            _this.newContainerReady.resolve();
                        });
                        return this.deferred.promise;
                    },
                    done: function() {
                        this.oldContainer.parentNode.removeChild(this.oldContainer);
                        this.newContainer.style.visibility = 'visible';
                        this.deferred.resolve();
                    },
                    start: function() {},
                };
                module.exports = BaseTransition;
            }, function(module, exports) {
                var Utils = {
                    getCurrentUrl: function() {
                        return window.location.protocol + '//' +
                            window.location.host +
                            window.location.pathname +
                            window.location.search;
                    },
                    cleanLink: function(url) {
                        return url.replace(/#.*/, '');
                    },
                    xhrTimeout: 5000,
                    xhr: function(url) {
                        var deferred = this.deferred();
                        var req = new XMLHttpRequest();
                        req.onreadystatechange = function() {
                            if (req.readyState === 4) {
                                if (req.status === 200) {
                                    return deferred.resolve(req.responseText);
                                } else {
                                    return deferred.reject(new Error('xhr: HTTP code is not 200'));
                                }
                            }
                        };
                        req.ontimeout = function() {
                            return deferred.reject(new Error('xhr: Timeout exceeded'));
                        };
                        req.open('GET', url);
                        req.timeout = this.xhrTimeout;
                        req.setRequestHeader('x-barba', 'yes');
                        req.send();
                        return deferred.promise;
                    },
                    extend: function(obj, props) {
                        var newObj = Object.create(obj);
                        for (var prop in props) {
                            if (props.hasOwnProperty(prop)) {
                                newObj[prop] = props[prop];
                            }
                        }
                        return newObj;
                    },
                    deferred: function() {
                        return new function() {
                            this.resolve = null;
                            this.reject = null;
                            this.promise = new Promise(function(resolve, reject) {
                                this.resolve = resolve;
                                this.reject = reject;
                            }.bind(this));
                        };
                    },
                    getPort: function(p) {
                        var port = typeof p !== 'undefined' ? p : window.location.port;
                        var protocol = window.location.protocol;
                        if (port != '')
                            return parseInt(port);
                        if (protocol === 'http:')
                            return 80;
                        if (protocol === 'https:')
                            return 443;
                    }
                };
                module.exports = Utils;
            }, function(module, exports, __webpack_require__) {
                var Dispatcher = __webpack_require__(7);
                var Utils = __webpack_require__(5);
                var BaseView = {
                    namespace: null,
                    extend: function(obj) {
                        return Utils.extend(this, obj);
                    },
                    init: function() {
                        var _this = this;
                        Dispatcher.on('initStateChange', function(newStatus, oldStatus) {
                            if (oldStatus && oldStatus.namespace === _this.namespace)
                                _this.onLeave();
                        });
                        Dispatcher.on('newPageReady', function(newStatus, oldStatus, container) {
                            _this.container = container;
                            if (newStatus.namespace === _this.namespace)
                                _this.onEnter();
                        });
                        Dispatcher.on('transitionCompleted', function(newStatus, oldStatus) {
                            if (newStatus.namespace === _this.namespace)
                                _this.onEnterCompleted();
                            if (oldStatus && oldStatus.namespace === _this.namespace)
                                _this.onLeaveCompleted();
                        });
                    },
                    onEnter: function() {},
                    onEnterCompleted: function() {},
                    onLeave: function() {},
                    onLeaveCompleted: function() {}
                }
                module.exports = BaseView;
            }, function(module, exports) {
                var Dispatcher = {
                    events: {},
                    on: function(e, f) {
                        this.events[e] = this.events[e] || [];
                        this.events[e].push(f);
                    },
                    off: function(e, f) {
                        if (e in this.events === false)
                            return;
                        this.events[e].splice(this.events[e].indexOf(f), 1);
                    },
                    trigger: function(e) {
                        if (e in this.events === false)
                            return;
                        for (var i = 0; i < this.events[e].length; i++) {
                            this.events[e][i].apply(this, Array.prototype.slice.call(arguments, 1));
                        }
                    }
                };
                module.exports = Dispatcher;
            }, function(module, exports, __webpack_require__) {
                var Utils = __webpack_require__(5);
                var BaseCache = {
                    data: {},
                    extend: function(obj) {
                        return Utils.extend(this, obj);
                    },
                    set: function(key, val) {
                        this.data[key] = val;
                    },
                    get: function(key) {
                        return this.data[key];
                    },
                    reset: function() {
                        this.data = {};
                    }
                };
                module.exports = BaseCache;
            }, function(module, exports) {
                var HistoryManager = {
                    history: [],
                    add: function(url, namespace) {
                        if (!namespace)
                            namespace = undefined;
                        this.history.push({
                            url: url,
                            namespace: namespace
                        });
                    },
                    currentStatus: function() {
                        return this.history[this.history.length - 1];
                    },
                    prevStatus: function() {
                        var history = this.history;
                        if (history.length < 2)
                            return null;
                        return history[history.length - 2];
                    }
                };
                module.exports = HistoryManager;
            }, function(module, exports, __webpack_require__) {
                var Utils = __webpack_require__(5);
                var Dispatcher = __webpack_require__(7);
                var HideShowTransition = __webpack_require__(11);
                var BaseCache = __webpack_require__(8);
                var HistoryManager = __webpack_require__(9);
                var Dom = __webpack_require__(12);
                var Pjax = {
                    Dom: Dom,
                    History: HistoryManager,
                    Cache: BaseCache,
                    cacheEnabled: true,
                    transitionProgress: false,
                    ignoreClassLink: 'no-barba',
                    start: function() {
                        this.init();
                    },
                    init: function() {
                        var container = this.Dom.getContainer();
                        var wrapper = this.Dom.getWrapper();
                        wrapper.setAttribute('aria-live', 'polite');
                        this.History.add(this.getCurrentUrl(), this.Dom.getNamespace(container));
                        Dispatcher.trigger('initStateChange', this.History.currentStatus());
                        Dispatcher.trigger('newPageReady', this.History.currentStatus(), {}, container, this.Dom.currentHTML);
                        Dispatcher.trigger('transitionCompleted', this.History.currentStatus());
                        this.bindEvents();
                    },
                    bindEvents: function() {
                        document.addEventListener('click', this.onLinkClick.bind(this));
                        window.addEventListener('popstate', this.onStateChange.bind(this));
                    },
                    getCurrentUrl: function() {
                        return Utils.cleanLink(Utils.getCurrentUrl());
                    },
                    goTo: function(url) {
                        window.history.pushState(null, null, url);
                        this.onStateChange();
                    },
                    forceGoTo: function(url) {
                        window.location = url;
                    },
                    load: function(url) {
                        var deferred = Utils.deferred();
                        var _this = this;
                        var xhr;
                        xhr = this.Cache.get(url);
                        if (!xhr) {
                            xhr = Utils.xhr(url);
                            this.Cache.set(url, xhr);
                        }
                        xhr.then(function(data) {
                            var container = _this.Dom.parseResponse(data);
                            _this.Dom.putContainer(container);
                            if (!_this.cacheEnabled)
                                _this.Cache.reset();
                            deferred.resolve(container);
                        }, function() {
                            _this.forceGoTo(url);
                            deferred.reject();
                        });
                        return deferred.promise;
                    },
                    getHref: function(el) {
                        if (!el) {
                            return undefined;
                        }
                        if (el.getAttribute && typeof el.getAttribute('xlink:href') === 'string') {
                            return el.getAttribute('xlink:href');
                        }
                        if (typeof el.href === 'string') {
                            return el.href;
                        }
                        return undefined;
                    },
                    onLinkClick: function(evt) {
                        var el = evt.target;
                        while (el && !this.getHref(el)) {
                            el = el.parentNode;
                        }
                        if (this.preventCheck(evt, el)) {
                            evt.stopPropagation();
                            evt.preventDefault();
                            Dispatcher.trigger('linkClicked', el, evt);
                            var href = this.getHref(el);
                            this.goTo(href);
                        }
                    },
                    preventCheck: function(evt, element) {
                        if (!window.history.pushState)
                            return false;
                        var href = this.getHref(element);
                        if (!element || !href)
                            return false;
                        if (evt.which > 1 || evt.metaKey || evt.ctrlKey || evt.shiftKey || evt.altKey)
                            return false;
                        if (element.target && element.target === '_blank')
                            return false;
                        if (window.location.protocol !== element.protocol || window.location.hostname !== element.hostname)
                            return false;
                        if (Utils.getPort() !== Utils.getPort(element.port))
                            return false;
                        if (href.indexOf('#') > -1)
                            return false;
                        if (element.getAttribute && typeof element.getAttribute('download') === 'string')
                            return false;
                        if (Utils.cleanLink(href) == Utils.cleanLink(location.href))
                            return false;
                        if (element.classList.contains(this.ignoreClassLink))
                            return false;
                        return true;
                    },
                    getTransition: function() {
                        return HideShowTransition;
                    },
                    onStateChange: function() {
                        var newUrl = this.getCurrentUrl();
                        if (this.transitionProgress)
                            this.forceGoTo(newUrl);
                        if (this.History.currentStatus().url === newUrl)
                            return false;
                        this.History.add(newUrl);
                        var newContainer = this.load(newUrl);
                        var transition = Object.create(this.getTransition());
                        this.transitionProgress = true;
                        Dispatcher.trigger('initStateChange', this.History.currentStatus(), this.History.prevStatus());
                        var transitionInstance = transition.init(this.Dom.getContainer(), newContainer);
                        newContainer.then(this.onNewContainerLoaded.bind(this));
                        transitionInstance.then(this.onTransitionEnd.bind(this));
                    },
                    onNewContainerLoaded: function(container) {
                        var currentStatus = this.History.currentStatus();
                        currentStatus.namespace = this.Dom.getNamespace(container);
                        Dispatcher.trigger('newPageReady', this.History.currentStatus(), this.History.prevStatus(), container, this.Dom.currentHTML);
                    },
                    onTransitionEnd: function() {
                        this.transitionProgress = false;
                        Dispatcher.trigger('transitionCompleted', this.History.currentStatus(), this.History.prevStatus());
                    }
                };
                module.exports = Pjax;
            }, function(module, exports, __webpack_require__) {
                var BaseTransition = __webpack_require__(4);
                var HideShowTransition = BaseTransition.extend({
                    start: function() {
                        this.newContainerLoading.then(this.finish.bind(this));
                    },
                    finish: function() {
                        document.body.scrollTop = 0;
                        this.done();
                    }
                });
                module.exports = HideShowTransition;
            }, function(module, exports) {
                var Dom = {
                    dataNamespace: 'namespace',
                    wrapperId: 'barba-wrapper',
                    containerClass: 'barba-container',
                    currentHTML: document.documentElement.innerHTML,
                    parseResponse: function(responseText) {
                        this.currentHTML = responseText;
                        var wrapper = document.createElement('div');
                        wrapper.innerHTML = responseText;
                        var titleEl = wrapper.querySelector('title');
                        if (titleEl)
                            document.title = titleEl.textContent;
                        return this.getContainer(wrapper);
                    },
                    getWrapper: function() {
                        var wrapper = document.getElementById(this.wrapperId);
                        if (!wrapper)
                            throw new Error('Barba.js: wrapper not found!');
                        return wrapper;
                    },
                    getContainer: function(element) {
                        if (!element)
                            element = document.body;
                        if (!element)
                            throw new Error('Barba.js: DOM not ready!');
                        var container = this.parseContainer(element);
                        if (container && container.jquery)
                            container = container[0];
                        if (!container)
                            throw new Error('Barba.js: no container found');
                        return container;
                    },
                    getNamespace: function(element) {
                        if (element && element.dataset) {
                            return element.dataset[this.dataNamespace];
                        } else if (element) {
                            return element.getAttribute('data-' + this.dataNamespace);
                        }
                        return null;
                    },
                    putContainer: function(element) {
                        element.style.visibility = 'hidden';
                        var wrapper = this.getWrapper();
                        wrapper.appendChild(element);
                    },
                    parseContainer: function(element) {
                        return element.querySelector('.' + this.containerClass);
                    }
                };
                module.exports = Dom;
            }, function(module, exports, __webpack_require__) {
                var Utils = __webpack_require__(5);
                var Pjax = __webpack_require__(10);
                var Prefetch = {
                    ignoreClassLink: 'no-barba-prefetch',
                    init: function() {
                        if (!window.history.pushState) {
                            return false;
                        }
                        document.body.addEventListener('mouseover', this.onLinkEnter.bind(this));
                        document.body.addEventListener('touchstart', this.onLinkEnter.bind(this));
                    },
                    onLinkEnter: function(evt) {
                        var el = evt.target;
                        while (el && !Pjax.getHref(el)) {
                            el = el.parentNode;
                        }
                        if (!el || el.classList.contains(this.ignoreClassLink)) {
                            return;
                        }
                        var url = Pjax.getHref(el);
                        if (Pjax.preventCheck(evt, el) && !Pjax.Cache.get(url)) {
                            var xhr = Utils.xhr(url);
                            Pjax.Cache.set(url, xhr);
                        }
                    }
                };
                module.exports = Prefetch;
            }])
    });;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.animateBg = undefined;
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _three = __webpack_require__(4);
    var _events = __webpack_require__(5);
    var _events2 = _interopRequireDefault(_events);
    var _viewport = __webpack_require__(10);
    var _viewport2 = _interopRequireDefault(_viewport);
    var _quad = __webpack_require__(30);
    var _quad2 = _interopRequireDefault(_quad);
    var _gsap = __webpack_require__(0);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Bg = function() {
        function Bg() {
            _classCallCheck(this, Bg);
            this.onResize();
            this.init();
            this.onResize();
            this.bind();
        }
        _createClass(Bg, [{
            key: 'init',
            value: function init() {
                this.scene = new _three.Scene();
                this.camera = new _three.PerspectiveCamera(70, this.ratio, 0.01, 100);
                this.camera.position.z = 1;
                this.renderer = new _three.WebGLRenderer({
                    antialias: false,
                    powerPreference: 'high-performance'
                });
                this.renderer.setPixelRatio(1);
                this.quad = new _quad2.default(this.renderer);
                this.scene.add(this.quad);
                document.body.querySelector(".page-background").appendChild(this.renderer.domElement);
                this.onUpdate = this.onUpdate.bind(this);
                this.onResize = this.onResize.bind(this);
            }
        }, {
            key: 'bind',
            value: function bind() {
                window.addEventListener('resize', this.onResize);
                _events2.default.on(_events2.default.RAF, this.onUpdate);
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                window.removeEventListener('resize', this.onResize);
                _events2.default.off(_events2.default.RAF, this.onUpdate);
            }
        }, {
            key: 'onResize',
            value: function onResize() {
                if (this.renderer) {
                    this.renderer.setSize(_viewport2.default.canvasWidth, _viewport2.default.canvasHeight);
                    this.camera.aspect = _viewport2.default.ratio;
                    this.camera.updateProjectionMatrix();
                }
            }
        }, {
            key: 'onUpdate',
            value: function onUpdate() {
                this.renderer.render(this.scene, this.camera);
            }
        }, {
            key: 'updateUniforms',
            value: function updateUniforms(property, newValue) {
                this.quad.material.uniforms[property].value = newValue;
            }
        }]);
        return Bg;
    }();
    var bg = new Bg();
    var animateBg = exports.animateBg = function animateBg(property, currValue, newValue, timing) {
        var easing = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _gsap.Power2.easeOut;
        return new Promise(function(resolve) {
            var prop = {
                value: currValue
            };
            TweenMax.to(prop, timing, {
                value: newValue,
                ease: easing,
                onUpdate: function onUpdate(_) {
                    bg.updateUniforms(property, prop.value);
                    BUFFA.background.current[property].value = prop.value;
                },
                onComplete: function onComplete(_) {
                    return resolve();
                }
            });
        });
    };
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.backgroundDefaults = undefined;
    var _three = __webpack_require__(4);
    var backgroundDefaults = exports.backgroundDefaults = {
        _colorA: {
            value: new _three.Color(0x78ffda)
        },
        _colorB: {
            value: new _three.Color(0x000000)
        },
        _sizePattern: {
            value: 13
        },
        _waterPattern: {
            value: 1
        },
        _inverse: {
            value: 0.00
        },
        _time: {
            value: 0
        },
        _noise: {
            value: 0.4
        },
        _exp: {
            value: 3.0
        },
        _brightness: {
            value: -0.7
        }
    };
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return TimelineMax;
    });
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    var __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__ = __webpack_require__(11);
    /*!
     * VERSION: 2.0.1
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     */
    __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function() {
        var TimelineMax = function(vars) {
                __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a"].call(this, vars);
                this._repeat = this.vars.repeat || 0;
                this._repeatDelay = this.vars.repeatDelay || 0;
                this._cycle = 0;
                this._yoyo = (this.vars.yoyo === true);
                this._dirty = true;
            },
            _tinyNum = 0.0000000001,
            TweenLiteInternals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"]._internals,
            _lazyTweens = TweenLiteInternals.lazyTweens,
            _lazyRender = TweenLiteInternals.lazyRender,
            _globals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine.globals,
            _easeNone = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"](null, null, 1, 0),
            p = TimelineMax.prototype = new __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a"]();
        p.constructor = TimelineMax;
        p.kill()._gc = false;
        TimelineMax.version = "2.0.1";
        p.invalidate = function() {
            this._yoyo = (this.vars.yoyo === true);
            this._repeat = this.vars.repeat || 0;
            this._repeatDelay = this.vars.repeatDelay || 0;
            this._uncache(true);
            return __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a"].prototype.invalidate.call(this);
        };
        p.addCallback = function(callback, position, params, scope) {
            return this.add(__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].delayedCall(0, callback, params, scope), position);
        };
        p.removeCallback = function(callback, position) {
            if (callback) {
                if (position == null) {
                    this._kill(null, callback);
                } else {
                    var a = this.getTweensOf(callback, false),
                        i = a.length,
                        time = this._parseTimeOrLabel(position);
                    while (--i > -1) {
                        if (a[i]._startTime === time) {
                            a[i]._enabled(false, false);
                        }
                    }
                }
            }
            return this;
        };
        p.removePause = function(position) {
            return this.removeCallback(__WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a"]._internals.pauseCallback, position);
        };
        p.tweenTo = function(position, vars) {
            vars = vars || {};
            var copy = {
                    ease: _easeNone,
                    useFrames: this.usesFrames(),
                    immediateRender: false,
                    lazy: false
                },
                Engine = (vars.repeat && _globals.TweenMax) || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"],
                duration, p, t;
            for (p in vars) {
                copy[p] = vars[p];
            }
            copy.time = this._parseTimeOrLabel(position);
            duration = (Math.abs(Number(copy.time) - this._time) / this._timeScale) || 0.001;
            t = new Engine(this, duration, copy);
            copy.onStart = function() {
                t.target.paused(true);
                if (t.vars.time !== t.target.time() && duration === t.duration() && !t.isFromTo) {
                    t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale).render(t.time(), true, true);
                }
                if (vars.onStart) {
                    vars.onStart.apply(vars.onStartScope || vars.callbackScope || t, vars.onStartParams || []);
                }
            };
            return t;
        };
        p.tweenFromTo = function(fromPosition, toPosition, vars) {
            vars = vars || {};
            fromPosition = this._parseTimeOrLabel(fromPosition);
            vars.startAt = {
                onComplete: this.seek,
                onCompleteParams: [fromPosition],
                callbackScope: this
            };
            vars.immediateRender = (vars.immediateRender !== false);
            var t = this.tweenTo(toPosition, vars);
            t.isFromTo = 1;
            return t.duration((Math.abs(t.vars.time - fromPosition) / this._timeScale) || 0.001);
        };
        p.render = function(time, suppressEvents, force) {
            if (this._gc) {
                this._enabled(true, false);
            }
            var prevTime = this._time,
                totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
                dur = this._duration,
                prevTotalTime = this._totalTime,
                prevStart = this._startTime,
                prevTimeScale = this._timeScale,
                prevRawPrevTime = this._rawPrevTime,
                prevPaused = this._paused,
                prevCycle = this._cycle,
                tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime;
            if (prevTime !== this._time) {
                time += this._time - prevTime;
            }
            if (time >= totalDur - 0.0000001 && time >= 0) {
                if (!this._locked) {
                    this._totalTime = totalDur;
                    this._cycle = this._repeat;
                }
                if (!this._reversed)
                    if (!this._hasPausedChild()) {
                        isComplete = true;
                        callback = "onComplete";
                        internalForce = !!this._timeline.autoRemoveChildren;
                        if (this._duration === 0)
                            if ((time <= 0 && time >= -0.0000001) || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum)
                                if (prevRawPrevTime !== time && this._first) {
                                    internalForce = true;
                                    if (prevRawPrevTime > _tinyNum) {
                                        callback = "onReverseComplete";
                                    }
                                }
                    }
                this._rawPrevTime = (this._duration || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum;
                if (this._yoyo && (this._cycle & 1) !== 0) {
                    this._time = time = 0;
                } else {
                    this._time = dur;
                    time = dur + 0.0001;
                }
            } else if (time < 0.0000001) {
                if (!this._locked) {
                    this._totalTime = this._cycle = 0;
                }
                this._time = 0;
                if (prevTime !== 0 || (dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || (time < 0 && prevRawPrevTime >= 0)) && !this._locked)) {
                    callback = "onReverseComplete";
                    isComplete = this._reversed;
                }
                if (time < 0) {
                    this._active = false;
                    if (this._timeline.autoRemoveChildren && this._reversed) {
                        internalForce = isComplete = true;
                        callback = "onReverseComplete";
                    } else if (prevRawPrevTime >= 0 && this._first) {
                        internalForce = true;
                    }
                    this._rawPrevTime = time;
                } else {
                    this._rawPrevTime = (dur || !suppressEvents || time || this._rawPrevTime === time) ? time : _tinyNum;
                    if (time === 0 && isComplete) {
                        tween = this._first;
                        while (tween && tween._startTime === 0) {
                            if (!tween._duration) {
                                isComplete = false;
                            }
                            tween = tween._next;
                        }
                    }
                    time = 0;
                    if (!this._initted) {
                        internalForce = true;
                    }
                }
            } else {
                if (dur === 0 && prevRawPrevTime < 0) {
                    internalForce = true;
                }
                this._time = this._rawPrevTime = time;
                if (!this._locked) {
                    this._totalTime = time;
                    if (this._repeat !== 0) {
                        cycleDuration = dur + this._repeatDelay;
                        this._cycle = (this._totalTime / cycleDuration) >> 0;
                        if (this._cycle !== 0)
                            if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
                                this._cycle--;
                            }
                        this._time = this._totalTime - (this._cycle * cycleDuration);
                        if (this._yoyo)
                            if ((this._cycle & 1) !== 0) {
                                this._time = dur - this._time;
                            }
                        if (this._time > dur) {
                            this._time = dur;
                            time = dur + 0.0001;
                        } else if (this._time < 0) {
                            this._time = time = 0;
                        } else {
                            time = this._time;
                        }
                    }
                }
                if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
                    time = this._time;
                    if (time >= prevTime || (this._repeat && prevCycle !== this._cycle)) {
                        tween = this._first;
                        while (tween && tween._startTime <= time && !pauseTween) {
                            if (!tween._duration)
                                if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
                                    pauseTween = tween;
                                }
                            tween = tween._next;
                        }
                    } else {
                        tween = this._last;
                        while (tween && tween._startTime >= time && !pauseTween) {
                            if (!tween._duration)
                                if (tween.data === "isPause" && tween._rawPrevTime > 0) {
                                    pauseTween = tween;
                                }
                            tween = tween._prev;
                        }
                    }
                    if (pauseTween && pauseTween._startTime < dur) {
                        this._time = time = pauseTween._startTime;
                        this._totalTime = time + (this._cycle * (this._totalDuration + this._repeatDelay));
                    }
                }
            }
            if (this._cycle !== prevCycle)
                if (!this._locked) {
                    var backwards = (this._yoyo && (prevCycle & 1) !== 0),
                        wrap = (backwards === (this._yoyo && (this._cycle & 1) !== 0)),
                        recTotalTime = this._totalTime,
                        recCycle = this._cycle,
                        recRawPrevTime = this._rawPrevTime,
                        recTime = this._time;
                    this._totalTime = prevCycle * dur;
                    if (this._cycle < prevCycle) {
                        backwards = !backwards;
                    } else {
                        this._totalTime += dur;
                    }
                    this._time = prevTime;
                    this._rawPrevTime = (dur === 0) ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
                    this._cycle = prevCycle;
                    this._locked = true;
                    prevTime = (backwards) ? 0 : dur;
                    this.render(prevTime, suppressEvents, (dur === 0));
                    if (!suppressEvents)
                        if (!this._gc) {
                            if (this.vars.onRepeat) {
                                this._cycle = recCycle;
                                this._locked = false;
                                this._callback("onRepeat");
                            }
                        }
                    if (prevTime !== this._time) {
                        return;
                    }
                    if (wrap) {
                        this._cycle = prevCycle;
                        this._locked = true;
                        prevTime = (backwards) ? dur + 0.0001 : -0.0001;
                        this.render(prevTime, true, false);
                    }
                    this._locked = false;
                    if (this._paused && !prevPaused) {
                        return;
                    }
                    this._time = recTime;
                    this._totalTime = recTotalTime;
                    this._cycle = recCycle;
                    this._rawPrevTime = recRawPrevTime;
                }
            if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
                if (prevTotalTime !== this._totalTime)
                    if (this._onUpdate)
                        if (!suppressEvents) {
                            this._callback("onUpdate");
                        }
                return;
            } else if (!this._initted) {
                this._initted = true;
            }
            if (!this._active)
                if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
                    this._active = true;
                }
            if (prevTotalTime === 0)
                if (this.vars.onStart)
                    if (this._totalTime !== 0 || !this._totalDuration)
                        if (!suppressEvents) {
                            this._callback("onStart");
                        }
            curTime = this._time;
            if (curTime >= prevTime) {
                tween = this._first;
                while (tween) {
                    next = tween._next;
                    if (curTime !== this._time || (this._paused && !prevPaused)) {
                        break;
                    } else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
                        if (pauseTween === tween) {
                            this.pause();
                        }
                        if (!tween._reversed) {
                            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
                        } else {
                            tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
                        }
                    }
                    tween = next;
                }
            } else {
                tween = this._last;
                while (tween) {
                    next = tween._prev;
                    if (curTime !== this._time || (this._paused && !prevPaused)) {
                        break;
                    } else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
                        if (pauseTween === tween) {
                            pauseTween = tween._prev;
                            while (pauseTween && pauseTween.endTime() > this._time) {
                                pauseTween.render((pauseTween._reversed ? pauseTween.totalDuration() - ((time - pauseTween._startTime) * pauseTween._timeScale) : (time - pauseTween._startTime) * pauseTween._timeScale), suppressEvents, force);
                                pauseTween = pauseTween._prev;
                            }
                            pauseTween = null;
                            this.pause();
                        }
                        if (!tween._reversed) {
                            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
                        } else {
                            tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
                        }
                    }
                    tween = next;
                }
            }
            if (this._onUpdate)
                if (!suppressEvents) {
                    if (_lazyTweens.length) {
                        _lazyRender();
                    }
                    this._callback("onUpdate");
                }
            if (callback)
                if (!this._locked)
                    if (!this._gc)
                        if (prevStart === this._startTime || prevTimeScale !== this._timeScale)
                            if (this._time === 0 || totalDur >= this.totalDuration()) {
                                if (isComplete) {
                                    if (_lazyTweens.length) {
                                        _lazyRender();
                                    }
                                    if (this._timeline.autoRemoveChildren) {
                                        this._enabled(false, false);
                                    }
                                    this._active = false;
                                }
                                if (!suppressEvents && this.vars[callback]) {
                                    this._callback(callback);
                                }
                            }
        };
        p.getActive = function(nested, tweens, timelines) {
            if (nested == null) {
                nested = true;
            }
            if (tweens == null) {
                tweens = true;
            }
            if (timelines == null) {
                timelines = false;
            }
            var a = [],
                all = this.getChildren(nested, tweens, timelines),
                cnt = 0,
                l = all.length,
                i, tween;
            for (i = 0; i < l; i++) {
                tween = all[i];
                if (tween.isActive()) {
                    a[cnt++] = tween;
                }
            }
            return a;
        };
        p.getLabelAfter = function(time) {
            if (!time)
                if (time !== 0) {
                    time = this._time;
                }
            var labels = this.getLabelsArray(),
                l = labels.length,
                i;
            for (i = 0; i < l; i++) {
                if (labels[i].time > time) {
                    return labels[i].name;
                }
            }
            return null;
        };
        p.getLabelBefore = function(time) {
            if (time == null) {
                time = this._time;
            }
            var labels = this.getLabelsArray(),
                i = labels.length;
            while (--i > -1) {
                if (labels[i].time < time) {
                    return labels[i].name;
                }
            }
            return null;
        };
        p.getLabelsArray = function() {
            var a = [],
                cnt = 0,
                p;
            for (p in this._labels) {
                a[cnt++] = {
                    time: this._labels[p],
                    name: p
                };
            }
            a.sort(function(a, b) {
                return a.time - b.time;
            });
            return a;
        };
        p.invalidate = function() {
            this._locked = false;
            return __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a"].prototype.invalidate.call(this);
        };
        p.progress = function(value, suppressEvents) {
            return (!arguments.length) ? (this._time / this.duration()) || 0 : this.totalTime(this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
        };
        p.totalProgress = function(value, suppressEvents) {
            return (!arguments.length) ? (this._totalTime / this.totalDuration()) || 0 : this.totalTime(this.totalDuration() * value, suppressEvents);
        };
        p.totalDuration = function(value) {
            if (!arguments.length) {
                if (this._dirty) {
                    __WEBPACK_IMPORTED_MODULE_1__TimelineLite_js__["a"].prototype.totalDuration.call(this);
                    this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
                }
                return this._totalDuration;
            }
            return (this._repeat === -1 || !value) ? this : this.timeScale(this.totalDuration() / value);
        };
        p.time = function(value, suppressEvents) {
            if (!arguments.length) {
                return this._time;
            }
            if (this._dirty) {
                this.totalDuration();
            }
            if (value > this._duration) {
                value = this._duration;
            }
            if (this._yoyo && (this._cycle & 1) !== 0) {
                value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
            } else if (this._repeat !== 0) {
                value += this._cycle * (this._duration + this._repeatDelay);
            }
            return this.totalTime(value, suppressEvents);
        };
        p.repeat = function(value) {
            if (!arguments.length) {
                return this._repeat;
            }
            this._repeat = value;
            return this._uncache(true);
        };
        p.repeatDelay = function(value) {
            if (!arguments.length) {
                return this._repeatDelay;
            }
            this._repeatDelay = value;
            return this._uncache(true);
        };
        p.yoyo = function(value) {
            if (!arguments.length) {
                return this._yoyo;
            }
            this._yoyo = value;
            return this;
        };
        p.currentLabel = function(value) {
            if (!arguments.length) {
                return this.getLabelBefore(this._time + 0.00000001);
            }
            return this.seek(value, true);
        };
        return TimelineMax;
    }, true);
    const TimelineMax = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].TimelineMax;
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return AttrPlugin;
    });
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    /*!
     * VERSION: 0.6.1
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     */
    const AttrPlugin = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine.plugin({
        propName: "attr",
        API: 2,
        version: "0.6.1",
        init: function(target, value, tween, index) {
            var p, end;
            if (typeof(target.setAttribute) !== "function") {
                return false;
            }
            for (p in value) {
                end = value[p];
                if (typeof(end) === "function") {
                    end = end(index, target);
                }
                this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, false, p);
                this._overwriteProps.push(p);
            }
            return true;
        }
    });
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return RoundPropsPlugin;
    });
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    /*!
     * VERSION: 1.6.0
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     **/
    const RoundPropsPlugin = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine.plugin({
            propName: "roundProps",
            version: "1.7.0",
            priority: -1,
            API: 2,
            init: function(target, value, tween) {
                this._tween = tween;
                return true;
            }
        }),
        _getRoundFunc = function(v) {
            var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1;
            return function(n) {
                return ((Math.round(n / v) * v * p) | 0) / p;
            };
        },
        _roundLinkedList = function(node, mod) {
            while (node) {
                if (!node.f && !node.blob) {
                    node.m = mod || Math.round;
                }
                node = node._next;
            }
        },
        p = RoundPropsPlugin.prototype;
    p._onInitAllProps = function() {
        var tween = this._tween,
            rp = tween.vars.roundProps,
            lookup = {},
            rpt = tween._propLookup.roundProps,
            pt, next, i, p;
        if (typeof(rp) === "object" && !rp.push) {
            for (p in rp) {
                lookup[p] = _getRoundFunc(rp[p]);
            }
        } else {
            if (typeof(rp) === "string") {
                rp = rp.split(",");
            }
            i = rp.length;
            while (--i > -1) {
                lookup[rp[i]] = Math.round;
            }
        }
        for (p in lookup) {
            pt = tween._firstPT;
            while (pt) {
                next = pt._next;
                if (pt.pg) {
                    pt.t._mod(lookup);
                } else if (pt.n === p) {
                    if (pt.f === 2 && pt.t) {
                        _roundLinkedList(pt.t._firstPT, lookup[p]);
                    } else {
                        this._add(pt.t, p, pt.s, pt.c, lookup[p]);
                        if (next) {
                            next._prev = pt._prev;
                        }
                        if (pt._prev) {
                            pt._prev._next = next;
                        } else if (tween._firstPT === pt) {
                            tween._firstPT = next;
                        }
                        pt._next = pt._prev = null;
                        tween._propLookup[p] = rpt;
                    }
                }
                pt = next;
            }
        }
        return false;
    };
    p._add = function(target, p, s, c, mod) {
        this._addTween(target, p, s, s + c, p, mod || Math.round);
        this._overwriteProps.push(p);
    };
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return DirectionalRotationPlugin;
    });
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    /*!
     * VERSION: 0.3.1
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     **/
    const DirectionalRotationPlugin = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine.plugin({
        propName: "directionalRotation",
        version: "0.3.1",
        API: 2,
        init: function(target, value, tween, index) {
            if (typeof(value) !== "object") {
                value = {
                    rotation: value
                };
            }
            this.finals = {};
            var cap = (value.useRadians === true) ? Math.PI * 2 : 360,
                min = 0.000001,
                p, v, start, end, dif, split;
            for (p in value) {
                if (p !== "useRadians") {
                    end = value[p];
                    if (typeof(end) === "function") {
                        end = end(index, target);
                    }
                    split = (end + "").split("_");
                    v = split[0];
                    start = parseFloat((typeof(target[p]) !== "function") ? target[p] : target[((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3))]());
                    end = this.finals[p] = (typeof(v) === "string" && v.charAt(1) === "=") ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
                    dif = end - start;
                    if (split.length) {
                        v = split.join("_");
                        if (v.indexOf("short") !== -1) {
                            dif = dif % cap;
                            if (dif !== dif % (cap / 2)) {
                                dif = (dif < 0) ? dif + cap : dif - cap;
                            }
                        }
                        if (v.indexOf("_cw") !== -1 && dif < 0) {
                            dif = ((dif + cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
                        } else if (v.indexOf("ccw") !== -1 && dif > 0) {
                            dif = ((dif - cap * 9999999999) % cap) - ((dif / cap) | 0) * cap;
                        }
                    }
                    if (dif > min || dif < -min) {
                        this._addTween(target, p, start, start + dif, p);
                        this._overwriteProps.push(p);
                    }
                }
            }
            return true;
        },
        set: function(ratio) {
            var pt;
            if (ratio !== 1) {
                this._super.setRatio.call(this, ratio);
            } else {
                pt = this._firstPT;
                while (pt) {
                    if (pt.f) {
                        pt.t[pt.p](this.finals[pt.p]);
                    } else {
                        pt.t[pt.p] = this.finals[pt.p];
                    }
                    pt = pt._next;
                }
            }
        }
    });
    DirectionalRotationPlugin._autoCSS = true;
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return BezierPlugin;
    });
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    /*!
     * VERSION: 1.3.8
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     **/
    var _RAD2DEG = 180 / Math.PI,
        _r1 = [],
        _r2 = [],
        _r3 = [],
        _corProps = {},
        _globals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine.globals,
        Segment = function(a, b, c, d) {
            if (c === d) {
                c = d - (d - b) / 1000000;
            }
            if (a === b) {
                b = a + (c - a) / 1000000;
            }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.da = d - a;
            this.ca = c - a;
            this.ba = b - a;
        },
        _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
        cubicToQuadratic = function(a, b, c, d) {
            var q1 = {
                    a: a
                },
                q2 = {},
                q3 = {},
                q4 = {
                    c: d
                },
                mab = (a + b) / 2,
                mbc = (b + c) / 2,
                mcd = (c + d) / 2,
                mabc = (mab + mbc) / 2,
                mbcd = (mbc + mcd) / 2,
                m8 = (mbcd - mabc) / 8;
            q1.b = mab + (a - mab) / 4;
            q2.b = mabc + m8;
            q1.c = q2.a = (q1.b + q2.b) / 2;
            q2.c = q3.a = (mabc + mbcd) / 2;
            q3.b = mbcd - m8;
            q4.b = mcd + (d - mcd) / 4;
            q3.c = q4.a = (q3.b + q4.b) / 2;
            return [q1, q2, q3, q4];
        },
        _calculateControlPoints = function(a, curviness, quad, basic, correlate) {
            var l = a.length - 1,
                ii = 0,
                cp1 = a[0].a,
                i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
            for (i = 0; i < l; i++) {
                seg = a[ii];
                p1 = seg.a;
                p2 = seg.d;
                p3 = a[ii + 1].d;
                if (correlate) {
                    r1 = _r1[i];
                    r2 = _r2[i];
                    tl = ((r2 + r1) * curviness * 0.25) / (basic ? 0.5 : _r3[i] || 0.5);
                    m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : (r1 !== 0 ? tl / r1 : 0));
                    m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : (r2 !== 0 ? tl / r2 : 0));
                    mm = p2 - (m1 + (((m2 - m1) * ((r1 * 3 / (r1 + r2)) + 0.5) / 4) || 0));
                } else {
                    m1 = p2 - (p2 - p1) * curviness * 0.5;
                    m2 = p2 + (p3 - p2) * curviness * 0.5;
                    mm = p2 - (m1 + m2) / 2;
                }
                m1 += mm;
                m2 += mm;
                seg.c = cp2 = m1;
                if (i !== 0) {
                    seg.b = cp1;
                } else {
                    seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6;
                }
                seg.da = p2 - p1;
                seg.ca = cp2 - p1;
                seg.ba = cp1 - p1;
                if (quad) {
                    qb = cubicToQuadratic(p1, cp1, cp2, p2);
                    a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
                    ii += 4;
                } else {
                    ii++;
                }
                cp1 = m2;
            }
            seg = a[ii];
            seg.b = cp1;
            seg.c = cp1 + (seg.d - cp1) * 0.4;
            seg.da = seg.d - seg.a;
            seg.ca = seg.c - seg.a;
            seg.ba = cp1 - seg.a;
            if (quad) {
                qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
                a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
            }
        },
        _parseAnchors = function(values, p, correlate, prepend) {
            var a = [],
                l, i, p1, p2, p3, tmp;
            if (prepend) {
                values = [prepend].concat(values);
                i = values.length;
                while (--i > -1) {
                    if (typeof((tmp = values[i][p])) === "string")
                        if (tmp.charAt(1) === "=") {
                            values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2));
                        }
                }
            }
            l = values.length - 2;
            if (l < 0) {
                a[0] = new Segment(values[0][p], 0, 0, values[0][p]);
                return a;
            }
            for (i = 0; i < l; i++) {
                p1 = values[i][p];
                p2 = values[i + 1][p];
                a[i] = new Segment(p1, 0, 0, p2);
                if (correlate) {
                    p3 = values[i + 2][p];
                    _r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
                    _r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
                }
            }
            a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
            return a;
        },
        bezierThrough = function(values, curviness, quadratic, basic, correlate, prepend) {
            var obj = {},
                props = [],
                first = prepend || values[0],
                i, p, a, j, r, l, seamless, last;
            correlate = (typeof(correlate) === "string") ? "," + correlate + "," : _correlate;
            if (curviness == null) {
                curviness = 1;
            }
            for (p in values[0]) {
                props.push(p);
            }
            if (values.length > 1) {
                last = values[values.length - 1];
                seamless = true;
                i = props.length;
                while (--i > -1) {
                    p = props[i];
                    if (Math.abs(first[p] - last[p]) > 0.05) {
                        seamless = false;
                        break;
                    }
                }
                if (seamless) {
                    values = values.concat();
                    if (prepend) {
                        values.unshift(prepend);
                    }
                    values.push(values[1]);
                    prepend = values[values.length - 3];
                }
            }
            _r1.length = _r2.length = _r3.length = 0;
            i = props.length;
            while (--i > -1) {
                p = props[i];
                _corProps[p] = (correlate.indexOf("," + p + ",") !== -1);
                obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
            }
            i = _r1.length;
            while (--i > -1) {
                _r1[i] = Math.sqrt(_r1[i]);
                _r2[i] = Math.sqrt(_r2[i]);
            }
            if (!basic) {
                i = props.length;
                while (--i > -1) {
                    if (_corProps[p]) {
                        a = obj[props[i]];
                        l = a.length - 1;
                        for (j = 0; j < l; j++) {
                            r = (a[j + 1].da / _r2[j] + a[j].da / _r1[j]) || 0;
                            _r3[j] = (_r3[j] || 0) + r * r;
                        }
                    }
                }
                i = _r3.length;
                while (--i > -1) {
                    _r3[i] = Math.sqrt(_r3[i]);
                }
            }
            i = props.length;
            j = quadratic ? 4 : 1;
            while (--i > -1) {
                p = props[i];
                a = obj[p];
                _calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]);
                if (seamless) {
                    a.splice(0, j);
                    a.splice(a.length - j, j);
                }
            }
            return obj;
        },
        _parseBezierData = function(values, type, prepend) {
            type = type || "soft";
            var obj = {},
                inc = (type === "cubic") ? 3 : 2,
                soft = (type === "soft"),
                props = [],
                a, b, c, d, cur, i, j, l, p, cnt, tmp;
            if (soft && prepend) {
                values = [prepend].concat(values);
            }
            if (values == null || values.length < inc + 1) {
                throw "invalid Bezier data";
            }
            for (p in values[0]) {
                props.push(p);
            }
            i = props.length;
            while (--i > -1) {
                p = props[i];
                obj[p] = cur = [];
                cnt = 0;
                l = values.length;
                for (j = 0; j < l; j++) {
                    a = (prepend == null) ? values[j][p] : (typeof((tmp = values[j][p])) === "string" && tmp.charAt(1) === "=") ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
                    if (soft)
                        if (j > 1)
                            if (j < l - 1) {
                                cur[cnt++] = (a + cur[cnt - 2]) / 2;
                            }
                    cur[cnt++] = a;
                }
                l = cnt - inc + 1;
                cnt = 0;
                for (j = 0; j < l; j += inc) {
                    a = cur[j];
                    b = cur[j + 1];
                    c = cur[j + 2];
                    d = (inc === 2) ? 0 : cur[j + 3];
                    cur[cnt++] = tmp = (inc === 3) ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
                }
                cur.length = cnt;
            }
            return obj;
        },
        _addCubicLengths = function(a, steps, resolution) {
            var inc = 1 / resolution,
                j = a.length,
                d, d1, s, da, ca, ba, p, i, inv, bez, index;
            while (--j > -1) {
                bez = a[j];
                s = bez.a;
                da = bez.d - s;
                ca = bez.c - s;
                ba = bez.b - s;
                d = d1 = 0;
                for (i = 1; i <= resolution; i++) {
                    p = inc * i;
                    inv = 1 - p;
                    d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
                    index = j * resolution + i - 1;
                    steps[index] = (steps[index] || 0) + d * d;
                }
            }
        },
        _parseLengthData = function(obj, resolution) {
            resolution = resolution >> 0 || 6;
            var a = [],
                lengths = [],
                d = 0,
                total = 0,
                threshold = resolution - 1,
                segments = [],
                curLS = [],
                p, i, l, index;
            for (p in obj) {
                _addCubicLengths(obj[p], a, resolution);
            }
            l = a.length;
            for (i = 0; i < l; i++) {
                d += Math.sqrt(a[i]);
                index = i % resolution;
                curLS[index] = d;
                if (index === threshold) {
                    total += d;
                    index = (i / resolution) >> 0;
                    segments[index] = curLS;
                    lengths[index] = total;
                    d = 0;
                    curLS = [];
                }
            }
            return {
                length: total,
                lengths: lengths,
                segments: segments
            };
        },
        BezierPlugin = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine.plugin({
            propName: "bezier",
            priority: -1,
            version: "1.3.8",
            API: 2,
            global: true,
            init: function(target, vars, tween) {
                this._target = target;
                if (vars instanceof Array) {
                    vars = {
                        values: vars
                    };
                }
                this._func = {};
                this._mod = {};
                this._props = [];
                this._timeRes = (vars.timeResolution == null) ? 6 : parseInt(vars.timeResolution, 10);
                var values = vars.values || [],
                    first = {},
                    second = values[0],
                    autoRotate = vars.autoRotate || tween.vars.orientToBezier,
                    p, isFunc, i, j, prepend;
                this._autoRotate = autoRotate ? (autoRotate instanceof Array) ? autoRotate : [
                    ["x", "y", "rotation", ((autoRotate === true) ? 0 : Number(autoRotate) || 0)]
                ] : null;
                for (p in second) {
                    this._props.push(p);
                }
                i = this._props.length;
                while (--i > -1) {
                    p = this._props[i];
                    this._overwriteProps.push(p);
                    isFunc = this._func[p] = (typeof(target[p]) === "function");
                    first[p] = (!isFunc) ? parseFloat(target[p]) : target[((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3))]();
                    if (!prepend)
                        if (first[p] !== values[0][p]) {
                            prepend = first;
                        }
                }
                this._beziers = (vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft") ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, (vars.type === "thruBasic"), vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
                this._segCount = this._beziers[p].length;
                if (this._timeRes) {
                    var ld = _parseLengthData(this._beziers, this._timeRes);
                    this._length = ld.length;
                    this._lengths = ld.lengths;
                    this._segments = ld.segments;
                    this._l1 = this._li = this._s1 = this._si = 0;
                    this._l2 = this._lengths[0];
                    this._curSeg = this._segments[0];
                    this._s2 = this._curSeg[0];
                    this._prec = 1 / this._curSeg.length;
                }
                if ((autoRotate = this._autoRotate)) {
                    this._initialRotations = [];
                    if (!(autoRotate[0] instanceof Array)) {
                        this._autoRotate = autoRotate = [autoRotate];
                    }
                    i = autoRotate.length;
                    while (--i > -1) {
                        for (j = 0; j < 3; j++) {
                            p = autoRotate[i][j];
                            this._func[p] = (typeof(target[p]) === "function") ? target[((p.indexOf("set") || typeof(target["get" + p.substr(3)]) !== "function") ? p : "get" + p.substr(3))] : false;
                        }
                        p = autoRotate[i][2];
                        this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
                        this._overwriteProps.push(p);
                    }
                }
                this._startRatio = tween.vars.runBackwards ? 1 : 0;
                return true;
            },
            set: function(v) {
                var segments = this._segCount,
                    func = this._func,
                    target = this._target,
                    notStart = (v !== this._startRatio),
                    curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
                if (!this._timeRes) {
                    curIndex = (v < 0) ? 0 : (v >= 1) ? segments - 1 : (segments * v) >> 0;
                    t = (v - (curIndex * (1 / segments))) * segments;
                } else {
                    lengths = this._lengths;
                    curSeg = this._curSeg;
                    v *= this._length;
                    i = this._li;
                    if (v > this._l2 && i < segments - 1) {
                        l = segments - 1;
                        while (i < l && (this._l2 = lengths[++i]) <= v) {}
                        this._l1 = lengths[i - 1];
                        this._li = i;
                        this._curSeg = curSeg = this._segments[i];
                        this._s2 = curSeg[(this._s1 = this._si = 0)];
                    } else if (v < this._l1 && i > 0) {
                        while (i > 0 && (this._l1 = lengths[--i]) >= v) {}
                        if (i === 0 && v < this._l1) {
                            this._l1 = 0;
                        } else {
                            i++;
                        }
                        this._l2 = lengths[i];
                        this._li = i;
                        this._curSeg = curSeg = this._segments[i];
                        this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
                        this._s2 = curSeg[this._si];
                    }
                    curIndex = i;
                    v -= this._l1;
                    i = this._si;
                    if (v > this._s2 && i < curSeg.length - 1) {
                        l = curSeg.length - 1;
                        while (i < l && (this._s2 = curSeg[++i]) <= v) {}
                        this._s1 = curSeg[i - 1];
                        this._si = i;
                    } else if (v < this._s1 && i > 0) {
                        while (i > 0 && (this._s1 = curSeg[--i]) >= v) {}
                        if (i === 0 && v < this._s1) {
                            this._s1 = 0;
                        } else {
                            i++;
                        }
                        this._s2 = curSeg[i];
                        this._si = i;
                    }
                    t = ((i + (v - this._s1) / (this._s2 - this._s1)) * this._prec) || 0;
                }
                inv = 1 - t;
                i = this._props.length;
                while (--i > -1) {
                    p = this._props[i];
                    b = this._beziers[p][curIndex];
                    val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
                    if (this._mod[p]) {
                        val = this._mod[p](val, target);
                    }
                    if (func[p]) {
                        target[p](val);
                    } else {
                        target[p] = val;
                    }
                }
                if (this._autoRotate) {
                    var ar = this._autoRotate,
                        b2, x1, y1, x2, y2, add, conv;
                    i = ar.length;
                    while (--i > -1) {
                        p = ar[i][2];
                        add = ar[i][3] || 0;
                        conv = (ar[i][4] === true) ? 1 : _RAD2DEG;
                        b = this._beziers[ar[i][0]];
                        b2 = this._beziers[ar[i][1]];
                        if (b && b2) {
                            b = b[curIndex];
                            b2 = b2[curIndex];
                            x1 = b.a + (b.b - b.a) * t;
                            x2 = b.b + (b.c - b.b) * t;
                            x1 += (x2 - x1) * t;
                            x2 += ((b.c + (b.d - b.c) * t) - x2) * t;
                            y1 = b2.a + (b2.b - b2.a) * t;
                            y2 = b2.b + (b2.c - b2.b) * t;
                            y1 += (y2 - y1) * t;
                            y2 += ((b2.c + (b2.d - b2.c) * t) - y2) * t;
                            val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];
                            if (this._mod[p]) {
                                val = this._mod[p](val, target);
                            }
                            if (func[p]) {
                                target[p](val);
                            } else {
                                target[p] = val;
                            }
                        }
                    }
                }
            }
        }),
        p = BezierPlugin.prototype;
    BezierPlugin.bezierThrough = bezierThrough;
    BezierPlugin.cubicToQuadratic = cubicToQuadratic;
    BezierPlugin._autoCSS = true;
    BezierPlugin.quadraticToCubic = function(a, b, c) {
        return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
    };
    BezierPlugin._cssRegister = function() {
        var CSSPlugin = _globals.CSSPlugin;
        if (!CSSPlugin) {
            return;
        }
        var _internals = CSSPlugin._internals,
            _parseToProxy = _internals._parseToProxy,
            _setPluginRatio = _internals._setPluginRatio,
            CSSPropTween = _internals.CSSPropTween;
        _internals._registerComplexSpecialProp("bezier", {
            parser: function(t, e, prop, cssp, pt, plugin) {
                if (e instanceof Array) {
                    e = {
                        values: e
                    };
                }
                plugin = new BezierPlugin();
                var values = e.values,
                    l = values.length - 1,
                    pluginValues = [],
                    v = {},
                    i, p, data;
                if (l < 0) {
                    return pt;
                }
                for (i = 0; i <= l; i++) {
                    data = _parseToProxy(t, values[i], cssp, pt, plugin, (l !== i));
                    pluginValues[i] = data.end;
                }
                for (p in e) {
                    v[p] = e[p];
                }
                v.values = pluginValues;
                pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
                pt.data = data;
                pt.plugin = plugin;
                pt.setRatio = _setPluginRatio;
                if (v.autoRotate === 0) {
                    v.autoRotate = true;
                }
                if (v.autoRotate && !(v.autoRotate instanceof Array)) {
                    i = (v.autoRotate === true) ? 0 : Number(v.autoRotate);
                    v.autoRotate = (data.end.left != null) ? [
                        ["left", "top", "rotation", i, false]
                    ] : (data.end.x != null) ? [
                        ["x", "y", "rotation", i, false]
                    ] : false;
                }
                if (v.autoRotate) {
                    if (!cssp._transform) {
                        cssp._enableTransforms(false);
                    }
                    data.autoRotate = cssp._target._gsTransform;
                    data.proxy.rotation = data.autoRotate.rotation || 0;
                    cssp._overwriteProps.push("rotation");
                }
                plugin._onInitTween(data.proxy, v, cssp._tween);
                return pt;
            }
        });
    };
    p._mod = function(lookup) {
        var op = this._overwriteProps,
            i = op.length,
            val;
        while (--i > -1) {
            val = lookup[op[i]];
            if (val && typeof(val) === "function") {
                this._mod[op[i]] = val;
            }
        }
    };
    p._kill = function(lookup) {
        var a = this._props,
            p, i;
        for (p in this._beziers) {
            if (p in lookup) {
                delete this._beziers[p];
                delete this._func[p];
                i = a.length;
                while (--i > -1) {
                    if (a[i] === p) {
                        a.splice(i, 1);
                    }
                }
            }
        }
        a = this._autoRotate;
        if (a) {
            i = a.length;
            while (--i > -1) {
                if (lookup[a[i][2]]) {
                    a.splice(i, 1);
                }
            }
        }
        return this._super._kill.call(this, lookup);
    };
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    /*!
     * VERSION: 1.16.0
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     **/
    __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine("easing.Back", ["easing.Ease"], function() {
        var w = (__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].GreenSockGlobals || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]),
            gs = w.com.greensock,
            _2PI = Math.PI * 2,
            _HALF_PI = Math.PI / 2,
            _class = gs._class,
            _create = function(n, f) {
                var C = _class("easing." + n, function() {}, true),
                    p = C.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"]();
                p.constructor = C;
                p.getRatio = f;
                return C;
            },
            _easeReg = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"].register || function() {},
            _wrap = function(name, EaseOut, EaseIn, EaseInOut, aliases) {
                var C = _class("easing." + name, {
                    easeOut: new EaseOut(),
                    easeIn: new EaseIn(),
                    easeInOut: new EaseInOut()
                }, true);
                _easeReg(C, name);
                return C;
            },
            EasePoint = function(time, value, next) {
                this.t = time;
                this.v = value;
                if (next) {
                    this.next = next;
                    next.prev = this;
                    this.c = next.v - value;
                    this.gap = next.t - time;
                }
            },
            _createBack = function(n, f) {
                var C = _class("easing." + n, function(overshoot) {
                        this._p1 = (overshoot || overshoot === 0) ? overshoot : 1.70158;
                        this._p2 = this._p1 * 1.525;
                    }, true),
                    p = C.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"]();
                p.constructor = C;
                p.getRatio = f;
                p.config = function(overshoot) {
                    return new C(overshoot);
                };
                return C;
            },
            Back = _wrap("Back", _createBack("BackOut", function(p) {
                return ((p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1);
            }), _createBack("BackIn", function(p) {
                return p * p * ((this._p1 + 1) * p - this._p1);
            }), _createBack("BackInOut", function(p) {
                return ((p *= 2) < 1) ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
            })),
            SlowMo = _class("easing.SlowMo", function(linearRatio, power, yoyoMode) {
                power = (power || power === 0) ? power : 0.7;
                if (linearRatio == null) {
                    linearRatio = 0.7;
                } else if (linearRatio > 1) {
                    linearRatio = 1;
                }
                this._p = (linearRatio !== 1) ? power : 0;
                this._p1 = (1 - linearRatio) / 2;
                this._p2 = linearRatio;
                this._p3 = this._p1 + this._p2;
                this._calcEnd = (yoyoMode === true);
            }, true),
            p = SlowMo.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"](),
            SteppedEase, ExpoScaleEase, RoughEase, _createElastic;
        p.constructor = SlowMo;
        p.getRatio = function(p) {
            var r = p + (0.5 - p) * this._p;
            if (p < this._p1) {
                return this._calcEnd ? 1 - ((p = 1 - (p / this._p1)) * p) : r - ((p = 1 - (p / this._p1)) * p * p * p * r);
            } else if (p > this._p3) {
                return this._calcEnd ? (p === 1 ? 0 : 1 - (p = (p - this._p3) / this._p1) * p) : r + ((p - r) * (p = (p - this._p3) / this._p1) * p * p * p);
            }
            return this._calcEnd ? 1 : r;
        };
        SlowMo.ease = new SlowMo(0.7, 0.7);
        p.config = SlowMo.config = function(linearRatio, power, yoyoMode) {
            return new SlowMo(linearRatio, power, yoyoMode);
        };
        SteppedEase = _class("easing.SteppedEase", function(steps, immediateStart) {
            steps = steps || 1;
            this._p1 = 1 / steps;
            this._p2 = steps + (immediateStart ? 0 : 1);
            this._p3 = immediateStart ? 1 : 0;
        }, true);
        p = SteppedEase.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"]();
        p.constructor = SteppedEase;
        p.getRatio = function(p) {
            if (p < 0) {
                p = 0;
            } else if (p >= 1) {
                p = 0.999999999;
            }
            return (((this._p2 * p) | 0) + this._p3) * this._p1;
        };
        p.config = SteppedEase.config = function(steps, immediateStart) {
            return new SteppedEase(steps, immediateStart);
        };
        ExpoScaleEase = _class("easing.ExpoScaleEase", function(start, end, ease) {
            this._p1 = Math.log(end / start);
            this._p2 = end - start;
            this._p3 = start;
            this._ease = ease;
        }, true);
        p = ExpoScaleEase.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"]();
        p.constructor = ExpoScaleEase;
        p.getRatio = function(p) {
            if (this._ease) {
                p = this._ease.getRatio(p);
            }
            return (this._p3 * Math.exp(this._p1 * p) - this._p3) / this._p2;
        };
        p.config = ExpoScaleEase.config = function(start, end, ease) {
            return new ExpoScaleEase(start, end, ease);
        };
        RoughEase = _class("easing.RoughEase", function(vars) {
            vars = vars || {};
            var taper = vars.taper || "none",
                a = [],
                cnt = 0,
                points = (vars.points || 20) | 0,
                i = points,
                randomize = (vars.randomize !== false),
                clamp = (vars.clamp === true),
                template = (vars.template instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"]) ? vars.template : null,
                strength = (typeof(vars.strength) === "number") ? vars.strength * 0.4 : 0.4,
                x, y, bump, invX, obj, pnt;
            while (--i > -1) {
                x = randomize ? Math.random() : (1 / points) * i;
                y = template ? template.getRatio(x) : x;
                if (taper === "none") {
                    bump = strength;
                } else if (taper === "out") {
                    invX = 1 - x;
                    bump = invX * invX * strength;
                } else if (taper === "in") {
                    bump = x * x * strength;
                } else if (x < 0.5) {
                    invX = x * 2;
                    bump = invX * invX * 0.5 * strength;
                } else {
                    invX = (1 - x) * 2;
                    bump = invX * invX * 0.5 * strength;
                }
                if (randomize) {
                    y += (Math.random() * bump) - (bump * 0.5);
                } else if (i % 2) {
                    y += bump * 0.5;
                } else {
                    y -= bump * 0.5;
                }
                if (clamp) {
                    if (y > 1) {
                        y = 1;
                    } else if (y < 0) {
                        y = 0;
                    }
                }
                a[cnt++] = {
                    x: x,
                    y: y
                };
            }
            a.sort(function(a, b) {
                return a.x - b.x;
            });
            pnt = new EasePoint(1, 1, null);
            i = points;
            while (--i > -1) {
                obj = a[i];
                pnt = new EasePoint(obj.x, obj.y, pnt);
            }
            this._prev = new EasePoint(0, 0, (pnt.t !== 0) ? pnt : pnt.next);
        }, true);
        p = RoughEase.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"]();
        p.constructor = RoughEase;
        p.getRatio = function(p) {
            var pnt = this._prev;
            if (p > pnt.t) {
                while (pnt.next && p >= pnt.t) {
                    pnt = pnt.next;
                }
                pnt = pnt.prev;
            } else {
                while (pnt.prev && p <= pnt.t) {
                    pnt = pnt.prev;
                }
            }
            this._prev = pnt;
            return (pnt.v + ((p - pnt.t) / pnt.gap) * pnt.c);
        };
        p.config = function(vars) {
            return new RoughEase(vars);
        };
        RoughEase.ease = new RoughEase();
        _wrap("Bounce", _create("BounceOut", function(p) {
            if (p < 1 / 2.75) {
                return 7.5625 * p * p;
            } else if (p < 2 / 2.75) {
                return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
            } else if (p < 2.5 / 2.75) {
                return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
            }
            return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
        }), _create("BounceIn", function(p) {
            if ((p = 1 - p) < 1 / 2.75) {
                return 1 - (7.5625 * p * p);
            } else if (p < 2 / 2.75) {
                return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
            } else if (p < 2.5 / 2.75) {
                return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
            }
            return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
        }), _create("BounceInOut", function(p) {
            var invert = (p < 0.5);
            if (invert) {
                p = 1 - (p * 2);
            } else {
                p = (p * 2) - 1;
            }
            if (p < 1 / 2.75) {
                p = 7.5625 * p * p;
            } else if (p < 2 / 2.75) {
                p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
            } else if (p < 2.5 / 2.75) {
                p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
            } else {
                p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
            }
            return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
        }));
        _wrap("Circ", _create("CircOut", function(p) {
            return Math.sqrt(1 - (p = p - 1) * p);
        }), _create("CircIn", function(p) {
            return -(Math.sqrt(1 - (p * p)) - 1);
        }), _create("CircInOut", function(p) {
            return ((p *= 2) < 1) ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
        }));
        _createElastic = function(n, f, def) {
            var C = _class("easing." + n, function(amplitude, period) {
                    this._p1 = (amplitude >= 1) ? amplitude : 1;
                    this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
                    this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
                    this._p2 = _2PI / this._p2;
                }, true),
                p = C.prototype = new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"]();
            p.constructor = C;
            p.getRatio = f;
            p.config = function(amplitude, period) {
                return new C(amplitude, period);
            };
            return C;
        };
        _wrap("Elastic", _createElastic("ElasticOut", function(p) {
            return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1;
        }, 0.3), _createElastic("ElasticIn", function(p) {
            return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2));
        }, 0.3), _createElastic("ElasticInOut", function(p) {
            return ((p *= 2) < 1) ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * 0.5 + 1;
        }, 0.45));
        _wrap("Expo", _create("ExpoOut", function(p) {
            return 1 - Math.pow(2, -10 * p);
        }), _create("ExpoIn", function(p) {
            return Math.pow(2, 10 * (p - 1)) - 0.001;
        }), _create("ExpoInOut", function(p) {
            return ((p *= 2) < 1) ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
        }));
        _wrap("Sine", _create("SineOut", function(p) {
            return Math.sin(p * _HALF_PI);
        }), _create("SineIn", function(p) {
            return -Math.cos(p * _HALF_PI) + 1;
        }), _create("SineInOut", function(p) {
            return -0.5 * (Math.cos(Math.PI * p) - 1);
        }));
        _class("easing.EaseLookup", {
            find: function(s) {
                return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"].map[s];
            }
        }, true);
        _easeReg(w.SlowMo, "SlowMo", "ease,");
        _easeReg(RoughEase, "RoughEase", "ease,");
        _easeReg(SteppedEase, "SteppedEase", "ease,");
        return Back;
    }, true);
    const Back = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].Back;
    __webpack_exports__["a"] = Back;
    const Elastic = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].Elastic;
    __webpack_exports__["d"] = Elastic;
    const Bounce = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].Bounce;
    __webpack_exports__["b"] = Bounce;
    const RoughEase = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].RoughEase;
    __webpack_exports__["g"] = RoughEase;
    const SlowMo = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].SlowMo;
    __webpack_exports__["i"] = SlowMo;
    const SteppedEase = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].SteppedEase;
    __webpack_exports__["j"] = SteppedEase;
    const Circ = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].Circ;
    __webpack_exports__["c"] = Circ;
    const Expo = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].Expo;
    __webpack_exports__["e"] = Expo;
    const Sine = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].Sine;
    __webpack_exports__["h"] = Sine;
    const ExpoScaleEase = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].ExpoScaleEase;
    __webpack_exports__["f"] = ExpoScaleEase;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.transitionend = exports.GetYoDigits = exports.rtl = undefined;
    var _jquery = __webpack_require__(3);
    var _jquery2 = _interopRequireDefault(_jquery);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function rtl() {
        return (0, _jquery2.default)('html').attr('dir') === 'rtl';
    }

    function GetYoDigits(length, namespace) {
        length = length || 6;
        return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? '-' + namespace : '');
    }

    function transitionend($elem) {
        var transitions = {
            'transition': 'transitionend',
            'WebkitTransition': 'webkitTransitionEnd',
            'MozTransition': 'transitionend',
            'OTransition': 'otransitionend'
        };
        var elem = document.createElement('div'),
            end;
        for (var t in transitions) {
            if (typeof elem.style[t] !== 'undefined') {
                end = transitions[t];
            }
        }
        if (end) {
            return end;
        } else {
            end = setTimeout(function() {
                $elem.triggerHandler('transitionend', [$elem]);
            }, 1);
            return 'transitionend';
        }
    }
    exports.rtl = rtl;
    exports.GetYoDigits = GetYoDigits;
    exports.transitionend = transitionend;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.MediaQuery = undefined;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _jquery = __webpack_require__(3);
    var _jquery2 = _interopRequireDefault(_jquery);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var defaultQueries = {
        'default': 'only screen',
        landscape: 'only screen and (orientation: landscape)',
        portrait: 'only screen and (orientation: portrait)',
        retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'
    };
    var matchMedia = window.matchMedia || function() {
        'use strict';
        var styleMedia = window.styleMedia || window.media;
        if (!styleMedia) {
            var style = document.createElement('style'),
                script = document.getElementsByTagName('script')[0],
                info = null;
            style.type = 'text/css';
            style.id = 'matchmediajs-test';
            script && script.parentNode && script.parentNode.insertBefore(style, script);
            info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;
            styleMedia = {
                matchMedium: function matchMedium(media) {
                    var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';
                    if (style.styleSheet) {
                        style.styleSheet.cssText = text;
                    } else {
                        style.textContent = text;
                    }
                    return info.width === '1px';
                }
            };
        }
        return function(media) {
            return {
                matches: styleMedia.matchMedium(media || 'all'),
                media: media || 'all'
            };
        };
    }();
    var MediaQuery = {
        queries: [],
        current: '',
        _init: function _init() {
            var self = this;
            var $meta = (0, _jquery2.default)('meta.foundation-mq');
            if (!$meta.length) {
                (0, _jquery2.default)('<meta class="foundation-mq">').appendTo(document.head);
            }
            var extractedStyles = (0, _jquery2.default)('.foundation-mq').css('font-family');
            var namedQueries;
            namedQueries = parseStyleToObject(extractedStyles);
            for (var key in namedQueries) {
                if (namedQueries.hasOwnProperty(key)) {
                    self.queries.push({
                        name: key,
                        value: 'only screen and (min-width: ' + namedQueries[key] + ')'
                    });
                }
            }
            this.current = this._getCurrentSize();
            this._watcher();
        },
        atLeast: function atLeast(size) {
            var query = this.get(size);
            if (query) {
                return matchMedia(query).matches;
            }
            return false;
        },
        is: function is(size) {
            size = size.trim().split(' ');
            if (size.length > 1 && size[1] === 'only') {
                if (size[0] === this._getCurrentSize()) return true;
            } else {
                return this.atLeast(size[0]);
            }
            return false;
        },
        get: function get(size) {
            for (var i in this.queries) {
                if (this.queries.hasOwnProperty(i)) {
                    var query = this.queries[i];
                    if (size === query.name) return query.value;
                }
            }
            return null;
        },
        _getCurrentSize: function _getCurrentSize() {
            var matched;
            for (var i = 0; i < this.queries.length; i++) {
                var query = this.queries[i];
                if (matchMedia(query.value).matches) {
                    matched = query;
                }
            }
            if ((typeof matched === 'undefined' ? 'undefined' : _typeof(matched)) === 'object') {
                return matched.name;
            } else {
                return matched;
            }
        },
        _watcher: function _watcher() {
            var _this = this;
            (0, _jquery2.default)(window).off('resize.zf.mediaquery').on('resize.zf.mediaquery', function() {
                var newSize = _this._getCurrentSize(),
                    currentSize = _this.current;
                if (newSize !== currentSize) {
                    _this.current = newSize;
                    (0, _jquery2.default)(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);
                }
            });
        }
    };

    function parseStyleToObject(str) {
        var styleObject = {};
        if (typeof str !== 'string') {
            return styleObject;
        }
        str = str.trim().slice(1, -1);
        if (!str) {
            return styleObject;
        }
        styleObject = str.split('&').reduce(function(ret, param) {
            var parts = param.replace(/\+/g, ' ').split('=');
            var key = parts[0];
            var val = parts[1];
            key = decodeURIComponent(key);
            val = val === undefined ? null : decodeURIComponent(val);
            if (!ret.hasOwnProperty(key)) {
                ret[key] = val;
            } else if (Array.isArray(ret[key])) {
                ret[key].push(val);
            } else {
                ret[key] = [ret[key], val];
            }
            return ret;
        }, {});
        return styleObject;
    }
    exports.MediaQuery = MediaQuery;
}), (function(module, exports) {
    module.exports = function(module) {
        if (!module.webpackPolyfill) {
            module.deprecate = function() {};
            module.paths = [];
            if (!module.children) module.children = [];
            Object.defineProperty(module, "loaded", {
                enumerable: true,
                get: function() {
                    return module.l;
                }
            });
            Object.defineProperty(module, "id", {
                enumerable: true,
                get: function() {
                    return module.i;
                }
            });
            module.webpackPolyfill = 1;
        }
        return module;
    };
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = exports.CustomEase = undefined;
    var _TweenLite = __webpack_require__(1);
    _TweenLite._gsScope._gsDefine("easing.CustomEase", ["easing.Ease"], function() {
        var _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
            _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
            _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
            _needsParsingExp = /[cLlsS]/g,
            _bezierError = "CustomEase only accepts Cubic Bezier data.",
            _bezierToPoints = function _bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
                var x12 = (x1 + x2) / 2,
                    y12 = (y1 + y2) / 2,
                    x23 = (x2 + x3) / 2,
                    y23 = (y2 + y3) / 2,
                    x34 = (x3 + x4) / 2,
                    y34 = (y3 + y4) / 2,
                    x123 = (x12 + x23) / 2,
                    y123 = (y12 + y23) / 2,
                    x234 = (x23 + x34) / 2,
                    y234 = (y23 + y34) / 2,
                    x1234 = (x123 + x234) / 2,
                    y1234 = (y123 + y234) / 2,
                    dx = x4 - x1,
                    dy = y4 - y1,
                    d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx),
                    d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx),
                    length;
                if (!points) {
                    points = [{
                        x: x1,
                        y: y1
                    }, {
                        x: x4,
                        y: y4
                    }];
                    index = 1;
                }
                points.splice(index || points.length - 1, 0, {
                    x: x1234,
                    y: y1234
                });
                if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
                    length = points.length;
                    _bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);
                    _bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));
                }
                return points;
            },
            _pathDataToBezier = function _pathDataToBezier(d) {
                var a = (d + "").replace(_scientific, function(m) {
                        var n = +m;
                        return n < 0.0001 && n > -0.0001 ? 0 : n;
                    }).match(_svgPathExp) || [],
                    path = [],
                    relativeX = 0,
                    relativeY = 0,
                    elements = a.length,
                    l = 2,
                    i, x, y, command, isRelative, segment, startX, startY, prevCommand, difX, difY;
                for (i = 0; i < elements; i++) {
                    prevCommand = command;
                    if (isNaN(a[i])) {
                        command = a[i].toUpperCase();
                        isRelative = command !== a[i];
                    } else {
                        i--;
                    }
                    x = +a[i + 1];
                    y = +a[i + 2];
                    if (isRelative) {
                        x += relativeX;
                        y += relativeY;
                    }
                    if (!i) {
                        startX = x;
                        startY = y;
                    }
                    if (command === "M") {
                        if (segment && segment.length < 8) {
                            path.length -= 1;
                            l = 0;
                        }
                        relativeX = startX = x;
                        relativeY = startY = y;
                        segment = [x, y];
                        l = 2;
                        path.push(segment);
                        i += 2;
                        command = "L";
                    } else if (command === "C") {
                        if (!segment) {
                            segment = [0, 0];
                        }
                        segment[l++] = x;
                        segment[l++] = y;
                        if (!isRelative) {
                            relativeX = relativeY = 0;
                        }
                        segment[l++] = relativeX + a[i + 3] * 1;
                        segment[l++] = relativeY + a[i + 4] * 1;
                        segment[l++] = relativeX = relativeX + a[i + 5] * 1;
                        segment[l++] = relativeY = relativeY + a[i + 6] * 1;
                        i += 6;
                    } else if (command === "S") {
                        if (prevCommand === "C" || prevCommand === "S") {
                            difX = relativeX - segment[l - 4];
                            difY = relativeY - segment[l - 3];
                            segment[l++] = relativeX + difX;
                            segment[l++] = relativeY + difY;
                        } else {
                            segment[l++] = relativeX;
                            segment[l++] = relativeY;
                        }
                        segment[l++] = x;
                        segment[l++] = y;
                        if (!isRelative) {
                            relativeX = relativeY = 0;
                        }
                        segment[l++] = relativeX = relativeX + a[i + 3] * 1;
                        segment[l++] = relativeY = relativeY + a[i + 4] * 1;
                        i += 4;
                    } else if (command === "L" || command === "Z") {
                        if (command === "Z") {
                            x = startX;
                            y = startY;
                            segment.closed = true;
                        }
                        if (command === "L" || Math.abs(relativeX - x) > 0.5 || Math.abs(relativeY - y) > 0.5) {
                            segment[l++] = relativeX + (x - relativeX) / 3;
                            segment[l++] = relativeY + (y - relativeY) / 3;
                            segment[l++] = relativeX + (x - relativeX) * 2 / 3;
                            segment[l++] = relativeY + (y - relativeY) * 2 / 3;
                            segment[l++] = x;
                            segment[l++] = y;
                            if (command === "L") {
                                i += 2;
                            }
                        }
                        relativeX = x;
                        relativeY = y;
                    } else {
                        throw _bezierError;
                    }
                }
                return path[0];
            },
            _findMinimum = function _findMinimum(values) {
                var l = values.length,
                    min = 999999999999,
                    i;
                for (i = 1; i < l; i += 6) {
                    if (+values[i] < min) {
                        min = +values[i];
                    }
                }
                return min;
            },
            _normalize = function _normalize(values, height, originY) {
                if (!originY && originY !== 0) {
                    originY = Math.max(+values[values.length - 1], +values[1]);
                }
                var tx = +values[0] * -1,
                    ty = -originY,
                    l = values.length,
                    sx = 1 / (+values[l - 2] + tx),
                    sy = -height || (Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty),
                    i;
                if (sy) {
                    sy = 1 / sy;
                } else {
                    sy = -sx;
                }
                for (i = 0; i < l; i += 2) {
                    values[i] = (+values[i] + tx) * sx;
                    values[i + 1] = (+values[i + 1] + ty) * sy;
                }
            },
            _getRatio = function _getRatio(p) {
                var point = this.lookup[p * this.l | 0] || this.lookup[this.l - 1];
                if (point.nx < p) {
                    point = point.n;
                }
                return point.y + (p - point.x) / point.cx * point.cy;
            },
            CustomEase = function CustomEase(id, data, config) {
                this._calcEnd = true;
                this.id = id;
                if (id) {
                    _TweenLite.Ease.map[id] = this;
                }
                this.getRatio = _getRatio;
                this.setData(data, config);
            },
            p = CustomEase.prototype = new _TweenLite.Ease();
        p.constructor = CustomEase;
        p.setData = function(data, config) {
            data = data || "0,0,1,1";
            var values = data.match(_numbersExp),
                closest = 1,
                points = [],
                l, a1, a2, i, inc, j, point, prevPoint, p, precision;
            config = config || {};
            precision = config.precision || 1;
            this.data = data;
            this.lookup = [];
            this.points = points;
            this.fast = precision <= 1;
            if (_needsParsingExp.test(data) || data.indexOf("M") !== -1 && data.indexOf("C") === -1) {
                values = _pathDataToBezier(data);
            }
            l = values.length;
            if (l === 4) {
                values.unshift(0, 0);
                values.push(1, 1);
                l = 8;
            } else if ((l - 2) % 6) {
                throw _bezierError;
            }
            if (+values[0] !== 0 || +values[l - 2] !== 1) {
                _normalize(values, config.height, config.originY);
            }
            this.rawBezier = values;
            for (i = 2; i < l; i += 6) {
                a1 = {
                    x: +values[i - 2],
                    y: +values[i - 1]
                };
                a2 = {
                    x: +values[i + 4],
                    y: +values[i + 5]
                };
                points.push(a1, a2);
                _bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 200000), points, points.length - 1);
            }
            l = points.length;
            for (i = 0; i < l; i++) {
                point = points[i];
                prevPoint = points[i - 1] || point;
                if (point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) {
                    prevPoint.cx = point.x - prevPoint.x;
                    prevPoint.cy = point.y - prevPoint.y;
                    prevPoint.n = point;
                    prevPoint.nx = point.x;
                    if (this.fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) {
                        this.fast = false;
                    }
                    if (prevPoint.cx < closest) {
                        if (!prevPoint.cx) {
                            prevPoint.cx = 0.001;
                            if (i === l - 1) {
                                prevPoint.x -= 0.001;
                                closest = Math.min(closest, 0.001);
                                this.fast = false;
                            }
                        } else {
                            closest = prevPoint.cx;
                        }
                    }
                } else {
                    points.splice(i--, 1);
                    l--;
                }
            }
            l = 1 / closest + 1 | 0;
            this.l = l;
            inc = 1 / l;
            j = 0;
            point = points[0];
            if (this.fast) {
                for (i = 0; i < l; i++) {
                    p = i * inc;
                    if (point.nx < p) {
                        point = points[++j];
                    }
                    a1 = point.y + (p - point.x) / point.cx * point.cy;
                    this.lookup[i] = {
                        x: p,
                        cx: inc,
                        y: a1,
                        cy: 0,
                        nx: 9
                    };
                    if (i) {
                        this.lookup[i - 1].cy = a1 - this.lookup[i - 1].y;
                    }
                }
                this.lookup[l - 1].cy = points[points.length - 1].y - a1;
            } else {
                for (i = 0; i < l; i++) {
                    if (point.nx < i * inc) {
                        point = points[++j];
                    }
                    this.lookup[i] = point;
                }
                if (j < points.length - 1) {
                    this.lookup[i - 1] = points[points.length - 2];
                }
            }
            this._calcEnd = points[points.length - 1].y !== 1 || points[0].y !== 0;
            return this;
        };
        p.getRatio = _getRatio;
        p.getSVGData = function(config) {
            return CustomEase.getSVGData(this, config);
        };
        CustomEase.create = function(id, data, config) {
            return new CustomEase(id, data, config);
        };
        CustomEase.version = "0.2.2";
        CustomEase.bezierToPoints = _bezierToPoints;
        CustomEase.get = function(id) {
            return _TweenLite.Ease.map[id];
        };
        CustomEase.getSVGData = function(ease, config) {
            config = config || {};
            var rnd = 1000,
                width = config.width || 100,
                height = config.height || 100,
                x = config.x || 0,
                y = (config.y || 0) + height,
                e = config.path,
                a, slope, i, inc, tx, ty, precision, threshold, prevX, prevY;
            if (config.invert) {
                height = -height;
                y = 0;
            }
            ease = ease.getRatio ? ease : _TweenLite.Ease.map[ease] || console.log("No ease found: ", ease);
            if (!ease.rawBezier) {
                a = ["M" + x + "," + y];
                precision = Math.max(5, (config.precision || 1) * 200);
                inc = 1 / precision;
                precision += 2;
                threshold = 5 / precision;
                prevX = ((x + inc * width) * rnd | 0) / rnd;
                prevY = ((y + ease.getRatio(inc) * -height) * rnd | 0) / rnd;
                slope = (prevY - y) / (prevX - x);
                for (i = 2; i < precision; i++) {
                    tx = ((x + i * inc * width) * rnd | 0) / rnd;
                    ty = ((y + ease.getRatio(i * inc) * -height) * rnd | 0) / rnd;
                    if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) {
                        a.push(prevX + "," + prevY);
                        slope = (ty - prevY) / (tx - prevX);
                    }
                    prevX = tx;
                    prevY = ty;
                }
            } else {
                a = [];
                precision = ease.rawBezier.length;
                for (i = 0; i < precision; i += 2) {
                    a.push(((x + ease.rawBezier[i] * width) * rnd | 0) / rnd + "," + ((y + ease.rawBezier[i + 1] * -height) * rnd | 0) / rnd);
                }
                a[0] = "M" + a[0];
                a[1] = "C" + a[1];
            }
            if (e) {
                (typeof e === "string" ? document.querySelector(e) : e).setAttribute("d", a.join(" "));
            }
            return a.join(" ");
        };
        return CustomEase;
    }, true);
    /*!
     * VERSION: 0.2.2
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     **/
    var CustomEase = exports.CustomEase = _TweenLite._gsScope.CustomEase;
    exports.default = CustomEase;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _gsap = __webpack_require__(0);
    var _three = __webpack_require__(4);
    var _const = __webpack_require__(8);

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var ImageReveal = function() {
        function ImageReveal(opts) {
            var _this = this;
            _classCallCheck(this, ImageReveal);
            CustomEase.create('easingBuffa', _const.BUFFA_EASE_CURVE);
            this.opts = opts;
            this.vertexShader = "\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n      }";
            this.fragmentShader = "\n      varying vec2 vUv;\n      uniform float dispFactor;\n      uniform sampler2D disp;\n      uniform sampler2D texture1;\n      uniform sampler2D texture2;\n      uniform float angle1;\n      uniform float angle2;\n      uniform float intensity1;\n      uniform float intensity2;\n\n      mat2 getRotM(float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n        return mat2(c, -s, s, c);\n      }\n\n      void main() {\n        vec4 disp = texture2D(disp, vUv);\n        vec2 dispVec = vec2(disp.r, disp.g);\n        vec2 distortedPosition1 = vUv + getRotM(angle1) * dispVec * intensity1 * dispFactor;\n        vec2 distortedPosition2 = vUv + getRotM(angle2) * dispVec * intensity2 * (1.0 - dispFactor);\n        vec4 _texture1 = texture2D(texture1, distortedPosition1);\n        vec4 _texture2 = texture2D(texture2, distortedPosition2);\n        gl_FragColor = mix(_texture1, _texture2, dispFactor);\n      }";
            this.parent = this.opts.parent;
            this.dispImage = this.opts.displacementImage;
            this.image1 = this.opts.image1;
            this.image2 = this.opts.image2;
            this.image2Mob = this.opts.image2Mob;
            this.intensity1 = this._firstDefined(this.opts.intensity1, this.opts.intensity, 1);
            this.intensity2 = this._firstDefined(this.opts.intensity2, this.opts.intensity, 1);
            this.commonAngle = this._firstDefined(this.opts.angle, Math.PI / 4);
            this.angle1 = this._firstDefined(this.opts.angle1, this.commonAngle);
            this.angle2 = this._firstDefined(this.opts.angle2, -this.commonAngle * 3);
            this.speedIn = this._firstDefined(this.opts.speedIn, this.opts.speed, 1.6);
            this.speedOut = this._firstDefined(this.opts.speedOut, this.opts.speed, 1.2);
            this.userHover = this._firstDefined(this.opts.hover, true);
            this.easing = this._firstDefined(this.opts.easing, "easingBuffa");
            this.once = this._firstDefined(this.opts.once, false);
            this.scene = null;
            this.camera = null;
            this.renderer = null;
            this.mat = null;
            this.loader = null;
            this.mouseenterCallback = function(_) {
                return _this._transitionIn();
            };
            this.touchstartCallback = function(_) {
                return _this._transitionIn();
            };
            this.mouseleaveCallback = function(_) {
                return _this._transitionOut();
            };
            this.touchendCallback = function(_) {
                return _this._transitionOut();
            };
            this.resizeCallback = function(_) {
                return _this._resize();
            };
            if (!this.parent) {
                console.warn('Parent missing');
                return;
            }
            if (!(this.image1 && this.image2 && this.dispImage)) {
                console.warn('One or more images are missing');
                return;
            }
            this.init();
        }
        _createClass(ImageReveal, [{
            key: "init",
            value: function init() {
                this._setupScene();
                this._setupDisplacement();
                this._setupListeners();
            }
        }, {
            key: "_firstDefined",
            value: function _firstDefined() {
                for (var i = 0; i < arguments.length; i++) {
                    if (arguments[i] !== undefined) return arguments[i];
                }
            }
        }, {
            key: "_setupScene",
            value: function _setupScene() {
                this.scene = new _three.Scene();
                this.camera = new _three.OrthographicCamera(this.parent.offsetWidth / -2, this.parent.offsetWidth / 2, this.parent.offsetHeight / 2, this.parent.offsetHeight / -2, 1, 1000);
                this.camera.position.z = 1;
                this.renderer = new _three.WebGLRenderer({
                    antialias: false,
                    alpha: true
                });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setClearColor(0x000000, 0.0);
                this.renderer.setSize(this.parent.offsetWidth, this.parent.offsetHeight);
                this.parent.appendChild(this.renderer.domElement);
            }
        }, {
            key: "_render",
            value: function _render() {
                if (this.renderer) this.renderer.render(this.scene, this.camera);
            }
        }, {
            key: "_setupDisplacement",
            value: function _setupDisplacement() {
                this.loader = new _three.TextureLoader();
                this.loader.crossOrigin = '';
                var texture1 = this.loader.load(this.image1, this._render());
                var texture2 = this.loader.load(this.image2Mob && !window.matchMedia("(min-width: 640px)").matches ? this.image2Mob : this.image2, this._render());
                var disp = this.loader.load(this.dispImage, this._render());
                disp.wrapS = disp.wrapT = _three.RepeatWrapping;
                texture1.magFilter = texture2.magFilter = _three.LinearFilter;
                texture1.minFilter = texture2.minFilter = _three.LinearFilter;
                this.mat = new _three.ShaderMaterial({
                    uniforms: {
                        intensity1: {
                            type: 'f',
                            value: this.intensity1
                        },
                        intensity2: {
                            type: 'f',
                            value: this.intensity2
                        },
                        dispFactor: {
                            type: 'f',
                            value: 0.0
                        },
                        angle1: {
                            type: 'f',
                            value: this.angle1
                        },
                        angle2: {
                            type: 'f',
                            value: this.angle2
                        },
                        texture1: {
                            type: 't',
                            value: texture1
                        },
                        texture2: {
                            type: 't',
                            value: texture2
                        },
                        disp: {
                            type: 't',
                            value: disp
                        }
                    },
                    vertexShader: this.vertexShader,
                    fragmentShader: this.fragmentShader,
                    transparent: true,
                    opacity: 1.0
                });
                var geometry = new _three.PlaneBufferGeometry(this.parent.offsetWidth, this.parent.offsetHeight, 1);
                var object = new _three.Mesh(geometry, this.mat);
                this.scene.add(object);
            }
        }, {
            key: "_transitionIn",
            value: function _transitionIn() {
                var _this2 = this;
                return new Promise(function(resolve) {
                    var _self = _this2;
                    _gsap.TweenMax.to(_this2.mat.uniforms.dispFactor, _this2.speedIn, {
                        value: 1,
                        ease: _self.easing,
                        onUpdate: _self._render,
                        onUpdateScope: _self,
                        onComplete: function onComplete(_) {
                            _self._render;
                            if (_self.once) _self.replaceWithImage();
                            resolve();
                        },
                        onCompleteScope: _self
                    });
                });
            }
        }, {
            key: "_transitionOut",
            value: function _transitionOut() {
                var _this3 = this;
                return new Promise(function(resolve) {
                    var _self = _this3;
                    _gsap.TweenMax.to(_this3.mat.uniforms.dispFactor, _this3.speedOut, {
                        value: 0,
                        ease: _self.easing,
                        onUpdate: _self._render,
                        onUpdateScope: _self,
                        onComplete: function onComplete(_) {
                            _self._render;
                            resolve();
                        },
                        onCompleteScope: _self
                    });
                });
            }
        }, {
            key: "_resize",
            value: function _resize() {
                if (this.renderer === null) return;
                this.renderer.setSize(this.parent.offsetWidth, this.parent.offsetHeight);
            }
        }, {
            key: "_setupListeners",
            value: function _setupListeners() {
                var _this4 = this;
                if (this.userHover) {
                    this.parent.addEventListener('mouseenter', function(_) {
                        return _this4.mouseenterCallback;
                    });
                    this.parent.addEventListener('touchstart', function(_) {
                        return _this4.touchstartCallback;
                    });
                    this.parent.addEventListener('mouseleave', function(_) {
                        return _this4.mouseleaveCallback;
                    });
                    this.parent.addEventListener('touchend', function(_) {
                        return _this4.touchendCallback;
                    });
                }
                window.addEventListener('resize', this.resizeCallback);
            }
        }, {
            key: "next",
            value: function next() {
                var _this5 = this;
                return new Promise(function(resolve) {
                    _this5._transitionIn().then(function(_) {
                        return resolve();
                    });
                });
            }
        }, {
            key: "prev",
            value: function prev() {
                var _this6 = this;
                return new Promise(function(resolve) {
                    _this6._transitionOut().then(function(_) {
                        return resolve();
                    });
                });
            }
        }, {
            key: "destroyContext",
            value: function destroyContext() {
                this.renderer.forceContextLoss();
                this.renderer.context = null;
                this.renderer.domElement = null;
                this.renderer = null;
            }
        }, {
            key: "destroy",
            value: function destroy() {
                var _this7 = this;
                this.destroyContext();
                if (this.userHover) {
                    this.parent.removeEventListener('mouseenter', function(_) {
                        return _this7.mouseenterCallback;
                    });
                    this.parent.removeEventListener('touchstart', function(_) {
                        return _this7.touchstartCallback;
                    });
                    this.parent.removeEventListener('mouseleave', function(_) {
                        return _this7.mouseleaveCallback;
                    });
                    this.parent.removeEventListener('touchend', function(_) {
                        return _this7.touchendCallback;
                    });
                }
                window.removeEventListener('resize', this.resizeCallback);
            }
        }, {
            key: "replaceWithImage",
            value: function replaceWithImage() {
                var _this8 = this;
                this.parent.style.backgroundImage = "url(" + this.image2 + ")";
                this.parent.style.backgroundPosition = "center center";
                this.parent.style.backgroundRepeat = "no-repeat";
                this.parent.style.backgroundSize = "cover";
                setTimeout(function(_) {
                    _this8.destroyContext();
                    var canvas = _this8.parent.querySelector("canvas");
                    _this8.parent.removeChild(canvas);
                }, 500);
            }
        }]);
        return ImageReveal;
    }();
    exports.default = ImageReveal;
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "b", function() {
        return win;
    });
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return doc;
    });
    var doc = (typeof document === 'undefined') ? {
        body: {},
        addEventListener: function addEventListener() {},
        removeEventListener: function removeEventListener() {},
        activeElement: {
            blur: function blur() {},
            nodeName: '',
        },
        querySelector: function querySelector() {
            return null;
        },
        querySelectorAll: function querySelectorAll() {
            return [];
        },
        getElementById: function getElementById() {
            return null;
        },
        createEvent: function createEvent() {
            return {
                initEvent: function initEvent() {},
            };
        },
        createElement: function createElement() {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute: function setAttribute() {},
                getElementsByTagName: function getElementsByTagName() {
                    return [];
                },
            };
        },
        location: {
            hash: ''
        },
    } : document;
    var win = (typeof window === 'undefined') ? {
        document: doc,
        navigator: {
            userAgent: '',
        },
        location: {},
        history: {},
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener: function addEventListener() {},
        removeEventListener: function removeEventListener() {},
        getComputedStyle: function getComputedStyle() {
            return {
                getPropertyValue: function getPropertyValue() {
                    return '';
                },
            };
        },
        Image: function Image() {},
        Date: function Date() {},
        screen: {},
        setTimeout: function setTimeout() {},
        clearTimeout: function clearTimeout() {},
    } : window;
}), (function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(28);
}), (function(module, exports, __webpack_require__) {
    "use strict";
    var _jquery = __webpack_require__(3);
    var _jquery2 = _interopRequireDefault(_jquery);
    __webpack_require__(13);
    __webpack_require__(43);
    __webpack_require__(48);
    var _smoothscrollForWebsites = __webpack_require__(76);
    var _smoothscrollForWebsites2 = _interopRequireDefault(_smoothscrollForWebsites);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    window.$ = _jquery2.default;
    (0, _smoothscrollForWebsites2.default)({
        animationTime: 900,
        stepSize: 140,
        accelerationDelta: 100,
        accelerationMax: 2
    });
    (0, _jquery2.default)(document).foundation();
    if ("serviceWorker" in navigator) {
        window.addEventListener("load", function(_) {
            navigator.serviceWorker.register(BUFFA.assets_url + '/js/service-worker.js');
        });
    }
}), (function(module, exports, __webpack_require__) {
    "use strict";
    var has = Object.prototype.hasOwnProperty,
        prefix = '~';

    function Events() {}
    if (Object.create) {
        Events.prototype = Object.create(null);
        if (!new Events().__proto__) prefix = false;
    }

    function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
    }

    function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== 'function') {
            throw new TypeError('The listener must be a function');
        }
        var listener = new EE(fn, context || emitter, once),
            evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
    }

    function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
    }

    function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
        var names = [],
            events, name;
        if (this._eventsCount === 0) return names;
        for (name in (events = this._events)) {
            if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
            return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event,
            handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
            ee[i] = handlers[i].fn;
        }
        return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event,
            listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt],
            len = arguments.length,
            args, i;
        if (listeners.fn) {
            if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
            switch (len) {
                case 1:
                    return listeners.fn.call(listeners.context), true;
                case 2:
                    return listeners.fn.call(listeners.context, a1), true;
                case 3:
                    return listeners.fn.call(listeners.context, a1, a2), true;
                case 4:
                    return listeners.fn.call(listeners.context, a1, a2, a3), true;
                case 5:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                case 6:
                    return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }
            for (i = 1, args = new Array(len - 1); i < len; i++) {
                args[i - 1] = arguments[i];
            }
            listeners.fn.apply(listeners.context, args);
        } else {
            var length = listeners.length,
                j;
            for (i = 0; i < length; i++) {
                if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
                switch (len) {
                    case 1:
                        listeners[i].fn.call(listeners[i].context);
                        break;
                    case 2:
                        listeners[i].fn.call(listeners[i].context, a1);
                        break;
                    case 3:
                        listeners[i].fn.call(listeners[i].context, a1, a2);
                        break;
                    case 4:
                        listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                        break;
                    default:
                        if (!args)
                            for (j = 1, args = new Array(len - 1); j < len; j++) {
                                args[j - 1] = arguments[j];
                            }
                        listeners[i].fn.apply(listeners[i].context, args);
                }
            }
        }
        return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
            clearEvent(this, evt);
            return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                clearEvent(this, evt);
            }
        } else {
            for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                if (listeners[i].fn !== fn || (once && !listeners[i].once) || (context && listeners[i].context !== context)) {
                    events.push(listeners[i]);
                }
            }
            if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
            else clearEvent(this, evt);
        }
        return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
            evt = prefix ? prefix + event : event;
            if (this._events[evt]) clearEvent(this, evt);
        } else {
            this._events = new Events();
            this._eventsCount = 0;
        }
        return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if (true) {
        module.exports = EventEmitter;
    }
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _three = __webpack_require__(4);
    var _events = __webpack_require__(5);
    var _events2 = _interopRequireDefault(_events);
    var _trail = __webpack_require__(31);
    var _trail2 = _interopRequireDefault(_trail);
    var _mathToolbox = __webpack_require__(37);
    var _viewport = __webpack_require__(10);
    var _viewport2 = _interopRequireDefault(_viewport);
    var _defaults = __webpack_require__(14);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var vertexShader = __webpack_require__(38);
    var fragmentShader = __webpack_require__(39);
    var Quad = function(_Object3D) {
        _inherits(Quad, _Object3D);

        function Quad(renderer) {
            _classCallCheck(this, Quad);
            var _this = _possibleConstructorReturn(this, (Quad.__proto__ || Object.getPrototypeOf(Quad)).call(this));
            var texture = new _three.TextureLoader().load(BUFFA.assets_url + '/images/noise.jpg');
            texture.wrapS = _three.RepeatWrapping;
            texture.wrapT = _three.RepeatWrapping;
            texture.repeat.set(4, 4);
            _this.trail = new _trail2.default(renderer);
            _this.geometry = new _three.BufferGeometry();
            var vertices = new Float32Array([1, -1, 0, -1, 1, 0, 0, 0, 1]);
            _this.geometry.addAttribute('position', new _three.BufferAttribute(vertices, 3));
            _this.geometry.rotateX(Math.PI / 2);
            _this.geometry.rotateZ(Math.PI / 2);
            _this.geometry.center();
            _this.geometry.scale(20, 20, 20);
            _this.material = new _three.RawShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: _extends({}, _defaults.backgroundDefaults, {
                    _resolution: {
                        value: new _three.Vector2(_viewport2.default.canvasWidth, _viewport2.default.canvasHeight)
                    },
                    _texture: {
                        value: texture
                    },
                    _trail: {
                        value: _this.trail.fbo.current
                    }
                })
            });
            _this.mesh = new _three.Mesh(_this.geometry, _this.material);
            _this.add(_this.mesh);
            _this.onUpdate = _this.onUpdate.bind(_this);
            _this.bind();
            return _this;
        }
        _createClass(Quad, [{
            key: 'bind',
            value: function bind() {
                var _this2 = this;
                _events2.default.on(_events2.default.RAF, this.onUpdate);
                this.updatePatternSize();
                window.addEventListener('resize', function() {
                    _this2.material.uniforms._resolution.value.x = _viewport2.default.canvasWidth;
                    _this2.material.uniforms._resolution.value.y = _viewport2.default.canvasHeight;
                    _this2.updatePatternSize();
                });
            }
        }, {
            key: 'updatePatternSize',
            value: function updatePatternSize() {
                var size = (0, _mathToolbox.map)(window.innerWidth, 320, 1600, 2.4, 14);
                size = (0, _mathToolbox.clamp)(2.4, 14, size);
                this.material.uniforms._sizePattern.value = size;
            }
        }, {
            key: 'onUpdate',
            value: function onUpdate(delta) {
                this.material.uniforms._time.value += 1;
                this.trail.update();
            }
        }]);
        return Quad;
    }(_three.Object3D);
    exports.default = Quad;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _three = __webpack_require__(4);
    var THREE = _interopRequireWildcard(_three);
    var _pointer = __webpack_require__(32);
    var _pointer2 = _interopRequireDefault(_pointer);
    var _fbo = __webpack_require__(35);
    var _fbo2 = _interopRequireDefault(_fbo);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
            return obj;
        } else {
            var newObj = {};
            if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                }
            }
            newObj.default = obj;
            return newObj;
        }
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var simulation = __webpack_require__(36);
    var Trail = function(_THREE$Group) {
        _inherits(Trail, _THREE$Group);

        function Trail(renderer) {
            _classCallCheck(this, Trail);
            var _this = _possibleConstructorReturn(this, (Trail.__proto__ || Object.getPrototypeOf(Trail)).call(this));
            _this.size = 16;
            _this.count = _this.size * _this.size;
            _this.renderer = renderer;
            _this.createTextureData();
            _this.createFBO();
            return _this;
        }
        _createClass(Trail, [{
            key: 'createTextureData',
            value: function createTextureData() {
                var data = new Float32Array(this.count * 4);
                this.dataTexturePlane = new THREE.DataTexture(data, this.size, this.size, THREE.RGBAFormat, THREE.FloatType);
                var i4 = 0;
                for (var i = 0; i < this.count; i++) {
                    this.dataTexturePlane.image.data[i4 + 0] = 0;
                    this.dataTexturePlane.image.data[i4 + 1] = 0;
                    this.dataTexturePlane.image.data[i4 + 2] = 0;
                    this.dataTexturePlane.image.data[i4 + 3] = 1;
                    i4 += 4;
                }
                this.uvs = new Float32Array(this.count * 2);
                var width = this.size;
                var height = this.size;
                var p = 0;
                for (var j = 0; j < width; j++) {
                    for (var _i = 0; _i < height; _i++) {
                        this.uvs[p++] = _i / (width - 1);
                        this.uvs[p++] = j / (height - 1);
                    }
                }
                this.dataTexturePlane.needsUpdate = true;
            }
        }, {
            key: 'createFBO',
            value: function createFBO() {
                this.simulationMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        t_pos: {
                            type: "t",
                            value: this.dataTexturePlane
                        },
                        t_oPos: {
                            type: "t",
                            value: null
                        },
                        mouse: {
                            type: 'v2',
                            value: new THREE.Vector3()
                        },
                        utime: {
                            value: performance.now()
                        }
                    },
                    vertexShader: 'varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}',
                    fragmentShader: simulation,
                    depthWrite: false,
                    depthTest: false,
                    type: "SimulationMaterial"
                });
                this.fbo = new _fbo2.default(this.renderer, this.size, this.size, this.simulationMaterial);
            }
        }, {
            key: 'update',
            value: function update() {
                this.fbo.update();
                this.simulationMaterial.uniforms.mouse.value.x = (_pointer2.default.normalized.x + 1) / 2;
                this.simulationMaterial.uniforms.mouse.value.y = (_pointer2.default.normalized.y + 1) / 2;
                this.simulationMaterial.uniforms.mouse.value.z = Math.abs(_pointer2.default.velocity.x) + Math.abs(_pointer2.default.velocity.y);
                this.simulationMaterial.uniforms.utime.value = performance.now();
            }
        }]);
        return Trail;
    }(THREE.Group);
    exports.default = Trail;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _three = __webpack_require__(4);
    var _raf = __webpack_require__(33);
    var _raf2 = _interopRequireDefault(_raf);
    var _viewport = __webpack_require__(10);
    var _viewport2 = _interopRequireDefault(_viewport);
    var _events = __webpack_require__(5);
    var _events2 = _interopRequireDefault(_events);
    var _velocityTracker = __webpack_require__(34);
    var _velocityTracker2 = _interopRequireDefault(_velocityTracker);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Pointer = function() {
        function Pointer() {
            _classCallCheck(this, Pointer);
            this.x = 0;
            this.y = 0;
            this.hold = new _three.Vector2();
            this.last = new _three.Vector2();
            this.delta = new _three.Vector2();
            this.move = new _three.Vector2();
            this.tracker = new _velocityTracker2.default(this);
            this.velocity = this.tracker.velocity;
            this.normalized = new _three.Vector2();
            this._tmp = new _three.Vector3();
            this.world = new _three.Vector3();
            this.distance = 0;
            this.isTouching = false;
            this.bind();
        }
        _createClass(Pointer, [{
            key: 'bind',
            value: function bind() {
                window.addEventListener('touchstart', this.onStart.bind(this));
                window.addEventListener('touchmove', this.onMove.bind(this));
                window.addEventListener('touchend', this.onEnd.bind(this));
                window.addEventListener('touchcancel', this.onEnd.bind(this));
                window.addEventListener('mousedown', this.onStart.bind(this));
                window.addEventListener('mousemove', this.onMove.bind(this));
                window.addEventListener('mouseup', this.onEnd.bind(this));
                window.addEventListener('contextmenu', this.onEnd.bind(this));
            }
        }, {
            key: 'onStart',
            value: function onStart(event) {
                var e = Pointer.convertEvent(event);
                this.isTouching = true;
                this.x = e.x;
                this.y = e.y;
                this.hold.set(e.x, e.y);
                this.last.set(e.x, e.y);
                this.delta.set(0, 0);
                this.move.set(0, 0);
                this.normalized.x = this.x / _viewport2.default.width * 2 - 1;
                this.normalized.y = -(this.y / _viewport2.default.height) * 2 + 1;
                this.distance = 0;
                _events2.default.emit(_events2.default.POINTER_START, this);
                this.timeDown = _raf2.default.time;
                this.timeMove = _raf2.default.time;
            }
        }, {
            key: 'onMove',
            value: function onMove(event) {
                var e = Pointer.convertEvent(event);
                if (this.isTouching) {
                    this.move.x = e.x - this.hold.x;
                    this.move.y = e.y - this.hold.y;
                }
                this.x = e.x;
                this.y = e.y;
                this.delta.x = e.x - this.last.x;
                this.delta.y = e.y - this.last.y;
                this.last.set(e.x, e.y);
                this.distance += this.delta.length();
                this.timeMove = _raf2.default.time;
                this.normalized.x = this.x / _viewport2.default.width * 2 - 1;
                this.normalized.y = -(this.y / _viewport2.default.height) * 2 + 1;
                _events2.default.emit(_events2.default.POINTER_MOVE, this);
                if (this.isTouching) {
                    _events2.default.emit(_events2.default.POINTER_DRAG, this);
                }
            }
        }, {
            key: 'onEnd',
            value: function onEnd() {
                this.isTouching = false;
                this.move.set(0, 0);
                var delta = this.timeDelta();
                if (delta > 100) {
                    this.delta.set(0, 0);
                }
                _events2.default.emit(_events2.default.POINTER_END, this);
            }
        }, {
            key: 'timeDelta',
            value: function timeDelta() {
                return Math.max(0.001, _raf2.default.time - (this.timeMove || _raf2.default.time));
            }
        }], [{
            key: 'convertEvent',
            value: function convertEvent(e) {
                var t = {
                    x: 0,
                    y: 0
                };
                if (e.windowsPointer) {
                    return e;
                }
                if (!e) {
                    return t;
                }
                if (e.touches || e.changedTouches) {
                    if (e.touches.length) {
                        t.x = e.touches[0].pageX;
                        t.y = e.touches[0].pageY;
                    } else {
                        t.x = e.changedTouches[0].pageX;
                        t.y = e.changedTouches[0].pageY;
                    }
                } else {
                    t.x = e.pageX;
                    t.y = e.pageY;
                }
                return t;
            }
        }]);
        return Pointer;
    }();
    exports.default = new Pointer();
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _events = __webpack_require__(5);
    var _events2 = _interopRequireDefault(_events);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Raf = function() {
        function Raf() {
            _classCallCheck(this, Raf);
            this.fps = undefined;
            this.time = window.performance.now();
            this.start = this.start.bind(this);
            this.pause = this.pause.bind(this);
            this.onTick = this.onTick.bind(this);
            this.start();
            this.bind();
            window.requestAnimationFrame(this.onTick);
        }
        _createClass(Raf, [{
            key: 'bind',
            value: function bind() {}
        }, {
            key: 'start',
            value: function start() {
                this.startTime = window.performance.now();
                this.oldTime = this.startTime;
                this.isPaused = false;
            }
        }, {
            key: 'pause',
            value: function pause() {
                this.isPaused = true;
            }
        }, {
            key: 'onTick',
            value: function onTick(now) {
                this.time = now;
                if (!this.isPaused) {
                    this.delta = (now - this.oldTime) / 1000;
                    this.oldTime = now;
                    _events2.default.emit(_events2.default.RAF, this.delta, now);
                }
                window.requestAnimationFrame(this.onTick);
            }
        }]);
        return Raf;
    }();
    exports.default = new Raf();
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _three = __webpack_require__(4);
    var _events = __webpack_require__(5);
    var _events2 = _interopRequireDefault(_events);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var VelocityTracker = function() {
        function VelocityTracker(vector) {
            _classCallCheck(this, VelocityTracker);
            this.vector = vector;
            this.last = new _three.Vector3();
            this.velocity = new _three.Vector3();
            this.onUpdate = this.onUpdate.bind(this);
            this.init();
        }
        _createClass(VelocityTracker, [{
            key: 'init',
            value: function init() {
                this.bind();
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                this.unbind();
            }
        }, {
            key: 'bind',
            value: function bind() {
                _events2.default.on(_events2.default.RAF, this.onUpdate);
            }
        }, {
            key: 'unbind',
            value: function unbind() {
                _events2.default.off(_events2.default.RAF, this.onUpdate);
            }
        }, {
            key: 'onUpdate',
            value: function onUpdate(delta) {
                this.velocity.copy(this.vector).sub(this.last);
                this.last.copy(this.vector);
                this.velocity.multiplyScalar(delta);
            }
        }]);
        return VelocityTracker;
    }();
    exports.default = VelocityTracker;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.FBO = undefined;
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _three = __webpack_require__(4);
    var THREE = _interopRequireWildcard(_three);

    function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
            return obj;
        } else {
            var newObj = {};
            if (obj != null) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                }
            }
            newObj.default = obj;
            return newObj;
        }
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var FBO = function() {
        function FBO(renderer, width, height, simulation) {
            _classCallCheck(this, FBO);
            this.simulation = simulation;
            this.renderer = renderer;
            var options = {
                wrapS: THREE.ClampToEdgeWrapping,
                wrapT: THREE.ClampToEdgeWrapping,
                format: THREE.RGBAFormat,
                type: THREE.FloatType,
                stencilBuffer: false,
                depthBuffer: false,
                generateMipmaps: false
            };
            this.rt = new THREE.WebGLRenderTarget(width, height, options);
            this.rt2 = new THREE.WebGLRenderTarget(width, height, options);
            this.rt3 = new THREE.WebGLRenderTarget(width, height, options);
            this.scene = new THREE.Scene();
            this.orthoCamera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0, 1);
            this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1, 1, 1));
            this.scene.add(this.mesh);
            this.texture = this.simulation.uniforms.t_pos.value;
        }
        _createClass(FBO, [{
            key: "setSimulation",
            value: function setSimulation(simulation) {
                this.simulation = simulation;
                this.mesh.material = this.simulation;
                this.simulation.uniforms.t_pos.value = this.rt3.texture;
                this.simulation.uniforms.t_oPos.value = this.rt2.texture;
            }
        }, {
            key: "update",
            value: function update(dt) {
                this.renderer.setClearColor(0);
                this.renderer.render(this.scene, this.orthoCamera, this.rt);
                var tmp = this.rt;
                this.rt = this.rt2;
                this.rt2 = this.rt3;
                this.rt3 = tmp;
                this.simulation.uniforms.t_pos.value = this.rt3.texture;
                this.simulation.uniforms.t_oPos.value = this.rt2.texture;
            }
        }, {
            key: "copy",
            value: function copy() {
                var material = new THREE.ShaderMaterial({
                    uniforms: {
                        t_pos: {
                            type: "t",
                            value: this.simulation.uniforms.t_pos.value
                        }
                    },
                    vertexShader: "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",
                    fragmentShader: "varying vec2 vUv;\nuniform sampler2D t_pos;\n\nvoid main() {\n\tgl_FragColor = texture2D( t_pos, vUv );\n}\n"
                });
                this.mesh.material = material;
                this.update();
                this.update();
                this.update();
                material.dispose();
                this.mesh.material = this.simulation;
            }
        }, {
            key: "debug",
            value: function debug() {
                this.debug1 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), new THREE.MeshBasicMaterial({
                    map: this.rt.texture
                }));
                this.debug2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), new THREE.MeshBasicMaterial({
                    map: this.rt2.texture
                }));
                this.debug3 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), new THREE.MeshBasicMaterial({
                    map: this.rt3.texture
                }));
                this.debug2.position.x = 2.1;
                this.debug3.position.x = -2.1;
                stage3d.add(this.debug1);
                stage3d.add(this.debug2);
                stage3d.add(this.debug3);
            }
        }, {
            key: "texture",
            set: function set(value) {
                this.simulation.uniforms.t_pos.value = value;
                this.copy();
            }
        }, {
            key: "current",
            get: function get() {
                return this.rt2.texture;
            }
        }, {
            key: "old",
            get: function get() {
                return this.rt3.texture;
            }
        }]);
        return FBO;
    }();
    exports.default = FBO;
    exports.FBO = FBO;
}), (function(module, exports) {
    module.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D t_pos;\nuniform sampler2D t_oPos;\nuniform vec3 mouse;\nvarying vec2 vUv;\nuniform float utime;\n\nvoid main() {\n\tvec4 position = texture2D( t_pos, vUv );\n\n\t// position.y += 0.1;\n\n  // vec2 ruv = gl_FragCoord.xy / vec2(1024.0, 800.0);\n\n  // position.rg = vUv;\n  // position.rg = mouse;\n\n  position.r += (max(0.0, (1.0 - (distance(vUv, mouse.xy) * 10.2))) * 0.1) * clamp(mouse.z, 0.0, 4.0);\n  position.r *= 0.97;\n  position.r = clamp(position.r, 0.0, 0.6);\n\n\tgl_FragColor = position;\n}\n"
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
    });
    __webpack_require__.d(__webpack_exports__, "clamp", function() {
        return clamp;
    });
    __webpack_require__.d(__webpack_exports__, "clamp01", function() {
        return clamp01;
    });
    __webpack_require__.d(__webpack_exports__, "step", function() {
        return step;
    });
    __webpack_require__.d(__webpack_exports__, "map", function() {
        return map;
    });
    __webpack_require__.d(__webpack_exports__, "diagonal", function() {
        return diagonal;
    });
    __webpack_require__.d(__webpack_exports__, "distance", function() {
        return distance;
    });
    __webpack_require__.d(__webpack_exports__, "smoothStep", function() {
        return smoothStep;
    });
    __webpack_require__.d(__webpack_exports__, "lerp", function() {
        return lerp;
    });
    __webpack_require__.d(__webpack_exports__, "mix", function() {
        return lerp;
    });
    __webpack_require__.d(__webpack_exports__, "normalize", function() {
        return normalize;
    });
    __webpack_require__.d(__webpack_exports__, "randomFloat", function() {
        return randomFloat;
    });
    __webpack_require__.d(__webpack_exports__, "randomInt", function() {
        return randomInt;
    });
    __webpack_require__.d(__webpack_exports__, "randomSign", function() {
        return randomSign;
    });
    __webpack_require__.d(__webpack_exports__, "wrap", function() {
        return wrap;
    });
    __webpack_require__.d(__webpack_exports__, "degToRad", function() {
        return degToRad;
    });
    __webpack_require__.d(__webpack_exports__, "toRadians", function() {
        return degToRad;
    });
    __webpack_require__.d(__webpack_exports__, "radToDeg", function() {
        return radToDeg;
    });
    __webpack_require__.d(__webpack_exports__, "toDegrees", function() {
        return radToDeg;
    });
    __webpack_require__.d(__webpack_exports__, "fuzzyFloor", function() {
        return fuzzyFloor;
    });
    __webpack_require__.d(__webpack_exports__, "fuzzyCeil", function() {
        return fuzzyCeil;
    });
    __webpack_require__.d(__webpack_exports__, "fuzzyEqual", function() {
        return fuzzyEqual;
    });
    __webpack_require__.d(__webpack_exports__, "fuzzyGreaterThan", function() {
        return fuzzyGreaterThan;
    });
    __webpack_require__.d(__webpack_exports__, "fuzzyLessThan", function() {
        return fuzzyLessThan;
    });
    __webpack_require__.d(__webpack_exports__, "maxAdd", function() {
        return maxAdd;
    });
    __webpack_require__.d(__webpack_exports__, "minSub", function() {
        return minSub;
    });
    __webpack_require__.d(__webpack_exports__, "isOdd", function() {
        return isOdd;
    });
    __webpack_require__.d(__webpack_exports__, "isEven", function() {
        return isEven;
    });
    __webpack_require__.d(__webpack_exports__, "isPowerOfTwo", function() {
        return isPowerOfTwo;
    });
    __webpack_require__.d(__webpack_exports__, "closestPowerOfTwo", function() {
        return closestPowerOfTwo;
    });
    __webpack_require__.d(__webpack_exports__, "nextPowerOfTwo", function() {
        return nextPowerOfTwo;
    });
    __webpack_require__.d(__webpack_exports__, "percent01", function() {
        return percent01;
    });
    __webpack_require__.d(__webpack_exports__, "average", function() {
        return average;
    });
    __webpack_require__.d(__webpack_exports__, "difference", function() {
        return difference;
    });
    __webpack_require__.d(__webpack_exports__, "within", function() {
        return within;
    });
    __webpack_require__.d(__webpack_exports__, "inverseLerp", function() {
        return inverseLerp;
    });
    __webpack_require__.d(__webpack_exports__, "inverseMix", function() {
        return inverseLerp;
    });
    __webpack_require__.d(__webpack_exports__, "lerpUnclamped", function() {
        return lerpUnclamped;
    });
    __webpack_require__.d(__webpack_exports__, "mixUnclamped", function() {
        return lerpUnclamped;
    });
    __webpack_require__.d(__webpack_exports__, "deltaAngleDeg", function() {
        return deltaAngleDeg$$1;
    });
    __webpack_require__.d(__webpack_exports__, "deltaAngle", function() {
        return deltaAngleDeg$$1;
    });
    __webpack_require__.d(__webpack_exports__, "deltaAngleRad", function() {
        return deltaAngleRad$$1;
    });
    __webpack_require__.d(__webpack_exports__, "fract", function() {
        return fract;
    });
    __webpack_require__.d(__webpack_exports__, "mod", function() {
        return mod;
    });
    __webpack_require__.d(__webpack_exports__, "lerpAngleDeg", function() {
        return lerpAngleDeg$$1;
    });
    __webpack_require__.d(__webpack_exports__, "lerpAngle", function() {
        return lerpAngleDeg$$1;
    });
    __webpack_require__.d(__webpack_exports__, "lerpAngleRad", function() {
        return lerpAngleRad$$1;
    });
    __webpack_require__.d(__webpack_exports__, "gammaToLinearSpace", function() {
        return gammaToLinearSpace;
    });
    __webpack_require__.d(__webpack_exports__, "linearToGammaSpace", function() {
        return linearToGammaSpace;
    });
    __webpack_require__.d(__webpack_exports__, "almostIdentity", function() {
        return almostIdentity;
    });
    __webpack_require__.d(__webpack_exports__, "impulse", function() {
        return impulse;
    });
    __webpack_require__.d(__webpack_exports__, "cubicPulse", function() {
        return cubicPulse;
    });
    __webpack_require__.d(__webpack_exports__, "expStep", function() {
        return expStep;
    });
    __webpack_require__.d(__webpack_exports__, "parabola", function() {
        return parabola;
    });
    __webpack_require__.d(__webpack_exports__, "powerCurve", function() {
        return powerCurve;
    });
    __webpack_require__.d(__webpack_exports__, "smoothMin", function() {
        return smoothMin;
    });
    __webpack_require__.d(__webpack_exports__, "smoothMax", function() {
        return smoothMax;
    });
    __webpack_require__.d(__webpack_exports__, "deltaTime", function() {
        return deltaTime;
    });
    __webpack_require__.d(__webpack_exports__, "gcd", function() {
        return gcd;
    });
    __webpack_require__.d(__webpack_exports__, "dotProduct", function() {
        return dotProduct;
    });

    function clamp(min, max, v) {
        return Math.min(max, Math.max(min, v));
    }

    function clamp01(v) {
        return v < 0 ? 0 : v > 1 ? 1 : v;
    }

    function step(edge, v) {
        return v < edge ? 0 : 1;
    }

    function map(value, start1, stop1, start2, stop2) {
        return (value - start1) / (stop1 - start1) * (stop2 - start2) + start2;
    }

    function diagonal(w, h) {
        return Math.sqrt(w * w + h * h);
    }

    function distance(x1, y1, x2, y2) {
        var dx = x1 - x2;
        var dy = y1 - y2;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function smoothStep(min, max, v) {
        var x = Math.max(0, Math.min(1, (v - min) / (max - min)));
        return x * x * (3 - 2 * x);
    }

    function lerp(x, y, r) {
        return x + (y - x) * r;
    }

    function normalize(min, max, x) {
        return (x - min) / (max - min);
    }

    function randomFloat(minValue, maxValue) {
        var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
        return parseFloat(Math.min(minValue + Math.random() * (maxValue - minValue), maxValue).toFixed(precision));
    }

    function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function randomSign() {
        return Math.random() > 0.5 ? 1 : -1;
    }

    function wrap(value, min, max) {
        var range = max - min;
        if (range <= 0) return 0;
        var result = (value - min) % range;
        if (result < 0) result += range;
        return result + min;
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    function radToDeg(radians) {
        return radians * 180 / Math.PI;
    }

    function fuzzyFloor(value) {
        var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0001;
        return Math.floor(value + epsilon);
    }

    function fuzzyCeil(value) {
        var epsilon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0001;
        return Math.ceil(value + epsilon);
    }

    function fuzzyEqual(a, b) {
        var epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;
        return Math.abs(a - b) < epsilon;
    }

    function fuzzyGreaterThan(a, b) {
        var epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;
        return a > b - epsilon;
    }

    function fuzzyLessThan(a, b) {
        var epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0001;
        return a < b + epsilon;
    }

    function maxAdd(value, amount, max) {
        return Math.min(value + amount, max);
    }

    function minSub(value, amount, min) {
        return Math.max(value - amount, min);
    }

    function isOdd(number) {
        return !!(number & 1);
    }

    function isEven(number) {
        return !(number & 1);
    }

    function isPowerOfTwo(value) {
        return value !== 0 && (value & value - 1) === 0;
    }

    function closestPowerOfTwo(value) {
        return Math.pow(2, Math.round(Math.log(value) / Math.log(2)));
    }

    function nextPowerOfTwo(v) {
        return Math.pow(2, Math.ceil(Math.log(v) / Math.log(2)));
    }

    function percent01(a, b) {
        var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        if (a > b || base > b) {
            return 1;
        } else if (a < base || base > a) {
            return 0;
        } else {
            return (a - base) / b;
        }
    }

    function average() {
        var sum = 0;
        for (var _len = arguments.length, numbers = Array(_len), _key = 0; _key < _len; _key++) {
            numbers[_key] = arguments[_key];
        }
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;
        try {
            for (var _iterator = numbers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var number = _step.value;
                sum += +number;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
        return sum / numbers.length;
    }

    function difference(a, b) {
        return Math.abs(a - b);
    }

    function within(a, b, tolerance) {
        return Math.abs(a - b) <= tolerance;
    }

    function inverseLerp(a, b, v) {
        return (v - a) / (b - a);
    }

    function lerpUnclamped(x, y, a) {
        if (a <= 0) return x;
        if (a >= 1) return y;
        return x + a * (y - x);
    }

    function deltaAngleDeg$$1(a, b) {
        var d = mod(b - a, 360);
        if (d > 180) d = Math.abs(d - 360);
        return d;
    }

    function deltaAngleRad$$1(a, b) {
        return degToRad(deltaAngleDeg$$1(radToDeg(a), radToDeg(b)));
    }

    function fract(v) {
        return v - Math.floor(v);
    }

    function mod(a, n) {
        return (a % n + n) % n;
    }

    function lerpAngleDeg$$1(a, b, t) {
        var angle = deltaAngleDeg$$1(a, b);
        return mod(a + lerp(0, angle, t), 360);
    }

    function lerpAngleRad$$1(a, b, t) {
        return degToRad(lerpAngleDeg$$1(radToDeg(a), radToDeg(b), t));
    }

    function gammaToLinearSpace(v) {
        return Math.pow(v, 2.2);
    }

    function linearToGammaSpace(v) {
        return Math.pow(v, 1 / 2.2);
    }

    function almostIdentity(x, m, n) {
        if (x > m) return x;
        var a = 2 * n - m;
        var b = 2 * m - 3 * n;
        var t = x / m;
        return (a * t + b) * t * t + n;
    }

    function impulse(k, x) {
        var h = k * x;
        return h * Math.exp(1 - h);
    }

    function cubicPulse(c, w, x) {
        x = Math.abs(x - c);
        if (x > w) return 0;
        x /= w;
        return 1 - x * x * (3 - 2 * x);
    }

    function expStep(x, k, n) {
        return Math.exp(-k * Math.pow(x, n));
    }

    function parabola(x, k) {
        return Math.pow(4 * x * (1 - x), k);
    }

    function powerCurve(x, a, b) {
        var k = Math.pow(a + b, a + b) / (Math.pow(a, a) * Math.pow(b, b));
        return k * Math.pow(x, a) * Math.pow(1 - x, b);
    }

    function smoothMin(a, b, k) {
        var res = Math.exp(-k * a) + Math.exp(-k * b);
        return -Math.log(res) / k;
    }

    function smoothMax(a, b, k) {
        return Math.log(Math.exp(a) + Math.exp(b)) / k;
    }

    function deltaTime(oldTime) {
        var newTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();
        return newTime - oldTime;
    }

    function gcd(a, b) {
        if (b === 0) return a;
        return gcd(b, a % b);
    }

    function dotProduct(x0, y0, x1, y1, x2, y2, x3, y3) {
        var dx0 = x1 - x0;
        var dy0 = y1 - y0;
        var dx1 = x3 - x2;
        var dy1 = y3 - y2;
        return dx0 * dx1 + dy0 * dy1;
    }
}), (function(module, exports) {
    module.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"
}), (function(module, exports) {
    module.exports = "precision highp float;\n#define GLSLIFY 1\n#define M_PI 3.1415926535897932384626433832795\n\nuniform vec3 _colorA;\nuniform vec3 _colorB;\nuniform float _inverse;\nuniform float _time;\nuniform float _sizePattern;\nuniform float _waterPattern;\nuniform float _noise;\nuniform float _exp;\nuniform float _brightness;\nuniform vec2 _resolution;\nuniform sampler2D _texture;\nuniform sampler2D _trail;\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(mix(mix( hash(p+vec3(0,0,0)),\n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)),\n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)),\n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)),\n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat parabola(float x, float k) {\n\treturn pow(4.0 * x * (1.0 - x), k);\n}\n\nvoid main() {\n\tvec2 uv = gl_FragCoord.xy / _resolution.xy;\n\tfloat trail = texture2D(_trail, uv).r;\n\tuv.y /= _resolution.x / _resolution.y;\n\n  vec3 color = vec3(0.0);\n\tfloat time = _time * 0.001;\n\tvec3 st = vec3(uv, 0.0) * _sizePattern;\n\tfloat n = _brightness + trail;\n\n\tn += fbm(vec3(\n\t\tst.x - time,\n\t\tst.y + time,\n    sin(time)\n\t));\n\n\tn *= 0.5 - trail * 3.0;\n\n  n += fbm(vec3(\n\t\tst.x + n * 0.4 + time * 0.4,\n\t\tst.y + n + time,\n\t\tsin(n * 24.0 + time * 2.0)\n\t)) * (_waterPattern + trail * 0.2);\n\n\tn += pow(parabola(uv.x, 1.0), 16.0) * 0.3 + n * 1.5 + n * 0.02;\n\tn -= pow(1.0 - parabola(uv.x, 2.0), 3.0) * 0.9 + n * 0.33;\n\n\tfloat texture = texture2D(_texture, uv * 20.0 * pow(n * 4.0, 0.1) + time * 3.0).r;\n\n\tvec3 colorA = mix(_colorA, _colorB, 1.0 - _inverse);\n\tvec3 colorB = mix(_colorB, _colorA, 1.0 - _inverse);\n\n\tcolor = mix(colorA, colorB, pow(n, _exp));\n\tcolor += (texture / 3.0) * _noise + trail * 0.5;\n\n\tcolor *= 0.6;\n\tgl_FragColor = vec4(color, 1.0);\n}\n"
}), (function(module, exports) {
    module.exports = function(originalModule) {
        if (!originalModule.webpackPolyfill) {
            var module = Object.create(originalModule);
            if (!module.children) module.children = [];
            Object.defineProperty(module, "loaded", {
                enumerable: true,
                get: function() {
                    return module.l;
                }
            });
            Object.defineProperty(module, "id", {
                enumerable: true,
                get: function() {
                    return module.i;
                }
            });
            Object.defineProperty(module, "exports", {
                enumerable: true,
            });
            module.webpackPolyfill = 1;
        }
        return module;
    };
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return TweenMax;
    });
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    var __WEBPACK_IMPORTED_MODULE_1__TweenMaxBase_js__ = __webpack_require__(42);
    var __WEBPACK_IMPORTED_MODULE_2__CSSPlugin_js__ = __webpack_require__(7);
    var __WEBPACK_IMPORTED_MODULE_3__AttrPlugin_js__ = __webpack_require__(16);
    var __WEBPACK_IMPORTED_MODULE_4__RoundPropsPlugin_js__ = __webpack_require__(17);
    var __WEBPACK_IMPORTED_MODULE_5__DirectionalRotationPlugin_js__ = __webpack_require__(18);
    var __WEBPACK_IMPORTED_MODULE_6__TimelineLite_js__ = __webpack_require__(11);
    var __WEBPACK_IMPORTED_MODULE_7__TimelineMax_js__ = __webpack_require__(15);
    var __WEBPACK_IMPORTED_MODULE_8__BezierPlugin_js__ = __webpack_require__(19);
    var __WEBPACK_IMPORTED_MODULE_9__EasePack_js__ = __webpack_require__(20);
    /*!
     * VERSION: 2.0.1
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     **/
    const TweenMax = __WEBPACK_IMPORTED_MODULE_1__TweenMaxBase_js__["a"];
    TweenMax._autoActivated = [__WEBPACK_IMPORTED_MODULE_6__TimelineLite_js__["a"], __WEBPACK_IMPORTED_MODULE_7__TimelineMax_js__["a"], __WEBPACK_IMPORTED_MODULE_2__CSSPlugin_js__["default"], __WEBPACK_IMPORTED_MODULE_3__AttrPlugin_js__["a"], __WEBPACK_IMPORTED_MODULE_8__BezierPlugin_js__["a"], __WEBPACK_IMPORTED_MODULE_4__RoundPropsPlugin_js__["a"], __WEBPACK_IMPORTED_MODULE_5__DirectionalRotationPlugin_js__["a"], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["a"], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["d"], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["b"], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["g"], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["i"], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["j"], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["c"], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["e"], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["h"], __WEBPACK_IMPORTED_MODULE_9__EasePack_js__["f"]];
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return TweenMax;
    });
    var __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__ = __webpack_require__(1);
    /*!
     * VERSION: 2.0.1
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     **/
    __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"]._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function() {
        var _slice = function(a) {
                var b = [],
                    l = a.length,
                    i;
                for (i = 0; i !== l; b.push(a[i++]));
                return b;
            },
            _applyCycle = function(vars, targets, i) {
                var alt = vars.cycle,
                    p, val;
                for (p in alt) {
                    val = alt[p];
                    vars[p] = (typeof(val) === "function") ? val(i, targets[i]) : val[i % val.length];
                }
                delete vars.cycle;
            },
            TweenMax = function(target, duration, vars) {
                __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].call(this, target, duration, vars);
                this._cycle = 0;
                this._yoyo = (this.vars.yoyo === true || !!this.vars.yoyoEase);
                this._repeat = this.vars.repeat || 0;
                this._repeatDelay = this.vars.repeatDelay || 0;
                if (this._repeat) {
                    this._uncache(true);
                }
                this.render = TweenMax.prototype.render;
            },
            _tinyNum = 0.0000000001,
            TweenLiteInternals = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"]._internals,
            _isSelector = TweenLiteInternals.isSelector,
            _isArray = TweenLiteInternals.isArray,
            p = TweenMax.prototype = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].to({}, 0.1, {}),
            _blankArray = [];
        TweenMax.version = "2.0.1";
        p.constructor = TweenMax;
        p.kill()._gc = false;
        TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].killTweensOf;
        TweenMax.getTweensOf = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].getTweensOf;
        TweenMax.lagSmoothing = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].lagSmoothing;
        TweenMax.ticker = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].ticker;
        TweenMax.render = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].render;
        p.invalidate = function() {
            this._yoyo = (this.vars.yoyo === true || !!this.vars.yoyoEase);
            this._repeat = this.vars.repeat || 0;
            this._repeatDelay = this.vars.repeatDelay || 0;
            this._yoyoEase = null;
            this._uncache(true);
            return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].prototype.invalidate.call(this);
        };
        p.updateTo = function(vars, resetDuration) {
            var curRatio = this.ratio,
                immediate = this.vars.immediateRender || vars.immediateRender,
                p;
            if (resetDuration && this._startTime < this._timeline._time) {
                this._startTime = this._timeline._time;
                this._uncache(false);
                if (this._gc) {
                    this._enabled(true, false);
                } else {
                    this._timeline.insert(this, this._startTime - this._delay);
                }
            }
            for (p in vars) {
                this.vars[p] = vars[p];
            }
            if (this._initted || immediate) {
                if (resetDuration) {
                    this._initted = false;
                    if (immediate) {
                        this.render(0, true, true);
                    }
                } else {
                    if (this._gc) {
                        this._enabled(true, false);
                    }
                    if (this._notifyPluginsOfEnabled && this._firstPT) {
                        __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"]._onPluginEvent("_onDisable", this);
                    }
                    if (this._time / this._duration > 0.998) {
                        var prevTime = this._totalTime;
                        this.render(0, true, false);
                        this._initted = false;
                        this.render(prevTime, true, false);
                    } else {
                        this._initted = false;
                        this._init();
                        if (this._time > 0 || immediate) {
                            var inv = 1 / (1 - curRatio),
                                pt = this._firstPT,
                                endValue;
                            while (pt) {
                                endValue = pt.s + pt.c;
                                pt.c *= inv;
                                pt.s = endValue - pt.c;
                                pt = pt._next;
                            }
                        }
                    }
                }
            }
            return this;
        };
        p.render = function(time, suppressEvents, force) {
            if (!this._initted)
                if (this._duration === 0 && this.vars.repeat) {
                    this.invalidate();
                }
            var totalDur = (!this._dirty) ? this._totalDuration : this.totalDuration(),
                prevTime = this._time,
                prevTotalTime = this._totalTime,
                prevCycle = this._cycle,
                duration = this._duration,
                prevRawPrevTime = this._rawPrevTime,
                isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, yoyoEase;
            if (time >= totalDur - 0.0000001 && time >= 0) {
                this._totalTime = totalDur;
                this._cycle = this._repeat;
                if (this._yoyo && (this._cycle & 1) !== 0) {
                    this._time = 0;
                    this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
                } else {
                    this._time = duration;
                    this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
                }
                if (!this._reversed) {
                    isComplete = true;
                    callback = "onComplete";
                    force = (force || this._timeline.autoRemoveChildren);
                }
                if (duration === 0)
                    if (this._initted || !this.vars.lazy || force) {
                        if (this._startTime === this._timeline._duration) {
                            time = 0;
                        }
                        if (prevRawPrevTime < 0 || (time <= 0 && time >= -0.0000001) || (prevRawPrevTime === _tinyNum && this.data !== "isPause"))
                            if (prevRawPrevTime !== time) {
                                force = true;
                                if (prevRawPrevTime > _tinyNum) {
                                    callback = "onReverseComplete";
                                }
                            }
                        this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum;
                    }
            } else if (time < 0.0000001) {
                this._totalTime = this._time = this._cycle = 0;
                this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
                if (prevTotalTime !== 0 || (duration === 0 && prevRawPrevTime > 0)) {
                    callback = "onReverseComplete";
                    isComplete = this._reversed;
                }
                if (time < 0) {
                    this._active = false;
                    if (duration === 0)
                        if (this._initted || !this.vars.lazy || force) {
                            if (prevRawPrevTime >= 0) {
                                force = true;
                            }
                            this._rawPrevTime = rawPrevTime = (!suppressEvents || time || prevRawPrevTime === time) ? time : _tinyNum;
                        }
                }
                if (!this._initted) {
                    force = true;
                }
            } else {
                this._totalTime = this._time = time;
                if (this._repeat !== 0) {
                    cycleDuration = duration + this._repeatDelay;
                    this._cycle = (this._totalTime / cycleDuration) >> 0;
                    if (this._cycle !== 0)
                        if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
                            this._cycle--;
                        }
                    this._time = this._totalTime - (this._cycle * cycleDuration);
                    if (this._yoyo)
                        if ((this._cycle & 1) !== 0) {
                            this._time = duration - this._time;
                            yoyoEase = this._yoyoEase || this.vars.yoyoEase;
                            if (yoyoEase) {
                                if (!this._yoyoEase) {
                                    if (yoyoEase === true && !this._initted) {
                                        yoyoEase = this.vars.ease;
                                        this._yoyoEase = yoyoEase = !yoyoEase ? __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].defaultEase : (yoyoEase instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"]) ? yoyoEase : (typeof(yoyoEase) === "function") ? new __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"](yoyoEase, this.vars.easeParams) : __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"].map[yoyoEase] || __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].defaultEase;
                                    } else {
                                        this._yoyoEase = yoyoEase = (yoyoEase === true) ? this._ease : (yoyoEase instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"]) ? yoyoEase : __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Ease"].map[yoyoEase];
                                    }
                                }
                                this.ratio = yoyoEase ? 1 - yoyoEase.getRatio((duration - this._time) / duration) : 0;
                            }
                        }
                    if (this._time > duration) {
                        this._time = duration;
                    } else if (this._time < 0) {
                        this._time = 0;
                    }
                }
                if (this._easeType && !yoyoEase) {
                    r = this._time / duration;
                    type = this._easeType;
                    pow = this._easePower;
                    if (type === 1 || (type === 3 && r >= 0.5)) {
                        r = 1 - r;
                    }
                    if (type === 3) {
                        r *= 2;
                    }
                    if (pow === 1) {
                        r *= r;
                    } else if (pow === 2) {
                        r *= r * r;
                    } else if (pow === 3) {
                        r *= r * r * r;
                    } else if (pow === 4) {
                        r *= r * r * r * r;
                    }
                    if (type === 1) {
                        this.ratio = 1 - r;
                    } else if (type === 2) {
                        this.ratio = r;
                    } else if (this._time / duration < 0.5) {
                        this.ratio = r / 2;
                    } else {
                        this.ratio = 1 - (r / 2);
                    }
                } else if (!yoyoEase) {
                    this.ratio = this._ease.getRatio(this._time / duration);
                }
            }
            if (prevTime === this._time && !force && prevCycle === this._cycle) {
                if (prevTotalTime !== this._totalTime)
                    if (this._onUpdate)
                        if (!suppressEvents) {
                            this._callback("onUpdate");
                        }
                return;
            } else if (!this._initted) {
                this._init();
                if (!this._initted || this._gc) {
                    return;
                } else if (!force && this._firstPT && ((this.vars.lazy !== false && this._duration) || (this.vars.lazy && !this._duration))) {
                    this._time = prevTime;
                    this._totalTime = prevTotalTime;
                    this._rawPrevTime = prevRawPrevTime;
                    this._cycle = prevCycle;
                    TweenLiteInternals.lazyTweens.push(this);
                    this._lazy = [time, suppressEvents];
                    return;
                }
                if (this._time && !isComplete && !yoyoEase) {
                    this.ratio = this._ease.getRatio(this._time / duration);
                } else if (isComplete && this._ease._calcEnd && !yoyoEase) {
                    this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
                }
            }
            if (this._lazy !== false) {
                this._lazy = false;
            }
            if (!this._active)
                if (!this._paused && this._time !== prevTime && time >= 0) {
                    this._active = true;
                }
            if (prevTotalTime === 0) {
                if (this._initted === 2 && time > 0) {
                    this._init();
                }
                if (this._startAt) {
                    if (time >= 0) {
                        this._startAt.render(time, true, force);
                    } else if (!callback) {
                        callback = "_dummyGS";
                    }
                }
                if (this.vars.onStart)
                    if (this._totalTime !== 0 || duration === 0)
                        if (!suppressEvents) {
                            this._callback("onStart");
                        }
            }
            pt = this._firstPT;
            while (pt) {
                if (pt.f) {
                    pt.t[pt.p](pt.c * this.ratio + pt.s);
                } else {
                    pt.t[pt.p] = pt.c * this.ratio + pt.s;
                }
                pt = pt._next;
            }
            if (this._onUpdate) {
                if (time < 0)
                    if (this._startAt && this._startTime) {
                        this._startAt.render(time, true, force);
                    }
                if (!suppressEvents)
                    if (this._totalTime !== prevTotalTime || callback) {
                        this._callback("onUpdate");
                    }
            }
            if (this._cycle !== prevCycle)
                if (!suppressEvents)
                    if (!this._gc)
                        if (this.vars.onRepeat) {
                            this._callback("onRepeat");
                        }
            if (callback)
                if (!this._gc || force) {
                    if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
                        this._startAt.render(time, true, force);
                    }
                    if (isComplete) {
                        if (this._timeline.autoRemoveChildren) {
                            this._enabled(false, false);
                        }
                        this._active = false;
                    }
                    if (!suppressEvents && this.vars[callback]) {
                        this._callback(callback);
                    }
                    if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
                        this._rawPrevTime = 0;
                    }
                }
        };
        TweenMax.to = function(target, duration, vars) {
            return new TweenMax(target, duration, vars);
        };
        TweenMax.from = function(target, duration, vars) {
            vars.runBackwards = true;
            vars.immediateRender = (vars.immediateRender != false);
            return new TweenMax(target, duration, vars);
        };
        TweenMax.fromTo = function(target, duration, fromVars, toVars) {
            toVars.startAt = fromVars;
            toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
            return new TweenMax(target, duration, toVars);
        };
        TweenMax.staggerTo = TweenMax.allTo = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            stagger = stagger || 0;
            var delay = 0,
                a = [],
                finalComplete = function() {
                    if (vars.onComplete) {
                        vars.onComplete.apply(vars.onCompleteScope || this, arguments);
                    }
                    onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
                },
                cycle = vars.cycle,
                fromCycle = (vars.startAt && vars.startAt.cycle),
                l, copy, i, p;
            if (!_isArray(targets)) {
                if (typeof(targets) === "string") {
                    targets = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].selector(targets) || targets;
                }
                if (_isSelector(targets)) {
                    targets = _slice(targets);
                }
            }
            targets = targets || [];
            if (stagger < 0) {
                targets = _slice(targets);
                targets.reverse();
                stagger *= -1;
            }
            l = targets.length - 1;
            for (i = 0; i <= l; i++) {
                copy = {};
                for (p in vars) {
                    copy[p] = vars[p];
                }
                if (cycle) {
                    _applyCycle(copy, targets, i);
                    if (copy.duration != null) {
                        duration = copy.duration;
                        delete copy.duration;
                    }
                }
                if (fromCycle) {
                    fromCycle = copy.startAt = {};
                    for (p in vars.startAt) {
                        fromCycle[p] = vars.startAt[p];
                    }
                    _applyCycle(copy.startAt, targets, i);
                }
                copy.delay = delay + (copy.delay || 0);
                if (i === l && onCompleteAll) {
                    copy.onComplete = finalComplete;
                }
                a[i] = new TweenMax(targets[i], duration, copy);
                delay += stagger;
            }
            return a;
        };
        TweenMax.staggerFrom = TweenMax.allFrom = function(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            vars.runBackwards = true;
            vars.immediateRender = (vars.immediateRender != false);
            return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        };
        TweenMax.staggerFromTo = TweenMax.allFromTo = function(targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            toVars.startAt = fromVars;
            toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
            return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
        };
        TweenMax.delayedCall = function(delay, callback, params, scope, useFrames) {
            return new TweenMax(callback, 0, {
                delay: delay,
                onComplete: callback,
                onCompleteParams: params,
                callbackScope: scope,
                onReverseComplete: callback,
                onReverseCompleteParams: params,
                immediateRender: false,
                useFrames: useFrames,
                overwrite: 0
            });
        };
        TweenMax.set = function(target, vars) {
            return new TweenMax(target, 0, vars);
        };
        TweenMax.isTweening = function(target) {
            return (__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].getTweensOf(target, true).length > 0);
        };
        var _getChildrenOf = function(timeline, includeTimelines) {
                var a = [],
                    cnt = 0,
                    tween = timeline._first;
                while (tween) {
                    if (tween instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"]) {
                        a[cnt++] = tween;
                    } else {
                        if (includeTimelines) {
                            a[cnt++] = tween;
                        }
                        a = a.concat(_getChildrenOf(tween, includeTimelines));
                        cnt = a.length;
                    }
                    tween = tween._next;
                }
                return a;
            },
            getAllTweens = TweenMax.getAllTweens = function(includeTimelines) {
                return _getChildrenOf(__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"]._rootTimeline, includeTimelines).concat(_getChildrenOf(__WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"]._rootFramesTimeline, includeTimelines));
            };
        TweenMax.killAll = function(complete, tweens, delayedCalls, timelines) {
            if (tweens == null) {
                tweens = true;
            }
            if (delayedCalls == null) {
                delayedCalls = true;
            }
            var a = getAllTweens((timelines != false)),
                l = a.length,
                allTrue = (tweens && delayedCalls && timelines),
                isDC, tween, i;
            for (i = 0; i < l; i++) {
                tween = a[i];
                if (allTrue || (tween instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["SimpleTimeline"]) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
                    if (complete) {
                        tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
                    } else {
                        tween._enabled(false, false);
                    }
                }
            }
        };
        TweenMax.killChildTweensOf = function(parent, complete) {
            if (parent == null) {
                return;
            }
            var tl = TweenLiteInternals.tweenLookup,
                a, curParent, p, i, l;
            if (typeof(parent) === "string") {
                parent = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].selector(parent) || parent;
            }
            if (_isSelector(parent)) {
                parent = _slice(parent);
            }
            if (_isArray(parent)) {
                i = parent.length;
                while (--i > -1) {
                    TweenMax.killChildTweensOf(parent[i], complete);
                }
                return;
            }
            a = [];
            for (p in tl) {
                curParent = tl[p].target.parentNode;
                while (curParent) {
                    if (curParent === parent) {
                        a = a.concat(tl[p].tweens);
                    }
                    curParent = curParent.parentNode;
                }
            }
            l = a.length;
            for (i = 0; i < l; i++) {
                if (complete) {
                    a[i].totalTime(a[i].totalDuration());
                }
                a[i]._enabled(false, false);
            }
        };
        var _changePause = function(pause, tweens, delayedCalls, timelines) {
            tweens = (tweens !== false);
            delayedCalls = (delayedCalls !== false);
            timelines = (timelines !== false);
            var a = getAllTweens(timelines),
                allTrue = (tweens && delayedCalls && timelines),
                i = a.length,
                isDC, tween;
            while (--i > -1) {
                tween = a[i];
                if (allTrue || (tween instanceof __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["SimpleTimeline"]) || ((isDC = (tween.target === tween.vars.onComplete)) && delayedCalls) || (tweens && !isDC)) {
                    tween.paused(pause);
                }
            }
        };
        TweenMax.pauseAll = function(tweens, delayedCalls, timelines) {
            _changePause(true, tweens, delayedCalls, timelines);
        };
        TweenMax.resumeAll = function(tweens, delayedCalls, timelines) {
            _changePause(false, tweens, delayedCalls, timelines);
        };
        TweenMax.globalTimeScale = function(value) {
            var tl = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"]._rootTimeline,
                t = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].ticker.time;
            if (!arguments.length) {
                return tl._timeScale;
            }
            value = value || _tinyNum;
            tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
            tl = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"]._rootFramesTimeline;
            t = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["default"].ticker.frame;
            tl._startTime = t - ((t - tl._startTime) * tl._timeScale / value);
            tl._timeScale = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"]._rootTimeline._timeScale = value;
            return value;
        };
        p.progress = function(value, suppressEvents) {
            return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * ((this._yoyo && (this._cycle & 1) !== 0) ? 1 - value : value) + (this._cycle * (this._duration + this._repeatDelay)), suppressEvents);
        };
        p.totalProgress = function(value, suppressEvents) {
            return (!arguments.length) ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
        };
        p.time = function(value, suppressEvents) {
            if (!arguments.length) {
                return this._time;
            }
            if (this._dirty) {
                this.totalDuration();
            }
            if (value > this._duration) {
                value = this._duration;
            }
            if (this._yoyo && (this._cycle & 1) !== 0) {
                value = (this._duration - value) + (this._cycle * (this._duration + this._repeatDelay));
            } else if (this._repeat !== 0) {
                value += this._cycle * (this._duration + this._repeatDelay);
            }
            return this.totalTime(value, suppressEvents);
        };
        p.duration = function(value) {
            if (!arguments.length) {
                return this._duration;
            }
            return __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["Animation"].prototype.duration.call(this, value);
        };
        p.totalDuration = function(value) {
            if (!arguments.length) {
                if (this._dirty) {
                    this._totalDuration = (this._repeat === -1) ? 999999999999 : this._duration * (this._repeat + 1) + (this._repeatDelay * this._repeat);
                    this._dirty = false;
                }
                return this._totalDuration;
            }
            return (this._repeat === -1) ? this : this.duration((value - (this._repeat * this._repeatDelay)) / (this._repeat + 1));
        };
        p.repeat = function(value) {
            if (!arguments.length) {
                return this._repeat;
            }
            this._repeat = value;
            return this._uncache(true);
        };
        p.repeatDelay = function(value) {
            if (!arguments.length) {
                return this._repeatDelay;
            }
            this._repeatDelay = value;
            return this._uncache(true);
        };
        p.yoyo = function(value) {
            if (!arguments.length) {
                return this._yoyo;
            }
            this._yoyo = value;
            return this;
        };
        return TweenMax;
    }, true);
    const TweenMax = __WEBPACK_IMPORTED_MODULE_0__TweenLite_js__["_gsScope"].TweenMax;
    const TweenMaxBase = TweenMax;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _jquery = __webpack_require__(3);
    var _jquery2 = _interopRequireDefault(_jquery);
    var _foundation = __webpack_require__(44);
    var _foundationUtil = __webpack_require__(45);
    var _foundationUtil2 = __webpack_require__(22);
    var _foundationUtil3 = __webpack_require__(46);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    _foundation.Foundation.addToJquery(_jquery2.default);
    _foundation.Foundation.onImagesLoaded = _foundationUtil.onImagesLoaded;
    _foundation.Foundation.MediaQuery = _foundationUtil2.MediaQuery;
    _foundationUtil3.Triggers.init(_jquery2.default, _foundation.Foundation);
    exports.default = _foundation.Foundation;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.Foundation = undefined;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _jquery = __webpack_require__(3);
    var _jquery2 = _interopRequireDefault(_jquery);
    var _foundationUtil = __webpack_require__(21);
    var _foundationUtil2 = __webpack_require__(22);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var FOUNDATION_VERSION = '6.4.3';
    var Foundation = {
        version: FOUNDATION_VERSION,
        _plugins: {},
        _uuids: [],
        plugin: function plugin(_plugin, name) {
            var className = name || functionName(_plugin);
            var attrName = hyphenate(className);
            this._plugins[attrName] = this[className] = _plugin;
        },
        registerPlugin: function registerPlugin(plugin, name) {
            var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();
            plugin.uuid = (0, _foundationUtil.GetYoDigits)(6, pluginName);
            if (!plugin.$element.attr('data-' + pluginName)) {
                plugin.$element.attr('data-' + pluginName, plugin.uuid);
            }
            if (!plugin.$element.data('zfPlugin')) {
                plugin.$element.data('zfPlugin', plugin);
            }
            plugin.$element.trigger('init.zf.' + pluginName);
            this._uuids.push(plugin.uuid);
            return;
        },
        unregisterPlugin: function unregisterPlugin(plugin) {
            var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));
            this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);
            plugin.$element.removeAttr('data-' + pluginName).removeData('zfPlugin').trigger('destroyed.zf.' + pluginName);
            for (var prop in plugin) {
                plugin[prop] = null;
            }
            return;
        },
        reInit: function reInit(plugins) {
            var isJQ = plugins instanceof _jquery2.default;
            try {
                if (isJQ) {
                    plugins.each(function() {
                        (0, _jquery2.default)(this).data('zfPlugin')._init();
                    });
                } else {
                    var type = typeof plugins === 'undefined' ? 'undefined' : _typeof(plugins),
                        _this = this,
                        fns = {
                            'object': function object(plgs) {
                                plgs.forEach(function(p) {
                                    p = hyphenate(p);
                                    (0, _jquery2.default)('[data-' + p + ']').foundation('_init');
                                });
                            },
                            'string': function string() {
                                plugins = hyphenate(plugins);
                                (0, _jquery2.default)('[data-' + plugins + ']').foundation('_init');
                            },
                            'undefined': function undefined() {
                                this['object'](Object.keys(_this._plugins));
                            }
                        };
                    fns[type](plugins);
                }
            } catch (err) {
                console.error(err);
            } finally {
                return plugins;
            }
        },
        reflow: function reflow(elem, plugins) {
            if (typeof plugins === 'undefined') {
                plugins = Object.keys(this._plugins);
            } else if (typeof plugins === 'string') {
                plugins = [plugins];
            }
            var _this = this;
            _jquery2.default.each(plugins, function(i, name) {
                var plugin = _this._plugins[name];
                var $elem = (0, _jquery2.default)(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');
                $elem.each(function() {
                    var $el = (0, _jquery2.default)(this),
                        opts = {};
                    if ($el.data('zfPlugin')) {
                        console.warn("Tried to initialize " + name + " on an element that already has a Foundation plugin.");
                        return;
                    }
                    if ($el.attr('data-options')) {
                        var thing = $el.attr('data-options').split(';').forEach(function(e, i) {
                            var opt = e.split(':').map(function(el) {
                                return el.trim();
                            });
                            if (opt[0]) opts[opt[0]] = parseValue(opt[1]);
                        });
                    }
                    try {
                        $el.data('zfPlugin', new plugin((0, _jquery2.default)(this), opts));
                    } catch (er) {
                        console.error(er);
                    } finally {
                        return;
                    }
                });
            });
        },
        getFnName: functionName,
        addToJquery: function addToJquery($) {
            var foundation = function foundation(method) {
                var type = typeof method === 'undefined' ? 'undefined' : _typeof(method),
                    $noJS = $('.no-js');
                if ($noJS.length) {
                    $noJS.removeClass('no-js');
                }
                if (type === 'undefined') {
                    _foundationUtil2.MediaQuery._init();
                    Foundation.reflow(this);
                } else if (type === 'string') {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var plugClass = this.data('zfPlugin');
                    if (plugClass !== undefined && plugClass[method] !== undefined) {
                        if (this.length === 1) {
                            plugClass[method].apply(plugClass, args);
                        } else {
                            this.each(function(i, el) {
                                plugClass[method].apply($(el).data('zfPlugin'), args);
                            });
                        }
                    } else {
                        throw new ReferenceError("We're sorry, '" + method + "' is not an available method for " + (plugClass ? functionName(plugClass) : 'this element') + '.');
                    }
                } else {
                    throw new TypeError('We\'re sorry, ' + type + ' is not a valid parameter. You must use a string representing the method you wish to invoke.');
                }
                return this;
            };
            $.fn.foundation = foundation;
            return $;
        }
    };
    Foundation.util = {
        throttle: function throttle(func, delay) {
            var timer = null;
            return function() {
                var context = this,
                    args = arguments;
                if (timer === null) {
                    timer = setTimeout(function() {
                        func.apply(context, args);
                        timer = null;
                    }, delay);
                }
            };
        }
    };
    window.Foundation = Foundation;
    (function() {
        if (!Date.now || !window.Date.now) window.Date.now = Date.now = function() {
            return new Date().getTime();
        };
        var vendors = ['webkit', 'moz'];
        for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
            var vp = vendors[i];
            window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
            window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
        }
        if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
            var lastTime = 0;
            window.requestAnimationFrame = function(callback) {
                var now = Date.now();
                var nextTime = Math.max(lastTime + 16, now);
                return setTimeout(function() {
                    callback(lastTime = nextTime);
                }, nextTime - now);
            };
            window.cancelAnimationFrame = clearTimeout;
        }
        if (!window.performance || !window.performance.now) {
            window.performance = {
                start: Date.now(),
                now: function now() {
                    return Date.now() - this.start;
                }
            };
        }
    })();
    if (!Function.prototype.bind) {
        Function.prototype.bind = function(oThis) {
            if (typeof this !== 'function') {
                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
            }
            var aArgs = Array.prototype.slice.call(arguments, 1),
                fToBind = this,
                fNOP = function fNOP() {},
                fBound = function fBound() {
                    return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
                };
            if (this.prototype) {
                fNOP.prototype = this.prototype;
            }
            fBound.prototype = new fNOP();
            return fBound;
        };
    }

    function functionName(fn) {
        if (Function.prototype.name === undefined) {
            var funcNameRegex = /function\s([^(]{1,})\(/;
            var results = funcNameRegex.exec(fn.toString());
            return results && results.length > 1 ? results[1].trim() : "";
        } else if (fn.prototype === undefined) {
            return fn.constructor.name;
        } else {
            return fn.prototype.constructor.name;
        }
    }

    function parseValue(str) {
        if ('true' === str) return true;
        else if ('false' === str) return false;
        else if (!isNaN(str * 1)) return parseFloat(str);
        return str;
    }

    function hyphenate(str) {
        return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    }
    exports.Foundation = Foundation;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.onImagesLoaded = undefined;
    var _jquery = __webpack_require__(3);
    var _jquery2 = _interopRequireDefault(_jquery);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function onImagesLoaded(images, callback) {
        var self = this,
            unloaded = images.length;
        if (unloaded === 0) {
            callback();
        }
        images.each(function() {
            if (this.complete && this.naturalWidth !== undefined) {
                singleImageLoaded();
            } else {
                var image = new Image();
                var events = "load.zf.images error.zf.images";
                (0, _jquery2.default)(image).one(events, function me(event) {
                    (0, _jquery2.default)(this).off(events, me);
                    singleImageLoaded();
                });
                image.src = (0, _jquery2.default)(this).attr('src');
            }
        });

        function singleImageLoaded() {
            unloaded--;
            if (unloaded === 0) {
                callback();
            }
        }
    }
    exports.onImagesLoaded = onImagesLoaded;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.Triggers = undefined;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _jquery = __webpack_require__(3);
    var _jquery2 = _interopRequireDefault(_jquery);
    var _foundationUtil = __webpack_require__(47);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var MutationObserver = function() {
        var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
        for (var i = 0; i < prefixes.length; i++) {
            if (prefixes[i] + 'MutationObserver' in window) {
                return window[prefixes[i] + 'MutationObserver'];
            }
        }
        return false;
    }();
    var triggers = function triggers(el, type) {
        el.data(type).split(' ').forEach(function(id) {
            (0, _jquery2.default)('#' + id)[type === 'close' ? 'trigger' : 'triggerHandler'](type + '.zf.trigger', [el]);
        });
    };
    var Triggers = {
        Listeners: {
            Basic: {},
            Global: {}
        },
        Initializers: {}
    };
    Triggers.Listeners.Basic = {
        openListener: function openListener() {
            triggers((0, _jquery2.default)(this), 'open');
        },
        closeListener: function closeListener() {
            var id = (0, _jquery2.default)(this).data('close');
            if (id) {
                triggers((0, _jquery2.default)(this), 'close');
            } else {
                (0, _jquery2.default)(this).trigger('close.zf.trigger');
            }
        },
        toggleListener: function toggleListener() {
            var id = (0, _jquery2.default)(this).data('toggle');
            if (id) {
                triggers((0, _jquery2.default)(this), 'toggle');
            } else {
                (0, _jquery2.default)(this).trigger('toggle.zf.trigger');
            }
        },
        closeableListener: function closeableListener(e) {
            e.stopPropagation();
            var animation = (0, _jquery2.default)(this).data('closable');
            if (animation !== '') {
                _foundationUtil.Motion.animateOut((0, _jquery2.default)(this), animation, function() {
                    (0, _jquery2.default)(this).trigger('closed.zf');
                });
            } else {
                (0, _jquery2.default)(this).fadeOut().trigger('closed.zf');
            }
        },
        toggleFocusListener: function toggleFocusListener() {
            var id = (0, _jquery2.default)(this).data('toggle-focus');
            (0, _jquery2.default)('#' + id).triggerHandler('toggle.zf.trigger', [(0, _jquery2.default)(this)]);
        }
    };
    Triggers.Initializers.addOpenListener = function($elem) {
        $elem.off('click.zf.trigger', Triggers.Listeners.Basic.openListener);
        $elem.on('click.zf.trigger', '[data-open]', Triggers.Listeners.Basic.openListener);
    };
    Triggers.Initializers.addCloseListener = function($elem) {
        $elem.off('click.zf.trigger', Triggers.Listeners.Basic.closeListener);
        $elem.on('click.zf.trigger', '[data-close]', Triggers.Listeners.Basic.closeListener);
    };
    Triggers.Initializers.addToggleListener = function($elem) {
        $elem.off('click.zf.trigger', Triggers.Listeners.Basic.toggleListener);
        $elem.on('click.zf.trigger', '[data-toggle]', Triggers.Listeners.Basic.toggleListener);
    };
    Triggers.Initializers.addCloseableListener = function($elem) {
        $elem.off('close.zf.trigger', Triggers.Listeners.Basic.closeableListener);
        $elem.on('close.zf.trigger', '[data-closeable], [data-closable]', Triggers.Listeners.Basic.closeableListener);
    };
    Triggers.Initializers.addToggleFocusListener = function($elem) {
        $elem.off('focus.zf.trigger blur.zf.trigger', Triggers.Listeners.Basic.toggleFocusListener);
        $elem.on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', Triggers.Listeners.Basic.toggleFocusListener);
    };
    Triggers.Listeners.Global = {
        resizeListener: function resizeListener($nodes) {
            if (!MutationObserver) {
                $nodes.each(function() {
                    (0, _jquery2.default)(this).triggerHandler('resizeme.zf.trigger');
                });
            }
            $nodes.attr('data-events', "resize");
        },
        scrollListener: function scrollListener($nodes) {
            if (!MutationObserver) {
                $nodes.each(function() {
                    (0, _jquery2.default)(this).triggerHandler('scrollme.zf.trigger');
                });
            }
            $nodes.attr('data-events', "scroll");
        },
        closeMeListener: function closeMeListener(e, pluginId) {
            var plugin = e.namespace.split('.')[0];
            var plugins = (0, _jquery2.default)('[data-' + plugin + ']').not('[data-yeti-box="' + pluginId + '"]');
            plugins.each(function() {
                var _this = (0, _jquery2.default)(this);
                _this.triggerHandler('close.zf.trigger', [_this]);
            });
        }
    };
    Triggers.Initializers.addClosemeListener = function(pluginName) {
        var yetiBoxes = (0, _jquery2.default)('[data-yeti-box]'),
            plugNames = ['dropdown', 'tooltip', 'reveal'];
        if (pluginName) {
            if (typeof pluginName === 'string') {
                plugNames.push(pluginName);
            } else if ((typeof pluginName === 'undefined' ? 'undefined' : _typeof(pluginName)) === 'object' && typeof pluginName[0] === 'string') {
                plugNames.concat(pluginName);
            } else {
                console.error('Plugin names must be strings');
            }
        }
        if (yetiBoxes.length) {
            var listeners = plugNames.map(function(name) {
                return 'closeme.zf.' + name;
            }).join(' ');
            (0, _jquery2.default)(window).off(listeners).on(listeners, Triggers.Listeners.Global.closeMeListener);
        }
    };

    function debounceGlobalListener(debounce, trigger, listener) {
        var timer = void 0,
            args = Array.prototype.slice.call(arguments, 3);
        (0, _jquery2.default)(window).off(trigger).on(trigger, function(e) {
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(function() {
                listener.apply(null, args);
            }, debounce || 10);
        });
    }
    Triggers.Initializers.addResizeListener = function(debounce) {
        var $nodes = (0, _jquery2.default)('[data-resize]');
        if ($nodes.length) {
            debounceGlobalListener(debounce, 'resize.zf.trigger', Triggers.Listeners.Global.resizeListener, $nodes);
        }
    };
    Triggers.Initializers.addScrollListener = function(debounce) {
        var $nodes = (0, _jquery2.default)('[data-scroll]');
        if ($nodes.length) {
            debounceGlobalListener(debounce, 'scroll.zf.trigger', Triggers.Listeners.Global.scrollListener, $nodes);
        }
    };
    Triggers.Initializers.addMutationEventsListener = function($elem) {
        if (!MutationObserver) {
            return false;
        }
        var $nodes = $elem.find('[data-resize], [data-scroll], [data-mutate]');
        var listeningElementsMutation = function listeningElementsMutation(mutationRecordsList) {
            var $target = (0, _jquery2.default)(mutationRecordsList[0].target);
            switch (mutationRecordsList[0].type) {
                case "attributes":
                    if ($target.attr("data-events") === "scroll" && mutationRecordsList[0].attributeName === "data-events") {
                        $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);
                    }
                    if ($target.attr("data-events") === "resize" && mutationRecordsList[0].attributeName === "data-events") {
                        $target.triggerHandler('resizeme.zf.trigger', [$target]);
                    }
                    if (mutationRecordsList[0].attributeName === "style") {
                        $target.closest("[data-mutate]").attr("data-events", "mutate");
                        $target.closest("[data-mutate]").triggerHandler('mutateme.zf.trigger', [$target.closest("[data-mutate]")]);
                    }
                    break;
                case "childList":
                    $target.closest("[data-mutate]").attr("data-events", "mutate");
                    $target.closest("[data-mutate]").triggerHandler('mutateme.zf.trigger', [$target.closest("[data-mutate]")]);
                    break;
                default:
                    return false;
            }
        };
        if ($nodes.length) {
            for (var i = 0; i <= $nodes.length - 1; i++) {
                var elementObserver = new MutationObserver(listeningElementsMutation);
                elementObserver.observe($nodes[i], {
                    attributes: true,
                    childList: true,
                    characterData: false,
                    subtree: true,
                    attributeFilter: ["data-events", "style"]
                });
            }
        }
    };
    Triggers.Initializers.addSimpleListeners = function() {
        var $document = (0, _jquery2.default)(document);
        Triggers.Initializers.addOpenListener($document);
        Triggers.Initializers.addCloseListener($document);
        Triggers.Initializers.addToggleListener($document);
        Triggers.Initializers.addCloseableListener($document);
        Triggers.Initializers.addToggleFocusListener($document);
    };
    Triggers.Initializers.addGlobalListeners = function() {
        var $document = (0, _jquery2.default)(document);
        Triggers.Initializers.addMutationEventsListener($document);
        Triggers.Initializers.addResizeListener();
        Triggers.Initializers.addScrollListener();
        Triggers.Initializers.addClosemeListener();
    };
    Triggers.init = function($, Foundation) {
        if (typeof $.triggersInitialized === 'undefined') {
            var $document = $(document);
            if (document.readyState === "complete") {
                Triggers.Initializers.addSimpleListeners();
                Triggers.Initializers.addGlobalListeners();
            } else {
                $(window).on('load', function() {
                    Triggers.Initializers.addSimpleListeners();
                    Triggers.Initializers.addGlobalListeners();
                });
            }
            $.triggersInitialized = true;
        }
        if (Foundation) {
            Foundation.Triggers = Triggers;
            Foundation.IHearYou = Triggers.Initializers.addGlobalListeners;
        }
    };
    exports.Triggers = Triggers;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.Motion = exports.Move = undefined;
    var _jquery = __webpack_require__(3);
    var _jquery2 = _interopRequireDefault(_jquery);
    var _foundationUtil = __webpack_require__(21);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var initClasses = ['mui-enter', 'mui-leave'];
    var activeClasses = ['mui-enter-active', 'mui-leave-active'];
    var Motion = {
        animateIn: function animateIn(element, animation, cb) {
            animate(true, element, animation, cb);
        },
        animateOut: function animateOut(element, animation, cb) {
            animate(false, element, animation, cb);
        }
    };

    function Move(duration, elem, fn) {
        var anim, prog, start = null;
        if (duration === 0) {
            fn.apply(elem);
            elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
            return;
        }

        function move(ts) {
            if (!start) start = ts;
            prog = ts - start;
            fn.apply(elem);
            if (prog < duration) {
                anim = window.requestAnimationFrame(move, elem);
            } else {
                window.cancelAnimationFrame(anim);
                elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
            }
        }
        anim = window.requestAnimationFrame(move);
    }

    function animate(isIn, element, animation, cb) {
        element = (0, _jquery2.default)(element).eq(0);
        if (!element.length) return;
        var initClass = isIn ? initClasses[0] : initClasses[1];
        var activeClass = isIn ? activeClasses[0] : activeClasses[1];
        reset();
        element.addClass(animation).css('transition', 'none');
        requestAnimationFrame(function() {
            element.addClass(initClass);
            if (isIn) element.show();
        });
        requestAnimationFrame(function() {
            element[0].offsetWidth;
            element.css('transition', '').addClass(activeClass);
        });
        element.one((0, _foundationUtil.transitionend)(element), finish);

        function finish() {
            if (!isIn) element.hide();
            reset();
            if (cb) cb.apply(element);
        }

        function reset() {
            element[0].style.transitionDuration = 0;
            element.removeClass(initClass + ' ' + activeClass + ' ' + animation);
        }
    }
    exports.Move = Move;
    exports.Motion = Motion;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    var _barba = __webpack_require__(12);
    var _barba2 = _interopRequireDefault(_barba);
    var _gsap = __webpack_require__(0);
    __webpack_require__(7);
    __webpack_require__(49);
    var _BuffaMenu = __webpack_require__(50);
    var _BuffaMenu2 = _interopRequireDefault(_BuffaMenu);
    var _BuffaTooltip = __webpack_require__(56);
    var _BuffaTooltip2 = _interopRequireDefault(_BuffaTooltip);
    var _PageAnimations = __webpack_require__(57);
    var _PageAnimations2 = _interopRequireDefault(_PageAnimations);
    var _BuffaPreload = __webpack_require__(67);
    var _BuffaPreload2 = _interopRequireDefault(_BuffaPreload);
    var _BuffaCursor = __webpack_require__(9);
    var _BuffaCursor2 = _interopRequireDefault(_BuffaCursor);
    var _utils = __webpack_require__(2);
    var _BuffaSideMenu = __webpack_require__(71);
    var _BuffaSideMenu2 = _interopRequireDefault(_BuffaSideMenu);
    var _BuffaSingleProject = __webpack_require__(72);
    var _BuffaSingleProject2 = _interopRequireDefault(_BuffaSingleProject);
    var _BuffaVerticalCarousel = __webpack_require__(73);
    var _BuffaVerticalCarousel2 = _interopRequireDefault(_BuffaVerticalCarousel);
    var _defaults = __webpack_require__(14);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    var pageAnimations = new _PageAnimations2.default();
    var buffaSideMenu = new _BuffaSideMenu2.default();
    var buffaPreload = new _BuffaPreload2.default();
    if (!(0, _utils.isFirefox)()) document.documentElement.classList.remove("single-work-scrollbar-hidden");
    var updatePage = function updatePage(newPageRawHTML) {
        var newDoc = (0, _utils.parseHTML)(newPageRawHTML);
        var newPageMenu = (0, _utils.qs)(".overlay-nav", newDoc);
        (0, _utils.qs)(".overlay-nav").innerHTML = newPageMenu.innerHTML;
    };
    var BuffaTransition = _barba2.default.BaseTransition.extend({
        start: function start() {
            var _self = this;
            Promise.all([this.newContainerLoading, this.fadeOut()]).then(function(_) {
                return buffaPreload.loadAssets(_self.newContainer);
            }).then(this.fadeIn.bind(this));
        },
        fadeOut: function fadeOut() {
            return pageAnimations.animateOut(_barba2.default.HistoryManager.prevStatus().namespace);
        },
        fadeIn: function fadeIn() {
            pageAnimations.animateIn(_barba2.default.HistoryManager.currentStatus().namespace);
            this.done();
        }
    });
    _barba2.default.Pjax.getTransition = function(_) {
        return BuffaTransition;
    };
    _barba2.default.Dispatcher.on("newPageReady", function(currentStatus, prevStatus, HTMLElementContainer, newPageRawHTML) {
        if (_barba2.default.HistoryManager.history.length > 1) buffaSideMenu.animateLinkIn(currentStatus.namespace);
        window.scrollTo(0, 0);
        updatePage(newPageRawHTML);
    });
    _barba2.default.Dispatcher.on("transitionCompleted", function(currentStatus) {
        if (_barba2.default.HistoryManager.history.length === 1) {
            buffaPreload.initLoadingCounter().then(function(_) {
                return pageAnimations.animateIn(currentStatus.namespace, true);
            }).then(function(_) {
                return (0, _utils.qs)(".cursor").classList.add("visible");
            });
            _BuffaCursor2.default.init();
            Object.assign(BUFFA, {
                background: {
                    current: _defaults.backgroundDefaults,
                    default: JSON.parse(JSON.stringify(_defaults.backgroundDefaults))
                }
            });
        }
        _gsap.TweenLite.set(document.body, {
            "clearProps": "touch-action, pointer-events"
        });
        _BuffaCursor2.default.removeHoverEvents();
        _BuffaCursor2.default.addHoverEvents();
        _BuffaMenu2.default.init();
    });
    _barba2.default.Dispatcher.on("linkClicked", function(HTMLElement) {
        if (_BuffaMenu2.default.open) _BuffaMenu2.default.animateOut();
        buffaSideMenu.animateLinkOut(HTMLElement);
        _gsap.TweenLite.set(document.body, {
            "pointer-events": "none",
            "touch-action": "none"
        });
    });
    _barba2.default.Dispatcher.on("initStateChange", function(_) {
        if (typeof __gaTracker === "function") __gaTracker("send", "pageview", location.pathname);
    });
    var AboutPage = _barba2.default.BaseView.extend({
        namespace: "about-page",
        onEnterCompleted: function onEnterCompleted(_) {
            return (0, _utils.qsa)(".tooltip").map(function(tooltip) {
                return BUFFA.tooltip_instances.push(new _BuffaTooltip2.default(tooltip));
            });
        },
        onLeave: function onLeave(_) {
            (0, _utils.destroyInstances)("image_reveal_instances");
            (0, _utils.destroyInstances)("tooltip_instances");
        }
    });
    var WorksPage = _barba2.default.BaseView.extend({
        namespace: "works-page",
        onEnter: function onEnter(_) {
            _BuffaCursor2.default.morph("circle");
            _BuffaCursor2.default.canAnimate = false;
        },
        onLeave: function onLeave(_) {
            _BuffaCursor2.default.canAnimate = true;
            _BuffaCursor2.default.morph("octagon");
        },
        onLeaveCompleted: function onLeaveCompleted(_) {
            (0, _utils.destroyInstances)("works_slider_instances");
            (0, _utils.destroyInstances)("tilt_instances");
        }
    });
    var WorksSinglePage = _barba2.default.BaseView.extend({
        namespace: "single-work",
        onEnterCompleted: function onEnterCompleted(_) {
            _gsap.TweenLite.to('.side-menu', 0.4, {
                opacity: 1,
                ease: Expo.easeOut
            });
            (0, _utils.qs)(".side-menu [data-ns='works-page'] a").setAttribute("data-animate-side-menu-link", "false");
            BUFFA.single_project_instances.push(new _BuffaSingleProject2.default());
        },
        onLeave: function onLeave(_) {
            (0, _utils.qs)(".side-menu [data-ns='works-page'] a").removeAttribute("data-animate-side-menu-link");
            (0, _utils.destroyInstances)("single_project_instances");
        },
        onLeaveCompleted: function onLeaveCompleted(_) {
            if (BUFFA.plyr_instances.length) {
                BUFFA.plyr_instances.forEach(function(e) {
                    return e.destroy();
                });
                BUFFA.plyr_instances = [];
            }
        }
    });
    var GifPage = _barba2.default.BaseView.extend({
        namespace: "gif-page",
        onEnter: function onEnter(_) {
            return BUFFA.vertical_carousel_instances.push(new _BuffaVerticalCarousel2.default(".vertical-carousel", {
                speed: 120
            }));
        },
        onLeaveCompleted: function onLeaveCompleted(_) {
            return (0, _utils.destroyInstances)("vertical_carousel_instances");
        }
    });
    var CreditsPage = _barba2.default.BaseView.extend({
        namespace: "credits-page"
    });
    var ContactsPage = _barba2.default.BaseView.extend({
        namespace: "contacts-page",
        onLeave: function onLeave(_) {
            BUFFA.words_carousel_instances.map(function(carousel) {
                return carousel.stop();
            });
        },
        onLeaveCompleted: function onLeaveCompleted(_) {
            return (0, _utils.destroyInstances)("words_carousel_instances");
        }
    });
    var NotFoundPage = _barba2.default.BaseView.extend({
        namespace: "404-page",
        onEnterCompleted: function onEnterCompleted(_) {
            new _BuffaVerticalCarousel2.default(".vertical-carousel");
        }
    });
    AboutPage.init();
    WorksPage.init();
    WorksSinglePage.init();
    GifPage.init();
    CreditsPage.init();
    ContactsPage.init();
    NotFoundPage.init();
    _barba2.default.Pjax.start();
}), (function(module, exports) { /*!npm.im/gsap-then*/
    window.com.greensock.core.Animation.prototype.then = function(onFullfilled) {
        var this$1 = this;
        return new Promise(function(resolve) {
            var existing = this$1.eventCallback('onComplete');
            this$1.eventCallback('onComplete', function() {
                if (existing) {
                    existing.apply(this, arguments);
                }
                resolve();
            });
        }).then(function() {
            return onFullfilled(this$1);
        });
    };
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _gsap = __webpack_require__(0);
    var _const = __webpack_require__(8);
    var _Magnet = __webpack_require__(51);
    var _utils = __webpack_require__(2);
    var _BuffaCursor = __webpack_require__(9);
    var _BuffaCursor2 = _interopRequireDefault(_BuffaCursor);
    var _barba = __webpack_require__(12);
    var _barba2 = _interopRequireDefault(_barba);
    var _index = __webpack_require__(13);
    var _CustomEase = __webpack_require__(24);
    var _CustomEase2 = _interopRequireDefault(_CustomEase);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var BuffaMenu = function() {
        function BuffaMenu() {
            _classCallCheck(this, BuffaMenu);
            this.trigger = (0, _utils.qs)(".hamburger");
            this.menu = (0, _utils.qs)(".overlay-menu");
            this.open = false;
            this.animatable = true;
            _CustomEase2.default.create('easingBuffa', _const.BUFFA_EASE_CURVE);
        }
        _createClass(BuffaMenu, [{
            key: "init",
            value: function init() {
                var _this = this;
                (0, _utils.handleEvent)(_const.TOUCH_EVENT, {
                    onElement: (0, _utils.qs)(".hamburger"),
                    withCallback: function withCallback() {
                        return _this.toggleMenu();
                    }
                });
                (0, _utils.qsa)(".overlay-nav__elem").forEach(function(e) {
                    (0, _utils.handleEvent)("mouseenter", {
                        onElement: e,
                        withCallback: function withCallback(e) {
                            return _this.mouseEnter(e);
                        }
                    });
                    (0, _utils.handleEvent)("mouseleave", {
                        onElement: e,
                        withCallback: function withCallback(e) {
                            return _this.mouseLeave(e);
                        }
                    });
                    (0, _Magnet.initMagnet)(e, e.firstChild, 10, 100);
                    (0, _Magnet.initMagnet)(e, (0, _utils.qs)(".overlay-nav__elem__counter", e), 50, 150);
                });
            }
        }, {
            key: "toggleMenu",
            value: function toggleMenu() {
                if (!this.animatable) return;
                if (this.open) {
                    this.animateOut();
                } else {
                    this.animateIn();
                }
            }
        }, {
            key: "animateIn",
            value: function animateIn() {
                var _this2 = this;
                var tl = new _gsap.TimelineMax({
                    onStart: function onStart() {
                        _this2.open = !_this2.open;
                        _this2.animatable = false;
                        (0, _utils.addClass)(document.body, "menu-open");
                        (0, _utils.addClass)(_this2.menu, "overlay-menu--visible");
                        document.body.style.overflow = "hidden";
                        if (_barba2.default.HistoryManager.currentStatus().namespace === "works-page") _BuffaCursor2.default.morph("octagon");
                        (0, _index.animateBg)("_brightness", BUFFA.background.current["_brightness"].value, -3.00, 1.6, 'easingBuffa');
                    },
                    onComplete: function onComplete() {
                        _this2.animatable = true;
                    }
                });
                tl.add("start").to(this.menu, 0.7, {
                    opacity: 1
                }, "start").to(".hamburger__line--top", 0.35, {
                    rotation: 45,
                    y: 9
                }, "start").to(".hamburger__line--middle", 0.35, {
                    scaleX: 0
                }, "start").to(".hamburger__line--bottom", 0.35, {
                    rotation: -45,
                    y: -9
                }, "start").to(".side-content--left", 0.8, {
                    x: -100,
                    opacity: 0,
                    ease: _gsap.Expo.easeInOut
                }, "start").to(".side-content--right", 0.8, {
                    x: 100,
                    opacity: 0,
                    ease: _gsap.Expo.easeInOut
                }, "start").set(".overlay-nav__elem a", {
                    className: "+=strip-animate strip-animate-in"
                }, "start+=0.55").staggerTo(".overlay-nav__elem__counter", 0.7, {
                    opacity: 1
                }, 0.2, "start+=0.65").staggerTo(".overlay-menu__line", 0.8, {
                    scaleY: 1,
                    ease: Power1.easeOut
                }, 0.15, "start+=0.3");
            }
        }, {
            key: "animateOut",
            value: function animateOut() {
                var _this3 = this;
                var tl = new _gsap.TimelineMax({
                    onStart: function onStart() {
                        _this3.open = !_this3.open;
                        _this3.animatable = false;
                        (0, _utils.removeClass)(document.body, "menu-open");
                        if (_barba2.default.HistoryManager.currentStatus().namespace === "works-page") _BuffaCursor2.default.morph("circle");
                        (0, _index.animateBg)("_brightness", BUFFA.background.current["_brightness"].value, BUFFA.background.default["_brightness"].value, 1.3, 'easingBuffa');
                    },
                    onComplete: function onComplete() {
                        _this3.animatable = true;
                        (0, _utils.removeClass)(_this3.menu, "overlay-menu--visible");
                        _gsap.TweenMax.set([_this3.menu, document.body, ".overlay-menu__line", ".overlay-nav a", ".overlay-nav__elem__counter"], {
                            clearProps: "all"
                        });
                        _gsap.TweenMax.set(".overlay-nav__elem a", {
                            className: "-=strip-animate strip-animate-in"
                        });
                    }
                });
                tl.add("start").to(this.menu, 0.7, {
                    opacity: 0
                }).to(".hamburger__line--top", 0.35, {
                    rotation: 0,
                    y: 0
                }, "start").to(".hamburger__line--middle", 0.35, {
                    scaleX: 1
                }, "start").to(".hamburger__line--bottom", 0.35, {
                    rotation: 0,
                    y: 0
                }, "start").to([".side-content--left", ".side-content--right"], 1, {
                    x: 0,
                    opacity: 1,
                    ease: _gsap.Expo.easeInOut
                }, "start");
            }
        }, {
            key: "mouseEnter",
            value: function mouseEnter(e) {
                var displace_filter = (0, _utils.qs)("filter feDisplacementMap", e.currentTarget);
                _gsap.TweenMax.to(displace_filter, 0.4, {
                    attr: {
                        scale: 17
                    }
                });
            }
        }, {
            key: "mouseLeave",
            value: function mouseLeave(e) {
                var displace_filter = (0, _utils.qs)("filter feDisplacementMap", e.currentTarget);
                _gsap.TweenMax.to(displace_filter, 0.4, {
                    attr: {
                        scale: 0
                    }
                });
            }
        }]);
        return BuffaMenu;
    }();
    var buffaMenu = new BuffaMenu();
    exports.default = buffaMenu;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.initMagnet = undefined;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _gsap = __webpack_require__(0);
    var _gsap2 = _interopRequireDefault(_gsap);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var Magnet = function() {
        function Magnet(_parent, _el) {
            var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 25;
            var maxHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
            _classCallCheck(this, Magnet);
            this.parent = (typeof _parent === "undefined" ? "undefined" : _typeof(_parent)) === "object" ? _parent : document.querySelector(_parent);
            this.element = (typeof _el === "undefined" ? "undefined" : _typeof(_el)) === "object" ? _el : document.querySelector(_el);
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this.init();
        }
        _createClass(Magnet, [{
            key: "reset",
            value: function reset() {
                _gsap2.default.to(this.element, 1, {
                    x: '0%',
                    y: '0%',
                    ease: Elastic.easeOut.config(1, 0.4)
                });
            }
        }, {
            key: "move",
            value: function move(e) {
                var _elCoords = this.parent.getBoundingClientRect();
                var _elY = _elCoords.top;
                var _elX = _elCoords.left;
                _gsap2.default.to(this.element, .2, {
                    x: this.maxWidth * ((e.clientX - _elX) / this.parent.offsetWidth * 2 - 1) + '%',
                    y: this.maxHeight * ((e.clientY - _elY) / this.parent.offsetHeight * 2 - 1) / 5 + '%',
                    scale: 1,
                    opacity: 1
                });
            }
        }, {
            key: "handleEvents",
            value: function handleEvents() {
                var _this = this;
                this.parent.addEventListener('mousemove', function(e) {
                    _this.move(e);
                });
                this.parent.addEventListener('mouseleave', function() {
                    _this.reset();
                });
            }
        }, {
            key: "init",
            value: function init() {
                this.handleEvents();
            }
        }]);
        return Magnet;
    }();
    var initMagnet = exports.initMagnet = function initMagnet(parent, elem, maxWidth, maxHeight) {
        new Magnet(parent, elem, maxWidth, maxHeight);
    };
}), (function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(53);
}), (function(module, exports, __webpack_require__) {
    "use strict";
    (function(module) {
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
         * classie - class helper functions
         * from bonzo https://github.com/ded/bonzo
         *
         * classie.has( elem, 'my-class' ) -> true/false
         * classie.add( elem, 'my-new-class' )
         * classie.remove( elem, 'my-unwanted-class' )
         * classie.toggle( elem, 'my-class' )
         */
        var classList = __webpack_require__(54),
            classie;

        function classReg(className) {
            return new RegExp("(^|\\s+)" + className + "(\\s+|$)");
        }

        function noop() {}

        function isArr(classes) {
            if (Array.isArray(classes)) {
                return true;
            } else if (Object.prototype.toString.call(classes) === '[object Array]') {
                return true;
            } else {
                return false;
            }
        }

        function removeMultiple() {
            var c = arguments[1],
                elem = arguments[0];
            c.forEach(function(value) {
                if (classie.has(elem, value)) {
                    noop();
                }
                classie.removeClass(elem, value);
            });
        }

        function addMultiple() {
            var c = arguments[1],
                elem = arguments[0];
            c.forEach(function(value) {
                if (classie.has(elem, value)) {
                    noop();
                }
                classie.addClass(elem, value);
            });
        }

        function hasClass(elem, c) {
            return elem.classList.contains(c);
        }

        function addClass(elem, c) {
            if (isArr(c)) {
                addMultiple.apply(this, arguments);
            } else {
                elem.classList.add(c);
            }
        }

        function removeClass(elem, c) {
            if (isArr(c)) {
                removeMultiple.apply(this, arguments);
            } else {
                elem.classList.remove(c);
            }
        }

        function toggleClass(elem, c) {
            var fn = hasClass(elem, c) ? removeClass : addClass;
            fn(elem, c);
        }
        var classie = {
            hasClass: hasClass,
            addClass: addClass,
            removeClass: removeClass,
            toggleClass: toggleClass,
            has: hasClass,
            add: addClass,
            remove: removeClass,
            toggle: toggleClass
        };
        if (typeof module === "object" && module && typeof module.exports === "object") {
            module.exports = classie;
        } else {
            !(__WEBPACK_AMD_DEFINE_FACTORY__ = (classie), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
    }.call(exports, __webpack_require__(23)(module)))
}), (function(module, exports) { /*!@source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/
    if ("document" in self) {
        if (!("classList" in document.createElement("_")) || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg", "g"))) {
            (function(view) {
                "use strict";
                if (!('Element' in view)) {
                    return;
                }
                var classListProp = "classList",
                    protoProp = "prototype",
                    elemCtrProto = view.Element[protoProp],
                    objCtr = Object,
                    strTrim = String[protoProp].trim || function() {
                        return this.replace(/^\s+|\s+$/g, "");
                    },
                    arrIndexOf = Array[protoProp].indexOf || function(item) {
                        var
                            i = 0,
                            len = this.length;
                        for (; i < len; i++) {
                            if (i in this && this[i] === item) {
                                return i;
                            }
                        }
                        return -1;
                    },
                    DOMEx = function(type, message) {
                        this.name = type;
                        this.code = DOMException[type];
                        this.message = message;
                    },
                    checkTokenAndGetIndex = function(classList, token) {
                        if (token === "") {
                            throw new DOMEx("SYNTAX_ERR", "An invalid or illegal string was specified");
                        }
                        if (/\s/.test(token)) {
                            throw new DOMEx("INVALID_CHARACTER_ERR", "String contains an invalid character");
                        }
                        return arrIndexOf.call(classList, token);
                    },
                    ClassList = function(elem) {
                        var
                            trimmedClasses = strTrim.call(elem.getAttribute("class") || ""),
                            classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [],
                            i = 0,
                            len = classes.length;
                        for (; i < len; i++) {
                            this.push(classes[i]);
                        }
                        this._updateClassName = function() {
                            elem.setAttribute("class", this.toString());
                        };
                    },
                    classListProto = ClassList[protoProp] = [],
                    classListGetter = function() {
                        return new ClassList(this);
                    };
                DOMEx[protoProp] = Error[protoProp];
                classListProto.item = function(i) {
                    return this[i] || null;
                };
                classListProto.contains = function(token) {
                    token += "";
                    return checkTokenAndGetIndex(this, token) !== -1;
                };
                classListProto.add = function() {
                    var
                        tokens = arguments,
                        i = 0,
                        l = tokens.length,
                        token, updated = false;
                    do {
                        token = tokens[i] + "";
                        if (checkTokenAndGetIndex(this, token) === -1) {
                            this.push(token);
                            updated = true;
                        }
                    }
                    while (++i < l);
                    if (updated) {
                        this._updateClassName();
                    }
                };
                classListProto.remove = function() {
                    var
                        tokens = arguments,
                        i = 0,
                        l = tokens.length,
                        token, updated = false,
                        index;
                    do {
                        token = tokens[i] + "";
                        index = checkTokenAndGetIndex(this, token);
                        while (index !== -1) {
                            this.splice(index, 1);
                            updated = true;
                            index = checkTokenAndGetIndex(this, token);
                        }
                    }
                    while (++i < l);
                    if (updated) {
                        this._updateClassName();
                    }
                };
                classListProto.toggle = function(token, force) {
                    token += "";
                    var
                        result = this.contains(token),
                        method = result ? force !== true && "remove" : force !== false && "add";
                    if (method) {
                        this[method](token);
                    }
                    if (force === true || force === false) {
                        return force;
                    } else {
                        return !result;
                    }
                };
                classListProto.toString = function() {
                    return this.join(" ");
                };
                if (objCtr.defineProperty) {
                    var classListPropDesc = {
                        get: classListGetter,
                        enumerable: true,
                        configurable: true
                    };
                    try {
                        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
                    } catch (ex) {
                        if (ex.number === -0x7FF5EC54) {
                            classListPropDesc.enumerable = false;
                            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
                        }
                    }
                } else if (objCtr[protoProp].__defineGetter__) {
                    elemCtrProto.__defineGetter__(classListProp, classListGetter);
                }
            }(self));
        } else {
            (function() {
                "use strict";
                var testElement = document.createElement("_");
                testElement.classList.add("c1", "c2");
                if (!testElement.classList.contains("c2")) {
                    var createMethod = function(method) {
                        var original = DOMTokenList.prototype[method];
                        DOMTokenList.prototype[method] = function(token) {
                            var i, len = arguments.length;
                            for (i = 0; i < len; i++) {
                                token = arguments[i];
                                original.call(this, token);
                            }
                        };
                    };
                    createMethod('add');
                    createMethod('remove');
                }
                testElement.classList.toggle("c3", false);
                if (testElement.classList.contains("c3")) {
                    var _toggle = DOMTokenList.prototype.toggle;
                    DOMTokenList.prototype.toggle = function(token, force) {
                        if (1 in arguments && !this.contains(token) === !force) {
                            return force;
                        } else {
                            return _toggle.call(this, token);
                        }
                    };
                }
                testElement = null;
            }());
        }
    }
}), (function(module, exports, __webpack_require__) {
    "use strict";
    (function(global) {
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        /*!
         * VERSION: 0.8.11
         * DATE: 2018-02-15
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
         * MorphSVGPlugin is a Club GreenSock membership benefit; You must have a valid membership to use
         * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.
         * This work is subject to the software agreement that was issued with your membership.
         *
         * @author: Jack Doyle, jack@greensock.com
         */
        var _gsScope = typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : undefined || window;
        (_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
            "use strict";
            var _DEG2RAD = Math.PI / 180,
                _RAD2DEG = 180 / Math.PI,
                _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
                _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
                _selectorExp = /(^[#\.][a-z]|[a-y][a-z])/gi,
                _commands = /[achlmqstvz]/ig,
                _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
                TweenLite = _gsScope._gsDefine.globals.TweenLite,
                _log = function _log(message) {
                    if (_gsScope.console) {
                        console.log(message);
                    }
                },
                _normalizedArcToBeziers = function _normalizedArcToBeziers(angleStart, angleExtent) {
                    var segments = Math.ceil(Math.abs(angleExtent) / 90),
                        l = 0,
                        a = [],
                        angleIncrement, controlLength, angle, dx, dy, i;
                    angleStart *= _DEG2RAD;
                    angleExtent *= _DEG2RAD;
                    angleIncrement = angleExtent / segments;
                    controlLength = 4 / 3 * Math.sin(angleIncrement / 2) / (1 + Math.cos(angleIncrement / 2));
                    for (i = 0; i < segments; i++) {
                        angle = angleStart + i * angleIncrement;
                        dx = Math.cos(angle);
                        dy = Math.sin(angle);
                        a[l++] = dx - controlLength * dy;
                        a[l++] = dy + controlLength * dx;
                        angle += angleIncrement;
                        dx = Math.cos(angle);
                        dy = Math.sin(angle);
                        a[l++] = dx + controlLength * dy;
                        a[l++] = dy - controlLength * dx;
                        a[l++] = dx;
                        a[l++] = dy;
                    }
                    return a;
                },
                _arcToBeziers = function _arcToBeziers(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
                    if (lastX === x && lastY === y) {
                        return;
                    }
                    rx = Math.abs(rx);
                    ry = Math.abs(ry);
                    var angleRad = angle % 360 * _DEG2RAD,
                        cosAngle = Math.cos(angleRad),
                        sinAngle = Math.sin(angleRad),
                        dx2 = (lastX - x) / 2,
                        dy2 = (lastY - y) / 2,
                        x1 = cosAngle * dx2 + sinAngle * dy2,
                        y1 = -sinAngle * dx2 + cosAngle * dy2,
                        rx_sq = rx * rx,
                        ry_sq = ry * ry,
                        x1_sq = x1 * x1,
                        y1_sq = y1 * y1,
                        radiiCheck = x1_sq / rx_sq + y1_sq / ry_sq;
                    if (radiiCheck > 1) {
                        rx = Math.sqrt(radiiCheck) * rx;
                        ry = Math.sqrt(radiiCheck) * ry;
                        rx_sq = rx * rx;
                        ry_sq = ry * ry;
                    }
                    var sign = largeArcFlag === sweepFlag ? -1 : 1,
                        sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);
                    if (sq < 0) {
                        sq = 0;
                    }
                    var coef = sign * Math.sqrt(sq),
                        cx1 = coef * (rx * y1 / ry),
                        cy1 = coef * -(ry * x1 / rx),
                        sx2 = (lastX + x) / 2,
                        sy2 = (lastY + y) / 2,
                        cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),
                        cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),
                        ux = (x1 - cx1) / rx,
                        uy = (y1 - cy1) / ry,
                        vx = (-x1 - cx1) / rx,
                        vy = (-y1 - cy1) / ry,
                        n = Math.sqrt(ux * ux + uy * uy),
                        p = ux;
                    sign = uy < 0 ? -1 : 1;
                    var angleStart = sign * Math.acos(p / n) * _RAD2DEG;
                    n = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
                    p = ux * vx + uy * vy;
                    sign = ux * vy - uy * vx < 0 ? -1 : 1;
                    var angleExtent = sign * Math.acos(p / n) * _RAD2DEG;
                    if (!sweepFlag && angleExtent > 0) {
                        angleExtent -= 360;
                    } else if (sweepFlag && angleExtent < 0) {
                        angleExtent += 360;
                    }
                    angleExtent %= 360;
                    angleStart %= 360;
                    var bezierPoints = _normalizedArcToBeziers(angleStart, angleExtent),
                        a = cosAngle * rx,
                        b = sinAngle * rx,
                        c = sinAngle * -ry,
                        d = cosAngle * ry,
                        l = bezierPoints.length - 2,
                        i, px, py;
                    for (i = 0; i < l; i += 2) {
                        px = bezierPoints[i];
                        py = bezierPoints[i + 1];
                        bezierPoints[i] = px * a + py * c + cx;
                        bezierPoints[i + 1] = px * b + py * d + cy;
                    }
                    bezierPoints[bezierPoints.length - 2] = x;
                    bezierPoints[bezierPoints.length - 1] = y;
                    return bezierPoints;
                },
                _pathDataToBezier = function _pathDataToBezier(d) {
                    var a = (d + "").replace(_scientific, function(m) {
                            var n = +m;
                            return n < 0.0001 && n > -0.0001 ? 0 : n;
                        }).match(_svgPathExp) || [],
                        path = [],
                        relativeX = 0,
                        relativeY = 0,
                        elements = a.length,
                        l = 2,
                        points = 0,
                        i, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand;
                    if (!d || !isNaN(a[0]) || isNaN(a[1])) {
                        _log("ERROR: malformed path data: " + d);
                        return path;
                    }
                    for (i = 0; i < elements; i++) {
                        prevCommand = command;
                        if (isNaN(a[i])) {
                            command = a[i].toUpperCase();
                            isRelative = command !== a[i];
                        } else {
                            i--;
                        }
                        x = +a[i + 1];
                        y = +a[i + 2];
                        if (isRelative) {
                            x += relativeX;
                            y += relativeY;
                        }
                        if (i === 0) {
                            startX = x;
                            startY = y;
                        }
                        if (command === "M") {
                            if (segment && segment.length < 8) {
                                path.length -= 1;
                                l = 0;
                            }
                            relativeX = startX = x;
                            relativeY = startY = y;
                            segment = [x, y];
                            points += l;
                            l = 2;
                            path.push(segment);
                            i += 2;
                            command = "L";
                        } else if (command === "C") {
                            if (!segment) {
                                segment = [0, 0];
                            }
                            segment[l++] = x;
                            segment[l++] = y;
                            if (!isRelative) {
                                relativeX = relativeY = 0;
                            }
                            segment[l++] = relativeX + a[i + 3] * 1;
                            segment[l++] = relativeY + a[i + 4] * 1;
                            segment[l++] = relativeX = relativeX + a[i + 5] * 1;
                            segment[l++] = relativeY = relativeY + a[i + 6] * 1;
                            i += 6;
                        } else if (command === "S") {
                            if (prevCommand === "C" || prevCommand === "S") {
                                difX = relativeX - segment[l - 4];
                                difY = relativeY - segment[l - 3];
                                segment[l++] = relativeX + difX;
                                segment[l++] = relativeY + difY;
                            } else {
                                segment[l++] = relativeX;
                                segment[l++] = relativeY;
                            }
                            segment[l++] = x;
                            segment[l++] = y;
                            if (!isRelative) {
                                relativeX = relativeY = 0;
                            }
                            segment[l++] = relativeX = relativeX + a[i + 3] * 1;
                            segment[l++] = relativeY = relativeY + a[i + 4] * 1;
                            i += 4;
                        } else if (command === "Q") {
                            difX = x - relativeX;
                            difY = y - relativeY;
                            segment[l++] = relativeX + difX * 2 / 3;
                            segment[l++] = relativeY + difY * 2 / 3;
                            if (!isRelative) {
                                relativeX = relativeY = 0;
                            }
                            relativeX = relativeX + a[i + 3] * 1;
                            relativeY = relativeY + a[i + 4] * 1;
                            difX = x - relativeX;
                            difY = y - relativeY;
                            segment[l++] = relativeX + difX * 2 / 3;
                            segment[l++] = relativeY + difY * 2 / 3;
                            segment[l++] = relativeX;
                            segment[l++] = relativeY;
                            i += 4;
                        } else if (command === "T") {
                            difX = relativeX - segment[l - 4];
                            difY = relativeY - segment[l - 3];
                            segment[l++] = relativeX + difX;
                            segment[l++] = relativeY + difY;
                            difX = relativeX + difX * 1.5 - x;
                            difY = relativeY + difY * 1.5 - y;
                            segment[l++] = x + difX * 2 / 3;
                            segment[l++] = y + difY * 2 / 3;
                            segment[l++] = relativeX = x;
                            segment[l++] = relativeY = y;
                            i += 2;
                        } else if (command === "H") {
                            y = relativeY;
                            segment[l++] = relativeX + (x - relativeX) / 3;
                            segment[l++] = relativeY + (y - relativeY) / 3;
                            segment[l++] = relativeX + (x - relativeX) * 2 / 3;
                            segment[l++] = relativeY + (y - relativeY) * 2 / 3;
                            segment[l++] = relativeX = x;
                            segment[l++] = y;
                            i += 1;
                        } else if (command === "V") {
                            y = x;
                            x = relativeX;
                            if (isRelative) {
                                y += relativeY - relativeX;
                            }
                            segment[l++] = x;
                            segment[l++] = relativeY + (y - relativeY) / 3;
                            segment[l++] = x;
                            segment[l++] = relativeY + (y - relativeY) * 2 / 3;
                            segment[l++] = x;
                            segment[l++] = relativeY = y;
                            i += 1;
                        } else if (command === "L" || command === "Z") {
                            if (command === "Z") {
                                x = startX;
                                y = startY;
                                segment.closed = true;
                            }
                            if (command === "L" || Math.abs(relativeX - x) > 0.5 || Math.abs(relativeY - y) > 0.5) {
                                segment[l++] = relativeX + (x - relativeX) / 3;
                                segment[l++] = relativeY + (y - relativeY) / 3;
                                segment[l++] = relativeX + (x - relativeX) * 2 / 3;
                                segment[l++] = relativeY + (y - relativeY) * 2 / 3;
                                segment[l++] = x;
                                segment[l++] = y;
                                if (command === "L") {
                                    i += 2;
                                }
                            }
                            relativeX = x;
                            relativeY = y;
                        } else if (command === "A") {
                            beziers = _arcToBeziers(relativeX, relativeY, a[i + 1] * 1, a[i + 2] * 1, a[i + 3] * 1, a[i + 4] * 1, a[i + 5] * 1, (isRelative ? relativeX : 0) + a[i + 6] * 1, (isRelative ? relativeY : 0) + a[i + 7] * 1);
                            if (beziers) {
                                for (j = 0; j < beziers.length; j++) {
                                    segment[l++] = beziers[j];
                                }
                            }
                            relativeX = segment[l - 2];
                            relativeY = segment[l - 1];
                            i += 7;
                        } else {
                            _log("Error: malformed path data: " + d);
                        }
                    }
                    path.totalPoints = points + l;
                    return path;
                },
                _subdivideBezier = function _subdivideBezier(bezier, quantity) {
                    var tally = 0,
                        max = 0.999999,
                        l = bezier.length,
                        newPointsPerSegment = quantity / ((l - 2) / 6),
                        ax, ay, cp1x, cp1y, cp2x, cp2y, bx, by, x1, y1, x2, y2, i, t;
                    for (i = 2; i < l; i += 6) {
                        tally += newPointsPerSegment;
                        while (tally > max) {
                            ax = bezier[i - 2];
                            ay = bezier[i - 1];
                            cp1x = bezier[i];
                            cp1y = bezier[i + 1];
                            cp2x = bezier[i + 2];
                            cp2y = bezier[i + 3];
                            bx = bezier[i + 4];
                            by = bezier[i + 5];
                            t = 1 / (Math.floor(tally) + 1);
                            x1 = ax + (cp1x - ax) * t;
                            x2 = cp1x + (cp2x - cp1x) * t;
                            x1 += (x2 - x1) * t;
                            x2 += (cp2x + (bx - cp2x) * t - x2) * t;
                            y1 = ay + (cp1y - ay) * t;
                            y2 = cp1y + (cp2y - cp1y) * t;
                            y1 += (y2 - y1) * t;
                            y2 += (cp2y + (by - cp2y) * t - y2) * t;
                            bezier.splice(i, 4, ax + (cp1x - ax) * t, ay + (cp1y - ay) * t, x1, y1, x1 + (x2 - x1) * t, y1 + (y2 - y1) * t, x2, y2, cp2x + (bx - cp2x) * t, cp2y + (by - cp2y) * t);
                            i += 6;
                            l += 6;
                            tally--;
                        }
                    }
                    return bezier;
                },
                _bezierToPathData = function _bezierToPathData(beziers) {
                    var data = "",
                        l = beziers.length,
                        rnd = 100,
                        sl, s, i, segment;
                    for (s = 0; s < l; s++) {
                        segment = beziers[s];
                        data += "M" + segment[0] + "," + segment[1] + " C";
                        sl = segment.length;
                        for (i = 2; i < sl; i++) {
                            data += (segment[i++] * rnd | 0) / rnd + "," + (segment[i++] * rnd | 0) / rnd + " " + (segment[i++] * rnd | 0) / rnd + "," + (segment[i++] * rnd | 0) / rnd + " " + (segment[i++] * rnd | 0) / rnd + "," + (segment[i] * rnd | 0) / rnd + " ";
                        }
                        if (segment.closed) {
                            data += "z";
                        }
                    }
                    return data;
                },
                _reverseBezier = function _reverseBezier(bezier) {
                    var a = [],
                        i = bezier.length - 1,
                        l = 0;
                    while (--i > -1) {
                        a[l++] = bezier[i];
                        a[l++] = bezier[i + 1];
                        i--;
                    }
                    for (i = 0; i < l; i++) {
                        bezier[i] = a[i];
                    }
                    bezier.reversed = bezier.reversed ? false : true;
                },
                _getAverageXY = function _getAverageXY(bezier) {
                    var l = bezier.length,
                        x = 0,
                        y = 0,
                        i;
                    for (i = 0; i < l; i++) {
                        x += bezier[i++];
                        y += bezier[i];
                    }
                    return [x / (l / 2), y / (l / 2)];
                },
                _getSize = function _getSize(bezier) {
                    var l = bezier.length,
                        xMax = bezier[0],
                        xMin = xMax,
                        yMax = bezier[1],
                        yMin = yMax,
                        x, y, i;
                    for (i = 6; i < l; i += 6) {
                        x = bezier[i];
                        y = bezier[i + 1];
                        if (x > xMax) {
                            xMax = x;
                        } else if (x < xMin) {
                            xMin = x;
                        }
                        if (y > yMax) {
                            yMax = y;
                        } else if (y < yMin) {
                            yMin = y;
                        }
                    }
                    bezier.centerX = (xMax + xMin) / 2;
                    bezier.centerY = (yMax + yMin) / 2;
                    return bezier.size = (xMax - xMin) * (yMax - yMin);
                },
                _getTotalSize = function _getTotalSize(bezier) {
                    var segment = bezier.length,
                        xMax = bezier[0][0],
                        xMin = xMax,
                        yMax = bezier[0][1],
                        yMin = yMax,
                        l, x, y, i, b;
                    while (--segment > -1) {
                        b = bezier[segment];
                        l = b.length;
                        for (i = 6; i < l; i += 6) {
                            x = b[i];
                            y = b[i + 1];
                            if (x > xMax) {
                                xMax = x;
                            } else if (x < xMin) {
                                xMin = x;
                            }
                            if (y > yMax) {
                                yMax = y;
                            } else if (y < yMin) {
                                yMin = y;
                            }
                        }
                    }
                    bezier.centerX = (xMax + xMin) / 2;
                    bezier.centerY = (yMax + yMin) / 2;
                    return bezier.size = (xMax - xMin) * (yMax - yMin);
                },
                _sortByComplexity = function _sortByComplexity(a, b) {
                    return b.length - a.length;
                },
                _sortBySize = function _sortBySize(a, b) {
                    var sizeA = a.size || _getSize(a),
                        sizeB = b.size || _getSize(b);
                    return Math.abs(sizeB - sizeA) < (sizeA + sizeB) / 20 ? b.centerX - a.centerX || b.centerY - a.centerY : sizeB - sizeA;
                },
                _offsetBezier = function _offsetBezier(bezier, shapeIndex) {
                    var a = bezier.slice(0),
                        l = bezier.length,
                        wrap = l - 2,
                        i, index;
                    shapeIndex = shapeIndex | 0;
                    for (i = 0; i < l; i++) {
                        index = (i + shapeIndex) % wrap;
                        bezier[i++] = a[index];
                        bezier[i] = a[index + 1];
                    }
                },
                _getTotalMovement = function _getTotalMovement(sb, eb, shapeIndex, offsetX, offsetY) {
                    var l = sb.length,
                        d = 0,
                        wrap = l - 2,
                        index, i, x, y;
                    shapeIndex *= 6;
                    for (i = 0; i < l; i += 6) {
                        index = (i + shapeIndex) % wrap;
                        y = sb[index] - (eb[i] - offsetX);
                        x = sb[index + 1] - (eb[i + 1] - offsetY);
                        d += Math.sqrt(x * x + y * y);
                    }
                    return d;
                },
                _getClosestShapeIndex = function _getClosestShapeIndex(sb, eb, checkReverse) {
                    var l = sb.length,
                        sCenter = _getAverageXY(sb),
                        eCenter = _getAverageXY(eb),
                        offsetX = eCenter[0] - sCenter[0],
                        offsetY = eCenter[1] - sCenter[1],
                        min = _getTotalMovement(sb, eb, 0, offsetX, offsetY),
                        minIndex = 0,
                        copy, d, i;
                    for (i = 6; i < l; i += 6) {
                        d = _getTotalMovement(sb, eb, i / 6, offsetX, offsetY);
                        if (d < min) {
                            min = d;
                            minIndex = i;
                        }
                    }
                    if (checkReverse) {
                        copy = sb.slice(0);
                        _reverseBezier(copy);
                        for (i = 6; i < l; i += 6) {
                            d = _getTotalMovement(copy, eb, i / 6, offsetX, offsetY);
                            if (d < min) {
                                min = d;
                                minIndex = -i;
                            }
                        }
                    }
                    return minIndex / 6;
                },
                _getClosestAnchor = function _getClosestAnchor(bezier, x, y) {
                    var j = bezier.length,
                        closestDistance = 99999999999,
                        closestX = 0,
                        closestY = 0,
                        b, dx, dy, d, i, l;
                    while (--j > -1) {
                        b = bezier[j];
                        l = b.length;
                        for (i = 0; i < l; i += 6) {
                            dx = b[i] - x;
                            dy = b[i + 1] - y;
                            d = Math.sqrt(dx * dx + dy * dy);
                            if (d < closestDistance) {
                                closestDistance = d;
                                closestX = b[i];
                                closestY = b[i + 1];
                            }
                        }
                    }
                    return [closestX, closestY];
                },
                _getClosestSegment = function _getClosestSegment(bezier, pool, startIndex, sortRatio, offsetX, offsetY) {
                    var l = pool.length,
                        index = 0,
                        minSize = Math.min(bezier.size || _getSize(bezier), pool[startIndex].size || _getSize(pool[startIndex])) * sortRatio,
                        min = 999999999999,
                        cx = bezier.centerX + offsetX,
                        cy = bezier.centerY + offsetY,
                        size, i, dx, dy, d;
                    for (i = startIndex; i < l; i++) {
                        size = pool[i].size || _getSize(pool[i]);
                        if (size < minSize) {
                            break;
                        }
                        dx = pool[i].centerX - cx;
                        dy = pool[i].centerY - cy;
                        d = Math.sqrt(dx * dx + dy * dy);
                        if (d < min) {
                            index = i;
                            min = d;
                        }
                    }
                    d = pool[index];
                    pool.splice(index, 1);
                    return d;
                },
                _equalizeSegmentQuantity = function _equalizeSegmentQuantity(start, end, shapeIndex, map) {
                    var dif = end.length - start.length,
                        longer = dif > 0 ? end : start,
                        shorter = dif > 0 ? start : end,
                        added = 0,
                        sortMethod = map === "complexity" ? _sortByComplexity : _sortBySize,
                        sortRatio = map === "position" ? 0 : typeof map === "number" ? map : 0.8,
                        i = shorter.length,
                        shapeIndices = (typeof shapeIndex === "undefined" ? "undefined" : _typeof(shapeIndex)) === "object" && shapeIndex.push ? shapeIndex.slice(0) : [shapeIndex],
                        reverse = shapeIndices[0] === "reverse" || shapeIndices[0] < 0,
                        log = shapeIndex === "log",
                        eb, sb, b, x, y, offsetX, offsetY;
                    if (!shorter[0]) {
                        return;
                    }
                    if (longer.length > 1) {
                        start.sort(sortMethod);
                        end.sort(sortMethod);
                        offsetX = longer.size || _getTotalSize(longer);
                        offsetX = shorter.size || _getTotalSize(shorter);
                        offsetX = longer.centerX - shorter.centerX;
                        offsetY = longer.centerY - shorter.centerY;
                        if (sortMethod === _sortBySize) {
                            for (i = 0; i < shorter.length; i++) {
                                longer.splice(i, 0, _getClosestSegment(shorter[i], longer, i, sortRatio, offsetX, offsetY));
                            }
                        }
                    }
                    if (dif) {
                        if (dif < 0) {
                            dif = -dif;
                        }
                        if (longer[0].length > shorter[0].length) {
                            _subdivideBezier(shorter[0], (longer[0].length - shorter[0].length) / 6 | 0);
                        }
                        i = shorter.length;
                        while (added < dif) {
                            x = longer[i].size || _getSize(longer[i]);
                            b = _getClosestAnchor(shorter, longer[i].centerX, longer[i].centerY);
                            x = b[0];
                            y = b[1];
                            shorter[i++] = [x, y, x, y, x, y, x, y];
                            shorter.totalPoints += 8;
                            added++;
                        }
                    }
                    for (i = 0; i < start.length; i++) {
                        eb = end[i];
                        sb = start[i];
                        dif = eb.length - sb.length;
                        if (dif < 0) {
                            _subdivideBezier(eb, -dif / 6 | 0);
                        } else if (dif > 0) {
                            _subdivideBezier(sb, dif / 6 | 0);
                        }
                        if (reverse && !sb.reversed) {
                            _reverseBezier(sb);
                        }
                        shapeIndex = shapeIndices[i] || shapeIndices[i] === 0 ? shapeIndices[i] : "auto";
                        if (shapeIndex) {
                            if (sb.closed || Math.abs(sb[0] - sb[sb.length - 2]) < 0.5 && Math.abs(sb[1] - sb[sb.length - 1]) < 0.5) {
                                if (shapeIndex === "auto" || shapeIndex === "log") {
                                    shapeIndices[i] = shapeIndex = _getClosestShapeIndex(sb, eb, i === 0);
                                    if (shapeIndex < 0) {
                                        reverse = true;
                                        _reverseBezier(sb);
                                        shapeIndex = -shapeIndex;
                                    }
                                    _offsetBezier(sb, shapeIndex * 6);
                                } else if (shapeIndex !== "reverse") {
                                    if (i && shapeIndex < 0) {
                                        _reverseBezier(sb);
                                    }
                                    _offsetBezier(sb, (shapeIndex < 0 ? -shapeIndex : shapeIndex) * 6);
                                }
                            } else if (!reverse && (shapeIndex === "auto" && Math.abs(eb[0] - sb[0]) + Math.abs(eb[1] - sb[1]) + Math.abs(eb[eb.length - 2] - sb[sb.length - 2]) + Math.abs(eb[eb.length - 1] - sb[sb.length - 1]) > Math.abs(eb[0] - sb[sb.length - 2]) + Math.abs(eb[1] - sb[sb.length - 1]) + Math.abs(eb[eb.length - 2] - sb[0]) + Math.abs(eb[eb.length - 1] - sb[1]) || shapeIndex % 2)) {
                                _reverseBezier(sb);
                                shapeIndices[i] = -1;
                                reverse = true;
                            } else if (shapeIndex === "auto") {
                                shapeIndices[i] = 0;
                            } else if (shapeIndex === "reverse") {
                                shapeIndices[i] = -1;
                            }
                            if (sb.closed !== eb.closed) {
                                sb.closed = eb.closed = false;
                            }
                        }
                    }
                    if (log) {
                        _log("shapeIndex:[" + shapeIndices.join(",") + "]");
                    }
                    return shapeIndices;
                },
                _pathFilter = function _pathFilter(a, shapeIndex, map, precompile) {
                    var start = _pathDataToBezier(a[0]),
                        end = _pathDataToBezier(a[1]);
                    if (!_equalizeSegmentQuantity(start, end, shapeIndex || shapeIndex === 0 ? shapeIndex : "auto", map)) {
                        return;
                    }
                    a[0] = _bezierToPathData(start);
                    a[1] = _bezierToPathData(end);
                    if (precompile === "log" || precompile === true) {
                        _log('precompile:["' + a[0] + '","' + a[1] + '"]');
                    }
                },
                _buildPathFilter = function _buildPathFilter(shapeIndex, map, precompile) {
                    return map || precompile || shapeIndex || shapeIndex === 0 ? function(a) {
                        _pathFilter(a, shapeIndex, map, precompile);
                    } : _pathFilter;
                },
                _offsetPoints = function _offsetPoints(text, offset) {
                    if (!offset) {
                        return text;
                    }
                    var a = text.match(_numbersExp) || [],
                        l = a.length,
                        s = "",
                        inc, i, j;
                    if (offset === "reverse") {
                        i = l - 1;
                        inc = -2;
                    } else {
                        i = ((parseInt(offset, 10) || 0) * 2 + 1 + l * 100) % l;
                        inc = 2;
                    }
                    for (j = 0; j < l; j += 2) {
                        s += a[i - 1] + "," + a[i] + " ";
                        i = (i + inc) % l;
                    }
                    return s;
                },
                _equalizePointQuantity = function _equalizePointQuantity(a, quantity) {
                    var tally = 0,
                        x = parseFloat(a[0]),
                        y = parseFloat(a[1]),
                        s = x + "," + y + " ",
                        max = 0.999999,
                        newPointsPerSegment, i, l, j, factor, nextX, nextY;
                    l = a.length;
                    newPointsPerSegment = quantity * 0.5 / (l * 0.5 - 1);
                    for (i = 0; i < l - 2; i += 2) {
                        tally += newPointsPerSegment;
                        nextX = parseFloat(a[i + 2]);
                        nextY = parseFloat(a[i + 3]);
                        if (tally > max) {
                            factor = 1 / (Math.floor(tally) + 1);
                            j = 1;
                            while (tally > max) {
                                s += (x + (nextX - x) * factor * j).toFixed(2) + "," + (y + (nextY - y) * factor * j).toFixed(2) + " ";
                                tally--;
                                j++;
                            }
                        }
                        s += nextX + "," + nextY + " ";
                        x = nextX;
                        y = nextY;
                    }
                    return s;
                },
                _pointsFilter = function _pointsFilter(a) {
                    var startNums = a[0].match(_numbersExp) || [],
                        endNums = a[1].match(_numbersExp) || [],
                        dif = endNums.length - startNums.length;
                    if (dif > 0) {
                        a[0] = _equalizePointQuantity(startNums, dif);
                    } else {
                        a[1] = _equalizePointQuantity(endNums, -dif);
                    }
                },
                _buildPointsFilter = function _buildPointsFilter(shapeIndex) {
                    return !isNaN(shapeIndex) ? function(a) {
                        _pointsFilter(a);
                        a[1] = _offsetPoints(a[1], parseInt(shapeIndex, 10));
                    } : _pointsFilter;
                },
                _createPath = function _createPath(e, ignore) {
                    var path = _gsScope.document.createElementNS("http://www.w3.org/2000/svg", "path"),
                        attr = Array.prototype.slice.call(e.attributes),
                        i = attr.length,
                        name;
                    ignore = "," + ignore + ",";
                    while (--i > -1) {
                        name = attr[i].nodeName.toLowerCase();
                        if (ignore.indexOf("," + name + ",") === -1) {
                            path.setAttributeNS(null, name, attr[i].nodeValue);
                        }
                    }
                    return path;
                },
                _convertToPath = function _convertToPath(e, swap) {
                    var type = e.tagName.toLowerCase(),
                        circ = 0.552284749831,
                        data, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6;
                    if (type === "path" || !e.getBBox) {
                        return e;
                    }
                    path = _createPath(e, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
                    if (type === "rect") {
                        r = +e.getAttribute("rx") || 0;
                        ry = +e.getAttribute("ry") || 0;
                        x = +e.getAttribute("x") || 0;
                        y = +e.getAttribute("y") || 0;
                        w = (+e.getAttribute("width") || 0) - r * 2;
                        h = (+e.getAttribute("height") || 0) - ry * 2;
                        if (r || ry) {
                            x2 = x + r * (1 - circ);
                            x3 = x + r;
                            x4 = x3 + w;
                            x5 = x4 + r * circ;
                            x6 = x4 + r;
                            y2 = y + ry * (1 - circ);
                            y3 = y + ry;
                            y4 = y3 + h;
                            y5 = y4 + ry * circ;
                            y6 = y4 + ry;
                            data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";
                        } else {
                            data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";
                        }
                    } else if (type === "circle" || type === "ellipse") {
                        if (type === "circle") {
                            r = ry = +e.getAttribute("r") || 0;
                            rycirc = r * circ;
                        } else {
                            r = +e.getAttribute("rx") || 0;
                            ry = +e.getAttribute("ry") || 0;
                            rycirc = ry * circ;
                        }
                        x = +e.getAttribute("cx") || 0;
                        y = +e.getAttribute("cy") || 0;
                        rcirc = r * circ;
                        data = "M" + (x + r) + "," + y + " C" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";
                    } else if (type === "line") {
                        data = _bezierToPathData(_pathDataToBezier("M" + (e.getAttribute("x1") || 0) + "," + (e.getAttribute("y1") || 0) + " L" + (e.getAttribute("x2") || 0) + "," + (e.getAttribute("y2") || 0)));
                    } else if (type === "polyline" || type === "polygon") {
                        points = (e.getAttribute("points") + "").match(_numbersExp) || [];
                        x = points.shift();
                        y = points.shift();
                        data = "M" + x + "," + y + " L" + points.join(",");
                        if (type === "polygon") {
                            data += "," + x + "," + y + "z";
                        }
                    }
                    path.setAttribute("d", data);
                    if (swap && e.parentNode) {
                        e.parentNode.insertBefore(path, e);
                        e.parentNode.removeChild(e);
                    }
                    return path;
                },
                _parseShape = function _parseShape(shape, forcePath, target) {
                    var isString = typeof shape === "string",
                        e, type;
                    if (!isString || _selectorExp.test(shape) || (shape.match(_numbersExp) || []).length < 3) {
                        e = isString ? TweenLite.selector(shape) : shape && shape[0] ? shape : [shape];
                        if (e && e[0]) {
                            e = e[0];
                            type = e.nodeName.toUpperCase();
                            if (forcePath && type !== "PATH") {
                                e = _convertToPath(e, false);
                                type = "PATH";
                            }
                            shape = e.getAttribute(type === "PATH" ? "d" : "points") || "";
                            if (e === target) {
                                shape = e.getAttributeNS(null, "data-original") || shape;
                            }
                        } else {
                            _log("WARNING: invalid morph to: " + shape);
                            shape = false;
                        }
                    }
                    return shape;
                },
                _morphMessage = "Use MorphSVGPlugin.convertToPath(elementOrSelectorText) to convert to a path before morphing.",
                MorphSVGPlugin = _gsScope._gsDefine.plugin({
                    propName: "morphSVG",
                    API: 2,
                    global: true,
                    version: "0.8.11",
                    init: function init(target, value, tween, index) {
                        var type, p, pt, shape, isPoly;
                        if (typeof target.setAttribute !== "function") {
                            return false;
                        }
                        if (typeof value === "function") {
                            value = value(index, target);
                        }
                        type = target.nodeName.toUpperCase();
                        isPoly = type === "POLYLINE" || type === "POLYGON";
                        if (type !== "PATH" && !isPoly) {
                            _log("WARNING: cannot morph a <" + type + "> SVG element. " + _morphMessage);
                            return false;
                        }
                        p = type === "PATH" ? "d" : "points";
                        if (typeof value === "string" || value.getBBox || value[0]) {
                            value = {
                                shape: value
                            };
                        }
                        shape = _parseShape(value.shape || value.d || value.points || "", p === "d", target);
                        if (isPoly && _commands.test(shape)) {
                            _log("WARNING: a <" + type + "> cannot accept path data. " + _morphMessage);
                            return false;
                        }
                        if (shape) {
                            this._target = target;
                            if (!target.getAttributeNS(null, "data-original")) {
                                target.setAttributeNS(null, "data-original", target.getAttribute(p));
                            }
                            pt = this._addTween(target, "setAttribute", target.getAttribute(p) + "", shape + "", "morphSVG", false, p, _typeof(value.precompile) === "object" ? function(a) {
                                a[0] = value.precompile[0];
                                a[1] = value.precompile[1];
                            } : p === "d" ? _buildPathFilter(value.shapeIndex, value.map || MorphSVGPlugin.defaultMap, value.precompile) : _buildPointsFilter(value.shapeIndex));
                            if (pt) {
                                this._overwriteProps.push("morphSVG");
                                pt.end = shape;
                                pt.endProp = p;
                            }
                        }
                        return true;
                    },
                    set: function set(ratio) {
                        var pt;
                        this._super.setRatio.call(this, ratio);
                        if (ratio === 1) {
                            pt = this._firstPT;
                            while (pt) {
                                if (pt.end) {
                                    this._target.setAttribute(pt.endProp, pt.end);
                                }
                                pt = pt._next;
                            }
                        }
                    }
                });
            MorphSVGPlugin.pathFilter = _pathFilter;
            MorphSVGPlugin.pointsFilter = _pointsFilter;
            MorphSVGPlugin.subdivideRawBezier = _subdivideBezier;
            MorphSVGPlugin.defaultMap = "size";
            MorphSVGPlugin.pathDataToRawBezier = function(data) {
                return _pathDataToBezier(_parseShape(data, true));
            };
            MorphSVGPlugin.equalizeSegmentQuantity = _equalizeSegmentQuantity;
            MorphSVGPlugin.convertToPath = function(targets, swap) {
                if (typeof targets === "string") {
                    targets = TweenLite.selector(targets);
                }
                var a = !targets || targets.length === 0 ? [] : targets.length && targets[0] && targets[0].nodeType ? Array.prototype.slice.call(targets, 0) : [targets],
                    i = a.length;
                while (--i > -1) {
                    a[i] = _convertToPath(a[i], swap !== false);
                }
                return a;
            };
            MorphSVGPlugin.pathDataToBezier = function(data, vars) {
                var bezier = _pathDataToBezier(_parseShape(data, true))[0] || [],
                    prefix = 0,
                    a, i, l, matrix, offsetX, offsetY, bbox, e;
                vars = vars || {};
                e = vars.align || vars.relative;
                matrix = vars.matrix || [1, 0, 0, 1, 0, 0];
                offsetX = vars.offsetX || 0;
                offsetY = vars.offsetY || 0;
                if (e === "relative" || e === true) {
                    offsetX -= bezier[0] * matrix[0] + bezier[1] * matrix[2];
                    offsetY -= bezier[0] * matrix[1] + bezier[1] * matrix[3];
                    prefix = "+=";
                } else {
                    offsetX += matrix[4];
                    offsetY += matrix[5];
                    if (e) {
                        e = typeof e === "string" ? TweenLite.selector(e) : e && e[0] ? e : [e];
                        if (e && e[0]) {
                            bbox = e[0].getBBox() || {
                                x: 0,
                                y: 0
                            };
                            offsetX -= bbox.x;
                            offsetY -= bbox.y;
                        }
                    }
                }
                a = [];
                l = bezier.length;
                if (matrix && matrix.join(",") !== "1,0,0,1,0,0") {
                    for (i = 0; i < l; i += 2) {
                        a.push({
                            x: prefix + (bezier[i] * matrix[0] + bezier[i + 1] * matrix[2] + offsetX),
                            y: prefix + (bezier[i] * matrix[1] + bezier[i + 1] * matrix[3] + offsetY)
                        });
                    }
                } else {
                    for (i = 0; i < l; i += 2) {
                        a.push({
                            x: prefix + (bezier[i] + offsetX),
                            y: prefix + (bezier[i + 1] + offsetY)
                        });
                    }
                }
                return a;
            };
        });
        if (_gsScope._gsDefine) {
            _gsScope._gsQueue.pop()();
        }
        (function(name) {
            "use strict";
            var getGlobal = function getGlobal() {
                return (_gsScope.GreenSockGlobals || _gsScope)[name];
            };
            if (typeof module !== "undefined" && module.exports) {
                __webpack_require__(0);
                module.exports = getGlobal();
            } else if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (getGlobal), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }
        })("MorphSVGPlugin");
    }.call(exports, __webpack_require__(6)))
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _gsap = __webpack_require__(0);
    var _utils = __webpack_require__(2);
    var _ImageReveal = __webpack_require__(25);
    var _ImageReveal2 = _interopRequireDefault(_ImageReveal);
    var _BuffaCursor = __webpack_require__(9);
    var _BuffaCursor2 = _interopRequireDefault(_BuffaCursor);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var BuffaTooltip = function() {
        function BuffaTooltip(target) {
            var _this = this;
            _classCallCheck(this, BuffaTooltip);
            this.target = target;
            this.imageRevealTarget = (0, _utils.qs)(".tooltip__image", this.target);
            this.imageRevealInstance = null;
            this.mq = window.matchMedia("(min-width: 640px)");
            this.active = this.mq.matches;
            this.elemOffset = {};
            this.mouseenterCallback = function(_) {
                return _this.toggleHover("add");
            };
            this.mouseleaveCallback = function(_) {
                return _this.toggleHover("remove");
            };
            this.mousemoveCallback = function(_) {
                return _this.animateOnHover();
            };
            this.init();
        }
        _createClass(BuffaTooltip, [{
            key: "init",
            value: function init() {
                this.imageRevealInstance = new _ImageReveal2.default({
                    parent: this.imageRevealTarget,
                    image1: BUFFA.assets_url + "/images/transparent.png",
                    image2: BUFFA.assets_url + "/images/about/" + this.target.dataset.image,
                    intensity: (0, _utils.getRandomFloat)(0.1, 0.2),
                    angle: (0, _utils.getRandomInt)(1, 360) * Math.PI / 180,
                    displacementImage: BUFFA.assets_url + "/images/displacement/filter-water.png",
                    speedIn: 0.45,
                    speedOut: 0.45,
                    easing: _gsap.Power1.easeInOut,
                    hover: false
                });
                BUFFA.image_reveal_instances.push(this.imageRevealInstance);
                this.setupListeners();
            }
        }, {
            key: "toggleHover",
            value: function toggleHover() {
                var _this2 = this;
                var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "add";
                if (!this.active) return;
                if (action === "add") {
                    this.activeTooltip = (0, _utils.qs)(".tooltip__image", this.target);
                    this.activeTooltip.style.opacity = 1;
                    this.imageRevealInstance.next();
                }
                if (action === "remove") {
                    this.imageRevealInstance.prev().then(function(_) {
                        return _gsap.TweenMax.set(_this2.imageRevealTarget, {
                            clearProps: "opacity"
                        });
                    });
                }
            }
        }, {
            key: "animateOnHover",
            value: function animateOnHover() {
                if (!this.active) return;
                this.elemOffset = {
                    x: this.target.offsetLeft + this.target.parentNode.parentNode.offsetLeft + this.target.parentNode.parentNode.parentNode.offsetLeft,
                    y: this.target.offsetTop + this.target.parentNode.parentNode.offsetTop + this.target.parentNode.parentNode.parentNode.offsetTop
                };
                var mouseRelativeCoords = {
                    x: _BuffaCursor2.default.coords.x - this.elemOffset.x,
                    y: _BuffaCursor2.default.coords.y - this.elemOffset.y
                };
                _gsap.TweenMax.to(this.activeTooltip, 1, {
                    x: mouseRelativeCoords.x,
                    y: mouseRelativeCoords.y
                });
            }
        }, {
            key: "setState",
            value: function setState(state) {
                this.active = state;
            }
        }, {
            key: "setupListeners",
            value: function setupListeners() {
                var _this3 = this;
                this.target.addEventListener("mouseenter", this.mouseenterCallback);
                this.target.addEventListener("mouseleave", this.mouseleaveCallback);
                this.target.addEventListener("mousemove", this.mousemoveCallback);
                var mqCallback = function mqCallback(_) {
                    return _this3.setState(_this3.mq.matches);
                };
                this.mq.addListener(mqCallback);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.target.removeEventListener("mouseenter", this.mouseenterCallback);
                this.target.removeEventListener("mouseleave", this.mouseleaveCallback);
                this.target.removeEventListener("mousemove", this.mousemoveCallback);
            }
        }]);
        return BuffaTooltip;
    }();
    exports.default = BuffaTooltip;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _gsap = __webpack_require__(0);
    var _CustomEase = __webpack_require__(24);
    var _CustomEase2 = _interopRequireDefault(_CustomEase);
    var _utils = __webpack_require__(2);
    var _const = __webpack_require__(8);
    var _BuffaWorksSlider = __webpack_require__(58);
    var _BuffaWorksSlider2 = _interopRequireDefault(_BuffaWorksSlider);
    var _BuffaObservers = __webpack_require__(63);
    var _BuffaWordsCarousel = __webpack_require__(66);
    var _BuffaWordsCarousel2 = _interopRequireDefault(_BuffaWordsCarousel);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var PageAnimations = function() {
        function PageAnimations() {
            _classCallCheck(this, PageAnimations);
            this.stripTiming = 0.2;
            _CustomEase2.default.create('easingBuffa', _const.BUFFA_EASE_CURVE);
        }
        _createClass(PageAnimations, [{
            key: 'animateIn',
            value: function animateIn(namespace) {
                var firstView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                if (firstView) this.animateInCommonStuff(namespace);
                switch (namespace) {
                    case "about-page":
                        this.animateInAbout();
                        break;
                    case "works-page":
                        this.animateInWorks();
                        break;
                    case "single-work":
                        this.animateInSingleWork();
                        break;
                    case "credits-page":
                        this.animateInCreditsPage();
                        break;
                    case "gif-page":
                        this.animateInGifPage();
                        break;
                    case "contacts-page":
                        this.animateInContacts();
                        break;
                    case "404-page":
                        this.animateIn404();
                        break;
                    default:
                        return;
                }
            }
        }, {
            key: 'animateOut',
            value: function animateOut(namespace) {
                var _this = this;
                return new Promise(function(resolve) {
                    switch (namespace) {
                        case "about-page":
                            _this.animateOutAbout().then(function(_) {
                                return resolve();
                            });
                            break;
                        case "works-page":
                            _this.animateOutWorks().then(function(_) {
                                return resolve();
                            });
                            break;
                        case "single-work":
                            _this.animateOutSingleWork().then(function(_) {
                                return resolve();
                            });
                            break;
                        case "credits-page":
                            _this.animateOutCredits().then(function(_) {
                                return resolve();
                            });
                            break;
                        case "gif-page":
                            _this.animateOutGifPage().then(function(_) {
                                return resolve();
                            });
                            break;
                        case "contacts-page":
                            _this.animateOutContacts().then(function(_) {
                                return resolve();
                            });
                            break;
                        case "404-page":
                            _this.animateOut404().then(function(_) {
                                return resolve();
                            });
                            break;
                        default:
                            resolve();
                    }
                });
            }
        }, {
            key: 'animateInCommonStuff',
            value: function animateInCommonStuff(namespace) {
                var tl = new _gsap.TimelineMax({
                    onComplete: function onComplete(_) {
                        _gsap.TweenMax.set(".side-menu__dot", {
                            className: "+=side-menu__dot--visible",
                            clearProps: "all"
                        });
                    }
                });
                tl.add("start").staggerTo('.side-menu__dot', this.stripTiming * 2, {
                    scale: 1,
                    ease: "easingBuffa"
                }, 0.2, "start");
                var linkToAnimateIn = namespace === "single-work" ? ".side-menu [data-ns='works-page'] a" : '.side-menu .current';
                tl.set(linkToAnimateIn, {
                    className: "+=current current-animate"
                }, "start+=0.7");
                tl.to('.hamburger__line--top', this.stripTiming * 3, {
                    css: {
                        right: '5px'
                    },
                    ease: "easingBuffa"
                }, 'start').to('.hamburger__line--middle', this.stripTiming * 4, {
                    css: {
                        left: '0px'
                    },
                    ease: "easingBuffa"
                }, 'start+=0.2').to('.hamburger__line--bottom', this.stripTiming * 4, {
                    css: {
                        left: '5px'
                    },
                    ease: "easingBuffa"
                }, 'start+=0.2').to('.top-bar-left, .top-bar-right, .footer-left, .footer-logo, .side-content--right, .footer-right', 2, {
                    opacity: 1,
                    ease: "easingBuffa"
                }, 'start');
            }
        }, {
            key: 'animateInAbout',
            value: function animateInAbout() {
                var _this2 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            _gsap.TweenMax.set(".corner-link", {
                                className: "+=corner-link--visible",
                                clearProps: "all"
                            });
                            resolve();
                        }
                    });
                    tl.add('start').to('.lettering--me', _this2.stripTiming * 4, {
                        y: 0,
                        ease: "easingBuffa"
                    }, 'start').to('.lettering--about', _this2.stripTiming * 4, {
                        y: 0,
                        ease: "easingBuffa"
                    }, 'start').staggerTo('.about-content__row', _this2.stripTiming * 3, {
                        x: 0,
                        ease: "easingBuffa"
                    }, 0.2, "start").set(".about-content__row", {
                        className: "+=strip-animate strip-animate-in"
                    }, "start+=0.2").staggerTo(".corner-link__inner", _this2.stripTiming * 4, {
                        opacity: 1,
                        x: 0,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.2, "start");
                });
            }
        }, {
            key: 'animateInWorks',
            value: function animateInWorks() {
                var _this3 = this;
                return new Promise(function(resolve) {
                    var slider = new _BuffaWorksSlider2.default();
                    BUFFA.works_slider_instances.push(slider);
                    slider.init().then(function(_) {
                        var tl = new _gsap.TimelineMax({
                            onComplete: function onComplete(_) {
                                return _gsap.TweenMax.set(".corner-link", {
                                    className: "+=corner-link--visible",
                                    clearProps: "all"
                                });
                            }
                        });
                        tl.add("start").staggerTo(".corner-link__inner", _this3.stripTiming * 4, {
                            opacity: 1,
                            x: 0,
                            force3D: true,
                            ease: "easingBuffa"
                        }, 0.2, "start+=0.4");
                        new _BuffaObservers.BuffaObservers();
                        setTimeout(function(_) {
                            return (0, _utils.qs)(".scroll-indicator").classList.add("scroll-indicator--visible");
                        }, 1000);
                        resolve();
                    });
                });
            }
        }, {
            key: 'animateInSingleWork',
            value: function animateInSingleWork() {
                var _this4 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            setTimeout(function(_) {
                                new _BuffaObservers.BuffaObservers();
                                resolve();
                            }, 350);
                        }
                    });
                    tl.add("start").set([".single-work__title", ".single-work__info span", ".single-work__behance__link"], {
                        className: "+=strip-animate strip-animate-in"
                    }, "start").to(".svg-number__text", 0.4, {
                        stroke: "#fafafa"
                    }, "start+=0.3").to(".svg-number feDisplacementMap", 0.7, {
                        attr: {
                            scale: 0
                        },
                        ease: _gsap.Power1.easeOut
                    }, "start+=0.5").to([".single-work__scroll-progress", ".single-work__next-prev"], 0.75, {
                        opacity: 1,
                        ease: "easingBuffa"
                    }, "start+=0.65").staggerTo(".corner-link__inner", _this4.stripTiming * 4, {
                        opacity: 1,
                        x: 0,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.2, "start");
                });
            }
        }, {
            key: 'animateInCreditsPage',
            value: function animateInCreditsPage() {
                var _this5 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            return setTimeout(function(_) {
                                return resolve();
                            }, 2000);
                        }
                    });
                    tl.add("start").to(".lettering--credits", 1, {
                        opacity: 1,
                        ease: "easingBuffa"
                    }, "start").staggerTo([".credits-content__row", ".people-list__person"], _this5.stripTiming * 3, {
                        x: 0,
                        ease: "easingBuffa"
                    }, 0.2, "start").set([".credits-content__row", ".people-list__person"], {
                        className: "+=strip-animate strip-animate-in"
                    }, "start").staggerTo(".corner-link__inner", _this5.stripTiming * 4, {
                        opacity: 1,
                        x: 0,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.2, "start");
                });
            }
        }, {
            key: 'animateInGifPage',
            value: function animateInGifPage() {
                var _this6 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        delay: 0.3,
                        onComplete: function onComplete(_) {
                            return resolve();
                        }
                    });
                    tl.add("start").to(".vertical-carousel", 1, {
                        opacity: 1
                    }, "start").staggerTo(".corner-link__inner", _this6.stripTiming * 4, {
                        opacity: 1,
                        x: 0,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.2, "start");
                });
            }
        }, {
            key: 'animateInContacts',
            value: function animateInContacts() {
                var _this7 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onStart: function onStart(_) {
                            return BUFFA.words_carousel_instances.push(new _BuffaWordsCarousel2.default((0, _utils.qs)(".lettering--contacts")));
                        },
                        onComplete: function onComplete(_) {
                            return setTimeout(function(_) {
                                return resolve();
                            }, 2000);
                        }
                    });
                    tl.add("start").to('.contacts-content__socials', 0.6, {
                        opacity: 1,
                        ease: "easingBuffa"
                    }, "start").staggerTo('.contacts-content__desc__row', _this7.stripTiming * 3, {
                        x: 0,
                        ease: "easingBuffa"
                    }, 0.2, "start").staggerTo(".corner-link__inner", _this7.stripTiming * 4, {
                        opacity: 1,
                        delay: 0.4,
                        x: 0,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.2, "start").set([".contacts-content__desc__row", ".contacts-content__email-title", ".contacts-content__email"], {
                        className: "+=strip-animate strip-animate-in"
                    }, "start+=0.2");
                });
            }
        }, {
            key: 'animateIn404',
            value: function animateIn404() {
                var _this8 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            return resolve();
                        }
                    });
                    tl.add("start").to(".lettering--404", 1, {
                        opacity: 1,
                        ease: "easingBuffa"
                    }, "start").staggerTo(".corner-link__inner", _this8.stripTiming * 4, {
                        opacity: 1,
                        delay: 0.4,
                        x: 0,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.2, "start").to(".vertical-carousel", 1, {
                        opacity: 1
                    }, "start+=0.3");
                });
            }
        }, {
            key: 'animateOutAbout',
            value: function animateOutAbout() {
                var _this9 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            setTimeout(function(_) {
                                return resolve();
                            }, 420);
                        }
                    });
                    tl.add("start").to(".lettering-bg", 0.7, {
                        scaleX: 0.92,
                        scaleY: 0.92,
                        opacity: 0
                    }, "start").set(".strip-animate.strip-animate-in", {
                        className: "-=strip-animate-in"
                    }, "start+=0.2").set(".strip-animate", {
                        className: "+=strip-animate-out"
                    }, "start+=0.2").staggerTo(".corner-link__inner", _this9.stripTiming * 3, {
                        opacity: 0,
                        x: -10,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.1, "start+=0.1");
                });
            }
        }, {
            key: 'animateOutWorks',
            value: function animateOutWorks() {
                var _this10 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            return setTimeout(function(_) {
                                return resolve();
                            }, 450);
                        }
                    });
                    tl.add("start").set(".strip-animate.strip-animate-in", {
                        className: "-=strip-animate-in"
                    }, "start").set(".strip-animate", {
                        className: "+=strip-animate-out"
                    }, "start").to(".svg-number__text", 0.6, {
                        stroke: "transparent"
                    }, "start+=0.2").to(".svg-number feDisplacementMap", 0.6, {
                        attr: {
                            scale: 60
                        }
                    }, "start").to(".work__figure", 0.8, {
                        opacity: 0,
                        scaleX: 1.3,
                        scaleY: 1.3
                    }, "start").set(".scroll-indicator", {
                        transition: "none"
                    }, "start").to(".scroll-indicator", 0.25, {
                        opacity: 0
                    }, "start+=0.1").staggerTo(".corner-link__inner", _this10.stripTiming * 3, {
                        opacity: 0,
                        x: -10,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.1, "start+=0.1");
                });
            }
        }, {
            key: 'animateOutSingleWork',
            value: function animateOutSingleWork() {
                var _this11 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            setTimeout(function(_) {
                                return resolve();
                            }, 300);
                        }
                    });
                    tl.add("start").set(".strip-animate.strip-animate-in", {
                        className: "-=strip-animate-in"
                    }, "start").set(".strip-animate", {
                        className: "+=strip-animate-out"
                    }, "start").to(".svg-number__text", 0.6, {
                        stroke: "transparent"
                    }, "start+=0.44").to(".svg-number feDisplacementMap", 0.6, {
                        attr: {
                            scale: 60
                        }
                    }, "start+=0.24").to([".single-work__scroll-progress", ".single-work__next-prev"], 0.75, {
                        opacity: 0,
                        ease: "easingBuffa"
                    }, "start+=0.25").to(".single-work__composer", 0.75, {
                        opacity: 0,
                        ease: "easingBuffa"
                    }, "start+=0.25").staggerTo(".corner-link__inner", _this11.stripTiming * 3, {
                        opacity: 0,
                        x: -10,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.1, "start+=0.1");
                });
            }
        }, {
            key: 'animateOutCredits',
            value: function animateOutCredits() {
                var _this12 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            setTimeout(function(_) {
                                return resolve();
                            }, 420);
                        }
                    });
                    tl.add("start").to(".lettering-bg", 0.7, {
                        scaleX: 0.92,
                        scaleY: 0.92,
                        opacity: 0
                    }, "start").staggerTo(".corner-link__inner", _this12.stripTiming * 3, {
                        opacity: 0,
                        x: -10,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.1, "start+=0.1").set(".strip-animate.strip-animate-in", {
                        className: "-=strip-animate-in"
                    }, "start+=0.2").set(".strip-animate", {
                        className: "+=strip-animate-out"
                    }, "start+=0.2");
                });
            }
        }, {
            key: 'animateOutGifPage',
            value: function animateOutGifPage() {
                var _this13 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            return resolve();
                        }
                    });
                    tl.add("start").to(".vertical-carousel", 0.6, {
                        opacity: 0,
                        ease: "easingBuffa"
                    }, "start").staggerTo(".corner-link__inner", _this13.stripTiming * 3, {
                        opacity: 0,
                        x: -10,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.1, "start+=0.1");
                });
            }
        }, {
            key: 'animateOutContacts',
            value: function animateOutContacts() {
                var _this14 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            return setTimeout(function(_) {
                                return resolve();
                            }, 1200);
                        }
                    });
                    tl.add("start").set(".strip-animate.strip-animate-in", {
                        className: "-=strip-animate-in"
                    }, "start").set(".strip-animate", {
                        className: "+=strip-animate-out"
                    }, "start").to('.contacts-content__socials', 0.6, {
                        opacity: 0,
                        ease: "easingBuffa"
                    }, "start").to(".lettering-bg", 0.7, {
                        scaleX: 0.92,
                        scaleY: 0.92,
                        opacity: 0
                    }, "start").staggerTo(".corner-link__inner", _this14.stripTiming * 3, {
                        opacity: 0,
                        x: -10,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.1, "start+=0.1");
                });
            }
        }, {
            key: 'animateOut404',
            value: function animateOut404() {
                var _this15 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete(_) {
                            return resolve();
                        }
                    });
                    tl.staggerTo([".vertical-slider", ".lettering--404"], 1, {
                        opacity: 0,
                        ease: "easingBuffa"
                    }, "start").staggerTo(".corner-link__inner", _this15.stripTiming * 3, {
                        opacity: 0,
                        x: -10,
                        force3D: true,
                        ease: "easingBuffa"
                    }, 0.1, "start+=0.1");
                });
            }
        }]);
        return PageAnimations;
    }();
    exports.default = PageAnimations;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _utils = __webpack_require__(2);
    var _gsap = __webpack_require__(0);
    var _BuffaTilt = __webpack_require__(59);
    var _BuffaTilt2 = _interopRequireDefault(_BuffaTilt);
    var _Draggable = __webpack_require__(60);
    var _Draggable2 = _interopRequireDefault(_Draggable);
    __webpack_require__(61);
    var _ScrollDetector = __webpack_require__(62);
    var _ScrollDetector2 = _interopRequireDefault(_ScrollDetector);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var BuffaWorksSlides = function() {
        function BuffaWorksSlides() {
            var _this = this;
            _classCallCheck(this, BuffaWorksSlides);
            this.draggableInstance = null;
            this.slides = Array.prototype.slice.call(document.querySelectorAll(".work"));
            this.draggableBounds = this._calculateBounds();
            this.snapPoints = this._calculateSnapPoints();
            this.mq = window.matchMedia("(min-width: 640px)");
            this.scrollDetector = new _ScrollDetector2.default({
                container: "[data-namespace='works-page']",
                element: ".works-slider",
                timeout: 800
            });
            BUFFA.scroll_detector_instances.push(this.scrollDetector);
            this.resizeCallback = function(_) {
                return _this._resize();
            };
        }
        _createClass(BuffaWorksSlides, [{
            key: "init",
            value: function init() {
                var _this2 = this;
                return new Promise(function(resolve) {
                    if (_this2.mq.matches) {
                        _this2._setupDraggable();
                    } else {
                        _this2.scrollDetector.init();
                    }
                    _this2._setupListeners();
                    (0, _utils.qsa)(".work").forEach(function(work) {
                        return BUFFA.tilt_instances.push(new _BuffaTilt2.default(work));
                    });
                    resolve();
                });
            }
        }, {
            key: "destroy",
            value: function destroy() {
                (0, _utils.destroyInstances)("scroll_detector_instances");
                window.removeEventListener("resize", this.resizeCallback);
            }
        }, {
            key: "_setupDraggable",
            value: function _setupDraggable() {
                this.draggableInstance = _Draggable2.default.create(".works-slider", {
                    type: "x",
                    bounds: this.draggableBounds,
                    edgeResistance: 0.35,
                    throwProps: true,
                    snap: this.snapPoints,
                    dragClickables: true,
                    onPress: function onPress(_) {
                        return _gsap.TweenMax.to(".work", 0.4, {
                            scale: 0.92
                        });
                    },
                    onRelease: function onRelease(_) {
                        return _gsap.TweenMax.to(".work", 0.4, {
                            scale: 1
                        });
                    },
                    onThrowUpdate: function onThrowUpdate(_) {
                        var delta = _Draggable2.default.get(".works-slider").deltaX;
                        _gsap.TweenMax.to(".works-slider", 0.3, {
                            skewX: delta / 3
                        });
                    }
                });
            }
        }, {
            key: "_setupListeners",
            value: function _setupListeners() {
                var _this3 = this;
                var mqCallback = function mqCallback(_) {
                    if (_this3.mq.matches) {
                        _this3._setupDraggable();
                        _this3.scrollDetector.destroy();
                    } else {
                        _Draggable2.default.get(".works-slider").kill();
                        _gsap.TweenMax.set(".works-slider", {
                            clearProps: "all"
                        });
                        _this3.scrollDetector.init();
                    }
                };
                this.mq.addListener(mqCallback);
                window.addEventListener("resize", this.resizeCallback);
            }
        }, {
            key: "_resize",
            value: function _resize() {
                if (!this.mq.matches) return;
                this.draggableBounds = this._calculateBounds();
                this.snapPoints = this._calculateSnapPoints();
                _Draggable2.default.get(".works-slider").kill();
                this._setupDraggable();
            }
        }, {
            key: "_calculateBounds",
            value: function _calculateBounds() {
                return {
                    minX: 0,
                    maxX: (this.slides.length - 1) * -this.slides[0].clientWidth
                };
            }
        }, {
            key: "_calculateSnapPoints",
            value: function _calculateSnapPoints() {
                var points = [0];
                for (var i = 1, l = this.slides.length; i < l; i++) {
                    points.push(-i * this.slides[0].clientWidth);
                }
                return points;
            }
        }]);
        return BuffaWorksSlides;
    }();
    exports.default = BuffaWorksSlides;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _gsap = __webpack_require__(0);
    var _BuffaCursor = __webpack_require__(9);
    var _BuffaCursor2 = _interopRequireDefault(_BuffaCursor);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var BuffaTilt = function() {
        function BuffaTilt(target) {
            var _this = this;
            _classCallCheck(this, BuffaTilt);
            this.target = target;
            this.mousemoveCallback = function(_) {
                return _this._mousemove();
            };
            this.init();
        }
        _createClass(BuffaTilt, [{
            key: "init",
            value: function init() {
                this.target.addEventListener("mousemove", this.mousemoveCallback);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.target.removeEventListener("mousemove", this.mousemoveCallback);
            }
        }, {
            key: "_mousemove",
            value: function _mousemove() {
                var x = _BuffaCursor2.default.coords.x / window.innerWidth - 0.5;
                var y = _BuffaCursor2.default.coords.y / window.innerHeight - 0.5;
                _gsap.TweenMax.to(this.target, 0.6, {
                    rotationY: 16 * x,
                    rotationX: 16 * -y,
                    ease: _gsap.Power1.easeOut,
                    transformPerspective: 900,
                    transformOrigin: 'center'
                });
            }
        }]);
        return BuffaTilt;
    }();
    exports.default = BuffaTilt;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.default = exports.Draggable = undefined;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    /*!
     * VERSION: 0.16.4
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * Requires TweenLite and CSSPlugin version 1.17.0 or later (TweenMax contains both TweenLite and CSSPlugin). ThrowPropsPlugin is required for momentum-based continuation of movement after the mouse/touch is released (ThrowPropsPlugin is a membership benefit of Club GreenSock - http://greensock.com/club/).
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     */
    var _TweenLite = __webpack_require__(1);
    var _TweenLite2 = _interopRequireDefault(_TweenLite);
    var _CSSPlugin = __webpack_require__(7);
    var _CSSPlugin2 = _interopRequireDefault(_CSSPlugin);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    _TweenLite._gsScope._gsDefine("utils.Draggable", ["events.EventDispatcher", "TweenLite", "plugins.CSSPlugin"], function() {
        var _tempVarsXY = {
                css: {},
                data: "_draggable"
            },
            _tempVarsX = {
                css: {},
                data: "_draggable"
            },
            _tempVarsY = {
                css: {},
                data: "_draggable"
            },
            _tempVarsRotation = {
                css: {}
            },
            _globals = _TweenLite._gsScope._gsDefine.globals,
            _tempEvent = {},
            _dummyElement = {
                style: {}
            },
            _doc = _TweenLite._gsScope.document || {
                createElement: function createElement() {
                    return _dummyElement;
                }
            },
            _docElement = _doc.documentElement || {},
            _createElement = function _createElement(type) {
                return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
            },
            _tempDiv = _createElement("div"),
            _emptyArray = [],
            _emptyFunc = function _emptyFunc() {
                return false;
            },
            _RAD2DEG = 180 / Math.PI,
            _max = 999999999999999,
            _getTime = Date.now || function() {
                return new Date().getTime();
            },
            _isOldIE = !!(!_doc.addEventListener && _doc.all),
            _placeholderDiv = _doc.createElement("div"),
            _renderQueue = [],
            _lookup = {},
            _lookupCount = 0,
            _clickableTagExp = /^(?:a|input|textarea|button|select)$/i,
            _dragCount = 0,
            _prefix, _isMultiTouching, _isAndroid = _TweenLite._gsScope.navigator && _TweenLite._gsScope.navigator.userAgent.toLowerCase().indexOf("android") !== -1,
            _lastDragTime = 0,
            _temp1 = {},
            _windowProxy = {},
            _slice = function _slice(a) {
                if (typeof a === "string") {
                    a = _TweenLite2.default.selector(a);
                }
                if (!a || a.nodeType) {
                    return [a];
                }
                var b = [],
                    l = a.length,
                    i;
                for (i = 0; i !== l; b.push(a[i++])) {}
                return b;
            },
            _copy = function _copy(obj, factor) {
                var copy = {},
                    p;
                if (factor) {
                    for (p in obj) {
                        copy[p] = obj[p] * factor;
                    }
                } else {
                    for (p in obj) {
                        copy[p] = obj[p];
                    }
                }
                return copy;
            },
            ThrowPropsPlugin, _renderQueueTick = function _renderQueueTick() {
                var i = _renderQueue.length;
                while (--i > -1) {
                    _renderQueue[i]();
                }
            },
            _addToRenderQueue = function _addToRenderQueue(func) {
                _renderQueue.push(func);
                if (_renderQueue.length === 1) {
                    _TweenLite2.default.ticker.addEventListener("tick", _renderQueueTick, this, false, 1);
                }
            },
            _removeFromRenderQueue = function _removeFromRenderQueue(func) {
                var i = _renderQueue.length;
                while (--i > -1) {
                    if (_renderQueue[i] === func) {
                        _renderQueue.splice(i, 1);
                    }
                }
                _TweenLite2.default.to(_renderQueueTimeout, 0, {
                    overwrite: "all",
                    delay: 15,
                    onComplete: _renderQueueTimeout,
                    data: "_draggable"
                });
            },
            _renderQueueTimeout = function _renderQueueTimeout() {
                if (!_renderQueue.length) {
                    _TweenLite2.default.ticker.removeEventListener("tick", _renderQueueTick);
                }
            },
            _extend = function _extend(obj, defaults) {
                var p;
                for (p in defaults) {
                    if (obj[p] === undefined) {
                        obj[p] = defaults[p];
                    }
                }
                return obj;
            },
            _getDocScrollTop = function _getDocScrollTop() {
                return window.pageYOffset != null ? window.pageYOffset : _doc.scrollTop != null ? _doc.scrollTop : _docElement.scrollTop || _doc.body.scrollTop || 0;
            },
            _getDocScrollLeft = function _getDocScrollLeft() {
                return window.pageXOffset != null ? window.pageXOffset : _doc.scrollLeft != null ? _doc.scrollLeft : _docElement.scrollLeft || _doc.body.scrollLeft || 0;
            },
            _addScrollListener = function _addScrollListener(e, callback) {
                _addListener(e, "scroll", callback);
                if (!_isRoot(e.parentNode)) {
                    _addScrollListener(e.parentNode, callback);
                }
            },
            _removeScrollListener = function _removeScrollListener(e, callback) {
                _removeListener(e, "scroll", callback);
                if (!_isRoot(e.parentNode)) {
                    _removeScrollListener(e.parentNode, callback);
                }
            },
            _isRoot = function _isRoot(e) {
                return !!(!e || e === _docElement || e === _doc || e === _doc.body || e === window || !e.nodeType || !e.parentNode);
            },
            _getMaxScroll = function _getMaxScroll(element, axis) {
                var dim = axis === "x" ? "Width" : "Height",
                    scroll = "scroll" + dim,
                    client = "client" + dim,
                    body = _doc.body;
                return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], body[scroll]) - (window["inner" + dim] || _docElement[client] || body[client]) : element[scroll] - element[client]);
            },
            _recordMaxScrolls = function _recordMaxScrolls(e) {
                var isRoot = _isRoot(e),
                    x = _getMaxScroll(e, "x"),
                    y = _getMaxScroll(e, "y");
                if (isRoot) {
                    e = _windowProxy;
                } else {
                    _recordMaxScrolls(e.parentNode);
                }
                e._gsMaxScrollX = x;
                e._gsMaxScrollY = y;
                e._gsScrollX = e.scrollLeft || 0;
                e._gsScrollY = e.scrollTop || 0;
            },
            _populateIEEvent = function _populateIEEvent(e, preventDefault) {
                e = e || window.event;
                _tempEvent.pageX = e.clientX + _doc.body.scrollLeft + _docElement.scrollLeft;
                _tempEvent.pageY = e.clientY + _doc.body.scrollTop + _docElement.scrollTop;
                if (preventDefault) {
                    e.returnValue = false;
                }
                return _tempEvent;
            },
            _unwrapElement = function _unwrapElement(value) {
                if (!value) {
                    return value;
                }
                if (typeof value === "string") {
                    value = _TweenLite2.default.selector(value);
                }
                if (value.length && value !== window && value[0] && value[0].style && !value.nodeType) {
                    value = value[0];
                }
                return value === window || value.nodeType && value.style ? value : null;
            },
            _checkPrefix = function _checkPrefix(e, p) {
                var s = e.style,
                    capped, i, a;
                if (s[p] === undefined) {
                    a = ["O", "Moz", "ms", "Ms", "Webkit"];
                    i = 5;
                    capped = p.charAt(0).toUpperCase() + p.substr(1);
                    while (--i > -1 && s[a[i] + capped] === undefined) {}
                    if (i < 0) {
                        return "";
                    }
                    _prefix = i === 3 ? "ms" : a[i];
                    p = _prefix + capped;
                }
                return p;
            },
            _setStyle = function _setStyle(e, p, value) {
                var s = e.style;
                if (!s) {
                    return;
                }
                if (s[p] === undefined) {
                    p = _checkPrefix(e, p);
                }
                if (value == null) {
                    if (s.removeProperty) {
                        s.removeProperty(p.replace(/([A-Z])/g, "-$1").toLowerCase());
                    } else {
                        s.removeAttribute(p);
                    }
                } else if (s[p] !== undefined) {
                    s[p] = value;
                }
            },
            _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : _emptyFunc,
            _horizExp = /(?:Left|Right|Width)/i,
            _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
            _convertToPixels = function _convertToPixels(t, p, v, sfx, recurse) {
                if (sfx === "px" || !sfx) {
                    return v;
                }
                if (sfx === "auto" || !v) {
                    return 0;
                }
                var horiz = _horizExp.test(p),
                    node = t,
                    style = _tempDiv.style,
                    neg = v < 0,
                    pix;
                if (neg) {
                    v = -v;
                }
                if (sfx === "%" && p.indexOf("border") !== -1) {
                    pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight);
                } else {
                    style.cssText = "border:0 solid red;position:" + _getStyle(t, "position", true) + ";line-height:0;";
                    if (sfx === "%" || !node.appendChild) {
                        node = t.parentNode || _doc.body;
                        style[horiz ? "width" : "height"] = v + sfx;
                    } else {
                        style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx;
                    }
                    node.appendChild(_tempDiv);
                    pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]);
                    node.removeChild(_tempDiv);
                    if (pix === 0 && !recurse) {
                        pix = _convertToPixels(t, p, v, sfx, true);
                    }
                }
                return neg ? -pix : pix;
            },
            _calculateOffset = function _calculateOffset(t, p) {
                if (_getStyle(t, "position", true) !== "absolute") {
                    return 0;
                }
                var dim = p === "left" ? "Left" : "Top",
                    v = _getStyle(t, "margin" + dim, true);
                return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), (v + "").replace(_suffixExp, "")) || 0);
            },
            _getStyle = function _getStyle(element, prop, keepUnits) {
                var rv = (element._gsTransform || {})[prop],
                    cs;
                if (rv || rv === 0) {
                    return rv;
                } else if (element.style[prop]) {
                    rv = element.style[prop];
                } else if (cs = _getComputedStyle(element)) {
                    rv = cs.getPropertyValue(prop.replace(/([A-Z])/g, "-$1").toLowerCase());
                    rv = rv || cs.length ? rv : cs[prop];
                } else if (element.currentStyle) {
                    rv = element.currentStyle[prop];
                }
                if (rv === "auto" && (prop === "top" || prop === "left")) {
                    rv = _calculateOffset(element, prop);
                }
                return keepUnits ? rv : parseFloat(rv) || 0;
            },
            _dispatchEvent = function _dispatchEvent(instance, type, callbackName) {
                var vars = instance.vars,
                    callback = vars[callbackName],
                    listeners = instance._listeners[type];
                if (typeof callback === "function") {
                    callback.apply(vars[callbackName + "Scope"] || vars.callbackScope || instance, vars[callbackName + "Params"] || [instance.pointerEvent]);
                }
                if (listeners) {
                    instance.dispatchEvent(type);
                }
            },
            _getBounds = function _getBounds(obj, context) {
                var e = _unwrapElement(obj),
                    top, left, offset;
                if (!e) {
                    if (obj.left !== undefined) {
                        offset = _getOffsetTransformOrigin(context);
                        return {
                            left: obj.left - offset.x,
                            top: obj.top - offset.y,
                            width: obj.width,
                            height: obj.height
                        };
                    }
                    left = obj.min || obj.minX || obj.minRotation || 0;
                    top = obj.min || obj.minY || 0;
                    return {
                        left: left,
                        top: top,
                        width: (obj.max || obj.maxX || obj.maxRotation || 0) - left,
                        height: (obj.max || obj.maxY || 0) - top
                    };
                }
                return _getElementBounds(e, context);
            },
            _svgBorderFactor, _svgBorderScales, _svgScrollOffset, _hasBorderBug, _hasReparentBug, _setEnvironmentVariables = function _setEnvironmentVariables() {
                if (!_doc.createElementNS) {
                    _svgBorderFactor = 0;
                    _svgBorderScales = false;
                    return;
                }
                var div = _createElement("div"),
                    svg = _doc.createElementNS("http://www.w3.org/2000/svg", "svg"),
                    wrapper = _createElement("div"),
                    style = div.style,
                    parent = _doc.body || _docElement,
                    isFlex = _getStyle(parent, "display", true) === "flex",
                    matrix, e1, point, oldValue;
                if (_doc.body && _transformProp) {
                    style.position = "absolute";
                    parent.appendChild(wrapper);
                    wrapper.appendChild(div);
                    oldValue = div.offsetParent;
                    wrapper.style[_transformProp] = "rotate(1deg)";
                    _hasReparentBug = div.offsetParent === oldValue;
                    wrapper.style.position = "absolute";
                    style.height = "10px";
                    oldValue = div.offsetTop;
                    wrapper.style.border = "5px solid red";
                    _hasBorderBug = oldValue !== div.offsetTop;
                    parent.removeChild(wrapper);
                }
                style = svg.style;
                svg.setAttributeNS(null, "width", "400px");
                svg.setAttributeNS(null, "height", "400px");
                svg.setAttributeNS(null, "viewBox", "0 0 400 400");
                style.display = "block";
                style.boxSizing = "border-box";
                style.border = "0px solid red";
                style.transform = "none";
                div.style.cssText = "width:100px;height:100px;overflow:scroll;-ms-overflow-style:none;";
                parent.appendChild(div);
                div.appendChild(svg);
                point = svg.createSVGPoint().matrixTransform(svg.getScreenCTM());
                e1 = point.y;
                div.scrollTop = 100;
                point.x = point.y = 0;
                point = point.matrixTransform(svg.getScreenCTM());
                _svgScrollOffset = e1 - point.y < 100.1 ? 0 : e1 - point.y - 150;
                div.removeChild(svg);
                parent.removeChild(div);
                parent.appendChild(svg);
                if (isFlex) {
                    parent.style.display = "block";
                }
                matrix = svg.getScreenCTM();
                e1 = matrix.e;
                style.border = "50px solid red";
                matrix = svg.getScreenCTM();
                if (e1 === 0 && matrix.e === 0 && matrix.f === 0 && matrix.a === 1) {
                    _svgBorderFactor = 1;
                    _svgBorderScales = true;
                } else {
                    _svgBorderFactor = e1 !== matrix.e ? 1 : 0;
                    _svgBorderScales = matrix.a !== 1;
                }
                if (isFlex) {
                    parent.style.display = "flex";
                }
                parent.removeChild(svg);
            },
            _supports3D = _checkPrefix(_tempDiv, "perspective") !== "",
            _transformOriginProp = _checkPrefix(_tempDiv, "transformOrigin").replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
            _transformProp = _checkPrefix(_tempDiv, "transform"),
            _transformPropCSS = _transformProp.replace(/^ms/g, "Ms").replace(/([A-Z])/g, "-$1").toLowerCase(),
            _point1 = {},
            _point2 = {},
            _SVGElement = _TweenLite._gsScope.SVGElement,
            _isSVG = function _isSVG(e) {
                return !!(_SVGElement && typeof e.getBBox === "function" && e.getCTM && (!e.parentNode || e.parentNode.getBBox && e.parentNode.getCTM));
            },
            _isIE10orBelow = (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(navigator.userAgent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(navigator.userAgent)) && parseFloat(RegExp.$1) < 11,
            _tempTransforms = [],
            _tempElements = [],
            _getSVGOffsets = function _getSVGOffsets(e) {
                if (!e.getBoundingClientRect || !e.parentNode || !_transformProp) {
                    return {
                        offsetTop: 0,
                        offsetLeft: 0,
                        scaleX: 1,
                        scaleY: 1,
                        offsetParent: _docElement
                    };
                }
                if (Draggable.cacheSVGData !== false && e._dCache && e._dCache.lastUpdate === _TweenLite2.default.ticker.frame) {
                    return e._dCache;
                }
                var curElement = e,
                    cache = _cache(e),
                    eRect, parentRect, offsetParent, cs, m, i, point1, point2, borderWidth, borderHeight, width, height;
                cache.lastUpdate = _TweenLite2.default.ticker.frame;
                if (e.getBBox && !cache.isSVGRoot) {
                    curElement = e.parentNode;
                    eRect = e.getBBox();
                    while (curElement && (curElement.nodeName + "").toLowerCase() !== "svg") {
                        curElement = curElement.parentNode;
                    }
                    cs = _getSVGOffsets(curElement);
                    cache.offsetTop = eRect.y * cs.scaleY;
                    cache.offsetLeft = eRect.x * cs.scaleX;
                    cache.scaleX = cs.scaleX;
                    cache.scaleY = cs.scaleY;
                    cache.offsetParent = curElement || _docElement;
                    return cache;
                }
                offsetParent = cache.offsetParent;
                if (offsetParent === _doc.body) {
                    offsetParent = _docElement;
                }
                _tempElements.length = _tempTransforms.length = 0;
                while (curElement) {
                    m = _getStyle(curElement, _transformProp, true);
                    if (m !== "matrix(1, 0, 0, 1, 0, 0)" && m !== "none" && m !== "translate3d(0px, 0px, 0px)") {
                        _tempElements.push(curElement);
                        _tempTransforms.push(curElement.style[_transformProp]);
                        curElement.style[_transformProp] = "none";
                    }
                    if (curElement === offsetParent) {
                        break;
                    }
                    curElement = curElement.parentNode;
                }
                parentRect = offsetParent.getBoundingClientRect();
                m = e.getScreenCTM();
                point2 = e.createSVGPoint();
                point1 = point2.matrixTransform(m);
                cache.scaleX = Math.sqrt(m.a * m.a + m.b * m.b);
                cache.scaleY = Math.sqrt(m.d * m.d + m.c * m.c);
                if (_svgBorderFactor === undefined) {
                    _setEnvironmentVariables();
                }
                if (cache.borderBox && !_svgBorderScales && e.getAttribute("width")) {
                    cs = _getComputedStyle(e) || {};
                    borderWidth = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth) || 0;
                    borderHeight = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth) || 0;
                    width = parseFloat(cs.width) || 0;
                    height = parseFloat(cs.height) || 0;
                    cache.scaleX *= (width - borderWidth) / width;
                    cache.scaleY *= (height - borderHeight) / height;
                }
                if (_svgScrollOffset) {
                    eRect = e.getBoundingClientRect();
                    cache.offsetLeft = eRect.left - parentRect.left;
                    cache.offsetTop = eRect.top - parentRect.top;
                } else {
                    cache.offsetLeft = point1.x - parentRect.left;
                    cache.offsetTop = point1.y - parentRect.top;
                }
                cache.offsetParent = offsetParent;
                i = _tempElements.length;
                while (--i > -1) {
                    _tempElements[i].style[_transformProp] = _tempTransforms[i];
                }
                return cache;
            },
            _getOffsetTransformOrigin = function _getOffsetTransformOrigin(e, decoratee) {
                decoratee = decoratee || {};
                if (!e || e === _docElement || !e.parentNode || e === window) {
                    return {
                        x: 0,
                        y: 0
                    };
                }
                var cs = _getComputedStyle(e),
                    v = _transformOriginProp && cs ? cs.getPropertyValue(_transformOriginProp) : "50% 50%",
                    a = v.split(" "),
                    x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
                    y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1];
                if (y === "center" || y == null) {
                    y = "50%";
                }
                if (x === "center" || isNaN(parseFloat(x))) {
                    x = "50%";
                }
                if (e.getBBox && _isSVG(e)) {
                    if (!e._gsTransform) {
                        _TweenLite2.default.set(e, {
                            x: "+=0",
                            overwrite: false
                        });
                        if (e._gsTransform.xOrigin === undefined) {
                            console.log("Draggable requires at least GSAP 1.17.0");
                        }
                    }
                    v = e.getBBox();
                    decoratee.x = e._gsTransform.xOrigin - v.x;
                    decoratee.y = e._gsTransform.yOrigin - v.y;
                } else {
                    if (e.getBBox && (x + y).indexOf("%") !== -1) {
                        e = e.getBBox();
                        e = {
                            offsetWidth: e.width,
                            offsetHeight: e.height
                        };
                    }
                    decoratee.x = x.indexOf("%") !== -1 ? e.offsetWidth * parseFloat(x) / 100 : parseFloat(x);
                    decoratee.y = y.indexOf("%") !== -1 ? e.offsetHeight * parseFloat(y) / 100 : parseFloat(y);
                }
                return decoratee;
            },
            _cache = function _cache(e) {
                if (Draggable.cacheSVGData !== false && e._dCache && e._dCache.lastUpdate === _TweenLite2.default.ticker.frame) {
                    return e._dCache;
                }
                var cache = e._dCache = e._dCache || {},
                    cs = _getComputedStyle(e),
                    isSVG = e.getBBox && _isSVG(e),
                    isSVGRoot = (e.nodeName + "").toLowerCase() === "svg",
                    curSVG;
                cache.isSVG = isSVG;
                cache.isSVGRoot = isSVGRoot;
                cache.borderBox = cs.boxSizing === "border-box";
                cache.computedStyle = cs;
                if (isSVGRoot) {
                    curSVG = e.parentNode || _docElement;
                    curSVG.insertBefore(_tempDiv, e);
                    cache.offsetParent = _tempDiv.offsetParent || _docElement;
                    curSVG.removeChild(_tempDiv);
                } else if (isSVG) {
                    curSVG = e.parentNode;
                    while (curSVG && (curSVG.nodeName + "").toLowerCase() !== "svg") {
                        curSVG = curSVG.parentNode;
                    }
                    cache.offsetParent = curSVG;
                } else {
                    cache.offsetParent = e.offsetParent;
                }
                return cache;
            },
            _getOffset2DMatrix = function _getOffset2DMatrix(e, offsetOrigin, parentOffsetOrigin, zeroOrigin, isBase) {
                if (e === window || !e || !e.style || !e.parentNode) {
                    return [1, 0, 0, 1, 0, 0];
                }
                var cache = e._dCache || _cache(e),
                    parent = e.parentNode,
                    parentCache = parent._dCache || _cache(parent),
                    cs = cache.computedStyle,
                    parentOffsetParent = cache.isSVG ? parentCache.offsetParent : parent.offsetParent,
                    m, isRoot, offsets, rect, t, sx, sy, offsetX, offsetY, parentRect, borderTop, borderLeft, borderTranslateX, borderTranslateY;
                m = cache.isSVG && (e.style[_transformProp] + "").indexOf("matrix") !== -1 ? e.style[_transformProp] : cs ? cs.getPropertyValue(_transformPropCSS) : e.currentStyle ? e.currentStyle[_transformProp] : "1,0,0,1,0,0";
                if (e.getBBox && (e.getAttribute("transform") + "").indexOf("matrix") !== -1) {
                    m = e.getAttribute("transform");
                }
                m = (m + "").match(/(?:\-|\.|\b)(\d|\.|e\-)+/g) || [1, 0, 0, 1, 0, 0];
                if (m.length > 6) {
                    m = [m[0], m[1], m[4], m[5], m[12], m[13]];
                }
                if (zeroOrigin) {
                    m[4] = m[5] = 0;
                } else if (cache.isSVG && (t = e._gsTransform) && (t.xOrigin || t.yOrigin)) {
                    m[0] = parseFloat(m[0]);
                    m[1] = parseFloat(m[1]);
                    m[2] = parseFloat(m[2]);
                    m[3] = parseFloat(m[3]);
                    m[4] = parseFloat(m[4]) - (t.xOrigin - (t.xOrigin * m[0] + t.yOrigin * m[2]));
                    m[5] = parseFloat(m[5]) - (t.yOrigin - (t.xOrigin * m[1] + t.yOrigin * m[3]));
                }
                if (offsetOrigin) {
                    if (_svgBorderFactor === undefined) {
                        _setEnvironmentVariables();
                    }
                    offsets = cache.isSVG || cache.isSVGRoot ? _getSVGOffsets(e) : e;
                    if (cache.isSVG) {
                        rect = e.getBBox();
                        parentRect = parentCache.isSVGRoot ? {
                            x: 0,
                            y: 0
                        } : parent.getBBox();
                        offsets = {
                            offsetLeft: rect.x - parentRect.x,
                            offsetTop: rect.y - parentRect.y,
                            offsetParent: cache.offsetParent
                        };
                    } else if (cache.isSVGRoot) {
                        borderTop = parseInt(cs.borderTopWidth, 10) || 0;
                        borderLeft = parseInt(cs.borderLeftWidth, 10) || 0;
                        borderTranslateX = (m[0] - _svgBorderFactor) * borderLeft + m[2] * borderTop;
                        borderTranslateY = m[1] * borderLeft + (m[3] - _svgBorderFactor) * borderTop;
                        sx = offsetOrigin.x;
                        sy = offsetOrigin.y;
                        offsetX = sx - (sx * m[0] + sy * m[2]);
                        offsetY = sy - (sx * m[1] + sy * m[3]);
                        m[4] = parseFloat(m[4]) + offsetX;
                        m[5] = parseFloat(m[5]) + offsetY;
                        offsetOrigin.x -= offsetX;
                        offsetOrigin.y -= offsetY;
                        sx = offsets.scaleX;
                        sy = offsets.scaleY;
                        if (!isBase) {
                            offsetOrigin.x *= sx;
                            offsetOrigin.y *= sy;
                        }
                        m[0] *= sx;
                        m[1] *= sy;
                        m[2] *= sx;
                        m[3] *= sy;
                        if (!_isIE10orBelow) {
                            offsetOrigin.x += borderTranslateX;
                            offsetOrigin.y += borderTranslateY;
                        }
                        if (parentOffsetParent === _doc.body && offsets.offsetParent === _docElement) {
                            parentOffsetParent = _docElement;
                        }
                    } else if (!_hasBorderBug && e.offsetParent) {
                        offsetOrigin.x += parseInt(_getStyle(e.offsetParent, "borderLeftWidth"), 10) || 0;
                        offsetOrigin.y += parseInt(_getStyle(e.offsetParent, "borderTopWidth"), 10) || 0;
                    }
                    isRoot = parent === _docElement || parent === _doc.body;
                    m[4] = Number(m[4]) + offsetOrigin.x + (offsets.offsetLeft || 0) - parentOffsetOrigin.x - (isRoot ? 0 : parent.scrollLeft || 0);
                    m[5] = Number(m[5]) + offsetOrigin.y + (offsets.offsetTop || 0) - parentOffsetOrigin.y - (isRoot ? 0 : parent.scrollTop || 0);
                    if (parent && _getStyle(e, "position", cs) === "fixed") {
                        m[4] += _getDocScrollLeft();
                        m[5] += _getDocScrollTop();
                    }
                    if (parent && parent !== _docElement && parentOffsetParent === offsets.offsetParent && !parentCache.isSVG && (!_hasReparentBug || _getOffset2DMatrix(parent).join("") === "100100")) {
                        offsets = parentCache.isSVGRoot ? _getSVGOffsets(parent) : parent;
                        m[4] -= offsets.offsetLeft || 0;
                        m[5] -= offsets.offsetTop || 0;
                        if (!_hasBorderBug && parentCache.offsetParent && !cache.isSVG && !cache.isSVGRoot) {
                            m[4] -= parseInt(_getStyle(parentCache.offsetParent, "borderLeftWidth"), 10) || 0;
                            m[5] -= parseInt(_getStyle(parentCache.offsetParent, "borderTopWidth"), 10) || 0;
                        }
                    }
                }
                return m;
            },
            _getConcatenatedMatrix = function _getConcatenatedMatrix(e, invert) {
                if (!e || e === window || !e.parentNode) {
                    return [1, 0, 0, 1, 0, 0];
                }
                var originOffset = _getOffsetTransformOrigin(e, _point1),
                    parentOriginOffset = _getOffsetTransformOrigin(e.parentNode, _point2),
                    m = _getOffset2DMatrix(e, originOffset, parentOriginOffset, false, !invert),
                    a, b, c, d, tx, ty, m2, determinant;
                while ((e = e.parentNode) && e.parentNode && e !== _docElement) {
                    originOffset = parentOriginOffset;
                    parentOriginOffset = _getOffsetTransformOrigin(e.parentNode, originOffset === _point1 ? _point2 : _point1);
                    m2 = _getOffset2DMatrix(e, originOffset, parentOriginOffset);
                    a = m[0];
                    b = m[1];
                    c = m[2];
                    d = m[3];
                    tx = m[4];
                    ty = m[5];
                    m[0] = a * m2[0] + b * m2[2];
                    m[1] = a * m2[1] + b * m2[3];
                    m[2] = c * m2[0] + d * m2[2];
                    m[3] = c * m2[1] + d * m2[3];
                    m[4] = tx * m2[0] + ty * m2[2] + m2[4];
                    m[5] = tx * m2[1] + ty * m2[3] + m2[5];
                }
                if (invert) {
                    a = m[0];
                    b = m[1];
                    c = m[2];
                    d = m[3];
                    tx = m[4];
                    ty = m[5];
                    determinant = a * d - b * c;
                    m[0] = d / determinant;
                    m[1] = -b / determinant;
                    m[2] = -c / determinant;
                    m[3] = a / determinant;
                    m[4] = (c * ty - d * tx) / determinant;
                    m[5] = -(a * ty - b * tx) / determinant;
                }
                return m;
            },
            _localToGlobal = function _localToGlobal(e, p, fromTopLeft, decoratee, zeroOrigin) {
                e = _unwrapElement(e);
                var m = _getConcatenatedMatrix(e, false, zeroOrigin),
                    x = p.x,
                    y = p.y;
                if (fromTopLeft) {
                    _getOffsetTransformOrigin(e, p);
                    x -= p.x;
                    y -= p.y;
                }
                decoratee = decoratee === true ? p : decoratee || {};
                decoratee.x = x * m[0] + y * m[2] + m[4];
                decoratee.y = x * m[1] + y * m[3] + m[5];
                return decoratee;
            },
            _localizePoint = function _localizePoint(p, localToGlobal, globalToLocal) {
                var x = p.x * localToGlobal[0] + p.y * localToGlobal[2] + localToGlobal[4],
                    y = p.x * localToGlobal[1] + p.y * localToGlobal[3] + localToGlobal[5];
                p.x = x * globalToLocal[0] + y * globalToLocal[2] + globalToLocal[4];
                p.y = x * globalToLocal[1] + y * globalToLocal[3] + globalToLocal[5];
                return p;
            },
            _getElementBounds = function _getElementBounds(e, context, fromTopLeft) {
                if (!(e = _unwrapElement(e))) {
                    return null;
                }
                context = _unwrapElement(context);
                var isSVG = e.getBBox && _isSVG(e),
                    origin, left, right, top, bottom, mLocalToGlobal, mGlobalToLocal, p1, p2, p3, p4, bbox, width, height, cache, borderLeft, borderTop, viewBox, viewBoxX, viewBoxY, computedDimensions, cs;
                if (e === window) {
                    top = _getDocScrollTop();
                    left = _getDocScrollLeft();
                    right = left + (_docElement.clientWidth || e.innerWidth || _doc.body.clientWidth || 0);
                    bottom = top + ((e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _doc.body.clientHeight || 0);
                } else if (context === undefined || context === window) {
                    return e.getBoundingClientRect();
                } else {
                    origin = _getOffsetTransformOrigin(e);
                    left = -origin.x;
                    top = -origin.y;
                    if (isSVG) {
                        bbox = e.getBBox();
                        width = bbox.width;
                        height = bbox.height;
                    } else if ((e.nodeName + "").toLowerCase() !== "svg" && e.offsetWidth) {
                        width = e.offsetWidth;
                        height = e.offsetHeight;
                    } else {
                        computedDimensions = _getComputedStyle(e);
                        width = parseFloat(computedDimensions.width);
                        height = parseFloat(computedDimensions.height);
                    }
                    right = left + width;
                    bottom = top + height;
                    if (e.nodeName.toLowerCase() === "svg" && !_isOldIE) {
                        cache = _getSVGOffsets(e);
                        cs = cache.computedStyle || {};
                        viewBox = (e.getAttribute("viewBox") || "0 0").split(" ");
                        viewBoxX = parseFloat(viewBox[0]);
                        viewBoxY = parseFloat(viewBox[1]);
                        borderLeft = parseFloat(cs.borderLeftWidth) || 0;
                        borderTop = parseFloat(cs.borderTopWidth) || 0;
                        right -= width - (width - borderLeft) / cache.scaleX - viewBoxX;
                        bottom -= height - (height - borderTop) / cache.scaleY - viewBoxY;
                        left -= borderLeft / cache.scaleX - viewBoxX;
                        top -= borderTop / cache.scaleY - viewBoxY;
                        if (computedDimensions) {
                            right += (parseFloat(cs.borderRightWidth) + borderLeft) / cache.scaleX;
                            bottom += (borderTop + parseFloat(cs.borderBottomWidth)) / cache.scaleY;
                        }
                    }
                }
                if (e === context) {
                    return {
                        left: left,
                        top: top,
                        width: right - left,
                        height: bottom - top
                    };
                }
                mLocalToGlobal = _getConcatenatedMatrix(e);
                mGlobalToLocal = _getConcatenatedMatrix(context, true);
                p1 = _localizePoint({
                    x: left,
                    y: top
                }, mLocalToGlobal, mGlobalToLocal);
                p2 = _localizePoint({
                    x: right,
                    y: top
                }, mLocalToGlobal, mGlobalToLocal);
                p3 = _localizePoint({
                    x: right,
                    y: bottom
                }, mLocalToGlobal, mGlobalToLocal);
                p4 = _localizePoint({
                    x: left,
                    y: bottom
                }, mLocalToGlobal, mGlobalToLocal);
                left = Math.min(p1.x, p2.x, p3.x, p4.x);
                top = Math.min(p1.y, p2.y, p3.y, p4.y);
                _temp1.x = _temp1.y = 0;
                if (fromTopLeft) {
                    _getOffsetTransformOrigin(context, _temp1);
                }
                return {
                    left: left + _temp1.x,
                    top: top + _temp1.y,
                    width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,
                    height: Math.max(p1.y, p2.y, p3.y, p4.y) - top
                };
            },
            _isArrayLike = function _isArrayLike(e) {
                return e && e.length && e[0] && (e[0].nodeType && e[0].style && !e.nodeType || e[0].length && e[0][0]) ? true : false;
            },
            _flattenArray = function _flattenArray(a) {
                var result = [],
                    l = a.length,
                    i, e, j;
                for (i = 0; i < l; i++) {
                    e = a[i];
                    if (_isArrayLike(e)) {
                        j = e.length;
                        for (j = 0; j < e.length; j++) {
                            result.push(e[j]);
                        }
                    } else if (e && e.length !== 0) {
                        result.push(e);
                    }
                }
                return result;
            },
            _isTouchDevice = "ontouchstart" in _docElement && "orientation" in window,
            _touchEventLookup = function(types) {
                var standard = types.split(","),
                    converted = (_tempDiv.onpointerdown !== undefined ? "pointerdown,pointermove,pointerup,pointercancel" : _tempDiv.onmspointerdown !== undefined ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),
                    obj = {},
                    i = 4;
                while (--i > -1) {
                    obj[standard[i]] = converted[i];
                    obj[converted[i]] = standard[i];
                }
                return obj;
            }("touchstart,touchmove,touchend,touchcancel"),
            _addListener = function _addListener(element, type, func, capture) {
                if (element.addEventListener) {
                    var touchType = _touchEventLookup[type];
                    capture = capture || {
                        passive: false
                    };
                    element.addEventListener(touchType || type, func, capture);
                    if (touchType && type !== touchType) {
                        element.addEventListener(type, func, capture);
                    }
                } else if (element.attachEvent) {
                    element.attachEvent("on" + type, func);
                }
            },
            _removeListener = function _removeListener(element, type, func) {
                if (element.removeEventListener) {
                    var touchType = _touchEventLookup[type];
                    element.removeEventListener(touchType || type, func);
                    if (touchType && type !== touchType) {
                        element.removeEventListener(type, func);
                    }
                } else if (element.detachEvent) {
                    element.detachEvent("on" + type, func);
                }
            },
            _hasTouchID = function _hasTouchID(list, ID) {
                var i = list.length;
                while (--i > -1) {
                    if (list[i].identifier === ID) {
                        return true;
                    }
                }
                return false;
            },
            _onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd(e) {
                _isMultiTouching = e.touches && _dragCount < e.touches.length;
                _removeListener(e.target, "touchend", _onMultiTouchDocumentEnd);
            },
            _onMultiTouchDocument = function _onMultiTouchDocument(e) {
                _isMultiTouching = e.touches && _dragCount < e.touches.length;
                _addListener(e.target, "touchend", _onMultiTouchDocumentEnd);
            },
            _parseThrowProps = function _parseThrowProps(draggable, snap, max, min, factor, forceZeroVelocity) {
                var vars = {},
                    a, i, l;
                if (snap) {
                    if (factor !== 1 && snap instanceof Array) {
                        vars.end = a = [];
                        l = snap.length;
                        if (_typeof(snap[0]) === "object") {
                            for (i = 0; i < l; i++) {
                                a[i] = _copy(snap[i], factor);
                            }
                        } else {
                            for (i = 0; i < l; i++) {
                                a[i] = snap[i] * factor;
                            }
                        }
                        max += 1.1;
                        min -= 1.1;
                    } else if (typeof snap === "function") {
                        vars.end = function(value) {
                            var result = snap.call(draggable, value),
                                copy, p;
                            if (factor !== 1) {
                                if ((typeof result === "undefined" ? "undefined" : _typeof(result)) === "object") {
                                    copy = {};
                                    for (p in result) {
                                        copy[p] = result[p] * factor;
                                    }
                                    result = copy;
                                } else {
                                    result *= factor;
                                }
                            }
                            return result;
                        };
                    } else {
                        vars.end = snap;
                    }
                }
                if (max || max === 0) {
                    vars.max = max;
                }
                if (min || min === 0) {
                    vars.min = min;
                }
                if (forceZeroVelocity) {
                    vars.velocity = 0;
                }
                return vars;
            },
            _isClickable = function _isClickable(e) {
                var data;
                return !e || !e.getAttribute || e.nodeName === "BODY" ? false : (data = e.getAttribute("data-clickable")) === "true" || data !== "false" && (e.onclick || _clickableTagExp.test(e.nodeName + "") || e.getAttribute("contentEditable") === "true") ? true : _isClickable(e.parentNode);
            },
            _setSelectable = function _setSelectable(elements, selectable) {
                var i = elements.length,
                    e;
                while (--i > -1) {
                    e = elements[i];
                    e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;
                    _setStyle(e, "userSelect", selectable ? "text" : "none");
                }
            },
            _addPaddingBR = function() {
                var div = _doc.createElement("div"),
                    child = _doc.createElement("div"),
                    childStyle = child.style,
                    parent = _doc.body || _tempDiv,
                    val;
                childStyle.display = "inline-block";
                childStyle.position = "relative";
                div.style.cssText = child.innerHTML = "width:90px; height:40px; padding:10px; overflow:auto; visibility: hidden";
                div.appendChild(child);
                parent.appendChild(div);
                val = child.offsetHeight + 18 > div.scrollHeight;
                parent.removeChild(div);
                return val;
            }(),
            ScrollProxy = function ScrollProxy(element, vars) {
                element = _unwrapElement(element);
                vars = vars || {};
                var content = _doc.createElement("div"),
                    style = content.style,
                    node = element.firstChild,
                    offsetTop = 0,
                    offsetLeft = 0,
                    prevTop = element.scrollTop,
                    prevLeft = element.scrollLeft,
                    scrollWidth = element.scrollWidth,
                    scrollHeight = element.scrollHeight,
                    extraPadRight = 0,
                    maxLeft = 0,
                    maxTop = 0,
                    elementWidth, elementHeight, contentHeight, nextNode, transformStart, transformEnd;
                if (_supports3D && vars.force3D !== false) {
                    transformStart = "translate3d(";
                    transformEnd = "px,0px)";
                } else if (_transformProp) {
                    transformStart = "translate(";
                    transformEnd = "px)";
                }
                this.scrollTop = function(value, force) {
                    if (!arguments.length) {
                        return -this.top();
                    }
                    this.top(-value, force);
                };
                this.scrollLeft = function(value, force) {
                    if (!arguments.length) {
                        return -this.left();
                    }
                    this.left(-value, force);
                };
                this.left = function(value, force) {
                    if (!arguments.length) {
                        return -(element.scrollLeft + offsetLeft);
                    }
                    var dif = element.scrollLeft - prevLeft,
                        oldOffset = offsetLeft;
                    if ((dif > 2 || dif < -2) && !force) {
                        prevLeft = element.scrollLeft;
                        _TweenLite2.default.killTweensOf(this, true, {
                            left: 1,
                            scrollLeft: 1
                        });
                        this.left(-prevLeft);
                        if (vars.onKill) {
                            vars.onKill();
                        }
                        return;
                    }
                    value = -value;
                    if (value < 0) {
                        offsetLeft = value - 0.5 | 0;
                        value = 0;
                    } else if (value > maxLeft) {
                        offsetLeft = value - maxLeft | 0;
                        value = maxLeft;
                    } else {
                        offsetLeft = 0;
                    }
                    if (offsetLeft || oldOffset) {
                        if (transformStart) {
                            if (!this._suspendTransforms) {
                                style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
                            }
                        } else {
                            style.left = -offsetLeft + "px";
                        }
                        if (offsetLeft + extraPadRight >= 0) {
                            style.paddingRight = offsetLeft + extraPadRight + "px";
                        }
                    }
                    element.scrollLeft = value | 0;
                    prevLeft = element.scrollLeft;
                };
                this.top = function(value, force) {
                    if (!arguments.length) {
                        return -(element.scrollTop + offsetTop);
                    }
                    var dif = element.scrollTop - prevTop,
                        oldOffset = offsetTop;
                    if ((dif > 2 || dif < -2) && !force) {
                        prevTop = element.scrollTop;
                        _TweenLite2.default.killTweensOf(this, true, {
                            top: 1,
                            scrollTop: 1
                        });
                        this.top(-prevTop);
                        if (vars.onKill) {
                            vars.onKill();
                        }
                        return;
                    }
                    value = -value;
                    if (value < 0) {
                        offsetTop = value - 0.5 | 0;
                        value = 0;
                    } else if (value > maxTop) {
                        offsetTop = value - maxTop | 0;
                        value = maxTop;
                    } else {
                        offsetTop = 0;
                    }
                    if (offsetTop || oldOffset) {
                        if (transformStart) {
                            if (!this._suspendTransforms) {
                                style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
                            }
                        } else {
                            style.top = -offsetTop + "px";
                        }
                    }
                    element.scrollTop = value | 0;
                    prevTop = element.scrollTop;
                };
                this.maxScrollTop = function() {
                    return maxTop;
                };
                this.maxScrollLeft = function() {
                    return maxLeft;
                };
                this.disable = function() {
                    node = content.firstChild;
                    while (node) {
                        nextNode = node.nextSibling;
                        element.appendChild(node);
                        node = nextNode;
                    }
                    if (element === content.parentNode) {
                        element.removeChild(content);
                    }
                };
                this.enable = function() {
                    node = element.firstChild;
                    if (node === content) {
                        return;
                    }
                    while (node) {
                        nextNode = node.nextSibling;
                        content.appendChild(node);
                        node = nextNode;
                    }
                    element.appendChild(content);
                    this.calibrate();
                };
                this.calibrate = function(force) {
                    var widthMatches = element.clientWidth === elementWidth,
                        x, y;
                    prevTop = element.scrollTop;
                    prevLeft = element.scrollLeft;
                    if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
                        return;
                    }
                    if (offsetTop || offsetLeft) {
                        x = this.left();
                        y = this.top();
                        this.left(-element.scrollLeft);
                        this.top(-element.scrollTop);
                    }
                    if (!widthMatches || force) {
                        style.display = "block";
                        style.width = "auto";
                        style.paddingRight = "0px";
                        extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth);
                        if (extraPadRight) {
                            extraPadRight += _getStyle(element, "paddingLeft") + (_addPaddingBR ? _getStyle(element, "paddingRight") : 0);
                        }
                    }
                    style.display = "inline-block";
                    style.position = "relative";
                    style.overflow = "visible";
                    style.verticalAlign = "top";
                    style.width = "100%";
                    style.paddingRight = extraPadRight + "px";
                    if (_addPaddingBR) {
                        style.paddingBottom = _getStyle(element, "paddingBottom", true);
                    }
                    if (_isOldIE) {
                        style.zoom = "1";
                    }
                    elementWidth = element.clientWidth;
                    elementHeight = element.clientHeight;
                    scrollWidth = element.scrollWidth;
                    scrollHeight = element.scrollHeight;
                    maxLeft = element.scrollWidth - elementWidth;
                    maxTop = element.scrollHeight - elementHeight;
                    contentHeight = content.offsetHeight;
                    style.display = "block";
                    if (x || y) {
                        this.left(x);
                        this.top(y);
                    }
                };
                this.content = content;
                this.element = element;
                this._suspendTransforms = false;
                this.enable();
            },
            Draggable = function Draggable(target, vars) {
                _TweenLite.EventDispatcher.call(this, target);
                target = _unwrapElement(target);
                if (!ThrowPropsPlugin) {
                    ThrowPropsPlugin = _globals.com.greensock.plugins.ThrowPropsPlugin;
                }
                this.vars = vars = _copy(vars || {});
                this.target = target;
                this.x = this.y = this.rotation = 0;
                this.dragResistance = parseFloat(vars.dragResistance) || 0;
                this.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
                this.lockAxis = vars.lockAxis;
                this.autoScroll = vars.autoScroll || 0;
                this.lockedAxis = null;
                this.allowEventDefault = !!vars.allowEventDefault;
                var type = (vars.type || (_isOldIE ? "top,left" : "x,y")).toLowerCase(),
                    xyMode = type.indexOf("x") !== -1 || type.indexOf("y") !== -1,
                    rotationMode = type.indexOf("rotation") !== -1,
                    xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",
                    yProp = xyMode ? "y" : "top",
                    allowX = type.indexOf("x") !== -1 || type.indexOf("left") !== -1 || type === "scroll",
                    allowY = type.indexOf("y") !== -1 || type.indexOf("top") !== -1 || type === "scroll",
                    minimumMovement = vars.minimumMovement || 2,
                    self = this,
                    triggers = _slice(vars.trigger || vars.handle || target),
                    killProps = {},
                    dragEndTime = 0,
                    checkAutoScrollBounds = false,
                    autoScrollMarginTop = vars.autoScrollMarginTop || 40,
                    autoScrollMarginRight = vars.autoScrollMarginRight || 40,
                    autoScrollMarginBottom = vars.autoScrollMarginBottom || 40,
                    autoScrollMarginLeft = vars.autoScrollMarginLeft || 40,
                    isClickable = vars.clickableTest || _isClickable,
                    clickTime = 0,
                    enabled, scrollProxy, startPointerX, startPointerY, startElementX, startElementY, hasBounds, hasDragCallback, maxX, minX, maxY, minY, tempVars, cssVars, touch, touchID, rotationOrigin, dirty, old, snapX, snapY, snapXY, isClicking, touchEventTarget, matrix, interrupted, startScrollTop, startScrollLeft, applyObj, allowNativeTouchScrolling, touchDragAxis, isDispatching, clickDispatch, trustedClickDispatch, onContextMenu = function onContextMenu(e) {
                        if (self.isPressed && e.which < 2) {
                            self.endDrag();
                        } else {
                            e.preventDefault();
                            e.stopPropagation();
                            return false;
                        }
                    },
                    render = function render(suppressEvents) {
                        if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {
                            var e = target,
                                autoScrollFactor = self.autoScroll * 15,
                                parent, isRoot, rect, pointerX, pointerY, changeX, changeY, gap;
                            checkAutoScrollBounds = false;
                            _windowProxy.scrollTop = window.pageYOffset != null ? window.pageYOffset : _docElement.scrollTop != null ? _docElement.scrollTop : _doc.body.scrollTop;
                            _windowProxy.scrollLeft = window.pageXOffset != null ? window.pageXOffset : _docElement.scrollLeft != null ? _docElement.scrollLeft : _doc.body.scrollLeft;
                            pointerX = self.pointerX - _windowProxy.scrollLeft;
                            pointerY = self.pointerY - _windowProxy.scrollTop;
                            while (e && !isRoot) {
                                isRoot = _isRoot(e.parentNode);
                                parent = isRoot ? _windowProxy : e.parentNode;
                                rect = isRoot ? {
                                    bottom: Math.max(_docElement.clientHeight, window.innerHeight || 0),
                                    right: Math.max(_docElement.clientWidth, window.innerWidth || 0),
                                    left: 0,
                                    top: 0
                                } : parent.getBoundingClientRect();
                                changeX = changeY = 0;
                                if (allowY) {
                                    gap = parent._gsMaxScrollY - parent.scrollTop;
                                    if (gap < 0) {
                                        changeY = gap;
                                    } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {
                                        checkAutoScrollBounds = true;
                                        changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);
                                    } else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {
                                        checkAutoScrollBounds = true;
                                        changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);
                                    }
                                    if (changeY) {
                                        parent.scrollTop += changeY;
                                    }
                                }
                                if (allowX) {
                                    gap = parent._gsMaxScrollX - parent.scrollLeft;
                                    if (gap < 0) {
                                        changeX = gap;
                                    } else if (pointerX > rect.right - autoScrollMarginRight && gap) {
                                        checkAutoScrollBounds = true;
                                        changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);
                                    } else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {
                                        checkAutoScrollBounds = true;
                                        changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);
                                    }
                                    if (changeX) {
                                        parent.scrollLeft += changeX;
                                    }
                                }
                                if (isRoot && (changeX || changeY)) {
                                    window.scrollTo(parent.scrollLeft, parent.scrollTop);
                                    setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);
                                }
                                e = parent;
                            }
                        }
                        if (dirty) {
                            var x = self.x,
                                y = self.y,
                                min = 0.000001;
                            if (x < min && x > -min) {
                                x = 0;
                            }
                            if (y < min && y > -min) {
                                y = 0;
                            }
                            if (rotationMode) {
                                self.deltaX = x - applyObj.data.rotation;
                                applyObj.data.rotation = self.rotation = x;
                                applyObj.setRatio(1);
                            } else {
                                if (scrollProxy) {
                                    if (allowY) {
                                        self.deltaY = y - scrollProxy.top();
                                        scrollProxy.top(y);
                                    }
                                    if (allowX) {
                                        self.deltaX = x - scrollProxy.left();
                                        scrollProxy.left(x);
                                    }
                                } else if (xyMode) {
                                    if (allowY) {
                                        self.deltaY = y - applyObj.data.y;
                                        applyObj.data.y = y;
                                    }
                                    if (allowX) {
                                        self.deltaX = x - applyObj.data.x;
                                        applyObj.data.x = x;
                                    }
                                    applyObj.setRatio(1);
                                } else {
                                    if (allowY) {
                                        self.deltaY = y - parseFloat(target.style.top || 0);
                                        target.style.top = y + "px";
                                    }
                                    if (allowX) {
                                        self.deltaY = x - parseFloat(target.style.left || 0);
                                        target.style.left = x + "px";
                                    }
                                }
                            }
                            if (hasDragCallback && !suppressEvents && !isDispatching) {
                                isDispatching = true;
                                _dispatchEvent(self, "drag", "onDrag");
                                isDispatching = false;
                            }
                        }
                        dirty = false;
                    },
                    syncXY = function syncXY(skipOnUpdate, skipSnap) {
                        var x = self.x,
                            y = self.y,
                            snappedValue;
                        if (!target._gsTransform && (xyMode || rotationMode)) {
                            _TweenLite2.default.set(target, {
                                x: "+=0",
                                overwrite: false,
                                data: "_draggable"
                            });
                        }
                        if (xyMode) {
                            self.y = target._gsTransform.y;
                            self.x = target._gsTransform.x;
                        } else if (rotationMode) {
                            self.x = self.rotation = target._gsTransform.rotation;
                        } else if (scrollProxy) {
                            self.y = scrollProxy.top();
                            self.x = scrollProxy.left();
                        } else {
                            self.y = parseInt(target.style.top, 10) || 0;
                            self.x = parseInt(target.style.left, 10) || 0;
                        }
                        if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {
                            if (snapXY) {
                                _temp1.x = self.x;
                                _temp1.y = self.y;
                                snappedValue = snapXY(_temp1);
                                if (snappedValue.x !== self.x) {
                                    self.x = snappedValue.x;
                                    dirty = true;
                                }
                                if (snappedValue.y !== self.y) {
                                    self.y = snappedValue.y;
                                    dirty = true;
                                }
                            }
                            if (snapX) {
                                snappedValue = snapX(self.x);
                                if (snappedValue !== self.x) {
                                    self.x = snappedValue;
                                    if (rotationMode) {
                                        self.rotation = snappedValue;
                                    }
                                    dirty = true;
                                }
                            }
                            if (snapY) {
                                snappedValue = snapY(self.y);
                                if (snappedValue !== self.y) {
                                    self.y = snappedValue;
                                }
                                dirty = true;
                            }
                        }
                        if (dirty) {
                            render(true);
                        }
                        if (!skipOnUpdate) {
                            self.deltaX = self.x - x;
                            self.deltaY = self.y - y;
                            _dispatchEvent(self, "throwupdate", "onThrowUpdate");
                        }
                    },
                    calculateBounds = function calculateBounds() {
                        var bounds, targetBounds, snap, snapIsRaw;
                        hasBounds = false;
                        if (scrollProxy) {
                            scrollProxy.calibrate();
                            self.minX = minX = -scrollProxy.maxScrollLeft();
                            self.minY = minY = -scrollProxy.maxScrollTop();
                            self.maxX = maxX = self.maxY = maxY = 0;
                            hasBounds = true;
                        } else if (!!vars.bounds) {
                            bounds = _getBounds(vars.bounds, target.parentNode);
                            if (rotationMode) {
                                self.minX = minX = bounds.left;
                                self.maxX = maxX = bounds.left + bounds.width;
                                self.minY = minY = self.maxY = maxY = 0;
                            } else if (vars.bounds.maxX !== undefined || vars.bounds.maxY !== undefined) {
                                bounds = vars.bounds;
                                self.minX = minX = bounds.minX;
                                self.minY = minY = bounds.minY;
                                self.maxX = maxX = bounds.maxX;
                                self.maxY = maxY = bounds.maxY;
                            } else {
                                targetBounds = _getBounds(target, target.parentNode);
                                self.minX = minX = _getStyle(target, xProp) + bounds.left - targetBounds.left;
                                self.minY = minY = _getStyle(target, yProp) + bounds.top - targetBounds.top;
                                self.maxX = maxX = minX + (bounds.width - targetBounds.width);
                                self.maxY = maxY = minY + (bounds.height - targetBounds.height);
                            }
                            if (minX > maxX) {
                                self.minX = maxX;
                                self.maxX = maxX = minX;
                                minX = self.minX;
                            }
                            if (minY > maxY) {
                                self.minY = maxY;
                                self.maxY = maxY = minY;
                                minY = self.minY;
                            }
                            if (rotationMode) {
                                self.minRotation = minX;
                                self.maxRotation = maxX;
                            }
                            hasBounds = true;
                        }
                        if (vars.liveSnap) {
                            snap = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;
                            snapIsRaw = snap instanceof Array || typeof snap === "function";
                            if (rotationMode) {
                                snapX = buildSnapFunc(snapIsRaw ? snap : snap.rotation, minX, maxX, 1);
                                snapY = null;
                            } else {
                                if (snap.points) {
                                    snapXY = buildPointSnapFunc(snapIsRaw ? snap : snap.points, minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);
                                } else {
                                    if (allowX) {
                                        snapX = buildSnapFunc(snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);
                                    }
                                    if (allowY) {
                                        snapY = buildSnapFunc(snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, minY, maxY, scrollProxy ? -1 : 1);
                                    }
                                }
                            }
                        }
                    },
                    onThrowComplete = function onThrowComplete() {
                        self.isThrowing = false;
                        _dispatchEvent(self, "throwcomplete", "onThrowComplete");
                    },
                    onThrowOverwrite = function onThrowOverwrite() {
                        self.isThrowing = false;
                    },
                    animate = function animate(throwProps, forceZeroVelocity) {
                        var snap, snapIsRaw, tween, overshootTolerance;
                        if (throwProps && ThrowPropsPlugin) {
                            if (throwProps === true) {
                                snap = vars.snap || vars.liveSnap || {};
                                snapIsRaw = snap instanceof Array || typeof snap === "function";
                                throwProps = {
                                    resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)
                                };
                                if (rotationMode) {
                                    throwProps.rotation = _parseThrowProps(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);
                                } else {
                                    if (allowX) {
                                        throwProps[xProp] = _parseThrowProps(self, snapIsRaw ? snap : snap.points || snap.x || snap.left || snap.scrollLeft, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "x");
                                    }
                                    if (allowY) {
                                        throwProps[yProp] = _parseThrowProps(self, snapIsRaw ? snap : snap.points || snap.y || snap.top || snap.scrollTop, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "y");
                                    }
                                    if (snap.points || snap instanceof Array && _typeof(snap[0]) === "object") {
                                        throwProps.linkedProps = xProp + "," + yProp;
                                        throwProps.radius = snap.radius;
                                    }
                                }
                            }
                            self.isThrowing = true;
                            overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self.edgeResistance + 0.2;
                            self.tween = tween = ThrowPropsPlugin.to(scrollProxy || target, {
                                throwProps: throwProps,
                                data: "_draggable",
                                ease: vars.ease || _globals.Power3.easeOut,
                                onComplete: onThrowComplete,
                                onOverwrite: onThrowOverwrite,
                                onUpdate: vars.fastMode ? _dispatchEvent : syncXY,
                                onUpdateParams: vars.fastMode ? [self, "onthrowupdate", "onThrowUpdate"] : snap && snap.radius ? [false, true] : _emptyArray
                            }, isNaN(vars.maxDuration) ? 2 : vars.maxDuration, !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || (typeof throwProps === "undefined" ? "undefined" : _typeof(throwProps)) === "object" && throwProps.resistance > 1000 ? 0 : 0.5, overshootTolerance);
                            if (!vars.fastMode) {
                                if (scrollProxy) {
                                    scrollProxy._suspendTransforms = true;
                                }
                                tween.render(tween.duration(), true, true);
                                syncXY(true, true);
                                self.endX = self.x;
                                self.endY = self.y;
                                if (rotationMode) {
                                    self.endRotation = self.x;
                                }
                                tween.play(0);
                                syncXY(true, true);
                                if (scrollProxy) {
                                    scrollProxy._suspendTransforms = false;
                                }
                            }
                        } else if (hasBounds) {
                            self.applyBounds();
                        }
                    },
                    updateMatrix = function updateMatrix(shiftStart) {
                        var start = matrix || [1, 0, 0, 1, 0, 0],
                            a, b, c, d, tx, ty, determinant, pointerX, pointerY;
                        matrix = _getConcatenatedMatrix(target.parentNode, true);
                        if (shiftStart && self.isPressed && start.join(",") !== matrix.join(",")) {
                            a = start[0];
                            b = start[1];
                            c = start[2];
                            d = start[3];
                            tx = start[4];
                            ty = start[5];
                            determinant = a * d - b * c;
                            pointerX = startPointerX * (d / determinant) + startPointerY * (-c / determinant) + (c * ty - d * tx) / determinant;
                            pointerY = startPointerX * (-b / determinant) + startPointerY * (a / determinant) + -(a * ty - b * tx) / determinant;
                            startPointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
                            startPointerX = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
                        }
                        if (!matrix[1] && !matrix[2] && matrix[0] == 1 && matrix[3] == 1 && matrix[4] == 0 && matrix[5] == 0) {
                            matrix = null;
                        }
                    },
                    recordStartPositions = function recordStartPositions() {
                        var edgeTolerance = 1 - self.edgeResistance;
                        updateMatrix(false);
                        if (matrix) {
                            startPointerX = self.pointerX * matrix[0] + self.pointerY * matrix[2] + matrix[4];
                            startPointerY = self.pointerX * matrix[1] + self.pointerY * matrix[3] + matrix[5];
                        }
                        if (dirty) {
                            setPointerPosition(self.pointerX, self.pointerY);
                            render(true);
                        }
                        if (scrollProxy) {
                            calculateBounds();
                            startElementY = scrollProxy.top();
                            startElementX = scrollProxy.left();
                        } else {
                            if (isTweening()) {
                                syncXY(true, true);
                                calculateBounds();
                            } else {
                                self.applyBounds();
                            }
                            if (rotationMode) {
                                rotationOrigin = self.rotationOrigin = _localToGlobal(target, {
                                    x: 0,
                                    y: 0
                                });
                                syncXY(true, true);
                                startElementX = self.x;
                                startElementY = self.y = Math.atan2(rotationOrigin.y - self.pointerY, self.pointerX - rotationOrigin.x) * _RAD2DEG;
                            } else {
                                startScrollTop = target.parentNode ? target.parentNode.scrollTop || 0 : 0;
                                startScrollLeft = target.parentNode ? target.parentNode.scrollLeft || 0 : 0;
                                startElementY = _getStyle(target, yProp);
                                startElementX = _getStyle(target, xProp);
                            }
                        }
                        if (hasBounds && edgeTolerance) {
                            if (startElementX > maxX) {
                                startElementX = maxX + (startElementX - maxX) / edgeTolerance;
                            } else if (startElementX < minX) {
                                startElementX = minX - (minX - startElementX) / edgeTolerance;
                            }
                            if (!rotationMode) {
                                if (startElementY > maxY) {
                                    startElementY = maxY + (startElementY - maxY) / edgeTolerance;
                                } else if (startElementY < minY) {
                                    startElementY = minY - (minY - startElementY) / edgeTolerance;
                                }
                            }
                        }
                        self.startX = startElementX;
                        self.startY = startElementY;
                    },
                    isTweening = function isTweening() {
                        return self.tween && self.tween.isActive();
                    },
                    removePlaceholder = function removePlaceholder() {
                        if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) {
                            _placeholderDiv.parentNode.removeChild(_placeholderDiv);
                        }
                    },
                    buildSnapFunc = function buildSnapFunc(snap, min, max, factor) {
                        if (typeof snap === "function") {
                            return function(n) {
                                var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance;
                                return snap.call(self, n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor;
                            };
                        }
                        if (snap instanceof Array) {
                            return function(n) {
                                var i = snap.length,
                                    closest = 0,
                                    absDif = _max,
                                    val, dif;
                                while (--i > -1) {
                                    val = snap[i];
                                    dif = val - n;
                                    if (dif < 0) {
                                        dif = -dif;
                                    }
                                    if (dif < absDif && val >= min && val <= max) {
                                        closest = i;
                                        absDif = dif;
                                    }
                                }
                                return snap[closest];
                            };
                        }
                        return isNaN(snap) ? function(n) {
                            return n;
                        } : function() {
                            return snap * factor;
                        };
                    },
                    buildPointSnapFunc = function buildPointSnapFunc(snap, minX, maxX, minY, maxY, radius, factor) {
                        radius = radius && radius < _max ? radius * radius : _max;
                        if (typeof snap === "function") {
                            return function(point) {
                                var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance,
                                    x = point.x,
                                    y = point.y,
                                    result, dx, dy;
                                point.x = x = x > maxX ? maxX + (x - maxX) * edgeTolerance : x < minX ? minX + (x - minX) * edgeTolerance : x;
                                point.y = y = y > maxY ? maxY + (y - maxY) * edgeTolerance : y < minY ? minY + (y - minY) * edgeTolerance : y;
                                result = snap.call(self, point);
                                if (result !== point) {
                                    point.x = result.x;
                                    point.y = result.y;
                                }
                                if (factor !== 1) {
                                    point.x *= factor;
                                    point.y *= factor;
                                }
                                if (radius < _max) {
                                    dx = point.x - x;
                                    dy = point.y - y;
                                    if (dx * dx + dy * dy > radius) {
                                        point.x = x;
                                        point.y = y;
                                    }
                                }
                                return point;
                            };
                        }
                        if (snap instanceof Array) {
                            return function(p) {
                                var i = snap.length,
                                    closest = 0,
                                    minDist = _max,
                                    x, y, point, dist;
                                while (--i > -1) {
                                    point = snap[i];
                                    x = point.x - p.x;
                                    y = point.y - p.y;
                                    dist = x * x + y * y;
                                    if (dist < minDist) {
                                        closest = i;
                                        minDist = dist;
                                    }
                                }
                                return minDist <= radius ? snap[closest] : p;
                            };
                        }
                        return function(n) {
                            return n;
                        };
                    },
                    onPress = function onPress(e, force) {
                        var i;
                        if (!enabled || self.isPressed || !e || (e.type === "mousedown" || e.type === "pointerdown") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type]) {
                            return;
                        }
                        interrupted = isTweening();
                        self.pointerEvent = e;
                        if (_touchEventLookup[e.type]) {
                            touchEventTarget = e.type.indexOf("touch") !== -1 ? e.currentTarget || e.target : _doc;
                            _addListener(touchEventTarget, "touchend", onRelease);
                            _addListener(touchEventTarget, "touchmove", onMove);
                            _addListener(touchEventTarget, "touchcancel", onRelease);
                            _addListener(_doc, "touchstart", _onMultiTouchDocument);
                        } else {
                            touchEventTarget = null;
                            _addListener(_doc, "mousemove", onMove);
                        }
                        touchDragAxis = null;
                        _addListener(_doc, "mouseup", onRelease);
                        if (e && e.target) {
                            _addListener(e.target, "mouseup", onRelease);
                        }
                        isClicking = isClickable.call(self, e.target) && !vars.dragClickables && !force;
                        if (isClicking) {
                            _addListener(e.target, "change", onRelease);
                            _dispatchEvent(self, "press", "onPress");
                            _setSelectable(triggers, true);
                            return;
                        }
                        allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? "y" : "x";
                        if (_isOldIE) {
                            e = _populateIEEvent(e, true);
                        } else if (!allowNativeTouchScrolling && !self.allowEventDefault) {
                            e.preventDefault();
                            if (e.preventManipulation) {
                                e.preventManipulation();
                            }
                        }
                        if (e.changedTouches) {
                            e = touch = e.changedTouches[0];
                            touchID = e.identifier;
                        } else if (e.pointerId) {
                            touchID = e.pointerId;
                        } else {
                            touch = touchID = null;
                        }
                        _dragCount++;
                        _addToRenderQueue(render);
                        startPointerY = self.pointerY = e.pageY;
                        startPointerX = self.pointerX = e.pageX;
                        if (allowNativeTouchScrolling || self.autoScroll) {
                            _recordMaxScrolls(target.parentNode);
                        }
                        if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {
                            _placeholderDiv.style.width = target.parentNode.scrollWidth + "px";
                            target.parentNode.appendChild(_placeholderDiv);
                        }
                        recordStartPositions();
                        if (self.tween) {
                            self.tween.kill();
                        }
                        self.isThrowing = false;
                        _TweenLite2.default.killTweensOf(scrollProxy || target, true, killProps);
                        if (scrollProxy) {
                            _TweenLite2.default.killTweensOf(target, true, {
                                scrollTo: 1
                            });
                        }
                        self.tween = self.lockedAxis = null;
                        if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {
                            target.style.zIndex = Draggable.zIndex++;
                        }
                        self.isPressed = true;
                        hasDragCallback = !!(vars.onDrag || self._listeners.drag);
                        if (!rotationMode) {
                            i = triggers.length;
                            while (--i > -1) {
                                _setStyle(triggers[i], "cursor", vars.cursor || "move");
                            }
                        }
                        _dispatchEvent(self, "press", "onPress");
                    },
                    onMove = function onMove(e) {
                        var originalEvent = e,
                            touches, pointerX, pointerY, i, dx, dy;
                        if (!enabled || _isMultiTouching || !self.isPressed || !e) {
                            return;
                        }
                        self.pointerEvent = e;
                        touches = e.changedTouches;
                        if (touches) {
                            e = touches[0];
                            if (e !== touch && e.identifier !== touchID) {
                                i = touches.length;
                                while (--i > -1 && (e = touches[i]).identifier !== touchID) {}
                                if (i < 0) {
                                    return;
                                }
                            }
                        } else if (e.pointerId && touchID && e.pointerId !== touchID) {
                            return;
                        }
                        if (_isOldIE) {
                            e = _populateIEEvent(e, true);
                        } else {
                            if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {
                                pointerX = e.pageX;
                                pointerY = e.pageY;
                                if (matrix) {
                                    i = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
                                    pointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
                                    pointerX = i;
                                }
                                dx = Math.abs(pointerX - startPointerX);
                                dy = Math.abs(pointerY - startPointerY);
                                if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {
                                    touchDragAxis = dx > dy && allowX ? "x" : "y";
                                    if (self.vars.lockAxisOnTouchScroll !== false) {
                                        self.lockedAxis = touchDragAxis === "x" ? "y" : "x";
                                        if (typeof self.vars.onLockAxis === "function") {
                                            self.vars.onLockAxis.call(self, originalEvent);
                                        }
                                    }
                                    if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
                                        onRelease(originalEvent);
                                        return;
                                    }
                                }
                            }
                            if (!self.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {
                                originalEvent.preventDefault();
                                if (originalEvent.preventManipulation) {
                                    originalEvent.preventManipulation();
                                }
                            }
                        }
                        if (self.autoScroll) {
                            checkAutoScrollBounds = true;
                        }
                        setPointerPosition(e.pageX, e.pageY);
                    },
                    setPointerPosition = function setPointerPosition(pointerX, pointerY) {
                        var dragTolerance = 1 - self.dragResistance,
                            edgeTolerance = 1 - self.edgeResistance,
                            xChange, yChange, x, y, dif, temp;
                        self.pointerX = pointerX;
                        self.pointerY = pointerY;
                        if (rotationMode) {
                            y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;
                            dif = self.y - y;
                            if (dif > 180) {
                                startElementY -= 360;
                                self.y = y;
                            } else if (dif < -180) {
                                startElementY += 360;
                                self.y = y;
                            }
                            if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {
                                self.y = y;
                                x = startElementX + (startElementY - y) * dragTolerance;
                            } else {
                                x = startElementX;
                            }
                        } else {
                            if (matrix) {
                                temp = pointerX * matrix[0] + pointerY * matrix[2] + matrix[4];
                                pointerY = pointerX * matrix[1] + pointerY * matrix[3] + matrix[5];
                                pointerX = temp;
                            }
                            yChange = pointerY - startPointerY;
                            xChange = pointerX - startPointerX;
                            if (yChange < minimumMovement && yChange > -minimumMovement) {
                                yChange = 0;
                            }
                            if (xChange < minimumMovement && xChange > -minimumMovement) {
                                xChange = 0;
                            }
                            if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {
                                temp = self.lockedAxis;
                                if (!temp) {
                                    self.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? "y" : allowY ? "x" : null;
                                    if (temp && typeof self.vars.onLockAxis === "function") {
                                        self.vars.onLockAxis.call(self, self.pointerEvent);
                                    }
                                }
                                if (temp === "y") {
                                    yChange = 0;
                                } else if (temp === "x") {
                                    xChange = 0;
                                }
                            }
                            x = startElementX + xChange * dragTolerance;
                            y = startElementY + yChange * dragTolerance;
                        }
                        if ((snapX || snapY || snapXY) && (self.x !== x || self.y !== y && !rotationMode)) {
                            if (snapXY) {
                                _temp1.x = x;
                                _temp1.y = y;
                                temp = snapXY(_temp1);
                                x = temp.x;
                                y = temp.y;
                            }
                            if (snapX) {
                                x = snapX(x);
                            }
                            if (snapY) {
                                y = snapY(y);
                            }
                        } else if (hasBounds) {
                            if (x > maxX) {
                                x = maxX + (x - maxX) * edgeTolerance;
                            } else if (x < minX) {
                                x = minX + (x - minX) * edgeTolerance;
                            }
                            if (!rotationMode) {
                                if (y > maxY) {
                                    y = maxY + (y - maxY) * edgeTolerance;
                                } else if (y < minY) {
                                    y = minY + (y - minY) * edgeTolerance;
                                }
                            }
                        }
                        if (!rotationMode && !matrix) {
                            x = Math.round(x);
                            y = Math.round(y);
                        }
                        if (self.x !== x || self.y !== y && !rotationMode) {
                            if (rotationMode) {
                                self.endRotation = self.x = self.endX = x;
                                dirty = true;
                            } else {
                                if (allowY) {
                                    self.y = self.endY = y;
                                    dirty = true;
                                }
                                if (allowX) {
                                    self.x = self.endX = x;
                                    dirty = true;
                                }
                            }
                            if (!self.isDragging && self.isPressed) {
                                self.isDragging = true;
                                _dispatchEvent(self, "dragstart", "onDragStart");
                            }
                        }
                    },
                    onRelease = function onRelease(e, force) {
                        if (!enabled || !self.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {
                            return;
                        }
                        self.isPressed = false;
                        var originalEvent = e,
                            wasDragging = self.isDragging,
                            isContextMenuRelease = self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2),
                            placeholderDelayedCall = _TweenLite2.default.delayedCall(0.001, removePlaceholder),
                            touches, i, syntheticEvent, eventTarget, syntheticClick;
                        if (touchEventTarget) {
                            _removeListener(touchEventTarget, "touchend", onRelease);
                            _removeListener(touchEventTarget, "touchmove", onMove);
                            _removeListener(touchEventTarget, "touchcancel", onRelease);
                            _removeListener(_doc, "touchstart", _onMultiTouchDocument);
                        } else {
                            _removeListener(_doc, "mousemove", onMove);
                        }
                        _removeListener(_doc, "mouseup", onRelease);
                        if (e && e.target) {
                            _removeListener(e.target, "mouseup", onRelease);
                        }
                        dirty = false;
                        if (isClicking && !isContextMenuRelease) {
                            if (e) {
                                _removeListener(e.target, "change", onRelease);
                                self.pointerEvent = originalEvent;
                            }
                            _setSelectable(triggers, false);
                            _dispatchEvent(self, "release", "onRelease");
                            _dispatchEvent(self, "click", "onClick");
                            isClicking = false;
                            return;
                        }
                        _removeFromRenderQueue(render);
                        if (!rotationMode) {
                            i = triggers.length;
                            while (--i > -1) {
                                _setStyle(triggers[i], "cursor", vars.cursor || "move");
                            }
                        }
                        if (wasDragging) {
                            dragEndTime = _lastDragTime = _getTime();
                            self.isDragging = false;
                        }
                        _dragCount--;
                        if (e) {
                            if (_isOldIE) {
                                e = _populateIEEvent(e, false);
                            }
                            touches = e.changedTouches;
                            if (touches) {
                                e = touches[0];
                                if (e !== touch && e.identifier !== touchID) {
                                    i = touches.length;
                                    while (--i > -1 && (e = touches[i]).identifier !== touchID) {}
                                    if (i < 0) {
                                        return;
                                    }
                                }
                            }
                            self.pointerEvent = originalEvent;
                            self.pointerX = e.pageX;
                            self.pointerY = e.pageY;
                        }
                        if (isContextMenuRelease && originalEvent) {
                            originalEvent.preventDefault();
                            if (originalEvent.preventManipulation) {
                                originalEvent.preventManipulation();
                            }
                            _dispatchEvent(self, "release", "onRelease");
                        } else if (originalEvent && !wasDragging) {
                            if (interrupted && (vars.snap || vars.bounds)) {
                                animate(vars.throwProps);
                            }
                            _dispatchEvent(self, "release", "onRelease");
                            if ((!_isAndroid || originalEvent.type !== "touchmove") && originalEvent.type.indexOf("cancel") === -1) {
                                _dispatchEvent(self, "click", "onClick");
                                if (_getTime() - clickTime < 300) {
                                    _dispatchEvent(self, "doubleclick", "onDoubleClick");
                                }
                                eventTarget = originalEvent.target || originalEvent.srcElement || target;
                                clickTime = _getTime();
                                syntheticClick = function syntheticClick() {
                                    if (clickTime !== clickDispatch && self.enabled() && !self.isPressed) {
                                        if (eventTarget.click) {
                                            eventTarget.click();
                                        } else if (_doc.createEvent) {
                                            syntheticEvent = _doc.createEvent("MouseEvents");
                                            syntheticEvent.initMouseEvent("click", true, true, window, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);
                                            eventTarget.dispatchEvent(syntheticEvent);
                                        }
                                    }
                                };
                                if (!_isAndroid && !originalEvent.defaultPrevented) {
                                    _TweenLite2.default.delayedCall(0.00001, syntheticClick);
                                }
                            }
                        } else {
                            animate(vars.throwProps);
                            if (!_isOldIE && !self.allowEventDefault && originalEvent && (vars.dragClickables || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {
                                originalEvent.preventDefault();
                                if (originalEvent.preventManipulation) {
                                    originalEvent.preventManipulation();
                                }
                            }
                            _dispatchEvent(self, "release", "onRelease");
                        }
                        if (isTweening()) {
                            placeholderDelayedCall.duration(self.tween.duration());
                        }
                        if (wasDragging) {
                            _dispatchEvent(self, "dragend", "onDragEnd");
                        }
                        return true;
                    },
                    updateScroll = function updateScroll(e) {
                        if (e && self.isDragging && !scrollProxy) {
                            var parent = e.target || e.srcElement || target.parentNode,
                                deltaX = parent.scrollLeft - parent._gsScrollX,
                                deltaY = parent.scrollTop - parent._gsScrollY;
                            if (deltaX || deltaY) {
                                if (matrix) {
                                    startPointerX -= deltaX * matrix[0] + deltaY * matrix[2];
                                    startPointerY -= deltaY * matrix[3] + deltaX * matrix[1];
                                } else {
                                    startPointerX -= deltaX;
                                    startPointerY -= deltaY;
                                }
                                parent._gsScrollX += deltaX;
                                parent._gsScrollY += deltaY;
                                setPointerPosition(self.pointerX, self.pointerY);
                            }
                        }
                    },
                    onClick = function onClick(e) {
                        var time = _getTime(),
                            recentlyClicked = time - clickTime < 40,
                            recentlyDragged = time - dragEndTime < 40,
                            alreadyDispatched = recentlyClicked && clickDispatch === clickTime,
                            isModern = !!e.preventDefault,
                            defaultPrevented = self.pointerEvent && self.pointerEvent.defaultPrevented,
                            alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime,
                            trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched;
                        if (isModern && (alreadyDispatched || recentlyDragged && self.vars.suppressClickOnDrag !== false)) {
                            e.stopImmediatePropagation();
                        }
                        if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted !== alreadyDispatchedTrusted)) {
                            if (trusted && alreadyDispatched) {
                                trustedClickDispatch = clickTime;
                            }
                            clickDispatch = clickTime;
                            return;
                        }
                        if (self.isPressed || recentlyDragged || recentlyClicked) {
                            if (!isModern) {
                                e.returnValue = false;
                            } else if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {
                                e.preventDefault();
                                if (e.preventManipulation) {
                                    e.preventManipulation();
                                }
                            }
                        }
                    },
                    localizePoint = function localizePoint(p) {
                        return matrix ? {
                            x: p.x * matrix[0] + p.y * matrix[2] + matrix[4],
                            y: p.x * matrix[1] + p.y * matrix[3] + matrix[5]
                        } : {
                            x: p.x,
                            y: p.y
                        };
                    };
                old = Draggable.get(this.target);
                if (old) {
                    old.kill();
                }
                this.startDrag = function(e, align) {
                    var r1, r2, p1, p2;
                    onPress(e || self.pointerEvent, true);
                    if (align && !self.hitTest(e || self.pointerEvent)) {
                        r1 = _parseRect(e || self.pointerEvent);
                        r2 = _parseRect(target);
                        p1 = localizePoint({
                            x: r1.left + r1.width / 2,
                            y: r1.top + r1.height / 2
                        });
                        p2 = localizePoint({
                            x: r2.left + r2.width / 2,
                            y: r2.top + r2.height / 2
                        });
                        startPointerX -= p1.x - p2.x;
                        startPointerY -= p1.y - p2.y;
                    }
                    if (!self.isDragging) {
                        self.isDragging = true;
                        _dispatchEvent(self, "dragstart", "onDragStart");
                    }
                };
                this.drag = onMove;
                this.endDrag = function(e) {
                    onRelease(e || self.pointerEvent, true);
                };
                this.timeSinceDrag = function() {
                    return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;
                };
                this.timeSinceClick = function() {
                    return (_getTime() - clickTime) / 1000;
                };
                this.hitTest = function(target, threshold) {
                    return Draggable.hitTest(self.target, target, threshold);
                };
                this.getDirection = function(from, diagonalThreshold) {
                    var mode = from === "velocity" && ThrowPropsPlugin ? from : (typeof from === "undefined" ? "undefined" : _typeof(from)) === "object" && !rotationMode ? "element" : "start",
                        xChange, yChange, ratio, direction, r1, r2;
                    if (mode === "element") {
                        r1 = _parseRect(self.target);
                        r2 = _parseRect(from);
                    }
                    xChange = mode === "start" ? self.x - startElementX : mode === "velocity" ? ThrowPropsPlugin.getVelocity(this.target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);
                    if (rotationMode) {
                        return xChange < 0 ? "counter-clockwise" : "clockwise";
                    } else {
                        diagonalThreshold = diagonalThreshold || 2;
                        yChange = mode === "start" ? self.y - startElementY : mode === "velocity" ? ThrowPropsPlugin.getVelocity(this.target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);
                        ratio = Math.abs(xChange / yChange);
                        direction = ratio < 1 / diagonalThreshold ? "" : xChange < 0 ? "left" : "right";
                        if (ratio < diagonalThreshold) {
                            if (direction !== "") {
                                direction += "-";
                            }
                            direction += yChange < 0 ? "up" : "down";
                        }
                    }
                    return direction;
                };
                this.applyBounds = function(newBounds) {
                    var x, y, forceZeroVelocity, e, parent, isRoot;
                    if (newBounds && vars.bounds !== newBounds) {
                        vars.bounds = newBounds;
                        return self.update(true);
                    }
                    syncXY(true);
                    calculateBounds();
                    if (hasBounds) {
                        x = self.x;
                        y = self.y;
                        if (x > maxX) {
                            x = maxX;
                        } else if (x < minX) {
                            x = minX;
                        }
                        if (y > maxY) {
                            y = maxY;
                        } else if (y < minY) {
                            y = minY;
                        }
                        if (self.x !== x || self.y !== y) {
                            forceZeroVelocity = true;
                            self.x = self.endX = x;
                            if (rotationMode) {
                                self.endRotation = x;
                            } else {
                                self.y = self.endY = y;
                            }
                            dirty = true;
                            render(true);
                            if (self.autoScroll && !self.isDragging) {
                                _recordMaxScrolls(target.parentNode);
                                e = target;
                                _windowProxy.scrollTop = window.pageYOffset != null ? window.pageYOffset : _docElement.scrollTop != null ? _docElement.scrollTop : _doc.body.scrollTop;
                                _windowProxy.scrollLeft = window.pageXOffset != null ? window.pageXOffset : _docElement.scrollLeft != null ? _docElement.scrollLeft : _doc.body.scrollLeft;
                                while (e && !isRoot) {
                                    isRoot = _isRoot(e.parentNode);
                                    parent = isRoot ? _windowProxy : e.parentNode;
                                    if (allowY && parent.scrollTop > parent._gsMaxScrollY) {
                                        parent.scrollTop = parent._gsMaxScrollY;
                                    }
                                    if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {
                                        parent.scrollLeft = parent._gsMaxScrollX;
                                    }
                                    e = parent;
                                }
                            }
                        }
                        if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {
                            animate(vars.throwProps, forceZeroVelocity);
                        }
                    }
                    return self;
                };
                this.update = function(applyBounds, sticky, ignoreExternalChanges) {
                    var x = self.x,
                        y = self.y;
                    updateMatrix(!sticky);
                    if (applyBounds) {
                        self.applyBounds();
                    } else {
                        if (dirty && ignoreExternalChanges) {
                            render(true);
                        }
                        syncXY(true);
                    }
                    if (sticky) {
                        setPointerPosition(self.pointerX, self.pointerY);
                        if (dirty) {
                            render(true);
                        }
                    }
                    if (self.isPressed && !sticky && (allowX && Math.abs(x - self.x) > 0.01 || allowY && Math.abs(y - self.y) > 0.01 && !rotationMode)) {
                        recordStartPositions();
                    }
                    if (self.autoScroll) {
                        _recordMaxScrolls(target.parentNode);
                        checkAutoScrollBounds = self.isDragging;
                        render(true);
                    }
                    if (self.autoScroll) {
                        _removeScrollListener(target, updateScroll);
                        _addScrollListener(target, updateScroll);
                    }
                    return self;
                };
                this.enable = function(type) {
                    var id, i, trigger;
                    if (type !== "soft") {
                        i = triggers.length;
                        while (--i > -1) {
                            trigger = triggers[i];
                            _addListener(trigger, "mousedown", onPress);
                            _addListener(trigger, "touchstart", onPress);
                            _addListener(trigger, "click", onClick, true);
                            if (!rotationMode) {
                                _setStyle(trigger, "cursor", vars.cursor || "move");
                            }
                            _setStyle(trigger, "touchCallout", "none");
                            _setStyle(trigger, "touchAction", allowX === allowY ? "none" : allowX ? "pan-y" : "pan-x");
                            if (_isSVG(trigger)) {
                                _setStyle(trigger.ownerSVGElement || trigger, "touchAction", allowX === allowY ? "none" : allowX ? "pan-y" : "pan-x");
                            }
                            if (!this.vars.allowContextMenu) {
                                _addListener(trigger, "contextmenu", onContextMenu);
                            }
                        }
                        _setSelectable(triggers, false);
                    }
                    _addScrollListener(target, updateScroll);
                    enabled = true;
                    if (ThrowPropsPlugin && type !== "soft") {
                        ThrowPropsPlugin.track(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
                    }
                    if (scrollProxy) {
                        scrollProxy.enable();
                    }
                    target._gsDragID = id = "d" + _lookupCount++;
                    _lookup[id] = this;
                    if (scrollProxy) {
                        scrollProxy.element._gsDragID = id;
                    }
                    _TweenLite2.default.set(target, {
                        x: "+=0",
                        overwrite: false,
                        data: "_draggable"
                    });
                    applyObj = {
                        t: target,
                        data: _isOldIE ? cssVars : target._gsTransform,
                        tween: {},
                        setRatio: _isOldIE ? function() {
                            _TweenLite2.default.set(target, tempVars);
                        } : _CSSPlugin2.default._internals.setTransformRatio || _CSSPlugin2.default._internals.set3DTransformRatio
                    };
                    recordStartPositions();
                    self.update(true);
                    return self;
                };
                this.disable = function(type) {
                    var dragging = self.isDragging,
                        i, trigger;
                    if (!rotationMode) {
                        i = triggers.length;
                        while (--i > -1) {
                            _setStyle(triggers[i], "cursor", null);
                        }
                    }
                    if (type !== "soft") {
                        i = triggers.length;
                        while (--i > -1) {
                            trigger = triggers[i];
                            _setStyle(trigger, "touchCallout", null);
                            _setStyle(trigger, "touchAction", null);
                            _removeListener(trigger, "mousedown", onPress);
                            _removeListener(trigger, "touchstart", onPress);
                            _removeListener(trigger, "click", onClick);
                            _removeListener(trigger, "contextmenu", onContextMenu);
                        }
                        _setSelectable(triggers, true);
                        if (touchEventTarget) {
                            _removeListener(touchEventTarget, "touchcancel", onRelease);
                            _removeListener(touchEventTarget, "touchend", onRelease);
                            _removeListener(touchEventTarget, "touchmove", onMove);
                        }
                        _removeListener(_doc, "mouseup", onRelease);
                        _removeListener(_doc, "mousemove", onMove);
                    }
                    _removeScrollListener(target, updateScroll);
                    enabled = false;
                    if (ThrowPropsPlugin && type !== "soft") {
                        ThrowPropsPlugin.untrack(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
                    }
                    if (scrollProxy) {
                        scrollProxy.disable();
                    }
                    _removeFromRenderQueue(render);
                    self.isDragging = self.isPressed = isClicking = false;
                    if (dragging) {
                        _dispatchEvent(self, "dragend", "onDragEnd");
                    }
                    return self;
                };
                this.enabled = function(value, type) {
                    return arguments.length ? value ? self.enable(type) : self.disable(type) : enabled;
                };
                this.kill = function() {
                    self.isThrowing = false;
                    _TweenLite2.default.killTweensOf(scrollProxy || target, true, killProps);
                    self.disable();
                    _TweenLite2.default.set(triggers, {
                        clearProps: "userSelect"
                    });
                    delete _lookup[target._gsDragID];
                    return self;
                };
                if (type.indexOf("scroll") !== -1) {
                    scrollProxy = this.scrollProxy = new ScrollProxy(target, _extend({
                        onKill: function onKill() {
                            if (self.isPressed) {
                                onRelease(null);
                            }
                        }
                    }, vars));
                    target.style.overflowY = allowY && !_isTouchDevice ? "auto" : "hidden";
                    target.style.overflowX = allowX && !_isTouchDevice ? "auto" : "hidden";
                    target = scrollProxy.content;
                }
                if (vars.force3D !== false) {
                    _TweenLite2.default.set(target, {
                        force3D: true
                    });
                }
                if (rotationMode) {
                    killProps.rotation = 1;
                } else {
                    if (allowX) {
                        killProps[xProp] = 1;
                    }
                    if (allowY) {
                        killProps[yProp] = 1;
                    }
                }
                if (rotationMode) {
                    tempVars = _tempVarsRotation;
                    cssVars = tempVars.css;
                    tempVars.overwrite = false;
                } else if (xyMode) {
                    tempVars = allowX && allowY ? _tempVarsXY : allowX ? _tempVarsX : _tempVarsY;
                    cssVars = tempVars.css;
                    tempVars.overwrite = false;
                }
                this.enable();
            },
            p = Draggable.prototype = new _TweenLite.EventDispatcher();
        p.constructor = Draggable;
        p.pointerX = p.pointerY = p.startX = p.startY = p.deltaX = p.deltaY = 0;
        p.isDragging = p.isPressed = false;
        Draggable.version = "0.16.4";
        Draggable.zIndex = 1000;
        _addListener(_doc, "touchcancel", function() {});
        _addListener(_doc, "contextmenu", function(e) {
            var p;
            for (p in _lookup) {
                if (_lookup[p].isPressed) {
                    _lookup[p].endDrag();
                }
            }
        });
        Draggable.create = function(targets, vars) {
            if (typeof targets === "string") {
                targets = _TweenLite2.default.selector(targets);
            }
            var a = !targets || targets.length === 0 ? [] : _isArrayLike(targets) ? _flattenArray(targets) : [targets],
                i = a.length;
            while (--i > -1) {
                a[i] = new Draggable(a[i], vars);
            }
            return a;
        };
        Draggable.get = function(target) {
            return _lookup[(_unwrapElement(target) || {})._gsDragID];
        };
        Draggable.timeSinceDrag = function() {
            return (_getTime() - _lastDragTime) / 1000;
        };
        var _tempRect = {},
            _oldIERect = function _oldIERect(e) {
                var top = 0,
                    left = 0,
                    width, height;
                e = _unwrapElement(e);
                width = e.offsetWidth;
                height = e.offsetHeight;
                while (e) {
                    top += e.offsetTop;
                    left += e.offsetLeft;
                    e = e.offsetParent;
                }
                return {
                    top: top,
                    left: left,
                    width: width,
                    height: height
                };
            },
            _parseRect = function _parseRect(e, undefined) {
                if (e === window) {
                    _tempRect.left = _tempRect.top = 0;
                    _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _doc.body.clientWidth || 0;
                    _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _doc.body.clientHeight || 0;
                    return _tempRect;
                }
                var r = e.pageX !== undefined ? {
                    left: e.pageX - _getDocScrollLeft(),
                    top: e.pageY - _getDocScrollTop(),
                    right: e.pageX - _getDocScrollLeft() + 1,
                    bottom: e.pageY - _getDocScrollTop() + 1
                } : !e.nodeType && e.left !== undefined && e.top !== undefined ? e : _isOldIE ? _oldIERect(e) : _unwrapElement(e).getBoundingClientRect();
                if (r.right === undefined && r.width !== undefined) {
                    r.right = r.left + r.width;
                    r.bottom = r.top + r.height;
                } else if (r.width === undefined) {
                    r = {
                        width: r.right - r.left,
                        height: r.bottom - r.top,
                        right: r.right,
                        left: r.left,
                        bottom: r.bottom,
                        top: r.top
                    };
                }
                return r;
            };
        Draggable.hitTest = function(obj1, obj2, threshold) {
            if (obj1 === obj2) {
                return false;
            }
            var r1 = _parseRect(obj1),
                r2 = _parseRect(obj2),
                isOutside = r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top,
                overlap, area, isRatio;
            if (isOutside || !threshold) {
                return !isOutside;
            }
            isRatio = (threshold + "").indexOf("%") !== -1;
            threshold = parseFloat(threshold) || 0;
            overlap = {
                left: Math.max(r1.left, r2.left),
                top: Math.max(r1.top, r2.top)
            };
            overlap.width = Math.min(r1.right, r2.right) - overlap.left;
            overlap.height = Math.min(r1.bottom, r2.bottom) - overlap.top;
            if (overlap.width < 0 || overlap.height < 0) {
                return false;
            }
            if (isRatio) {
                threshold *= 0.01;
                area = overlap.width * overlap.height;
                return area >= r1.width * r1.height * threshold || area >= r2.width * r2.height * threshold;
            }
            return overlap.width > threshold && overlap.height > threshold;
        };
        _placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;";
        return Draggable;
    }, true);
    var Draggable = exports.Draggable = _TweenLite._gsScope.Draggable;
    exports.default = Draggable;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    exports.VelocityTracker = exports.default = exports.ThrowPropsPlugin = undefined;
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    /*!
     * VERSION: 0.11.1
     * DATE: 2018-05-30
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * ThrowPropsPlugin is a Club GreenSock membership benefit; You must have a valid membership to use
     * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.
     * This work is subject to the software agreement that was issued with your membership.
     *
     * @author: Jack Doyle, jack@greensock.com
     */
    var _TweenLite = __webpack_require__(1);
    _TweenLite._gsScope._gsDefine("plugins.ThrowPropsPlugin", ["utils.VelocityTracker", "plugins.TweenPlugin", "TweenLite", "easing.Ease"], function(VelocityTracker) {
        var ThrowPropsPlugin = function ThrowPropsPlugin(props, priority) {
                _TweenLite.TweenPlugin.call(this, "throwProps");
                this._overwriteProps.length = 0;
            },
            _max = 999999999999999,
            _min = 0.0000000001,
            _globals = _TweenLite._gsScope._gsDefine.globals,
            _recordEndMode = false,
            _transforms = {
                x: 1,
                y: 1,
                z: 2,
                scale: 1,
                scaleX: 1,
                scaleY: 1,
                rotation: 1,
                rotationZ: 1,
                rotationX: 2,
                rotationY: 2,
                skewX: 1,
                skewY: 1,
                xPercent: 1,
                yPercent: 1
            },
            _getClosest = function _getClosest(n, values, max, min, radius) {
                var i = values.length,
                    closest = 0,
                    absDif = _max,
                    val, dif, p, dist;
                if ((typeof n === "undefined" ? "undefined" : _typeof(n)) === "object") {
                    while (--i > -1) {
                        val = values[i];
                        dif = 0;
                        for (p in n) {
                            dist = val[p] - n[p];
                            dif += dist * dist;
                        }
                        if (dif < absDif) {
                            closest = i;
                            absDif = dif;
                        }
                    }
                    if ((radius || _max) < _max && radius < Math.sqrt(absDif)) {
                        return n;
                    }
                } else {
                    while (--i > -1) {
                        val = values[i];
                        dif = val - n;
                        if (dif < 0) {
                            dif = -dif;
                        }
                        if (dif < absDif && val >= min && val <= max) {
                            closest = i;
                            absDif = dif;
                        }
                    }
                }
                return values[closest];
            },
            _parseEnd = function _parseEnd(curProp, end, max, min, name, radius) {
                if (curProp.end === "auto") {
                    return curProp;
                }
                var endVar = curProp.end,
                    adjustedEnd, p;
                max = isNaN(max) ? _max : max;
                min = isNaN(min) ? -_max : min;
                if ((typeof end === "undefined" ? "undefined" : _typeof(end)) === "object") {
                    adjustedEnd = end.calculated ? end : (typeof endVar === "function" ? endVar(end) : _getClosest(end, endVar, max, min, radius)) || end;
                    if (!end.calculated) {
                        for (p in adjustedEnd) {
                            end[p] = adjustedEnd[p];
                        }
                        end.calculated = true;
                    }
                    adjustedEnd = adjustedEnd[name];
                } else {
                    adjustedEnd = typeof endVar === "function" ? endVar(end) : endVar instanceof Array ? _getClosest(end, endVar, max, min, radius) : Number(endVar);
                }
                if (adjustedEnd > max) {
                    adjustedEnd = max;
                } else if (adjustedEnd < min) {
                    adjustedEnd = min;
                }
                return {
                    max: adjustedEnd,
                    min: adjustedEnd,
                    unitFactor: curProp.unitFactor
                };
            },
            _extend = function _extend(decoratee, extras, exclude) {
                for (var p in extras) {
                    if (decoratee[p] === undefined && p !== exclude) {
                        decoratee[p] = extras[p];
                    }
                }
                return decoratee;
            },
            _calculateChange = ThrowPropsPlugin.calculateChange = function(velocity, ease, duration, checkpoint) {
                if (checkpoint == null) {
                    checkpoint = 0.05;
                }
                var e = ease instanceof _TweenLite.Ease ? ease : !ease ? _TweenLite.TweenLite.defaultEase : new _TweenLite.Ease(ease);
                return duration * checkpoint * velocity / e.getRatio(checkpoint);
            },
            _calculateDuration = ThrowPropsPlugin.calculateDuration = function(start, end, velocity, ease, checkpoint) {
                checkpoint = checkpoint || 0.05;
                var e = ease instanceof _TweenLite.Ease ? ease : !ease ? _TweenLite.TweenLite.defaultEase : new _TweenLite.Ease(ease);
                return Math.abs((end - start) * e.getRatio(checkpoint) / velocity / checkpoint);
            },
            _calculateTweenDuration = ThrowPropsPlugin.calculateTweenDuration = function(target, vars, maxDuration, minDuration, overshootTolerance, recordEnd) {
                if (typeof target === "string") {
                    target = _TweenLite.TweenLite.selector(target);
                }
                if (!target) {
                    return 0;
                }
                if (maxDuration == null) {
                    maxDuration = 10;
                }
                if (minDuration == null) {
                    minDuration = 0.2;
                }
                if (overshootTolerance == null) {
                    overshootTolerance = 1;
                }
                if (target.length) {
                    target = target[0] || target;
                }
                var duration = 0,
                    clippedDuration = 9999999999,
                    throwPropsVars = vars.throwProps || vars,
                    ease = vars.ease instanceof _TweenLite.Ease ? vars.ease : !vars.ease ? _TweenLite.TweenLite.defaultEase : new _TweenLite.Ease(vars.ease),
                    checkpoint = isNaN(throwPropsVars.checkpoint) ? 0.05 : Number(throwPropsVars.checkpoint),
                    resistance = isNaN(throwPropsVars.resistance) ? ThrowPropsPlugin.defaultResistance : Number(throwPropsVars.resistance),
                    p, curProp, curDuration, curVelocity, curResistance, curVal, end, curClippedDuration, tracker, unitFactor, linkedProps, linkedPropNames, i;
                if (throwPropsVars.linkedProps) {
                    linkedPropNames = throwPropsVars.linkedProps.split(",");
                    linkedProps = {};
                    for (i = 0; i < linkedPropNames.length; i++) {
                        p = linkedPropNames[i];
                        curProp = throwPropsVars[p];
                        if (curProp) {
                            if (curProp.velocity !== undefined && typeof curProp.velocity === "number") {
                                curVelocity = Number(curProp.velocity) || 0;
                            } else {
                                tracker = tracker || VelocityTracker.getByTarget(target);
                                curVelocity = tracker && tracker.isTrackingProp(p) ? tracker.getVelocity(p) : 0;
                            }
                            curResistance = isNaN(curProp.resistance) ? resistance : Number(curProp.resistance);
                            curDuration = curVelocity * curResistance > 0 ? curVelocity / curResistance : curVelocity / -curResistance;
                            curVal = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]() : target[p] || 0;
                            linkedProps[p] = curVal + _calculateChange(curVelocity, ease, curDuration, checkpoint);
                        }
                    }
                }
                for (p in throwPropsVars) {
                    if (p !== "resistance" && p !== "checkpoint" && p !== "preventOvershoot" && p !== "linkedProps" && p !== "radius") {
                        curProp = throwPropsVars[p];
                        if ((typeof curProp === "undefined" ? "undefined" : _typeof(curProp)) !== "object") {
                            tracker = tracker || VelocityTracker.getByTarget(target);
                            if (tracker && tracker.isTrackingProp(p)) {
                                curProp = typeof curProp === "number" ? {
                                    velocity: curProp
                                } : {
                                    velocity: tracker.getVelocity(p)
                                };
                            } else {
                                curVelocity = Number(curProp) || 0;
                                curDuration = curVelocity * resistance > 0 ? curVelocity / resistance : curVelocity / -resistance;
                            }
                        }
                        if ((typeof curProp === "undefined" ? "undefined" : _typeof(curProp)) === "object") {
                            if (curProp.velocity !== undefined && typeof curProp.velocity === "number") {
                                curVelocity = Number(curProp.velocity) || 0;
                            } else {
                                tracker = tracker || VelocityTracker.getByTarget(target);
                                curVelocity = tracker && tracker.isTrackingProp(p) ? tracker.getVelocity(p) : 0;
                            }
                            curResistance = isNaN(curProp.resistance) ? resistance : Number(curProp.resistance);
                            curDuration = curVelocity * curResistance > 0 ? curVelocity / curResistance : curVelocity / -curResistance;
                            curVal = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]() : target[p] || 0;
                            end = curVal + _calculateChange(curVelocity, ease, curDuration, checkpoint);
                            if (curProp.end !== undefined) {
                                curProp = _parseEnd(curProp, linkedProps && p in linkedProps ? linkedProps : end, curProp.max, curProp.min, p, throwPropsVars.radius);
                                if (recordEnd || _recordEndMode) {
                                    throwPropsVars[p] = _extend(curProp, throwPropsVars[p], "end");
                                }
                            }
                            if (curProp.max !== undefined && end > Number(curProp.max) + _min) {
                                unitFactor = curProp.unitFactor || ThrowPropsPlugin.defaultUnitFactors[p] || 1;
                                curClippedDuration = curVal > curProp.max && curProp.min !== curProp.max || curVelocity * unitFactor > -15 && curVelocity * unitFactor < 45 ? minDuration + (maxDuration - minDuration) * 0.1 : _calculateDuration(curVal, curProp.max, curVelocity, ease, checkpoint);
                                if (curClippedDuration + overshootTolerance < clippedDuration) {
                                    clippedDuration = curClippedDuration + overshootTolerance;
                                }
                            } else if (curProp.min !== undefined && end < Number(curProp.min) - _min) {
                                unitFactor = curProp.unitFactor || ThrowPropsPlugin.defaultUnitFactors[p] || 1;
                                curClippedDuration = curVal < curProp.min && curProp.min !== curProp.max || curVelocity * unitFactor > -45 && curVelocity * unitFactor < 15 ? minDuration + (maxDuration - minDuration) * 0.1 : _calculateDuration(curVal, curProp.min, curVelocity, ease, checkpoint);
                                if (curClippedDuration + overshootTolerance < clippedDuration) {
                                    clippedDuration = curClippedDuration + overshootTolerance;
                                }
                            }
                            if (curClippedDuration > duration) {
                                duration = curClippedDuration;
                            }
                        }
                        if (curDuration > duration) {
                            duration = curDuration;
                        }
                    }
                }
                if (duration > clippedDuration) {
                    duration = clippedDuration;
                }
                if (duration > maxDuration) {
                    return maxDuration;
                } else if (duration < minDuration) {
                    return minDuration;
                }
                return duration;
            },
            p = ThrowPropsPlugin.prototype = new _TweenLite.TweenPlugin("throwProps"),
            _cssProxy, _cssVars, _last, _lastValue;
        p.constructor = ThrowPropsPlugin;
        ThrowPropsPlugin.version = "0.11.1";
        ThrowPropsPlugin.API = 2;
        ThrowPropsPlugin._autoCSS = true;
        ThrowPropsPlugin.defaultResistance = 100;
        ThrowPropsPlugin.defaultUnitFactors = {
            time: 1000,
            totalTime: 1000
        };
        ThrowPropsPlugin.track = function(target, props, types) {
            return VelocityTracker.track(target, props, types);
        };
        ThrowPropsPlugin.untrack = function(target, props) {
            VelocityTracker.untrack(target, props);
        };
        ThrowPropsPlugin.isTracking = function(target, prop) {
            return VelocityTracker.isTracking(target, prop);
        };
        ThrowPropsPlugin.getVelocity = function(target, prop) {
            var vt = VelocityTracker.getByTarget(target);
            return vt ? vt.getVelocity(prop) : NaN;
        };
        ThrowPropsPlugin._cssRegister = function() {
            var CSSPlugin = _globals.com.greensock.plugins.CSSPlugin;
            if (!CSSPlugin) {
                return;
            }
            var _internals = CSSPlugin._internals,
                _parseToProxy = _internals._parseToProxy,
                _setPluginRatio = _internals._setPluginRatio,
                CSSPropTween = _internals.CSSPropTween;
            _internals._registerComplexSpecialProp("throwProps", {
                parser: function parser(t, e, prop, cssp, pt, plugin) {
                    plugin = new ThrowPropsPlugin();
                    var velocities = {},
                        min = {},
                        max = {},
                        end = {},
                        res = {},
                        preventOvershoot = {},
                        hasResistance, val, p, data, tracker;
                    _cssVars = {};
                    for (p in e) {
                        if (p !== "resistance" && p !== "preventOvershoot" && p !== "linkedProps" && p !== "radius") {
                            val = e[p];
                            if ((typeof val === "undefined" ? "undefined" : _typeof(val)) === "object") {
                                if (val.velocity !== undefined && typeof val.velocity === "number") {
                                    velocities[p] = Number(val.velocity) || 0;
                                } else {
                                    tracker = tracker || VelocityTracker.getByTarget(t);
                                    velocities[p] = tracker && tracker.isTrackingProp(p) ? tracker.getVelocity(p) : 0;
                                }
                                if (val.end !== undefined) {
                                    end[p] = val.end;
                                }
                                if (val.min !== undefined) {
                                    min[p] = val.min;
                                }
                                if (val.max !== undefined) {
                                    max[p] = val.max;
                                }
                                if (val.preventOvershoot) {
                                    preventOvershoot[p] = true;
                                }
                                if (val.resistance !== undefined) {
                                    hasResistance = true;
                                    res[p] = val.resistance;
                                }
                            } else if (typeof val === "number") {
                                velocities[p] = val;
                            } else {
                                tracker = tracker || VelocityTracker.getByTarget(t);
                                if (tracker && tracker.isTrackingProp(p)) {
                                    velocities[p] = tracker.getVelocity(p);
                                } else {
                                    velocities[p] = val || 0;
                                }
                            }
                            if (_transforms[p]) {
                                cssp._enableTransforms(_transforms[p] === 2);
                            }
                        }
                    }
                    data = _parseToProxy(t, velocities, cssp, pt, plugin);
                    _cssProxy = data.proxy;
                    velocities = data.end;
                    for (p in _cssProxy) {
                        _cssVars[p] = {
                            velocity: velocities[p],
                            min: min[p],
                            max: max[p],
                            end: end[p],
                            resistance: res[p],
                            preventOvershoot: preventOvershoot[p]
                        };
                    }
                    if (e.resistance != null) {
                        _cssVars.resistance = e.resistance;
                    }
                    if (e.linkedProps != null) {
                        _cssVars.linkedProps = e.linkedProps;
                    }
                    if (e.radius != null) {
                        _cssVars.radius = e.radius;
                    }
                    if (e.preventOvershoot) {
                        _cssVars.preventOvershoot = true;
                    }
                    pt = new CSSPropTween(t, "throwProps", 0, 0, data.pt, 2);
                    cssp._overwriteProps.pop();
                    pt.plugin = plugin;
                    pt.setRatio = _setPluginRatio;
                    pt.data = data;
                    plugin._onInitTween(_cssProxy, _cssVars, cssp._tween);
                    return pt;
                }
            });
        };
        ThrowPropsPlugin.to = function(target, vars, maxDuration, minDuration, overshootTolerance) {
            if (!vars.throwProps) {
                vars = {
                    throwProps: vars
                };
            }
            if (overshootTolerance === 0) {
                vars.throwProps.preventOvershoot = true;
            }
            _recordEndMode = true;
            var tween = new _TweenLite.TweenLite(target, minDuration || 1, vars);
            tween.render(0, true, true);
            if (tween.vars.css) {
                tween.duration(_calculateTweenDuration(_cssProxy, {
                    throwProps: _cssVars,
                    ease: vars.ease
                }, maxDuration, minDuration, overshootTolerance));
                if (tween._delay && !tween.vars.immediateRender) {
                    tween.invalidate();
                } else {
                    _last._onInitTween(_cssProxy, _lastValue, tween);
                }
                _recordEndMode = false;
                return tween;
            } else {
                tween.kill();
                tween = new _TweenLite.TweenLite(target, _calculateTweenDuration(target, vars, maxDuration, minDuration, overshootTolerance), vars);
                _recordEndMode = false;
                return tween;
            }
        };
        p._onInitTween = function(target, value, tween, index) {
            this.target = target;
            this._props = [];
            _last = this;
            _lastValue = value;
            var ease = tween._ease,
                checkpoint = isNaN(value.checkpoint) ? 0.05 : Number(value.checkpoint),
                duration = tween._duration,
                preventOvershoot = value.preventOvershoot,
                cnt = 0,
                p, curProp, curVal, isFunc, velocity, change1, end, change2, tracker, linkedProps, linkedPropNames, i;
            if (value.linkedProps) {
                linkedPropNames = value.linkedProps.split(",");
                linkedProps = {};
                for (i = 0; i < linkedPropNames.length; i++) {
                    p = linkedPropNames[i];
                    curProp = value[p];
                    if (curProp) {
                        if (curProp.velocity !== undefined && typeof curProp.velocity === "number") {
                            velocity = Number(curProp.velocity) || 0;
                        } else {
                            tracker = tracker || VelocityTracker.getByTarget(target);
                            velocity = tracker && tracker.isTrackingProp(p) ? tracker.getVelocity(p) : 0;
                        }
                        curVal = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]() : target[p] || 0;
                        linkedProps[p] = curVal + _calculateChange(velocity, ease, duration, checkpoint);
                    }
                }
            }
            for (p in value) {
                if (p !== "resistance" && p !== "checkpoint" && p !== "preventOvershoot" && p !== "linkedProps" && p !== "radius") {
                    curProp = value[p];
                    if (typeof curProp === "function") {
                        curProp = curProp(index, target);
                    }
                    if (typeof curProp === "number") {
                        velocity = Number(curProp) || 0;
                    } else if ((typeof curProp === "undefined" ? "undefined" : _typeof(curProp)) === "object" && !isNaN(curProp.velocity)) {
                        velocity = Number(curProp.velocity);
                    } else {
                        tracker = tracker || VelocityTracker.getByTarget(target);
                        if (tracker && tracker.isTrackingProp(p)) {
                            velocity = tracker.getVelocity(p);
                        } else {
                            throw "ERROR: No velocity was defined in the throwProps tween of " + target + " property: " + p;
                        }
                    }
                    change1 = _calculateChange(velocity, ease, duration, checkpoint);
                    change2 = 0;
                    isFunc = typeof target[p] === "function";
                    curVal = isFunc ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]() : target[p];
                    if ((typeof curProp === "undefined" ? "undefined" : _typeof(curProp)) === "object") {
                        end = curVal + change1;
                        if (curProp.end !== undefined) {
                            curProp = _parseEnd(curProp, linkedProps && p in linkedProps ? linkedProps : end, curProp.max, curProp.min, p, value.radius);
                            if (_recordEndMode) {
                                value[p] = _extend(curProp, value[p], "end");
                            }
                        }
                        if (curProp.max !== undefined && Number(curProp.max) < end) {
                            if (preventOvershoot || curProp.preventOvershoot) {
                                change1 = curProp.max - curVal;
                            } else {
                                change2 = curProp.max - curVal - change1;
                            }
                        } else if (curProp.min !== undefined && Number(curProp.min) > end) {
                            if (preventOvershoot || curProp.preventOvershoot) {
                                change1 = curProp.min - curVal;
                            } else {
                                change2 = curProp.min - curVal - change1;
                            }
                        }
                    }
                    this._overwriteProps[cnt] = p;
                    this._props[cnt++] = {
                        p: p,
                        s: curVal,
                        c1: change1,
                        c2: change2,
                        f: isFunc,
                        r: false
                    };
                }
            }
            return true;
        };
        p._kill = function(lookup) {
            var i = this._props.length;
            while (--i > -1) {
                if (lookup[this._props[i].p] != null) {
                    this._props.splice(i, 1);
                }
            }
            return _TweenLite.TweenPlugin.prototype._kill.call(this, lookup);
        };
        p._mod = function(lookup) {
            var p = this._props,
                i = p.length,
                val;
            while (--i > -1) {
                val = lookup[p[i].p] || lookup.throwProps;
                if (typeof val === "function") {
                    p[i].m = val;
                }
            }
        };
        p.setRatio = function(v) {
            var i = this._props.length,
                cp, val;
            while (--i > -1) {
                cp = this._props[i];
                val = cp.s + cp.c1 * v + cp.c2 * v * v;
                if (cp.m) {
                    val = cp.m(val, this.target);
                } else if (v === 1) {
                    val = (val * 10000 + (val < 0 ? -0.5 : 0.5) | 0) / 10000;
                }
                if (cp.f) {
                    this.target[cp.p](val);
                } else {
                    this.target[cp.p] = val;
                }
            }
        };
        _TweenLite.TweenPlugin.activate([ThrowPropsPlugin]);
        return ThrowPropsPlugin;
    }, true);
    _TweenLite._gsScope._gsDefine("utils.VelocityTracker", ["TweenLite"], function() {
        var _first, _initted, _time1, _time2, _capsExp = /([A-Z])/g,
            _empty = {},
            _doc = _TweenLite._gsScope.document,
            _transforms = {
                x: 1,
                y: 1,
                z: 2,
                scale: 1,
                scaleX: 1,
                scaleY: 1,
                rotation: 1,
                rotationZ: 1,
                rotationX: 2,
                rotationY: 2,
                skewX: 1,
                skewY: 1,
                xPercent: 1,
                yPercent: 1
            },
            _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function() {},
            _getStyle = function _getStyle(t, p, cs) {
                var rv = (t._gsTransform || _empty)[p];
                if (rv || rv === 0) {
                    return rv;
                } else if (t.style[p]) {
                    rv = t.style[p];
                } else if (cs = cs || _getComputedStyle(t, null)) {
                    rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
                } else if (t.currentStyle) {
                    rv = t.currentStyle[p];
                }
                return parseFloat(rv) || 0;
            },
            _ticker = _TweenLite.TweenLite.ticker,
            VelocityProp = function VelocityProp(p, isFunc, next) {
                this.p = p;
                this.f = isFunc;
                this.v1 = this.v2 = 0;
                this.t1 = this.t2 = _ticker.time;
                this.css = false;
                this.type = "";
                this._prev = null;
                if (next) {
                    this._next = next;
                    next._prev = this;
                }
            },
            _update = function _update() {
                var vt = _first,
                    t = _ticker.time,
                    val, vp;
                if (t - _time1 >= 0.03) {
                    _time2 = _time1;
                    _time1 = t;
                    while (vt) {
                        vp = vt._firstVP;
                        while (vp) {
                            val = vp.css ? _getStyle(vt.target, vp.p) : vp.f ? vt.target[vp.p]() : vt.target[vp.p];
                            if (val !== vp.v1 || t - vp.t1 > 0.15) {
                                vp.v2 = vp.v1;
                                vp.v1 = val;
                                vp.t2 = vp.t1;
                                vp.t1 = t;
                            }
                            vp = vp._next;
                        }
                        vt = vt._next;
                    }
                }
            },
            VelocityTracker = function VelocityTracker(target) {
                this._lookup = {};
                this.target = target;
                this.elem = target.style && target.nodeType ? true : false;
                if (!_initted) {
                    _ticker.addEventListener("tick", _update, null, false, -100);
                    _time1 = _time2 = _ticker.time;
                    _initted = true;
                }
                if (_first) {
                    this._next = _first;
                    _first._prev = this;
                }
                _first = this;
            },
            getByTarget = VelocityTracker.getByTarget = function(target) {
                var vt = _first;
                while (vt) {
                    if (vt.target === target) {
                        return vt;
                    }
                    vt = vt._next;
                }
            },
            p = VelocityTracker.prototype;
        p.addProp = function(prop, type) {
            if (!this._lookup[prop]) {
                var t = this.target,
                    isFunc = typeof t[prop] === "function",
                    alt = isFunc ? this._altProp(prop) : prop,
                    vp = this._firstVP;
                this._firstVP = this._lookup[prop] = this._lookup[alt] = vp = new VelocityProp(alt !== prop && prop.indexOf("set") === 0 ? alt : prop, isFunc, vp);
                vp.css = this.elem && (this.target.style[vp.p] !== undefined || _transforms[vp.p]);
                if (vp.css && _transforms[vp.p] && !t._gsTransform) {
                    _TweenLite.TweenLite.set(t, {
                        x: "+=0",
                        overwrite: false
                    });
                }
                vp.type = type || vp.css && prop.indexOf("rotation") === 0 ? "deg" : "";
                vp.v1 = vp.v2 = vp.css ? _getStyle(t, vp.p) : isFunc ? t[vp.p]() : t[vp.p];
            }
        };
        p.removeProp = function(prop) {
            var vp = this._lookup[prop];
            if (vp) {
                if (vp._prev) {
                    vp._prev._next = vp._next;
                } else if (vp === this._firstVP) {
                    this._firstVP = vp._next;
                }
                if (vp._next) {
                    vp._next._prev = vp._prev;
                }
                this._lookup[prop] = 0;
                if (vp.f) {
                    this._lookup[this._altProp(prop)] = 0;
                }
            }
        };
        p.isTrackingProp = function(prop) {
            return this._lookup[prop] instanceof VelocityProp;
        };
        p.getVelocity = function(prop) {
            var vp = this._lookup[prop],
                target = this.target,
                val, dif, rotationCap;
            if (!vp) {
                throw "The velocity of " + prop + " is not being tracked.";
            }
            val = vp.css ? _getStyle(target, vp.p) : vp.f ? target[vp.p]() : target[vp.p];
            dif = val - vp.v2;
            if (vp.type === "rad" || vp.type === "deg") {
                rotationCap = vp.type === "rad" ? Math.PI * 2 : 360;
                dif = dif % rotationCap;
                if (dif !== dif % (rotationCap / 2)) {
                    dif = dif < 0 ? dif + rotationCap : dif - rotationCap;
                }
            }
            return dif / (_ticker.time - vp.t2);
        };
        p._altProp = function(p) {
            var pre = p.substr(0, 3),
                alt = (pre === "get" ? "set" : pre === "set" ? "get" : pre) + p.substr(3);
            return typeof this.target[alt] === "function" ? alt : p;
        };
        VelocityTracker.getByTarget = function(target) {
            var vt = _first;
            if (typeof target === "string") {
                target = _TweenLite.TweenLite.selector(target);
            }
            if (target.length && target !== window && target[0] && target[0].style && !target.nodeType) {
                target = target[0];
            }
            while (vt) {
                if (vt.target === target) {
                    return vt;
                }
                vt = vt._next;
            }
        };
        VelocityTracker.track = function(target, props, types) {
            var vt = getByTarget(target),
                a = props.split(","),
                i = a.length;
            types = (types || "").split(",");
            if (!vt) {
                vt = new VelocityTracker(target);
            }
            while (--i > -1) {
                vt.addProp(a[i], types[i] || types[0]);
            }
            return vt;
        };
        VelocityTracker.untrack = function(target, props) {
            var vt = getByTarget(target),
                a = (props || "").split(","),
                i = a.length;
            if (!vt) {
                return;
            }
            while (--i > -1) {
                vt.removeProp(a[i]);
            }
            if (!vt._firstVP || !props) {
                if (vt._prev) {
                    vt._prev._next = vt._next;
                } else if (vt === _first) {
                    _first = vt._next;
                }
                if (vt._next) {
                    vt._next._prev = vt._prev;
                }
            }
        };
        VelocityTracker.isTracking = function(target, prop) {
            var vt = getByTarget(target);
            return !vt ? false : !prop && vt._firstVP ? true : vt.isTrackingProp(prop);
        };
        return VelocityTracker;
    }, true);
    var ThrowPropsPlugin = exports.ThrowPropsPlugin = _TweenLite._gsScope.ThrowPropsPlugin;
    exports.default = ThrowPropsPlugin;
    var VelocityTracker = exports.VelocityTracker = _TweenLite._gsScope.com.greensock.utils.VelocityTracker;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var ScrollDetector = function() {
        function ScrollDetector() {
            var _this = this;
            var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            _classCallCheck(this, ScrollDetector);
            this.scrollContainer = args.container ? document.querySelector(args.container) : window;
            this.scrollElement = args.element ? this.scrollContainer.querySelector(args.element) : null;
            this.scrollContainerHeight = 0;
            this.scrollElementHeight = 0;
            this.scroll = 0;
            this.maxScroll = 0;
            this.isScrolling = null;
            this.scrollTimeout = args.timeout || 1000;
            this.scrollCallback = function(_) {
                return _this._scrollCallback();
            };
            this.resizeCallback = function(_) {
                return _this._resizeCallback();
            };
            if (!this.scrollElement) console.warn("Scroll element not set.");
        }
        _createClass(ScrollDetector, [{
            key: "init",
            value: function init() {
                this._update();
                this.scrollContainer.addEventListener("scroll", this.scrollCallback, {
                    passive: true
                });
                window.addEventListener("resize", this.resizeCallback, {
                    passive: true
                });
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.scrollContainer.removeEventListener("scroll", this.scrollCallback, {
                    passive: true
                });
                window.removeEventListener("resize", this.resizeCallback, {
                    passive: true
                });
            }
        }, {
            key: "_scrollCallback",
            value: function _scrollCallback() {
                clearTimeout(this.isScrolling);
                document.body.classList.add("is-scrolling");
                this._updateScroll();
                if (this.scroll === this.maxScroll) {
                    document.body.classList.add("scroll-end-reached");
                } else {
                    document.body.classList.remove("scroll-end-reached");
                }
                this.isScrolling = setTimeout(function(_) {
                    document.body.classList.remove("is-scrolling");
                }, this.scrollTimeout);
            }
        }, {
            key: "_resizeCallback",
            value: function _resizeCallback() {
                this._update();
            }
        }, {
            key: "_update",
            value: function _update() {
                var pb = parseInt(getComputedStyle(this.scrollContainer).paddingBottom);
                var pt = parseInt(getComputedStyle(this.scrollContainer).paddingTop);
                this.scrollContainerHeight = this.scrollContainer.clientHeight - pt - pb;
                if (this.scrollElement) this.scrollElementHeight = this.scrollElement.clientHeight;
                if (this.scrollElement) {
                    this.maxScroll = this.scrollElementHeight - this.scrollContainerHeight;
                } else {
                    var body = document.body;
                    var html = document.documentElement;
                    this.maxScroll = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight) - window.innerHeight;
                }
            }
        }, {
            key: "_updateScroll",
            value: function _updateScroll() {
                if (this.scrollContainer === window) {
                    this.scroll = window.scrollY || window.pageYOffset;
                } else {
                    this.scroll = this.scrollContainer.scrollTop;
                }
            }
        }]);
        return ScrollDetector;
    }();
    exports.default = ScrollDetector;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    exports.BuffaObservers = BuffaObservers;
    var _gsap = __webpack_require__(0);
    __webpack_require__(64);
    var _utils = __webpack_require__(2);
    var _ImageReveal = __webpack_require__(25);
    var _ImageReveal2 = _interopRequireDefault(_ImageReveal);
    var _barba = __webpack_require__(12);
    var _barba2 = _interopRequireDefault(_barba);
    var _plyr = __webpack_require__(65);
    var _plyr2 = _interopRequireDefault(_plyr);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }
    window.BuffaObserver = null;

    function BuffaObservers() {
        var elems = [].slice.call(document.querySelectorAll("[data-observe]"));
        var observeMap = [];
        var config = {
            image1: BUFFA.assets_url + "/images/transparent.png",
            displacementImage: BUFFA.assets_url + "/images/displacement/filter-water.png",
            hover: false,
            speedIn: 1.2,
            once: true
        };
        observeMap["image"] = function(elem) {
            var figure = (0, _utils.qs)("[data-image-reveal]", elem);
            (0, _utils.qsa)(".work__title, .work__role, .work__year__inner", elem).forEach(function(e) {
                e.classList.add("strip-animate");
                e.classList.add("strip-animate-in");
            });
            if (_barba2.default.HistoryManager.currentStatus().namespace === "works-page") {
                var tl = new _gsap.TimelineLite({
                    delay: 0.5
                });
                tl.add("start").to((0, _utils.qs)(".svg-number__text", elem), 0.4, {
                    stroke: "#fafafa"
                }, "start").to((0, _utils.qs)("feDisplacementMap", elem), 0.7, {
                    attr: {
                        scale: 0
                    },
                    ease: _gsap.Power1.easeOut
                }, "start+=0.2");
            }
            var imageRevealInstance = new _ImageReveal2.default(_extends({}, config, {
                intensity: (0, _utils.getRandomFloat)(0.15, 0.25),
                angle: (0, _utils.getRandomInt)(1, 360) * Math.PI / 180,
                parent: figure,
                image2: figure.dataset.src,
                image2Mob: figure.dataset.srcMobile
            }));
            setTimeout(function(_) {
                return imageRevealInstance.next();
            }, 10);
        };
        observeMap["video"] = function(elem) {
            var figure = (0, _utils.qs)("[data-image-reveal]", elem);
            var video = void 0;
            var imageRevealInstance = new _ImageReveal2.default(_extends({}, config, {
                intensity: (0, _utils.getRandomFloat)(0.15, 0.25),
                angle: (0, _utils.getRandomInt)(1, 360) * Math.PI / 180,
                parent: figure,
                image2: figure.dataset.poster
            }));
            var initPlyr = function initPlyr(_) {
                figure.removeEventListener("click", initPlyr);
                figure.setAttribute("data-plyr", "initialized");
                figure.appendChild(video);
                if (figure.dataset.plyrYoutube === undefined) {
                    var instance = new _plyr2.default(video, {
                        autoplay: true,
                        resetOnEnd: true
                    });
                    BUFFA.plyr_instances.push(instance);
                }
            };
            setTimeout(function(_) {
                imageRevealInstance.next().then(function(_) {
                    var elemType = figure.dataset.plyrYoutube !== undefined ? "iframe" : "video";
                    video = document.createElement(elemType);
                    if (elemType === "video") {
                        video.setAttribute("playsinline", "");
                        video.setAttribute("src", figure.dataset.src);
                    } else if (elemType === "iframe") {
                        video.setAttribute("allowfullscreen", "");
                        video.setAttribute("allowtransparency", "");
                        video.setAttribute("allow", "autoplay");
                        video.setAttribute("src", "https://www.youtube.com/embed/" + figure.dataset.youtubeVideoId + "?origin=https://plyr.io&amp;iv_load_policy=3&amp;modestbranding=1&amp;playsinline=1&amp;showinfo=0&amp;rel=0&amp;enablejsapi=1");
                    }
                    if (figure.dataset.plyr === undefined) {
                        if (elemType === "video") {
                            video.muted = true;
                            video.setAttribute("loop", "");
                            video.setAttribute("autoplay", "");
                            video.setAttribute("muted", "");
                            figure.appendChild(video);
                        }
                    } else {
                        figure.addEventListener("click", initPlyr);
                    }
                });
            }, 10);
        };
        window.BuffaObserver = new IntersectionObserver(function(entries) {
            entries.filter(function(entry) {
                return entry.isIntersecting;
            }).forEach(function(entry) {
                if (entry.intersectionRatio > window.BuffaObserver.thresholds[0]) {
                    var target = entry.target;
                    var dataObserve = (0, _utils.qs)("[data-image-reveal]", target).dataset.imageReveal;
                    eval(observeMap[dataObserve](target));
                    window.BuffaObserver.unobserve(target);
                }
            });
        }, {
            threshold: [0.15]
        });
        elems.forEach(function(e) {
            window.BuffaObserver.observe(e);
        });
    }
}), (function(module, exports) {
    (function(window, document) {
        'use strict';
        if ('IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype) {
            if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
                Object.defineProperty(window.IntersectionObserverEntry.prototype, 'isIntersecting', {
                    get: function() {
                        return this.intersectionRatio > 0;
                    }
                });
            }
            return;
        }
        var registry = [];

        function IntersectionObserverEntry(entry) {
            this.time = entry.time;
            this.target = entry.target;
            this.rootBounds = entry.rootBounds;
            this.boundingClientRect = entry.boundingClientRect;
            this.intersectionRect = entry.intersectionRect || getEmptyRect();
            this.isIntersecting = !!entry.intersectionRect;
            var targetRect = this.boundingClientRect;
            var targetArea = targetRect.width * targetRect.height;
            var intersectionRect = this.intersectionRect;
            var intersectionArea = intersectionRect.width * intersectionRect.height;
            if (targetArea) {
                this.intersectionRatio = intersectionArea / targetArea;
            } else {
                this.intersectionRatio = this.isIntersecting ? 1 : 0;
            }
        }

        function IntersectionObserver(callback, opt_options) {
            var options = opt_options || {};
            if (typeof callback != 'function') {
                throw new Error('callback must be a function');
            }
            if (options.root && options.root.nodeType != 1) {
                throw new Error('root must be an Element');
            }
            this._checkForIntersections = throttle(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);
            this._callback = callback;
            this._observationTargets = [];
            this._queuedEntries = [];
            this._rootMarginValues = this._parseRootMargin(options.rootMargin);
            this.thresholds = this._initThresholds(options.threshold);
            this.root = options.root || null;
            this.rootMargin = this._rootMarginValues.map(function(margin) {
                return margin.value + margin.unit;
            }).join(' ');
        }
        IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;
        IntersectionObserver.prototype.POLL_INTERVAL = null;
        IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;
        IntersectionObserver.prototype.observe = function(target) {
            var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
                return item.element == target;
            });
            if (isTargetAlreadyObserved) {
                return;
            }
            if (!(target && target.nodeType == 1)) {
                throw new Error('target must be an Element');
            }
            this._registerInstance();
            this._observationTargets.push({
                element: target,
                entry: null
            });
            this._monitorIntersections();
            this._checkForIntersections();
        };
        IntersectionObserver.prototype.unobserve = function(target) {
            this._observationTargets = this._observationTargets.filter(function(item) {
                return item.element != target;
            });
            if (!this._observationTargets.length) {
                this._unmonitorIntersections();
                this._unregisterInstance();
            }
        };
        IntersectionObserver.prototype.disconnect = function() {
            this._observationTargets = [];
            this._unmonitorIntersections();
            this._unregisterInstance();
        };
        IntersectionObserver.prototype.takeRecords = function() {
            var records = this._queuedEntries.slice();
            this._queuedEntries = [];
            return records;
        };
        IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
            var threshold = opt_threshold || [0];
            if (!Array.isArray(threshold)) threshold = [threshold];
            return threshold.sort().filter(function(t, i, a) {
                if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
                    throw new Error('threshold must be a number between 0 and 1 inclusively');
                }
                return t !== a[i - 1];
            });
        };
        IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
            var marginString = opt_rootMargin || '0px';
            var margins = marginString.split(/\s+/).map(function(margin) {
                var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
                if (!parts) {
                    throw new Error('rootMargin must be specified in pixels or percent');
                }
                return {
                    value: parseFloat(parts[1]),
                    unit: parts[2]
                };
            });
            margins[1] = margins[1] || margins[0];
            margins[2] = margins[2] || margins[0];
            margins[3] = margins[3] || margins[1];
            return margins;
        };
        IntersectionObserver.prototype._monitorIntersections = function() {
            if (!this._monitoringIntersections) {
                this._monitoringIntersections = true;
                if (this.POLL_INTERVAL) {
                    this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL);
                } else {
                    addEvent(window, 'resize', this._checkForIntersections, true);
                    addEvent(document, 'scroll', this._checkForIntersections, true);
                    if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {
                        this._domObserver = new MutationObserver(this._checkForIntersections);
                        this._domObserver.observe(document, {
                            attributes: true,
                            childList: true,
                            characterData: true,
                            subtree: true
                        });
                    }
                }
            }
        };
        IntersectionObserver.prototype._unmonitorIntersections = function() {
            if (this._monitoringIntersections) {
                this._monitoringIntersections = false;
                clearInterval(this._monitoringInterval);
                this._monitoringInterval = null;
                removeEvent(window, 'resize', this._checkForIntersections, true);
                removeEvent(document, 'scroll', this._checkForIntersections, true);
                if (this._domObserver) {
                    this._domObserver.disconnect();
                    this._domObserver = null;
                }
            }
        };
        IntersectionObserver.prototype._checkForIntersections = function() {
            var rootIsInDom = this._rootIsInDom();
            var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();
            this._observationTargets.forEach(function(item) {
                var target = item.element;
                var targetRect = getBoundingClientRect(target);
                var rootContainsTarget = this._rootContainsTarget(target);
                var oldEntry = item.entry;
                var intersectionRect = rootIsInDom && rootContainsTarget && this._computeTargetAndRootIntersection(target, rootRect);
                var newEntry = item.entry = new IntersectionObserverEntry({
                    time: now(),
                    target: target,
                    boundingClientRect: targetRect,
                    rootBounds: rootRect,
                    intersectionRect: intersectionRect
                });
                if (!oldEntry) {
                    this._queuedEntries.push(newEntry);
                } else if (rootIsInDom && rootContainsTarget) {
                    if (this._hasCrossedThreshold(oldEntry, newEntry)) {
                        this._queuedEntries.push(newEntry);
                    }
                } else {
                    if (oldEntry && oldEntry.isIntersecting) {
                        this._queuedEntries.push(newEntry);
                    }
                }
            }, this);
            if (this._queuedEntries.length) {
                this._callback(this.takeRecords(), this);
            }
        };
        IntersectionObserver.prototype._computeTargetAndRootIntersection = function(target, rootRect) {
            if (window.getComputedStyle(target).display == 'none') return;
            var targetRect = getBoundingClientRect(target);
            var intersectionRect = targetRect;
            var parent = getParentNode(target);
            var atRoot = false;
            while (!atRoot) {
                var parentRect = null;
                var parentComputedStyle = parent.nodeType == 1 ? window.getComputedStyle(parent) : {};
                if (parentComputedStyle.display == 'none') return;
                if (parent == this.root || parent == document) {
                    atRoot = true;
                    parentRect = rootRect;
                } else {
                    if (parent != document.body && parent != document.documentElement && parentComputedStyle.overflow != 'visible') {
                        parentRect = getBoundingClientRect(parent);
                    }
                }
                if (parentRect) {
                    intersectionRect = computeRectIntersection(parentRect, intersectionRect);
                    if (!intersectionRect) break;
                }
                parent = getParentNode(parent);
            }
            return intersectionRect;
        };
        IntersectionObserver.prototype._getRootRect = function() {
            var rootRect;
            if (this.root) {
                rootRect = getBoundingClientRect(this.root);
            } else {
                var html = document.documentElement;
                var body = document.body;
                rootRect = {
                    top: 0,
                    left: 0,
                    right: html.clientWidth || body.clientWidth,
                    width: html.clientWidth || body.clientWidth,
                    bottom: html.clientHeight || body.clientHeight,
                    height: html.clientHeight || body.clientHeight
                };
            }
            return this._expandRectByRootMargin(rootRect);
        };
        IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
            var margins = this._rootMarginValues.map(function(margin, i) {
                return margin.unit == 'px' ? margin.value : margin.value * (i % 2 ? rect.width : rect.height) / 100;
            });
            var newRect = {
                top: rect.top - margins[0],
                right: rect.right + margins[1],
                bottom: rect.bottom + margins[2],
                left: rect.left - margins[3]
            };
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;
            return newRect;
        };
        IntersectionObserver.prototype._hasCrossedThreshold = function(oldEntry, newEntry) {
            var oldRatio = oldEntry && oldEntry.isIntersecting ? oldEntry.intersectionRatio || 0 : -1;
            var newRatio = newEntry.isIntersecting ? newEntry.intersectionRatio || 0 : -1;
            if (oldRatio === newRatio) return;
            for (var i = 0; i < this.thresholds.length; i++) {
                var threshold = this.thresholds[i];
                if (threshold == oldRatio || threshold == newRatio || threshold < oldRatio !== threshold < newRatio) {
                    return true;
                }
            }
        };
        IntersectionObserver.prototype._rootIsInDom = function() {
            return !this.root || containsDeep(document, this.root);
        };
        IntersectionObserver.prototype._rootContainsTarget = function(target) {
            return containsDeep(this.root || document, target);
        };
        IntersectionObserver.prototype._registerInstance = function() {
            if (registry.indexOf(this) < 0) {
                registry.push(this);
            }
        };
        IntersectionObserver.prototype._unregisterInstance = function() {
            var index = registry.indexOf(this);
            if (index != -1) registry.splice(index, 1);
        };

        function now() {
            return window.performance && performance.now && performance.now();
        }

        function throttle(fn, timeout) {
            var timer = null;
            return function() {
                if (!timer) {
                    timer = setTimeout(function() {
                        fn();
                        timer = null;
                    }, timeout);
                }
            };
        }

        function addEvent(node, event, fn, opt_useCapture) {
            if (typeof node.addEventListener == 'function') {
                node.addEventListener(event, fn, opt_useCapture || false);
            } else if (typeof node.attachEvent == 'function') {
                node.attachEvent('on' + event, fn);
            }
        }

        function removeEvent(node, event, fn, opt_useCapture) {
            if (typeof node.removeEventListener == 'function') {
                node.removeEventListener(event, fn, opt_useCapture || false);
            } else if (typeof node.detatchEvent == 'function') {
                node.detatchEvent('on' + event, fn);
            }
        }

        function computeRectIntersection(rect1, rect2) {
            var top = Math.max(rect1.top, rect2.top);
            var bottom = Math.min(rect1.bottom, rect2.bottom);
            var left = Math.max(rect1.left, rect2.left);
            var right = Math.min(rect1.right, rect2.right);
            var width = right - left;
            var height = bottom - top;
            return (width >= 0 && height >= 0) && {
                top: top,
                bottom: bottom,
                left: left,
                right: right,
                width: width,
                height: height
            };
        }

        function getBoundingClientRect(el) {
            var rect;
            try {
                rect = el.getBoundingClientRect();
            } catch (err) {}
            if (!rect) return getEmptyRect();
            if (!(rect.width && rect.height)) {
                rect = {
                    top: rect.top,
                    right: rect.right,
                    bottom: rect.bottom,
                    left: rect.left,
                    width: rect.right - rect.left,
                    height: rect.bottom - rect.top
                };
            }
            return rect;
        }

        function getEmptyRect() {
            return {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
            };
        }

        function containsDeep(parent, child) {
            var node = child;
            while (node) {
                if (node == parent) return true;
                node = getParentNode(node);
            }
            return false;
        }

        function getParentNode(node) {
            var parent = node.parentNode;
            if (parent && parent.nodeType == 11 && parent.host) {
                return parent.host;
            }
            return parent;
        }
        window.IntersectionObserver = IntersectionObserver;
        window.IntersectionObserverEntry = IntersectionObserverEntry;
    }(window, document));
}), (function(module, exports, __webpack_require__) {
    (function(global) {
        "object" == typeof navigator && function(e, t) {
            true ? module.exports = t() : "function" == typeof define && define.amd ? define("Plyr", t) : e.Plyr = t()
        }(this, function() {
            "use strict";
            var e = function(e) {
                    return null != e ? e.constructor : null
                },
                t = function(e, t) {
                    return Boolean(e && t && e instanceof t)
                },
                i = function(e) {
                    return null == e
                },
                n = function(t) {
                    return e(t) === Object
                },
                s = function(t) {
                    return e(t) === String
                },
                a = function(e) {
                    return Array.isArray(e)
                },
                o = function(e) {
                    return t(e, NodeList)
                },
                r = function(e) {
                    return i(e) || (s(e) || a(e) || o(e)) && !e.length || n(e) && !Object.keys(e).length
                },
                l = {
                    nullOrUndefined: i,
                    object: n,
                    number: function(t) {
                        return e(t) === Number && !Number.isNaN(t)
                    },
                    string: s,
                    boolean: function(t) {
                        return e(t) === Boolean
                    },
                    function: function(t) {
                        return e(t) === Function
                    },
                    array: a,
                    weakMap: function(e) {
                        return t(e, WeakMap)
                    },
                    nodeList: o,
                    element: function(e) {
                        return t(e, Element)
                    },
                    textNode: function(t) {
                        return e(t) === Text
                    },
                    event: function(e) {
                        return t(e, Event)
                    },
                    keyboardEvent: function(e) {
                        return t(e, KeyboardEvent)
                    },
                    cue: function(e) {
                        return t(e, window.TextTrackCue) || t(e, window.VTTCue)
                    },
                    track: function(e) {
                        return t(e, TextTrack) || !i(e) && s(e.kind)
                    },
                    url: function(e) {
                        if (t(e, window.URL)) return !0;
                        var i = e;
                        e.startsWith("http://") && e.startsWith("https://") || (i = "http://" + e);
                        try {
                            return !r(new URL(i).hostname)
                        } catch (e) {
                            return !1
                        }
                    },
                    empty: r
                },
                c = function() {
                    var e = !1;
                    try {
                        var t = Object.defineProperty({}, "passive", {
                            get: function() {
                                return e = !0, null
                            }
                        });
                        window.addEventListener("test", null, t), window.removeEventListener("test", null, t)
                    } catch (e) {}
                    return e
                }();

            function u(e, t, i) {
                var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                    s = this,
                    a = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                    o = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
                if (e && "addEventListener" in e && !l.empty(t) && l.function(i)) {
                    var r = t.split(" "),
                        u = o;
                    c && (u = {
                        passive: a,
                        capture: o
                    }), r.forEach(function(t) {
                        s && s.eventListeners && n && s.eventListeners.push({
                            element: e,
                            type: t,
                            callback: i,
                            options: u
                        }), e[n ? "addEventListener" : "removeEventListener"](t, i, u)
                    })
                }
            }

            function d(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    i = arguments[2],
                    n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                u.call(this, e, t, i, !0, n, s)
            }

            function h(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    i = arguments[2],
                    n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                u.call(this, e, t, i, !1, n, s)
            }

            function p(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    i = arguments[2],
                    n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                u.call(this, e, t, function a() {
                    h(e, t, a, n, s);
                    for (var o = arguments.length, r = Array(o), l = 0; l < o; l++) r[l] = arguments[l];
                    i.apply(this, r)
                }, !0, n, s)
            }

            function f(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                if (l.element(e) && !l.empty(t)) {
                    var s = new CustomEvent(t, {
                        bubbles: i,
                        detail: Object.assign({}, n, {
                            plyr: this
                        })
                    });
                    e.dispatchEvent(s)
                }
            }
            var m = function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                },
                g = function() {
                    function e(e, t) {
                        for (var i = 0; i < t.length; i++) {
                            var n = t[i];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
                        }
                    }
                    return function(t, i, n) {
                        return i && e(t.prototype, i), n && e(t, n), t
                    }
                }(),
                y = function(e, t, i) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = i, e
                },
                v = function() {
                    return function(e, t) {
                        if (Array.isArray(e)) return e;
                        if (Symbol.iterator in Object(e)) return function(e, t) {
                            var i = [],
                                n = !0,
                                s = !1,
                                a = void 0;
                            try {
                                for (var o, r = e[Symbol.iterator](); !(n = (o = r.next()).done) && (i.push(o.value), !t || i.length !== t); n = !0);
                            } catch (e) {
                                s = !0, a = e
                            } finally {
                                try {
                                    !n && r.return && r.return()
                                } finally {
                                    if (s) throw a
                                }
                            }
                            return i
                        }(e, t);
                        throw new TypeError("Invalid attempt to destructure non-iterable instance")
                    }
                }();

            function b(e, t) {
                var i = e.length ? e : [e];
                Array.from(i).reverse().forEach(function(e, i) {
                    var n = i > 0 ? t.cloneNode(!0) : t,
                        s = e.parentNode,
                        a = e.nextSibling;
                    n.appendChild(e), a ? s.insertBefore(n, a) : s.appendChild(n)
                })
            }

            function k(e, t) {
                l.element(e) && !l.empty(t) && Object.entries(t).filter(function(e) {
                    var t = v(e, 2)[1];
                    return !l.nullOrUndefined(t)
                }).forEach(function(t) {
                    var i = v(t, 2),
                        n = i[0],
                        s = i[1];
                    return e.setAttribute(n, s)
                })
            }

            function w(e, t, i) {
                var n = document.createElement(e);
                return l.object(t) && k(n, t), l.string(i) && (n.innerText = i), n
            }

            function T(e, t, i, n) {
                l.element(t) && t.appendChild(w(e, i, n))
            }

            function A(e) {
                l.nodeList(e) || l.array(e) ? Array.from(e).forEach(A) : l.element(e) && l.element(e.parentNode) && e.parentNode.removeChild(e)
            }

            function E(e) {
                if (l.element(e))
                    for (var t = e.childNodes.length; t > 0;) e.removeChild(e.lastChild), t -= 1
            }

            function C(e, t) {
                return l.element(t) && l.element(t.parentNode) && l.element(e) ? (t.parentNode.replaceChild(e, t), e) : null
            }

            function P(e, t) {
                if (!l.string(e) || l.empty(e)) return {};
                var i = {},
                    n = t;
                return e.split(",").forEach(function(e) {
                    var t = e.trim(),
                        s = t.replace(".", ""),
                        a = t.replace(/[[\]]/g, "").split("="),
                        o = a[0],
                        r = a.length > 1 ? a[1].replace(/["']/g, "") : "";
                    switch (t.charAt(0)) {
                        case ".":
                            l.object(n) && l.string(n.class) && (n.class += " " + s), i.class = s;
                            break;
                        case "#":
                            i.id = t.replace("#", "");
                            break;
                        case "[":
                            i[o] = r
                    }
                }), i
            }

            function S(e, t) {
                if (l.element(e)) {
                    var i = t;
                    l.boolean(i) || (i = !e.hidden), i ? e.setAttribute("hidden", "") : e.removeAttribute("hidden")
                }
            }

            function M(e, t, i) {
                if (l.nodeList(e)) return Array.from(e).map(function(e) {
                    return M(e, t, i)
                });
                if (l.element(e)) {
                    var n = "toggle";
                    return void 0 !== i && (n = i ? "add" : "remove"), e.classList[n](t), e.classList.contains(t)
                }
                return !1
            }

            function N(e, t) {
                return l.element(e) && e.classList.contains(t)
            }

            function L(e, t) {
                var i = {
                    Element: Element
                };
                return (i.matches || i.webkitMatchesSelector || i.mozMatchesSelector || i.msMatchesSelector || function() {
                    return Array.from(document.querySelectorAll(t)).includes(this)
                }).call(e, t)
            }

            function x(e) {
                return this.elements.container.querySelectorAll(e)
            }

            function _(e) {
                return this.elements.container.querySelector(e)
            }

            function I() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                l.element(e) && (e.focus(), t && M(e, this.config.classNames.tabFocus))
            }
            var O, j, q, R = (O = document.createElement("span"), j = {
                WebkitTransition: "webkitTransitionEnd",
                MozTransition: "transitionend",
                OTransition: "oTransitionEnd otransitionend",
                transition: "transitionend"
            }, q = Object.keys(j).find(function(e) {
                return void 0 !== O.style[e]
            }), !!l.string(q) && j[q]);

            function B(e) {
                setTimeout(function() {
                    try {
                        S(e, !0), e.offsetHeight, S(e, !1)
                    } catch (e) {}
                }, 0)
            }
            var H, V = {
                    isIE: !!document.documentMode,
                    isWebkit: "WebkitAppearance" in document.documentElement.style && !/Edge/.test(navigator.userAgent),
                    isIPhone: /(iPhone|iPod)/gi.test(navigator.platform),
                    isIos: /(iPad|iPhone|iPod)/gi.test(navigator.platform)
                },
                D = {
                    "audio/ogg": "vorbis",
                    "audio/wav": "1",
                    "video/webm": "vp8, vorbis",
                    "video/mp4": "avc1.42E01E, mp4a.40.2",
                    "video/ogg": "theora"
                },
                F = {
                    audio: "canPlayType" in document.createElement("audio"),
                    video: "canPlayType" in document.createElement("video"),
                    check: function(e, t, i) {
                        var n = V.isIPhone && i && F.playsinline,
                            s = F[e] || "html5" !== t;
                        return {
                            api: s,
                            ui: s && F.rangeInput && ("video" !== e || !V.isIPhone || n)
                        }
                    },
                    pip: !V.isIPhone && l.function(w("video").webkitSetPresentationMode),
                    airplay: l.function(window.WebKitPlaybackTargetAvailabilityEvent),
                    playsinline: "playsInline" in document.createElement("video"),
                    mime: function(e) {
                        var t = e.split("/"),
                            i = v(t, 1)[0];
                        if (!this.isHTML5 || i !== this.type) return !1;
                        var n = void 0;
                        e && e.includes("codecs=") ? n = e : "audio/mpeg" === e ? n = "audio/mpeg;" : e in D && (n = e + '; codecs="' + D[e] + '"');
                        try {
                            return Boolean(n && this.media.canPlayType(n).replace(/no/, ""))
                        } catch (e) {
                            return !1
                        }
                    },
                    textTracks: "textTracks" in document.createElement("video"),
                    rangeInput: (H = document.createElement("input"), H.type = "range", "range" === H.type),
                    touch: "ontouchstart" in document.documentElement,
                    transitions: !1 !== R,
                    reducedMotion: "matchMedia" in window && window.matchMedia("(prefers-reduced-motion)").matches
                },
                U = {
                    getSources: function() {
                        var e = this;
                        return this.isHTML5 ? Array.from(this.media.querySelectorAll("source")).filter(function(t) {
                            return F.mime.call(e, t.getAttribute("type"))
                        }) : []
                    },
                    getQualityOptions: function() {
                        return U.getSources.call(this).map(function(e) {
                            return Number(e.getAttribute("size"))
                        }).filter(Boolean)
                    },
                    extend: function() {
                        if (this.isHTML5) {
                            var e = this;
                            Object.defineProperty(e.media, "quality", {
                                get: function() {
                                    var t = U.getSources.call(e).find(function(t) {
                                        return t.getAttribute("src") === e.source
                                    });
                                    return t && Number(t.getAttribute("size"))
                                },
                                set: function(t) {
                                    var i = U.getSources.call(e).find(function(e) {
                                        return Number(e.getAttribute("size")) === t
                                    });
                                    if (i) {
                                        var n = e.media,
                                            s = n.currentTime,
                                            a = n.paused,
                                            o = n.preload,
                                            r = n.readyState;
                                        e.media.src = i.getAttribute("src"), ("none" !== o || r) && (e.once("loadedmetadata", function() {
                                            e.currentTime = s, a || e.play()
                                        }), e.media.load()), f.call(e, e.media, "qualitychange", !1, {
                                            quality: t
                                        }), e.storage.set({
                                            quality: t
                                        })
                                    }
                                }
                            })
                        }
                    },
                    cancelRequests: function() {
                        this.isHTML5 && (A(U.getSources.call(this)), this.media.setAttribute("src", this.config.blankVideo), this.media.load(), this.debug.log("Cancelled network requests"))
                    }
                };

            function z(e) {
                return l.array(e) ? e.filter(function(t, i) {
                    return e.indexOf(t) === i
                }) : e
            }

            function W(e, t) {
                return t.split(".").reduce(function(e, t) {
                    return e && e[t]
                }, e)
            }

            function K() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = arguments.length, i = Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];
                if (!i.length) return e;
                var s = i.shift();
                return l.object(s) ? (Object.keys(s).forEach(function(t) {
                    l.object(s[t]) ? (Object.keys(e).includes(t) || Object.assign(e, y({}, t, {})), K(e[t], s[t])) : Object.assign(e, y({}, t, s[t]))
                }), K.apply(void 0, [e].concat(i))) : e
            }

            function Y(e) {
                for (var t = arguments.length, i = Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) i[n - 1] = arguments[n];
                return l.empty(e) ? e : e.toString().replace(/{(\d+)}/g, function(e, t) {
                    return i[t].toString()
                })
            }

            function J() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
                return e.replace(new RegExp(t.toString().replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1"), "g"), i.toString())
            }

            function Q() {
                return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "").toString().replace(/\w\S*/g, function(e) {
                    return e.charAt(0).toUpperCase() + e.substr(1).toLowerCase()
                })
            }

            function $() {
                var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "").toString();
                return (e = function() {
                    var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "").toString();
                    return e = J(e, "-", " "), e = J(e, "_", " "), J(e = Q(e), " ", "")
                }(e)).charAt(0).toLowerCase() + e.slice(1)
            }

            function G(e) {
                var t = document.createElement("div");
                return t.appendChild(e), t.innerHTML
            }
            var X = function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (l.empty(e) || l.empty(t)) return "";
                    var i = W(t.i18n, e);
                    if (l.empty(i)) return "";
                    var n = {
                        "{seektime}": t.seekTime,
                        "{title}": t.title
                    };
                    return Object.entries(n).forEach(function(e) {
                        var t = v(e, 2),
                            n = t[0],
                            s = t[1];
                        i = J(i, n, s)
                    }), i
                },
                Z = function() {
                    function e(t) {
                        m(this, e), this.enabled = t.config.storage.enabled, this.key = t.config.storage.key
                    }
                    return g(e, [{
                        key: "get",
                        value: function(t) {
                            if (!e.supported || !this.enabled) return null;
                            var i = window.localStorage.getItem(this.key);
                            if (l.empty(i)) return null;
                            var n = JSON.parse(i);
                            return l.string(t) && t.length ? n[t] : n
                        }
                    }, {
                        key: "set",
                        value: function(t) {
                            if (e.supported && this.enabled && l.object(t)) {
                                var i = this.get();
                                l.empty(i) && (i = {}), K(i, t), window.localStorage.setItem(this.key, JSON.stringify(i))
                            }
                        }
                    }], [{
                        key: "supported",
                        get: function() {
                            try {
                                if (!("localStorage" in window)) return !1;
                                return window.localStorage.setItem("___test", "___test"), window.localStorage.removeItem("___test"), !0
                            } catch (e) {
                                return !1
                            }
                        }
                    }]), e
                }();

            function ee(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "text";
                return new Promise(function(i, n) {
                    try {
                        var s = new XMLHttpRequest;
                        if (!("withCredentials" in s)) return;
                        s.addEventListener("load", function() {
                            if ("text" === t) try {
                                i(JSON.parse(s.responseText))
                            } catch (e) {
                                i(s.responseText)
                            } else i(s.response)
                        }), s.addEventListener("error", function() {
                            throw new Error(s.status)
                        }), s.open("GET", e, !0), s.responseType = t, s.send()
                    } catch (e) {
                        n(e)
                    }
                })
            }

            function te(e, t) {
                if (l.string(e)) {
                    var i = l.string(t),
                        n = function() {
                            return null !== document.getElementById(t)
                        },
                        s = function(e, t) {
                            e.innerHTML = t, i && n() || document.body.insertAdjacentElement("afterbegin", e)
                        };
                    if (!i || !n()) {
                        var a = Z.supported,
                            o = document.createElement("div");
                        if (o.setAttribute("hidden", ""), i && o.setAttribute("id", t), a) {
                            var r = window.localStorage.getItem("cache-" + t);
                            if (null !== r) {
                                var c = JSON.parse(r);
                                s(o, c.content)
                            }
                        }
                        ee(e).then(function(e) {
                            l.empty(e) || (a && window.localStorage.setItem("cache-" + t, JSON.stringify({
                                content: e
                            })), s(o, e))
                        }).catch(function() {})
                    }
                }
            }
            var ie = function(e) {
                    return parseInt(e / 60 / 60 % 60, 10)
                },
                ne = function(e) {
                    return parseInt(e / 60 % 60, 10)
                },
                se = function(e) {
                    return parseInt(e % 60, 10)
                };

            function ae() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                if (!l.number(e)) return ae(null, t, i);
                var n = function(e) {
                        return ("0" + e).slice(-2)
                    },
                    s = ie(e),
                    a = ne(e),
                    o = se(e);
                return t || s > 0 ? s += ":" : s = "", (i && e > 0 ? "-" : "") + s + n(a) + ":" + n(o)
            }
            var oe = {
                getIconUrl: function() {
                    var e = new URL(this.config.iconUrl, window.location).host !== window.location.host || V.isIE && !window.svg4everybody;
                    return {
                        url: this.config.iconUrl,
                        cors: e
                    }
                },
                findElements: function() {
                    try {
                        return this.elements.controls = _.call(this, this.config.selectors.controls.wrapper), this.elements.buttons = {
                            play: x.call(this, this.config.selectors.buttons.play),
                            pause: _.call(this, this.config.selectors.buttons.pause),
                            restart: _.call(this, this.config.selectors.buttons.restart),
                            rewind: _.call(this, this.config.selectors.buttons.rewind),
                            fastForward: _.call(this, this.config.selectors.buttons.fastForward),
                            mute: _.call(this, this.config.selectors.buttons.mute),
                            pip: _.call(this, this.config.selectors.buttons.pip),
                            airplay: _.call(this, this.config.selectors.buttons.airplay),
                            settings: _.call(this, this.config.selectors.buttons.settings),
                            captions: _.call(this, this.config.selectors.buttons.captions),
                            fullscreen: _.call(this, this.config.selectors.buttons.fullscreen)
                        }, this.elements.progress = _.call(this, this.config.selectors.progress), this.elements.inputs = {
                            seek: _.call(this, this.config.selectors.inputs.seek),
                            volume: _.call(this, this.config.selectors.inputs.volume)
                        }, this.elements.display = {
                            buffer: _.call(this, this.config.selectors.display.buffer),
                            currentTime: _.call(this, this.config.selectors.display.currentTime),
                            duration: _.call(this, this.config.selectors.display.duration)
                        }, l.element(this.elements.progress) && (this.elements.display.seekTooltip = this.elements.progress.querySelector("." + this.config.classNames.tooltip)), !0
                    } catch (e) {
                        return this.debug.warn("It looks like there is a problem with your custom controls HTML", e), this.toggleNativeControls(!0), !1
                    }
                },
                createIcon: function(e, t) {
                    var i = oe.getIconUrl.call(this),
                        n = (i.cors ? "" : i.url) + "#" + this.config.iconPrefix,
                        s = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    k(s, K(t, {
                        role: "presentation",
                        focusable: "false"
                    }));
                    var a = document.createElementNS("http://www.w3.org/2000/svg", "use"),
                        o = n + "-" + e;
                    return "href" in a ? a.setAttributeNS("http://www.w3.org/1999/xlink", "href", o) : a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", o), s.appendChild(a), s
                },
                createLabel: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        i = {
                            pip: "PIP",
                            airplay: "AirPlay"
                        }[e] || X(e, this.config);
                    return w("span", Object.assign({}, t, {
                        class: [t.class, this.config.classNames.hidden].filter(Boolean).join(" ")
                    }), i)
                },
                createBadge: function(e) {
                    if (l.empty(e)) return null;
                    var t = w("span", {
                        class: this.config.classNames.menu.value
                    });
                    return t.appendChild(w("span", {
                        class: this.config.classNames.menu.badge
                    }, e)), t
                },
                createButton: function(e, t) {
                    var i = w("button"),
                        n = Object.assign({}, t),
                        s = $(e),
                        a = !1,
                        o = void 0,
                        r = void 0,
                        c = void 0,
                        u = void 0;
                    switch ("type" in n || (n.type = "button"), "class" in n ? n.class.includes(this.config.classNames.control) || (n.class += " " + this.config.classNames.control) : n.class = this.config.classNames.control, e) {
                        case "play":
                            a = !0, o = "play", c = "pause", r = "play", u = "pause";
                            break;
                        case "mute":
                            a = !0, o = "mute", c = "unmute", r = "volume", u = "muted";
                            break;
                        case "captions":
                            a = !0, o = "enableCaptions", c = "disableCaptions", r = "captions-off", u = "captions-on";
                            break;
                        case "fullscreen":
                            a = !0, o = "enterFullscreen", c = "exitFullscreen", r = "enter-fullscreen", u = "exit-fullscreen";
                            break;
                        case "play-large":
                            n.class += " " + this.config.classNames.control + "--overlaid", s = "play", o = "play", r = "play";
                            break;
                        default:
                            o = s, r = e
                    }
                    return a ? (i.appendChild(oe.createIcon.call(this, u, {
                        class: "icon--pressed"
                    })), i.appendChild(oe.createIcon.call(this, r, {
                        class: "icon--not-pressed"
                    })), i.appendChild(oe.createLabel.call(this, c, {
                        class: "label--pressed"
                    })), i.appendChild(oe.createLabel.call(this, o, {
                        class: "label--not-pressed"
                    }))) : (i.appendChild(oe.createIcon.call(this, r)), i.appendChild(oe.createLabel.call(this, o))), K(n, P(this.config.selectors.buttons[s], n)), k(i, n), "play" === s ? (l.array(this.elements.buttons[s]) || (this.elements.buttons[s] = []), this.elements.buttons[s].push(i)) : this.elements.buttons[s] = i, i
                },
                createRange: function(e, t) {
                    var i = w("input", K(P(this.config.selectors.inputs[e]), {
                        type: "range",
                        min: 0,
                        max: 100,
                        step: .01,
                        value: 0,
                        autocomplete: "off",
                        role: "slider",
                        "aria-label": X(e, this.config),
                        "aria-valuemin": 0,
                        "aria-valuemax": 100,
                        "aria-valuenow": 0
                    }, t));
                    return this.elements.inputs[e] = i, oe.updateRangeFill.call(this, i), i
                },
                createProgress: function(e, t) {
                    var i = w("progress", K(P(this.config.selectors.display[e]), {
                        min: 0,
                        max: 100,
                        value: 0,
                        role: "presentation",
                        "aria-hidden": !0
                    }, t));
                    if ("volume" !== e) {
                        i.appendChild(w("span", null, "0"));
                        var n = {
                                played: "played",
                                buffer: "buffered"
                            }[e],
                            s = n ? X(n, this.config) : "";
                        i.innerText = "% " + s.toLowerCase()
                    }
                    return this.elements.display[e] = i, i
                },
                createTime: function(e) {
                    var t = P(this.config.selectors.display[e]),
                        i = w("div", K(t, {
                            class: (this.config.classNames.display.time + " " + (t.class ? t.class : "")).trim(),
                            "aria-label": X(e, this.config)
                        }), "00:00");
                    return this.elements.display[e] = i, i
                },
                bindMenuItemShortcuts: function(e, t) {
                    var i = this;
                    d(e, "keydown keyup", function(n) {
                        if ([32, 38, 39, 40].includes(n.which) && (n.preventDefault(), n.stopPropagation(), "keydown" !== n.type)) {
                            var s = L(e, '[role="menuitemradio"]');
                            if (!s && [32, 39].includes(n.which)) oe.showMenuPanel.call(i, t, !0);
                            else {
                                var a = void 0;
                                32 !== n.which && (40 === n.which || s && 39 === n.which ? (a = e.nextElementSibling, l.element(a) || (a = e.parentNode.firstElementChild)) : (a = e.previousElementSibling, l.element(a) || (a = e.parentNode.lastElementChild)), I.call(i, a, !0))
                            }
                        }
                    }, !1), d(e, "keyup", function(e) {
                        13 === e.which && oe.focusFirstMenuItem.call(i, null, !0)
                    })
                },
                createMenuItem: function(e) {
                    var t = this,
                        i = e.value,
                        n = e.list,
                        s = e.type,
                        a = e.title,
                        o = e.badge,
                        r = void 0 === o ? null : o,
                        c = e.checked,
                        u = void 0 !== c && c,
                        d = P(this.config.selectors.inputs[s]),
                        h = w("button", K(d, {
                            type: "button",
                            role: "menuitemradio",
                            class: (this.config.classNames.control + " " + (d.class ? d.class : "")).trim(),
                            "aria-checked": u,
                            value: i
                        })),
                        p = w("span");
                    p.innerHTML = a, l.element(r) && p.appendChild(r), h.appendChild(p), Object.defineProperty(h, "checked", {
                        enumerable: !0,
                        get: function() {
                            return "true" === h.getAttribute("aria-checked")
                        },
                        set: function(e) {
                            e && Array.from(h.parentNode.children).filter(function(e) {
                                return L(e, '[role="menuitemradio"]')
                            }).forEach(function(e) {
                                return e.setAttribute("aria-checked", "false")
                            }), h.setAttribute("aria-checked", e ? "true" : "false")
                        }
                    }), this.listeners.bind(h, "click keyup", function(e) {
                        if (!l.keyboardEvent(e) || 32 === e.which) {
                            switch (e.preventDefault(), e.stopPropagation(), h.checked = !0, s) {
                                case "language":
                                    t.currentTrack = Number(i);
                                    break;
                                case "quality":
                                    t.quality = i;
                                    break;
                                case "speed":
                                    t.speed = parseFloat(i)
                            }
                            oe.showMenuPanel.call(t, "home", l.keyboardEvent(e))
                        }
                    }, s, !1), oe.bindMenuItemShortcuts.call(this, h, s), n.appendChild(h)
                },
                formatTime: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    return l.number(e) ? ae(e, ie(this.duration) > 0, t) : e
                },
                updateTimeDisplay: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    l.element(e) && l.number(t) && (e.innerText = oe.formatTime(t, i))
                },
                updateVolume: function() {
                    this.supported.ui && (l.element(this.elements.inputs.volume) && oe.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume), l.element(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || 0 === this.volume))
                },
                setRange: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    l.element(e) && (e.value = t, oe.updateRangeFill.call(this, e))
                },
                updateProgress: function(e) {
                    var t = this;
                    if (this.supported.ui && l.event(e)) {
                        var i, n, s = 0;
                        if (e) switch (e.type) {
                            case "timeupdate":
                            case "seeking":
                            case "seeked":
                                i = this.currentTime, n = this.duration, s = 0 === i || 0 === n || Number.isNaN(i) || Number.isNaN(n) ? 0 : (i / n * 100).toFixed(2), "timeupdate" === e.type && oe.setRange.call(this, this.elements.inputs.seek, s);
                                break;
                            case "playing":
                            case "progress":
                                ! function(e, i) {
                                    var n = l.number(i) ? i : 0,
                                        s = l.element(e) ? e : t.elements.display.buffer;
                                    if (l.element(s)) {
                                        s.value = n;
                                        var a = s.getElementsByTagName("span")[0];
                                        l.element(a) && (a.childNodes[0].nodeValue = n)
                                    }
                                }(this.elements.display.buffer, 100 * this.buffered)
                        }
                    }
                },
                updateRangeFill: function(e) {
                    var t = l.event(e) ? e.target : e;
                    if (l.element(t) && "range" === t.getAttribute("type")) {
                        if (L(t, this.config.selectors.inputs.seek)) {
                            t.setAttribute("aria-valuenow", this.currentTime);
                            var i = oe.formatTime(this.currentTime),
                                n = oe.formatTime(this.duration),
                                s = X("seekLabel", this.config);
                            t.setAttribute("aria-valuetext", s.replace("{currentTime}", i).replace("{duration}", n))
                        } else if (L(t, this.config.selectors.inputs.volume)) {
                            var a = 100 * t.value;
                            t.setAttribute("aria-valuenow", a), t.setAttribute("aria-valuetext", a.toFixed(1) + "%")
                        } else t.setAttribute("aria-valuenow", t.value);
                        V.isWebkit && t.style.setProperty("--value", t.value / t.max * 100 + "%")
                    }
                },
                updateSeekTooltip: function(e) {
                    var t = this;
                    if (this.config.tooltips.seek && l.element(this.elements.inputs.seek) && l.element(this.elements.display.seekTooltip) && 0 !== this.duration) {
                        var i = 0,
                            n = this.elements.progress.getBoundingClientRect(),
                            s = this.config.classNames.tooltip + "--visible",
                            a = function(e) {
                                M(t.elements.display.seekTooltip, s, e)
                            };
                        if (this.touch) a(!1);
                        else {
                            if (l.event(e)) i = 100 / n.width * (e.pageX - n.left);
                            else {
                                if (!N(this.elements.display.seekTooltip, s)) return;
                                i = parseFloat(this.elements.display.seekTooltip.style.left, 10)
                            }
                            i < 0 ? i = 0 : i > 100 && (i = 100), oe.updateTimeDisplay.call(this, this.elements.display.seekTooltip, this.duration / 100 * i), this.elements.display.seekTooltip.style.left = i + "%", l.event(e) && ["mouseenter", "mouseleave"].includes(e.type) && a("mouseenter" === e.type)
                        }
                    }
                },
                timeUpdate: function(e) {
                    var t = !l.element(this.elements.display.duration) && this.config.invertTime;
                    oe.updateTimeDisplay.call(this, this.elements.display.currentTime, t ? this.duration - this.currentTime : this.currentTime, t), e && "timeupdate" === e.type && this.media.seeking || oe.updateProgress.call(this, e)
                },
                durationUpdate: function() {
                    if (this.supported.ui && (this.config.invertTime || !this.currentTime)) {
                        if (this.duration >= Math.pow(2, 32)) return S(this.elements.display.currentTime, !0), void S(this.elements.progress, !0);
                        l.element(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute("aria-valuemax", this.duration);
                        var e = l.element(this.elements.display.duration);
                        !e && this.config.displayDuration && this.paused && oe.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration), e && oe.updateTimeDisplay.call(this, this.elements.display.duration, this.duration), oe.updateSeekTooltip.call(this)
                    }
                },
                toggleMenuButton: function(e, t) {
                    S(this.elements.settings.buttons[e], !t)
                },
                updateSetting: function(e, t, i) {
                    var n = this.elements.settings.panels[e],
                        s = null,
                        a = t;
                    if ("captions" === e) s = this.currentTrack;
                    else {
                        if (s = l.empty(i) ? this[e] : i, l.empty(s) && (s = this.config[e].default), !l.empty(this.options[e]) && !this.options[e].includes(s)) return void this.debug.warn("Unsupported value of '" + s + "' for " + e);
                        if (!this.config[e].options.includes(s)) return void this.debug.warn("Disabled value of '" + s + "' for " + e)
                    }
                    if (l.element(a) || (a = n && n.querySelector('[role="menu"]')), l.element(a)) {
                        this.elements.settings.buttons[e].querySelector("." + this.config.classNames.menu.value).innerHTML = oe.getLabel.call(this, e, s);
                        var o = a && a.querySelector('[value="' + s + '"]');
                        l.element(o) && (o.checked = !0)
                    }
                },
                getLabel: function(e, t) {
                    switch (e) {
                        case "speed":
                            return 1 === t ? X("normal", this.config) : t + "&times;";
                        case "quality":
                            if (l.number(t)) {
                                var i = X("qualityLabel." + t, this.config);
                                return i.length ? i : t + "p"
                            }
                            return Q(t);
                        case "captions":
                            return ce.getLabel.call(this);
                        default:
                            return null
                    }
                },
                setQualityMenu: function(e) {
                    var t = this;
                    if (l.element(this.elements.settings.panels.quality)) {
                        var i = this.elements.settings.panels.quality.querySelector('[role="menu"]');
                        l.array(e) && (this.options.quality = z(e).filter(function(e) {
                            return t.config.quality.options.includes(e)
                        }));
                        var n = !l.empty(this.options.quality) && this.options.quality.length > 1;
                        if (oe.toggleMenuButton.call(this, "quality", n), E(i), oe.checkMenu.call(this), n) {
                            this.options.quality.sort(function(e, i) {
                                var n = t.config.quality.options;
                                return n.indexOf(e) > n.indexOf(i) ? 1 : -1
                            }).forEach(function(e) {
                                oe.createMenuItem.call(t, {
                                    value: e,
                                    list: i,
                                    type: "quality",
                                    title: oe.getLabel.call(t, "quality", e),
                                    badge: function(e) {
                                        var i = X("qualityBadge." + e, t.config);
                                        return i.length ? oe.createBadge.call(t, i) : null
                                    }(e)
                                })
                            }), oe.updateSetting.call(this, "quality", i)
                        }
                    }
                },
                setCaptionsMenu: function() {
                    var e = this;
                    if (l.element(this.elements.settings.panels.captions)) {
                        var t = this.elements.settings.panels.captions.querySelector('[role="menu"]'),
                            i = ce.getTracks.call(this),
                            n = Boolean(i.length);
                        if (oe.toggleMenuButton.call(this, "captions", n), E(t), oe.checkMenu.call(this), n) {
                            var s = i.map(function(i, n) {
                                return {
                                    value: n,
                                    checked: e.captions.toggled && e.currentTrack === n,
                                    title: ce.getLabel.call(e, i),
                                    badge: i.language && oe.createBadge.call(e, i.language.toUpperCase()),
                                    list: t,
                                    type: "language"
                                }
                            });
                            s.unshift({
                                value: -1,
                                checked: !this.captions.toggled,
                                title: X("disabled", this.config),
                                list: t,
                                type: "language"
                            }), s.forEach(oe.createMenuItem.bind(this)), oe.updateSetting.call(this, "captions", t)
                        }
                    }
                },
                setSpeedMenu: function(e) {
                    var t = this;
                    if (l.element(this.elements.settings.panels.speed)) {
                        var i = this.elements.settings.panels.speed.querySelector('[role="menu"]');
                        l.array(e) ? this.options.speed = e : (this.isHTML5 || this.isVimeo) && (this.options.speed = [.5, .75, 1, 1.25, 1.5, 1.75, 2]), this.options.speed = this.options.speed.filter(function(e) {
                            return t.config.speed.options.includes(e)
                        });
                        var n = !l.empty(this.options.speed) && this.options.speed.length > 1;
                        oe.toggleMenuButton.call(this, "speed", n), E(i), oe.checkMenu.call(this), n && (this.options.speed.forEach(function(e) {
                            oe.createMenuItem.call(t, {
                                value: e,
                                list: i,
                                type: "speed",
                                title: oe.getLabel.call(t, "speed", e)
                            })
                        }), oe.updateSetting.call(this, "speed", i))
                    }
                },
                checkMenu: function() {
                    var e = this.elements.settings.buttons,
                        t = !l.empty(e) && Object.values(e).some(function(e) {
                            return !e.hidden
                        });
                    S(this.elements.settings.menu, !t)
                },
                focusFirstMenuItem: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (!this.elements.settings.popup.hidden) {
                        var i = e;
                        l.element(i) || (i = Object.values(this.elements.settings.panels).find(function(e) {
                            return !e.hidden
                        }));
                        var n = i.querySelector('[role^="menuitem"]');
                        I.call(this, n, t)
                    }
                },
                toggleMenu: function(e) {
                    var t = this.elements.settings.popup,
                        i = this.elements.buttons.settings;
                    if (l.element(t) && l.element(i)) {
                        var n = t.hidden,
                            s = n;
                        if (l.boolean(e)) s = e;
                        else if (l.keyboardEvent(e) && 27 === e.which) s = !1;
                        else if (l.event(e)) {
                            var a = t.contains(e.target);
                            if (a || !a && e.target !== i && s) return
                        }
                        i.setAttribute("aria-expanded", s), S(t, !s), M(this.elements.container, this.config.classNames.menu.open, s), s && l.keyboardEvent(e) ? oe.focusFirstMenuItem.call(this, null, !0) : s || n || I.call(this, i, l.keyboardEvent(e))
                    }
                },
                getMenuSize: function(e) {
                    var t = e.cloneNode(!0);
                    t.style.position = "absolute", t.style.opacity = 0, t.removeAttribute("hidden"), e.parentNode.appendChild(t);
                    var i = t.scrollWidth,
                        n = t.scrollHeight;
                    return A(t), {
                        width: i,
                        height: n
                    }
                },
                showMenuPanel: function() {
                    var e = this,
                        t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                        i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                        n = document.getElementById("plyr-settings-" + this.id + "-" + t);
                    if (l.element(n)) {
                        var s = n.parentNode,
                            a = Array.from(s.children).find(function(e) {
                                return !e.hidden
                            });
                        if (F.transitions && !F.reducedMotion) {
                            s.style.width = a.scrollWidth + "px", s.style.height = a.scrollHeight + "px";
                            var o = oe.getMenuSize.call(this, n);
                            d.call(this, s, R, function t(i) {
                                i.target === s && ["width", "height"].includes(i.propertyName) && (s.style.width = "", s.style.height = "", h.call(e, s, R, t))
                            }), s.style.width = o.width + "px", s.style.height = o.height + "px"
                        }
                        S(a, !0), S(n, !1), oe.focusFirstMenuItem.call(this, n, i)
                    }
                },
                create: function(e) {
                    var t = this,
                        i = w("div", P(this.config.selectors.controls.wrapper));
                    if (this.config.controls.includes("restart") && i.appendChild(oe.createButton.call(this, "restart")), this.config.controls.includes("rewind") && i.appendChild(oe.createButton.call(this, "rewind")), this.config.controls.includes("play") && i.appendChild(oe.createButton.call(this, "play")), this.config.controls.includes("fast-forward") && i.appendChild(oe.createButton.call(this, "fast-forward")), this.config.controls.includes("progress")) {
                        var n = w("div", P(this.config.selectors.progress));
                        if (n.appendChild(oe.createRange.call(this, "seek", {
                                id: "plyr-seek-" + e.id
                            })), n.appendChild(oe.createProgress.call(this, "buffer")), this.config.tooltips.seek) {
                            var s = w("span", {
                                class: this.config.classNames.tooltip
                            }, "00:00");
                            n.appendChild(s), this.elements.display.seekTooltip = s
                        }
                        this.elements.progress = n, i.appendChild(this.elements.progress)
                    }
                    if (this.config.controls.includes("current-time") && i.appendChild(oe.createTime.call(this, "currentTime")), this.config.controls.includes("duration") && i.appendChild(oe.createTime.call(this, "duration")), this.config.controls.includes("mute") || this.config.controls.includes("volume")) {
                        var a = w("div", {
                            class: "plyr__volume"
                        });
                        if (this.config.controls.includes("mute") && a.appendChild(oe.createButton.call(this, "mute")), this.config.controls.includes("volume")) {
                            var o = {
                                max: 1,
                                step: .05,
                                value: this.config.volume
                            };
                            a.appendChild(oe.createRange.call(this, "volume", K(o, {
                                id: "plyr-volume-" + e.id
                            }))), this.elements.volume = a
                        }
                        i.appendChild(a)
                    }
                    if (this.config.controls.includes("captions") && i.appendChild(oe.createButton.call(this, "captions")), this.config.controls.includes("settings") && !l.empty(this.config.settings)) {
                        var r = w("div", {
                            class: "plyr__menu",
                            hidden: ""
                        });
                        r.appendChild(oe.createButton.call(this, "settings", {
                            "aria-haspopup": !0,
                            "aria-controls": "plyr-settings-" + e.id,
                            "aria-expanded": !1
                        }));
                        var c = w("div", {
                                class: "plyr__menu__container",
                                id: "plyr-settings-" + e.id,
                                hidden: ""
                            }),
                            u = w("div"),
                            h = w("div", {
                                id: "plyr-settings-" + e.id + "-home"
                            }),
                            p = w("div", {
                                role: "menu"
                            });
                        h.appendChild(p), u.appendChild(h), this.elements.settings.panels.home = h, this.config.settings.forEach(function(i) {
                            var n = w("button", K(P(t.config.selectors.buttons.settings), {
                                type: "button",
                                class: t.config.classNames.control + " " + t.config.classNames.control + "--forward",
                                role: "menuitem",
                                "aria-haspopup": !0,
                                hidden: ""
                            }));
                            oe.bindMenuItemShortcuts.call(t, n, i), d(n, "click", function() {
                                oe.showMenuPanel.call(t, i, !1)
                            });
                            var s = w("span", null, X(i, t.config)),
                                a = w("span", {
                                    class: t.config.classNames.menu.value
                                });
                            a.innerHTML = e[i], s.appendChild(a), n.appendChild(s), p.appendChild(n);
                            var o = w("div", {
                                    id: "plyr-settings-" + e.id + "-" + i,
                                    hidden: ""
                                }),
                                r = w("button", {
                                    type: "button",
                                    class: t.config.classNames.control + " " + t.config.classNames.control + "--back"
                                });
                            r.appendChild(w("span", {
                                "aria-hidden": !0
                            }, X(i, t.config))), r.appendChild(w("span", {
                                class: t.config.classNames.hidden
                            }, X("menuBack", t.config))), d(o, "keydown", function(e) {
                                37 === e.which && (e.preventDefault(), e.stopPropagation(), oe.showMenuPanel.call(t, "home", !0))
                            }, !1), d(r, "click", function() {
                                oe.showMenuPanel.call(t, "home", !1)
                            }), o.appendChild(r), o.appendChild(w("div", {
                                role: "menu"
                            })), u.appendChild(o), t.elements.settings.buttons[i] = n, t.elements.settings.panels[i] = o
                        }), c.appendChild(u), r.appendChild(c), i.appendChild(r), this.elements.settings.popup = c, this.elements.settings.menu = r
                    }
                    return this.config.controls.includes("pip") && F.pip && i.appendChild(oe.createButton.call(this, "pip")), this.config.controls.includes("airplay") && F.airplay && i.appendChild(oe.createButton.call(this, "airplay")), this.config.controls.includes("fullscreen") && i.appendChild(oe.createButton.call(this, "fullscreen")), this.config.controls.includes("play-large") && this.elements.container.appendChild(oe.createButton.call(this, "play-large")), this.elements.controls = i, this.isHTML5 && oe.setQualityMenu.call(this, U.getQualityOptions.call(this)), oe.setSpeedMenu.call(this), i
                },
                inject: function() {
                    var e = this;
                    if (this.config.loadSprite) {
                        var t = oe.getIconUrl.call(this);
                        t.cors && te(t.url, "sprite-plyr")
                    }
                    this.id = Math.floor(1e4 * Math.random());
                    var i = null;
                    this.elements.controls = null;
                    var n = {
                            id: this.id,
                            seektime: this.config.seekTime,
                            title: this.config.title
                        },
                        s = !0;
                    l.function(this.config.controls) && (this.config.controls = this.config.controls.call(this.props)), this.config.controls || (this.config.controls = []), l.element(this.config.controls) || l.string(this.config.controls) ? i = this.config.controls : (i = oe.create.call(this, {
                        id: this.id,
                        seektime: this.config.seekTime,
                        speed: this.speed,
                        quality: this.quality,
                        captions: ce.getLabel.call(this)
                    }), s = !1);
                    var a = function(e) {
                        var t = e;
                        return Object.entries(n).forEach(function(e) {
                            var i = v(e, 2),
                                n = i[0],
                                s = i[1];
                            t = J(t, "{" + n + "}", s)
                        }), t
                    };
                    s && (l.string(this.config.controls) ? i = a(i) : l.element(i) && (i.innerHTML = a(i.innerHTML)));
                    var o = void 0;
                    if (l.string(this.config.selectors.controls.container) && (o = document.querySelector(this.config.selectors.controls.container)), l.element(o) || (o = this.elements.container), o[l.element(i) ? "insertAdjacentElement" : "insertAdjacentHTML"]("afterbegin", i), l.element(this.elements.controls) || oe.findElements.call(this), !l.empty(this.elements.buttons)) {
                        var r = function(t) {
                            var i = e.config.classNames.controlPressed;
                            Object.defineProperty(t, "pressed", {
                                enumerable: !0,
                                get: function() {
                                    return N(t, i)
                                },
                                set: function() {
                                    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                                    M(t, i, e)
                                }
                            })
                        };
                        Object.values(this.elements.buttons).filter(Boolean).forEach(function(e) {
                            l.array(e) || l.nodeList(e) ? Array.from(e).filter(Boolean).forEach(r) : r(e)
                        })
                    }
                    if (window.navigator.userAgent.includes("Edge") && B(o), this.config.tooltips.controls) {
                        var c = this.config,
                            u = c.classNames,
                            d = c.selectors,
                            h = d.controls.wrapper + " " + d.labels + " ." + u.hidden,
                            p = x.call(this, h);
                        Array.from(p).forEach(function(t) {
                            M(t, e.config.classNames.hidden, !1), M(t, e.config.classNames.tooltip, !0)
                        })
                    }
                }
            };

            function re(e) {
                var t = e;
                if (!(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]) {
                    var i = document.createElement("a");
                    i.href = t, t = i.href
                }
                try {
                    return new URL(t)
                } catch (e) {
                    return null
                }
            }

            function le(e) {
                var t = new URLSearchParams;
                return l.object(e) && Object.entries(e).forEach(function(e) {
                    var i = v(e, 2),
                        n = i[0],
                        s = i[1];
                    t.set(n, s)
                }), t
            }
            var ce = {
                    setup: function() {
                        if (this.supported.ui)
                            if (!this.isVideo || this.isYouTube || this.isHTML5 && !F.textTracks) l.array(this.config.controls) && this.config.controls.includes("settings") && this.config.settings.includes("captions") && oe.setCaptionsMenu.call(this);
                            else {
                                var e, t;
                                if (l.element(this.elements.captions) || (this.elements.captions = w("div", P(this.config.selectors.captions)), e = this.elements.captions, t = this.elements.wrapper, l.element(e) && l.element(t) && t.parentNode.insertBefore(e, t.nextSibling)), V.isIE && window.URL) {
                                    var i = this.media.querySelectorAll("track");
                                    Array.from(i).forEach(function(e) {
                                        var t = e.getAttribute("src"),
                                            i = re(t);
                                        null !== i && i.hostname !== window.location.href.hostname && ["http:", "https:"].includes(i.protocol) && ee(t, "blob").then(function(t) {
                                            e.setAttribute("src", window.URL.createObjectURL(t))
                                        }).catch(function() {
                                            A(e)
                                        })
                                    })
                                }
                                var n = z((navigator.languages || [navigator.language || navigator.userLanguage || "en"]).map(function(e) {
                                        return e.split("-")[0]
                                    })),
                                    s = (this.storage.get("language") || this.config.captions.language || "auto").toLowerCase();
                                if ("auto" === s) s = v(n, 1)[0];
                                var a = this.storage.get("captions");
                                if (l.boolean(a) || (a = this.config.captions.active), Object.assign(this.captions, {
                                        toggled: !1,
                                        active: a,
                                        language: s,
                                        languages: n
                                    }), this.isHTML5) {
                                    var o = this.config.captions.update ? "addtrack removetrack" : "removetrack";
                                    d.call(this, this.media.textTracks, o, ce.update.bind(this))
                                }
                                setTimeout(ce.update.bind(this), 0)
                            }
                    },
                    update: function() {
                        var e = this,
                            t = ce.getTracks.call(this, !0),
                            i = this.captions,
                            n = i.active,
                            s = i.language,
                            a = i.meta,
                            o = i.currentTrackNode,
                            r = Boolean(t.find(function(e) {
                                return e.language === s
                            }));
                        this.isHTML5 && this.isVideo && t.filter(function(e) {
                            return !a.get(e)
                        }).forEach(function(t) {
                            e.debug.log("Track added", t), a.set(t, {
                                default: "showing" === t.mode
                            }), t.mode = "hidden", d.call(e, t, "cuechange", function() {
                                return ce.updateCues.call(e)
                            })
                        }), (r && this.language !== s || !t.includes(o)) && (ce.setLanguage.call(this, s), ce.toggle.call(this, n && r)), M(this.elements.container, this.config.classNames.captions.enabled, !l.empty(t)), (this.config.controls || []).includes("settings") && this.config.settings.includes("captions") && oe.setCaptionsMenu.call(this)
                    },
                    toggle: function(e) {
                        var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                        if (this.supported.ui) {
                            var i = this.captions.toggled,
                                n = this.config.classNames.captions.active,
                                s = l.nullOrUndefined(e) ? !i : e;
                            if (s !== i) {
                                if (t || (this.captions.active = s, this.storage.set({
                                        captions: s
                                    })), !this.language && s && !t) {
                                    var a = ce.getTracks.call(this),
                                        o = ce.findTrack.call(this, [this.captions.language].concat(function(e) {
                                            if (Array.isArray(e)) {
                                                for (var t = 0, i = Array(e.length); t < e.length; t++) i[t] = e[t];
                                                return i
                                            }
                                            return Array.from(e)
                                        }(this.captions.languages)), !0);
                                    return this.captions.language = o.language, void ce.set.call(this, a.indexOf(o))
                                }
                                this.elements.buttons.captions && (this.elements.buttons.captions.pressed = s), M(this.elements.container, n, s), this.captions.toggled = s, oe.updateSetting.call(this, "captions"), f.call(this, this.media, s ? "captionsenabled" : "captionsdisabled")
                            }
                        }
                    },
                    set: function(e) {
                        var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                            i = ce.getTracks.call(this);
                        if (-1 !== e)
                            if (l.number(e))
                                if (e in i) {
                                    if (this.captions.currentTrack !== e) {
                                        this.captions.currentTrack = e;
                                        var n = i[e],
                                            s = (n || {}).language;
                                        this.captions.currentTrackNode = n, oe.updateSetting.call(this, "captions"), t || (this.captions.language = s, this.storage.set({
                                            language: s
                                        })), this.isVimeo && this.embed.enableTextTrack(s), f.call(this, this.media, "languagechange")
                                    }
                                    ce.toggle.call(this, !0, t), this.isHTML5 && this.isVideo && ce.updateCues.call(this)
                                } else this.debug.warn("Track not found", e);
                        else this.debug.warn("Invalid caption argument", e);
                        else ce.toggle.call(this, !1, t)
                    },
                    setLanguage: function(e) {
                        var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                        if (l.string(e)) {
                            var i = e.toLowerCase();
                            this.captions.language = i;
                            var n = ce.getTracks.call(this),
                                s = ce.findTrack.call(this, [i]);
                            ce.set.call(this, n.indexOf(s), t)
                        } else this.debug.warn("Invalid language argument", e)
                    },
                    getTracks: function() {
                        var e = this,
                            t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        return Array.from((this.media || {}).textTracks || []).filter(function(i) {
                            return !e.isHTML5 || t || e.captions.meta.has(i)
                        }).filter(function(e) {
                            return ["captions", "subtitles"].includes(e.kind)
                        })
                    },
                    findTrack: function(e) {
                        var t = this,
                            i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            n = ce.getTracks.call(this),
                            s = function(e) {
                                return Number((t.captions.meta.get(e) || {}).default)
                            },
                            a = Array.from(n).sort(function(e, t) {
                                return s(t) - s(e)
                            }),
                            o = void 0;
                        return e.every(function(e) {
                            return !(o = a.find(function(t) {
                                return t.language === e
                            }))
                        }), o || (i ? a[0] : void 0)
                    },
                    getCurrentTrack: function() {
                        return ce.getTracks.call(this)[this.currentTrack]
                    },
                    getLabel: function(e) {
                        var t = e;
                        return !l.track(t) && F.textTracks && this.captions.toggled && (t = ce.getCurrentTrack.call(this)), l.track(t) ? l.empty(t.label) ? l.empty(t.language) ? X("enabled", this.config) : e.language.toUpperCase() : t.label : X("disabled", this.config)
                    },
                    updateCues: function(e) {
                        if (this.supported.ui)
                            if (l.element(this.elements.captions))
                                if (l.nullOrUndefined(e) || Array.isArray(e)) {
                                    var t = e;
                                    if (!t) {
                                        var i = ce.getCurrentTrack.call(this);
                                        t = Array.from((i || {}).activeCues || []).map(function(e) {
                                            return e.getCueAsHTML()
                                        }).map(G)
                                    }
                                    var n = t.map(function(e) {
                                        return e.trim()
                                    }).join("\n");
                                    if (n !== this.elements.captions.innerHTML) {
                                        E(this.elements.captions);
                                        var s = w("span", P(this.config.selectors.caption));
                                        s.innerHTML = n, this.elements.captions.appendChild(s), f.call(this, this.media, "cuechange")
                                    }
                                } else this.debug.warn("updateCues: Invalid input", e);
                        else this.debug.warn("No captions element to render to")
                    }
                },
                ue = {
                    enabled: !0,
                    title: "",
                    debug: !1,
                    autoplay: !1,
                    autopause: !0,
                    playsinline: !0,
                    seekTime: 10,
                    volume: 1,
                    muted: !1,
                    duration: null,
                    displayDuration: !0,
                    invertTime: !0,
                    toggleInvert: !0,
                    ratio: "16:9",
                    clickToPlay: !0,
                    hideControls: !0,
                    resetOnEnd: !1,
                    disableContextMenu: !0,
                    loadSprite: !0,
                    iconPrefix: "plyr",
                    iconUrl: "https://cdn.plyr.io/3.3.12/plyr.svg",
                    blankVideo: "https://cdn.plyr.io/static/blank.mp4",
                    quality: {
                        default: 576,
                        options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240]
                    },
                    loop: {
                        active: !1
                    },
                    speed: {
                        selected: 1,
                        options: [.5, .75, 1, 1.25, 1.5, 1.75, 2]
                    },
                    keyboard: {
                        focused: !0,
                        global: !1
                    },
                    tooltips: {
                        controls: !1,
                        seek: !0
                    },
                    captions: {
                        active: !1,
                        language: "auto",
                        update: !1
                    },
                    fullscreen: {
                        enabled: !0,
                        fallback: !0,
                        iosNative: !1
                    },
                    storage: {
                        enabled: !0,
                        key: "plyr"
                    },
                    controls: ["play-large", "play", "progress", "current-time", "mute", "volume", "captions", "settings", "pip", "airplay", "fullscreen"],
                    settings: ["captions", "quality", "speed"],
                    i18n: {
                        restart: "Restart",
                        rewind: "Rewind {seektime}s",
                        play: "Play",
                        pause: "Pause",
                        fastForward: "Forward {seektime}s",
                        seek: "Seek",
                        seekLabel: "{currentTime} of {duration}",
                        played: "Played",
                        buffered: "Buffered",
                        currentTime: "Current time",
                        duration: "Duration",
                        volume: "Volume",
                        mute: "Mute",
                        unmute: "Unmute",
                        enableCaptions: "Enable captions",
                        disableCaptions: "Disable captions",
                        enterFullscreen: "Enter fullscreen",
                        exitFullscreen: "Exit fullscreen",
                        frameTitle: "Player for {title}",
                        captions: "Captions",
                        settings: "Settings",
                        menuBack: "Go back to previous menu",
                        speed: "Speed",
                        normal: "Normal",
                        quality: "Quality",
                        loop: "Loop",
                        start: "Start",
                        end: "End",
                        all: "All",
                        reset: "Reset",
                        disabled: "Disabled",
                        enabled: "Enabled",
                        advertisement: "Ad",
                        qualityBadge: {
                            2160: "4K",
                            1440: "HD",
                            1080: "HD",
                            720: "HD",
                            576: "SD",
                            480: "SD"
                        }
                    },
                    urls: {
                        vimeo: {
                            sdk: "https://player.vimeo.com/api/player.js",
                            iframe: "https://player.vimeo.com/video/{0}?{1}",
                            api: "https://vimeo.com/api/v2/video/{0}.json"
                        },
                        youtube: {
                            sdk: "https://www.youtube.com/iframe_api",
                            api: "https://www.googleapis.com/youtube/v3/videos?id={0}&key={1}&fields=items(snippet(title))&part=snippet"
                        },
                        googleIMA: {
                            sdk: "https://imasdk.googleapis.com/js/sdkloader/ima3.js"
                        }
                    },
                    listeners: {
                        seek: null,
                        play: null,
                        pause: null,
                        restart: null,
                        rewind: null,
                        fastForward: null,
                        mute: null,
                        volume: null,
                        captions: null,
                        fullscreen: null,
                        pip: null,
                        airplay: null,
                        speed: null,
                        quality: null,
                        loop: null,
                        language: null
                    },
                    events: ["ended", "progress", "stalled", "playing", "waiting", "canplay", "canplaythrough", "loadstart", "loadeddata", "loadedmetadata", "timeupdate", "volumechange", "play", "pause", "error", "seeking", "seeked", "emptied", "ratechange", "cuechange", "enterfullscreen", "exitfullscreen", "captionsenabled", "captionsdisabled", "languagechange", "controlshidden", "controlsshown", "ready", "statechange", "qualitychange", "adsloaded", "adscontentpause", "adscontentresume", "adstarted", "adsmidpoint", "adscomplete", "adsallcomplete", "adsimpression", "adsclick"],
                    selectors: {
                        editable: "input, textarea, select, [contenteditable]",
                        container: ".plyr",
                        controls: {
                            container: null,
                            wrapper: ".plyr__controls"
                        },
                        labels: "[data-plyr]",
                        buttons: {
                            play: '[data-plyr="play"]',
                            pause: '[data-plyr="pause"]',
                            restart: '[data-plyr="restart"]',
                            rewind: '[data-plyr="rewind"]',
                            fastForward: '[data-plyr="fast-forward"]',
                            mute: '[data-plyr="mute"]',
                            captions: '[data-plyr="captions"]',
                            fullscreen: '[data-plyr="fullscreen"]',
                            pip: '[data-plyr="pip"]',
                            airplay: '[data-plyr="airplay"]',
                            settings: '[data-plyr="settings"]',
                            loop: '[data-plyr="loop"]'
                        },
                        inputs: {
                            seek: '[data-plyr="seek"]',
                            volume: '[data-plyr="volume"]',
                            speed: '[data-plyr="speed"]',
                            language: '[data-plyr="language"]',
                            quality: '[data-plyr="quality"]'
                        },
                        display: {
                            currentTime: ".plyr__time--current",
                            duration: ".plyr__time--duration",
                            buffer: ".plyr__progress__buffer",
                            loop: ".plyr__progress__loop",
                            volume: ".plyr__volume--display"
                        },
                        progress: ".plyr__progress",
                        captions: ".plyr__captions",
                        caption: ".plyr__caption",
                        menu: {
                            quality: ".js-plyr__menu__list--quality"
                        }
                    },
                    classNames: {
                        type: "plyr--{0}",
                        provider: "plyr--{0}",
                        video: "plyr__video-wrapper",
                        embed: "plyr__video-embed",
                        embedContainer: "plyr__video-embed__container",
                        poster: "plyr__poster",
                        posterEnabled: "plyr__poster-enabled",
                        ads: "plyr__ads",
                        control: "plyr__control",
                        controlPressed: "plyr__control--pressed",
                        playing: "plyr--playing",
                        paused: "plyr--paused",
                        stopped: "plyr--stopped",
                        loading: "plyr--loading",
                        hover: "plyr--hover",
                        tooltip: "plyr__tooltip",
                        cues: "plyr__cues",
                        hidden: "plyr__sr-only",
                        hideControls: "plyr--hide-controls",
                        isIos: "plyr--is-ios",
                        isTouch: "plyr--is-touch",
                        uiSupported: "plyr--full-ui",
                        noTransition: "plyr--no-transition",
                        display: {
                            time: "plyr__time"
                        },
                        menu: {
                            value: "plyr__menu__value",
                            badge: "plyr__badge",
                            open: "plyr--menu-open"
                        },
                        captions: {
                            enabled: "plyr--captions-enabled",
                            active: "plyr--captions-active"
                        },
                        fullscreen: {
                            enabled: "plyr--fullscreen-enabled",
                            fallback: "plyr--fullscreen-fallback"
                        },
                        pip: {
                            supported: "plyr--pip-supported",
                            active: "plyr--pip-active"
                        },
                        airplay: {
                            supported: "plyr--airplay-supported",
                            active: "plyr--airplay-active"
                        },
                        tabFocus: "plyr__tab-focus"
                    },
                    attributes: {
                        embed: {
                            provider: "data-plyr-provider",
                            id: "data-plyr-embed-id"
                        }
                    },
                    keys: {
                        google: null
                    },
                    ads: {
                        enabled: !1,
                        publisherId: ""
                    }
                },
                de = {
                    html5: "html5",
                    youtube: "youtube",
                    vimeo: "vimeo"
                },
                he = {
                    audio: "audio",
                    video: "video"
                };
            var pe = function() {},
                fe = function() {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        m(this, e), this.enabled = window.console && t, this.enabled && this.log("Debugging enabled")
                    }
                    return g(e, [{
                        key: "log",
                        get: function() {
                            return this.enabled ? Function.prototype.bind.call(console.log, console) : pe
                        }
                    }, {
                        key: "warn",
                        get: function() {
                            return this.enabled ? Function.prototype.bind.call(console.warn, console) : pe
                        }
                    }, {
                        key: "error",
                        get: function() {
                            return this.enabled ? Function.prototype.bind.call(console.error, console) : pe
                        }
                    }]), e
                }();

            function me() {
                if (this.enabled) {
                    var e = this.player.elements.buttons.fullscreen;
                    l.element(e) && (e.pressed = this.active), f.call(this.player, this.target, this.active ? "enterfullscreen" : "exitfullscreen", !0), V.isIos || function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                            t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        if (l.element(e)) {
                            var i = x.call(this, "button:not(:disabled), input:not(:disabled), [tabindex]"),
                                n = i[0],
                                s = i[i.length - 1];
                            u.call(this, this.elements.container, "keydown", function(e) {
                                if ("Tab" === e.key && 9 === e.keyCode) {
                                    var t = document.activeElement;
                                    t !== s || e.shiftKey ? t === n && e.shiftKey && (s.focus(), e.preventDefault()) : (n.focus(), e.preventDefault())
                                }
                            }, t, !1)
                        }
                    }.call(this.player, this.target, this.active)
                }
            }

            function ge() {
                var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                e ? this.scrollPosition = {
                    x: window.scrollX || 0,
                    y: window.scrollY || 0
                } : window.scrollTo(this.scrollPosition.x, this.scrollPosition.y), document.body.style.overflow = e ? "hidden" : "", M(this.target, this.player.config.classNames.fullscreen.fallback, e), me.call(this)
            }
            var ye = function() {
                function e(t) {
                    var i = this;
                    m(this, e), this.player = t, this.prefix = e.prefix, this.property = e.property, this.scrollPosition = {
                        x: 0,
                        y: 0
                    }, d.call(this.player, document, "ms" === this.prefix ? "MSFullscreenChange" : this.prefix + "fullscreenchange", function() {
                        me.call(i)
                    }), d.call(this.player, this.player.elements.container, "dblclick", function(e) {
                        l.element(i.player.elements.controls) && i.player.elements.controls.contains(e.target) || i.toggle()
                    }), this.update()
                }
                return g(e, [{
                    key: "update",
                    value: function() {
                        this.enabled ? this.player.debug.log((e.native ? "Native" : "Fallback") + " fullscreen enabled") : this.player.debug.log("Fullscreen not supported and fallback disabled"), M(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled)
                    }
                }, {
                    key: "enter",
                    value: function() {
                        this.enabled && (V.isIos && this.player.config.fullscreen.iosNative ? this.target.webkitEnterFullscreen() : e.native ? this.prefix ? l.empty(this.prefix) || this.target[this.prefix + "Request" + this.property]() : this.target.requestFullscreen() : ge.call(this, !0))
                    }
                }, {
                    key: "exit",
                    value: function() {
                        if (this.enabled)
                            if (V.isIos && this.player.config.fullscreen.iosNative) this.target.webkitExitFullscreen(), this.player.play();
                            else if (e.native)
                            if (this.prefix) {
                                if (!l.empty(this.prefix)) {
                                    var t = "moz" === this.prefix ? "Cancel" : "Exit";
                                    document["" + this.prefix + t + this.property]()
                                }
                            } else(document.cancelFullScreen || document.exitFullscreen).call(document);
                        else ge.call(this, !1)
                    }
                }, {
                    key: "toggle",
                    value: function() {
                        this.active ? this.exit() : this.enter()
                    }
                }, {
                    key: "enabled",
                    get: function() {
                        return (e.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo
                    }
                }, {
                    key: "active",
                    get: function() {
                        return !!this.enabled && (e.native ? (this.prefix ? document["" + this.prefix + this.property + "Element"] : document.fullscreenElement) === this.target : N(this.target, this.player.config.classNames.fullscreen.fallback))
                    }
                }, {
                    key: "target",
                    get: function() {
                        return V.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.container
                    }
                }], [{
                    key: "native",
                    get: function() {
                        return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled)
                    }
                }, {
                    key: "prefix",
                    get: function() {
                        if (l.function(document.exitFullscreen)) return "";
                        var e = "";
                        return ["webkit", "moz", "ms"].some(function(t) {
                            return !(!l.function(document[t + "ExitFullscreen"]) && !l.function(document[t + "CancelFullScreen"])) && (e = t, !0)
                        }), e
                    }
                }, {
                    key: "property",
                    get: function() {
                        return "moz" === this.prefix ? "FullScreen" : "Fullscreen"
                    }
                }]), e
            }();

            function ve(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                return new Promise(function(i, n) {
                    var s = new Image,
                        a = function() {
                            delete s.onload, delete s.onerror, (s.naturalWidth >= t ? i : n)(s)
                        };
                    Object.assign(s, {
                        onload: a,
                        onerror: a,
                        src: e
                    })
                })
            }
            var be = {
                    addStyleHook: function() {
                        M(this.elements.container, this.config.selectors.container.replace(".", ""), !0), M(this.elements.container, this.config.classNames.uiSupported, this.supported.ui)
                    },
                    toggleNativeControls: function() {
                        arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.isHTML5 ? this.media.setAttribute("controls", "") : this.media.removeAttribute("controls")
                    },
                    build: function() {
                        var e = this;
                        if (this.listeners.media(), !this.supported.ui) return this.debug.warn("Basic support only for " + this.provider + " " + this.type), void be.toggleNativeControls.call(this, !0);
                        l.element(this.elements.controls) || (oe.inject.call(this), this.listeners.controls()), be.toggleNativeControls.call(this), this.isHTML5 && ce.setup.call(this), this.volume = null, this.muted = null, this.speed = null, this.loop = null, this.quality = null, oe.updateVolume.call(this), oe.timeUpdate.call(this), be.checkPlaying.call(this), M(this.elements.container, this.config.classNames.pip.supported, F.pip && this.isHTML5 && this.isVideo), M(this.elements.container, this.config.classNames.airplay.supported, F.airplay && this.isHTML5), M(this.elements.container, this.config.classNames.isIos, V.isIos), M(this.elements.container, this.config.classNames.isTouch, this.touch), this.ready = !0, setTimeout(function() {
                            f.call(e, e.media, "ready")
                        }, 0), be.setTitle.call(this), this.poster && be.setPoster.call(this, this.poster, !1).catch(function() {}), this.config.duration && oe.durationUpdate.call(this)
                    },
                    setTitle: function() {
                        var e = X("play", this.config);
                        if (l.string(this.config.title) && !l.empty(this.config.title) && (e += ", " + this.config.title), Array.from(this.elements.buttons.play || []).forEach(function(t) {
                                t.setAttribute("aria-label", e)
                            }), this.isEmbed) {
                            var t = _.call(this, "iframe");
                            if (!l.element(t)) return;
                            var i = l.empty(this.config.title) ? "video" : this.config.title,
                                n = X("frameTitle", this.config);
                            t.setAttribute("title", n.replace("{title}", i))
                        }
                    },
                    togglePoster: function(e) {
                        M(this.elements.container, this.config.classNames.posterEnabled, e)
                    },
                    setPoster: function(e) {
                        var t = this;
                        return arguments.length > 1 && void 0 !== arguments[1] && !arguments[1] || !this.poster ? (this.media.setAttribute("poster", e), function() {
                            var e = this;
                            return new Promise(function(t) {
                                return e.ready ? setTimeout(t, 0) : d.call(e, e.elements.container, "ready", t)
                            }).then(function() {})
                        }.call(this).then(function() {
                            return ve(e)
                        }).catch(function(i) {
                            throw e === t.poster && be.togglePoster.call(t, !1), i
                        }).then(function() {
                            if (e !== t.poster) throw new Error("setPoster cancelled by later call to setPoster")
                        }).then(function() {
                            return Object.assign(t.elements.poster.style, {
                                backgroundImage: "url('" + e + "')",
                                backgroundSize: ""
                            }), be.togglePoster.call(t, !0), e
                        })) : Promise.reject(new Error("Poster already set"))
                    },
                    checkPlaying: function(e) {
                        var t = this;
                        M(this.elements.container, this.config.classNames.playing, this.playing), M(this.elements.container, this.config.classNames.paused, this.paused), M(this.elements.container, this.config.classNames.stopped, this.stopped), Array.from(this.elements.buttons.play || []).forEach(function(e) {
                            e.pressed = t.playing
                        }), l.event(e) && "timeupdate" === e.type || be.toggleControls.call(this)
                    },
                    checkLoading: function(e) {
                        var t = this;
                        this.loading = ["stalled", "waiting"].includes(e.type), clearTimeout(this.timers.loading), this.timers.loading = setTimeout(function() {
                            M(t.elements.container, t.config.classNames.loading, t.loading), be.toggleControls.call(t)
                        }, this.loading ? 250 : 0)
                    },
                    toggleControls: function(e) {
                        var t = this.elements.controls;
                        t && this.config.hideControls && this.toggleControls(Boolean(e || this.loading || this.paused || t.pressed || t.hover))
                    }
                },
                ke = function() {
                    function e(t) {
                        m(this, e), this.player = t, this.lastKey = null, this.focusTimer = null, this.lastKeyDown = null, this.handleKey = this.handleKey.bind(this), this.toggleMenu = this.toggleMenu.bind(this), this.setTabFocus = this.setTabFocus.bind(this), this.firstTouch = this.firstTouch.bind(this)
                    }
                    return g(e, [{
                        key: "handleKey",
                        value: function(e) {
                            var t = this.player,
                                i = t.elements,
                                n = e.keyCode ? e.keyCode : e.which,
                                s = "keydown" === e.type,
                                a = s && n === this.lastKey;
                            if (!(e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) && l.number(n)) {
                                if (s) {
                                    var o = document.activeElement;
                                    if (l.element(o)) {
                                        var r = t.config.selectors.editable;
                                        if (o !== i.inputs.seek && L(o, r)) return;
                                        if (32 === e.which && L(o, 'button, [role^="menuitem"]')) return
                                    }
                                    switch ([32, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 56, 57, 67, 70, 73, 75, 76, 77, 79].includes(n) && (e.preventDefault(), e.stopPropagation()), n) {
                                        case 48:
                                        case 49:
                                        case 50:
                                        case 51:
                                        case 52:
                                        case 53:
                                        case 54:
                                        case 55:
                                        case 56:
                                        case 57:
                                            a || (t.currentTime = t.duration / 10 * (n - 48));
                                            break;
                                        case 32:
                                        case 75:
                                            a || t.togglePlay();
                                            break;
                                        case 38:
                                            t.increaseVolume(.1);
                                            break;
                                        case 40:
                                            t.decreaseVolume(.1);
                                            break;
                                        case 77:
                                            a || (t.muted = !t.muted);
                                            break;
                                        case 39:
                                            t.forward();
                                            break;
                                        case 37:
                                            t.rewind();
                                            break;
                                        case 70:
                                            t.fullscreen.toggle();
                                            break;
                                        case 67:
                                            a || t.toggleCaptions();
                                            break;
                                        case 76:
                                            t.loop = !t.loop
                                    }!t.fullscreen.enabled && t.fullscreen.active && 27 === n && t.fullscreen.toggle(), this.lastKey = n
                                } else this.lastKey = null
                            }
                        }
                    }, {
                        key: "toggleMenu",
                        value: function(e) {
                            oe.toggleMenu.call(this.player, e)
                        }
                    }, {
                        key: "firstTouch",
                        value: function() {
                            var e = this.player,
                                t = e.elements;
                            e.touch = !0, M(t.container, e.config.classNames.isTouch, !0)
                        }
                    }, {
                        key: "setTabFocus",
                        value: function(e) {
                            var t = this.player,
                                i = t.elements;
                            if (clearTimeout(this.focusTimer), "keydown" !== e.type || 9 === e.which) {
                                "keydown" === e.type && (this.lastKeyDown = e.timeStamp);
                                var n, s = e.timeStamp - this.lastKeyDown <= 20;
                                if ("focus" !== e.type || s) n = t.config.classNames.tabFocus, M(x.call(t, "." + n), n, !1), this.focusTimer = setTimeout(function() {
                                    var e = document.activeElement;
                                    i.container.contains(e) && M(document.activeElement, t.config.classNames.tabFocus, !0)
                                }, 10)
                            }
                        }
                    }, {
                        key: "global",
                        value: function() {
                            var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                                t = this.player;
                            t.config.keyboard.global && u.call(t, window, "keydown keyup", this.handleKey, e, !1), u.call(t, document.body, "click", this.toggleMenu, e), p.call(t, document.body, "touchstart", this.firstTouch), u.call(t, document.body, "keydown focus blur", this.setTabFocus, e, !1, !0)
                        }
                    }, {
                        key: "container",
                        value: function() {
                            var e = this.player,
                                t = e.elements;
                            !e.config.keyboard.global && e.config.keyboard.focused && d.call(e, t.container, "keydown keyup", this.handleKey, !1), d.call(e, t.container, "mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen", function(i) {
                                var n = t.controls;
                                n && "enterfullscreen" === i.type && (n.pressed = !1, n.hover = !1);
                                var s = 0;
                                ["touchstart", "touchmove", "mousemove"].includes(i.type) && (be.toggleControls.call(e, !0), s = e.touch ? 3e3 : 2e3), clearTimeout(e.timers.controls), e.timers.controls = setTimeout(function() {
                                    return be.toggleControls.call(e, !1)
                                }, s)
                            })
                        }
                    }, {
                        key: "media",
                        value: function() {
                            var e = this.player,
                                t = e.elements;
                            if (d.call(e, e.media, "timeupdate seeking seeked", function(t) {
                                    return oe.timeUpdate.call(e, t)
                                }), d.call(e, e.media, "durationchange loadeddata loadedmetadata", function(t) {
                                    return oe.durationUpdate.call(e, t)
                                }), d.call(e, e.media, "canplay", function() {
                                    S(t.volume, !e.hasAudio), S(t.buttons.mute, !e.hasAudio)
                                }), d.call(e, e.media, "ended", function() {
                                    e.isHTML5 && e.isVideo && e.config.resetOnEnd && e.restart()
                                }), d.call(e, e.media, "progress playing seeking seeked", function(t) {
                                    return oe.updateProgress.call(e, t)
                                }), d.call(e, e.media, "volumechange", function(t) {
                                    return oe.updateVolume.call(e, t)
                                }), d.call(e, e.media, "playing play pause ended emptied timeupdate", function(t) {
                                    return be.checkPlaying.call(e, t)
                                }), d.call(e, e.media, "waiting canplay seeked playing", function(t) {
                                    return be.checkLoading.call(e, t)
                                }), d.call(e, e.media, "playing", function() {
                                    e.ads && e.ads.enabled && !e.ads.initialized && e.ads.managerPromise.then(function() {
                                        return e.ads.play()
                                    }).catch(function() {
                                        return e.play()
                                    })
                                }), e.supported.ui && e.config.clickToPlay && !e.isAudio) {
                                var i = _.call(e, "." + e.config.classNames.video);
                                if (!l.element(i)) return;
                                d.call(e, t.container, "click touchstart", function(n) {
                                    ([t.container, i].includes(n.target) || i.contains(n.target)) && (e.config.hideControls && e.touch && N(t.container, e.config.classNames.hideControls) || (e.ended ? (e.restart(), e.play()) : e.togglePlay()))
                                })
                            }
                            e.supported.ui && e.config.disableContextMenu && d.call(e, t.wrapper, "contextmenu", function(e) {
                                e.preventDefault()
                            }, !1), d.call(e, e.media, "volumechange", function() {
                                e.storage.set({
                                    volume: e.volume,
                                    muted: e.muted
                                })
                            }), d.call(e, e.media, "ratechange", function() {
                                oe.updateSetting.call(e, "speed"), e.storage.set({
                                    speed: e.speed
                                })
                            }), d.call(e, e.media, "qualitychange", function(t) {
                                oe.updateSetting.call(e, "quality", null, t.detail.quality)
                            });
                            var n = e.config.events.concat(["keyup", "keydown"]).join(" ");
                            d.call(e, e.media, n, function(i) {
                                var n = i.detail,
                                    s = void 0 === n ? {} : n;
                                "error" === i.type && (s = e.media.error), f.call(e, t.container, i.type, !0, s)
                            })
                        }
                    }, {
                        key: "proxy",
                        value: function(e, t, i) {
                            var n = this.player,
                                s = n.config.listeners[i],
                                a = !0;
                            l.function(s) && (a = s.call(n, e)), a && l.function(t) && t.call(n, e)
                        }
                    }, {
                        key: "bind",
                        value: function(e, t, i, n) {
                            var s = this,
                                a = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                                o = this.player,
                                r = o.config.listeners[n],
                                c = l.function(r);
                            d.call(o, e, t, function(e) {
                                return s.proxy(e, i, n)
                            }, a && !c)
                        }
                    }, {
                        key: "controls",
                        value: function() {
                            var e = this,
                                t = this.player,
                                i = t.elements,
                                n = V.isIE ? "change" : "input";
                            if (i.buttons.play && Array.from(i.buttons.play).forEach(function(i) {
                                    e.bind(i, "click", t.togglePlay, "play")
                                }), this.bind(i.buttons.restart, "click", t.restart, "restart"), this.bind(i.buttons.rewind, "click", t.rewind, "rewind"), this.bind(i.buttons.fastForward, "click", t.forward, "fastForward"), this.bind(i.buttons.mute, "click", function() {
                                    t.muted = !t.muted
                                }, "mute"), this.bind(i.buttons.captions, "click", function() {
                                    return t.toggleCaptions()
                                }), this.bind(i.buttons.fullscreen, "click", function() {
                                    t.fullscreen.toggle()
                                }, "fullscreen"), this.bind(i.buttons.pip, "click", function() {
                                    t.pip = "toggle"
                                }, "pip"), this.bind(i.buttons.airplay, "click", t.airplay, "airplay"), this.bind(i.buttons.settings, "click", function(e) {
                                    e.stopPropagation(), oe.toggleMenu.call(t, e)
                                }), this.bind(i.buttons.settings, "keyup", function(e) {
                                    var i = e.which;
                                    [13, 32].includes(i) && (13 !== i ? (e.preventDefault(), e.stopPropagation(), oe.toggleMenu.call(t, e)) : oe.focusFirstMenuItem.call(t, null, !0))
                                }, null, !1), this.bind(i.settings.menu, "keydown", function(e) {
                                    27 === e.which && oe.toggleMenu.call(t, e)
                                }), this.bind(i.inputs.seek, "mousedown mousemove", function(e) {
                                    var t = i.progress.getBoundingClientRect(),
                                        n = 100 / t.width * (e.pageX - t.left);
                                    e.currentTarget.setAttribute("seek-value", n)
                                }), this.bind(i.inputs.seek, "mousedown mouseup keydown keyup touchstart touchend", function(e) {
                                    var i = e.currentTarget,
                                        n = e.keyCode ? e.keyCode : e.which;
                                    if (!l.keyboardEvent(e) || 39 === n || 37 === n) {
                                        var s = i.hasAttribute("play-on-seeked"),
                                            a = ["mouseup", "touchend", "keyup"].includes(e.type);
                                        s && a ? (i.removeAttribute("play-on-seeked"), t.play()) : !a && t.playing && (i.setAttribute("play-on-seeked", ""), t.pause())
                                    }
                                }), V.isIos) {
                                var s = x.call(t, 'input[type="range"]');
                                Array.from(s).forEach(function(t) {
                                    return e.bind(t, n, function(e) {
                                        return B(e.target)
                                    })
                                })
                            }
                            this.bind(i.inputs.seek, n, function(e) {
                                var i = e.currentTarget,
                                    n = i.getAttribute("seek-value");
                                l.empty(n) && (n = i.value), i.removeAttribute("seek-value"), t.currentTime = n / i.max * t.duration
                            }, "seek"), this.bind(i.progress, "mouseenter mouseleave mousemove", function(e) {
                                return oe.updateSeekTooltip.call(t, e)
                            }), V.isWebkit && Array.from(x.call(t, 'input[type="range"]')).forEach(function(i) {
                                e.bind(i, "input", function(e) {
                                    return oe.updateRangeFill.call(t, e.target)
                                })
                            }), t.config.toggleInvert && !l.element(i.display.duration) && this.bind(i.display.currentTime, "click", function() {
                                0 !== t.currentTime && (t.config.invertTime = !t.config.invertTime, oe.timeUpdate.call(t))
                            }), this.bind(i.inputs.volume, n, function(e) {
                                t.volume = e.target.value
                            }, "volume"), this.bind(i.controls, "mouseenter mouseleave", function(e) {
                                i.controls.hover = !t.touch && "mouseenter" === e.type
                            }), this.bind(i.controls, "mousedown mouseup touchstart touchend touchcancel", function(e) {
                                i.controls.pressed = ["mousedown", "touchstart"].includes(e.type)
                            }), this.bind(i.controls, "focusin focusout", function(i) {
                                var n = t.config,
                                    s = t.elements,
                                    a = t.timers,
                                    o = "focusin" === i.type;
                                if (M(s.controls, n.classNames.noTransition, o), be.toggleControls.call(t, o), o) {
                                    setTimeout(function() {
                                        M(s.controls, n.classNames.noTransition, !1)
                                    }, 0);
                                    var r = e.touch ? 3e3 : 4e3;
                                    clearTimeout(a.controls), a.controls = setTimeout(function() {
                                        return be.toggleControls.call(t, !1)
                                    }, r)
                                }
                            }), this.bind(i.inputs.volume, "wheel", function(e) {
                                var i = e.webkitDirectionInvertedFromDevice,
                                    n = [e.deltaX, -e.deltaY].map(function(e) {
                                        return i ? -e : e
                                    }),
                                    s = v(n, 2),
                                    a = s[0],
                                    o = s[1],
                                    r = Math.sign(Math.abs(a) > Math.abs(o) ? a : o);
                                t.increaseVolume(r / 50);
                                var l = t.media.volume;
                                (1 === r && l < 1 || -1 === r && l > 0) && e.preventDefault()
                            }, "volume", !1)
                        }
                    }]), e
                }();
            "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;
            var we, Te = (function(e, t) {
                var i;
                i = function() {
                    var e = function() {},
                        t = {},
                        i = {},
                        n = {};

                    function s(e, t) {
                        if (e) {
                            var s = n[e];
                            if (i[e] = t, s)
                                for (; s.length;) s[0](e, t), s.splice(0, 1)
                        }
                    }

                    function a(t, i) {
                        t.call && (t = {
                            success: t
                        }), i.length ? (t.error || e)(i) : (t.success || e)(t)
                    }

                    function o(t, i, n, s) {
                        var a, r, l = document,
                            c = n.async,
                            u = (n.numRetries || 0) + 1,
                            d = n.before || e,
                            h = t.replace(/^(css|img)!/, "");
                        s = s || 0, /(^css!|\.css$)/.test(t) ? (a = !0, (r = l.createElement("link")).rel = "stylesheet", r.href = h) : /(^img!|\.(png|gif|jpg|svg)$)/.test(t) ? (r = l.createElement("img")).src = h : ((r = l.createElement("script")).src = t, r.async = void 0 === c || c), r.onload = r.onerror = r.onbeforeload = function(e) {
                            var l = e.type[0];
                            if (a && "hideFocus" in r) try {
                                r.sheet.cssText.length || (l = "e")
                            } catch (e) {
                                l = "e"
                            }
                            if ("e" == l && (s += 1) < u) return o(t, i, n, s);
                            i(t, l, e.defaultPrevented)
                        }, !1 !== d(t, r) && l.head.appendChild(r)
                    }

                    function r(e, i, n) {
                        var r, l;
                        if (i && i.trim && (r = i), l = (r ? n : i) || {}, r) {
                            if (r in t) throw "LoadJS";
                            t[r] = !0
                        }! function(e, t, i) {
                            var n, s, a = (e = e.push ? e : [e]).length,
                                r = a,
                                l = [];
                            for (n = function(e, i, n) {
                                    if ("e" == i && l.push(e), "b" == i) {
                                        if (!n) return;
                                        l.push(e)
                                    }--a || t(l)
                                }, s = 0; s < r; s++) o(e[s], n, i)
                        }(e, function(e) {
                            a(l, e), s(r, e)
                        }, l)
                    }
                    return r.ready = function(e, t) {
                        return function(e, t) {
                            e = e.push ? e : [e];
                            var s, a, o, r = [],
                                l = e.length,
                                c = l;
                            for (s = function(e, i) {
                                    i.length && r.push(e), --c || t(r)
                                }; l--;) a = e[l], (o = i[a]) ? s(a, o) : (n[a] = n[a] || []).push(s)
                        }(e, function(e) {
                            a(t, e)
                        }), r
                    }, r.done = function(e) {
                        s(e, [])
                    }, r.reset = function() {
                        t = {}, i = {}, n = {}
                    }, r.isDefined = function(e) {
                        return e in t
                    }, r
                }, e.exports = i()
            }(we = {
                exports: {}
            }, we.exports), we.exports);

            function Ae(e) {
                return new Promise(function(t, i) {
                    Te(e, {
                        success: t,
                        error: i
                    })
                })
            }

            function Ee(e) {
                e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, f.call(this, this.media, e ? "play" : "pause"))
            }
            var Ce = {
                setup: function() {
                    var e = this;
                    M(this.elements.wrapper, this.config.classNames.embed, !0), Ce.setAspectRatio.call(this), l.object(window.Vimeo) ? Ce.ready.call(this) : Ae(this.config.urls.vimeo.sdk).then(function() {
                        Ce.ready.call(e)
                    }).catch(function(t) {
                        e.debug.warn("Vimeo API failed to load", t)
                    })
                },
                setAspectRatio: function(e) {
                    var t = (l.string(e) ? e : this.config.ratio).split(":"),
                        i = v(t, 2),
                        n = 100 / i[0] * i[1];
                    if (this.elements.wrapper.style.paddingBottom = n + "%", this.supported.ui) {
                        var s = (240 - n) / 4.8;
                        this.media.style.transform = "translateY(-" + s + "%)"
                    }
                },
                ready: function() {
                    var e = this,
                        t = this,
                        i = le({
                            loop: t.config.loop.active,
                            autoplay: t.autoplay,
                            byline: !1,
                            portrait: !1,
                            title: !1,
                            speed: !0,
                            transparent: 0,
                            gesture: "media",
                            playsinline: !this.config.fullscreen.iosNative
                        }),
                        n = t.media.getAttribute("src");
                    l.empty(n) && (n = t.media.getAttribute(t.config.attributes.embed.id));
                    var s, a = (s = n, l.empty(s) ? null : l.number(Number(s)) ? s : s.match(/^.*(vimeo.com\/|video\/)(\d+).*/) ? RegExp.$2 : s),
                        o = w("iframe"),
                        r = Y(t.config.urls.vimeo.iframe, a, i);
                    o.setAttribute("src", r), o.setAttribute("allowfullscreen", ""), o.setAttribute("allowtransparency", ""), o.setAttribute("allow", "autoplay");
                    var c = w("div", {
                        poster: t.poster,
                        class: t.config.classNames.embedContainer
                    });
                    c.appendChild(o), t.media = C(c, t.media), ee(Y(t.config.urls.vimeo.api, a), "json").then(function(e) {
                        if (!l.empty(e)) {
                            var i = new URL(e[0].thumbnail_large);
                            i.pathname = i.pathname.split("_")[0] + ".jpg", be.setPoster.call(t, i.href).catch(function() {})
                        }
                    }), t.embed = new window.Vimeo.Player(o, {
                        autopause: t.config.autopause,
                        muted: t.muted
                    }), t.media.paused = !0, t.media.currentTime = 0, t.supported.ui && t.embed.disableTextTrack(), t.media.play = function() {
                        return Ee.call(t, !0), t.embed.play()
                    }, t.media.pause = function() {
                        return Ee.call(t, !1), t.embed.pause()
                    }, t.media.stop = function() {
                        t.pause(), t.currentTime = 0
                    };
                    var u = t.media.currentTime;
                    Object.defineProperty(t.media, "currentTime", {
                        get: function() {
                            return u
                        },
                        set: function(e) {
                            var i = t.embed,
                                n = t.media,
                                s = t.paused,
                                a = t.volume,
                                o = s && !i.hasPlayed;
                            n.seeking = !0, f.call(t, n, "seeking"), Promise.resolve(o && i.setVolume(0)).then(function() {
                                return i.setCurrentTime(e)
                            }).then(function() {
                                return o && i.pause()
                            }).then(function() {
                                return o && i.setVolume(a)
                            }).catch(function() {})
                        }
                    });
                    var d = t.config.speed.selected;
                    Object.defineProperty(t.media, "playbackRate", {
                        get: function() {
                            return d
                        },
                        set: function(e) {
                            t.embed.setPlaybackRate(e).then(function() {
                                d = e, f.call(t, t.media, "ratechange")
                            }).catch(function(e) {
                                "Error" === e.name && oe.setSpeedMenu.call(t, [])
                            })
                        }
                    });
                    var h = t.config.volume;
                    Object.defineProperty(t.media, "volume", {
                        get: function() {
                            return h
                        },
                        set: function(e) {
                            t.embed.setVolume(e).then(function() {
                                h = e, f.call(t, t.media, "volumechange")
                            })
                        }
                    });
                    var p = t.config.muted;
                    Object.defineProperty(t.media, "muted", {
                        get: function() {
                            return p
                        },
                        set: function(e) {
                            var i = !!l.boolean(e) && e;
                            t.embed.setVolume(i ? 0 : t.config.volume).then(function() {
                                p = i, f.call(t, t.media, "volumechange")
                            })
                        }
                    });
                    var m = t.config.loop;
                    Object.defineProperty(t.media, "loop", {
                        get: function() {
                            return m
                        },
                        set: function(e) {
                            var i = l.boolean(e) ? e : t.config.loop.active;
                            t.embed.setLoop(i).then(function() {
                                m = i
                            })
                        }
                    });
                    var g = void 0;
                    t.embed.getVideoUrl().then(function(e) {
                        g = e
                    }).catch(function(t) {
                        e.debug.warn(t)
                    }), Object.defineProperty(t.media, "currentSrc", {
                        get: function() {
                            return g
                        }
                    }), Object.defineProperty(t.media, "ended", {
                        get: function() {
                            return t.currentTime === t.duration
                        }
                    }), Promise.all([t.embed.getVideoWidth(), t.embed.getVideoHeight()]).then(function(t) {
                        var i = function(e, t) {
                            var i = function e(t, i) {
                                return 0 === i ? t : e(i, t % i)
                            }(e, t);
                            return e / i + ":" + t / i
                        }(t[0], t[1]);
                        Ce.setAspectRatio.call(e, i)
                    }), t.embed.setAutopause(t.config.autopause).then(function(e) {
                        t.config.autopause = e
                    }), t.embed.getVideoTitle().then(function(i) {
                        t.config.title = i, be.setTitle.call(e)
                    }), t.embed.getCurrentTime().then(function(e) {
                        u = e, f.call(t, t.media, "timeupdate")
                    }), t.embed.getDuration().then(function(e) {
                        t.media.duration = e, f.call(t, t.media, "durationchange")
                    }), t.embed.getTextTracks().then(function(e) {
                        t.media.textTracks = e, ce.setup.call(t)
                    }), t.embed.on("cuechange", function(e) {
                        var i = e.cues,
                            n = (void 0 === i ? [] : i).map(function(e) {
                                return t = e.text, i = document.createDocumentFragment(), n = document.createElement("div"), i.appendChild(n), n.innerHTML = t, i.firstChild.innerText;
                                var t, i, n
                            });
                        ce.updateCues.call(t, n)
                    }), t.embed.on("loaded", function() {
                        (t.embed.getPaused().then(function(e) {
                            Ee.call(t, !e), e || f.call(t, t.media, "playing")
                        }), l.element(t.embed.element) && t.supported.ui) && t.embed.element.setAttribute("tabindex", -1)
                    }), t.embed.on("play", function() {
                        Ee.call(t, !0), f.call(t, t.media, "playing")
                    }), t.embed.on("pause", function() {
                        Ee.call(t, !1)
                    }), t.embed.on("timeupdate", function(e) {
                        t.media.seeking = !1, u = e.seconds, f.call(t, t.media, "timeupdate")
                    }), t.embed.on("progress", function(e) {
                        t.media.buffered = e.percent, f.call(t, t.media, "progress"), 1 === parseInt(e.percent, 10) && f.call(t, t.media, "canplaythrough"), t.embed.getDuration().then(function(e) {
                            e !== t.media.duration && (t.media.duration = e, f.call(t, t.media, "durationchange"))
                        })
                    }), t.embed.on("seeked", function() {
                        t.media.seeking = !1, f.call(t, t.media, "seeked")
                    }), t.embed.on("ended", function() {
                        t.media.paused = !0, f.call(t, t.media, "ended")
                    }), t.embed.on("error", function(e) {
                        t.media.error = e, f.call(t, t.media, "error")
                    }), setTimeout(function() {
                        return be.build.call(t)
                    }, 0)
                }
            };

            function Pe(e) {
                e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, f.call(this, this.media, e ? "play" : "pause"))
            }
            var Se, Me = {
                    setup: function() {
                        var e = this;
                        M(this.elements.wrapper, this.config.classNames.embed, !0), Me.setAspectRatio.call(this), l.object(window.YT) && l.function(window.YT.Player) ? Me.ready.call(this) : (Ae(this.config.urls.youtube.sdk).catch(function(t) {
                            e.debug.warn("YouTube API failed to load", t)
                        }), window.onYouTubeReadyCallbacks = window.onYouTubeReadyCallbacks || [], window.onYouTubeReadyCallbacks.push(function() {
                            Me.ready.call(e)
                        }), window.onYouTubeIframeAPIReady = function() {
                            window.onYouTubeReadyCallbacks.forEach(function(e) {
                                e()
                            })
                        })
                    },
                    getTitle: function(e) {
                        var t = this;
                        if (l.function(this.embed.getVideoData)) {
                            var i = this.embed.getVideoData().title;
                            if (l.empty(i)) return this.config.title = i, void be.setTitle.call(this)
                        }
                        var n = this.config.keys.google;
                        l.string(n) && !l.empty(n) && ee(Y(this.config.urls.youtube.api, e, n)).then(function(e) {
                            l.object(e) && (t.config.title = e.items[0].snippet.title, be.setTitle.call(t))
                        }).catch(function() {})
                    },
                    setAspectRatio: function() {
                        var e = this.config.ratio.split(":");
                        this.elements.wrapper.style.paddingBottom = 100 / e[0] * e[1] + "%"
                    },
                    ready: function() {
                        var e = this,
                            t = e.media.getAttribute("id");
                        if (l.empty(t) || !t.startsWith("youtube-")) {
                            var i = e.media.getAttribute("src");
                            l.empty(i) && (i = e.media.getAttribute(this.config.attributes.embed.id));
                            var n, s = (n = i, l.empty(n) ? null : n.match(/^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/) ? RegExp.$2 : n),
                                a = e.provider + "-" + Math.floor(1e4 * Math.random()),
                                o = w("div", {
                                    id: a,
                                    poster: e.poster
                                });
                            e.media = C(o, e.media);
                            var r = function(e) {
                                return "https://img.youtube.com/vi/" + s + "/" + e + "default.jpg"
                            };
                            ve(r("maxres"), 121).catch(function() {
                                return ve(r("sd"), 121)
                            }).catch(function() {
                                return ve(r("hq"))
                            }).then(function(t) {
                                return be.setPoster.call(e, t.src)
                            }).then(function(t) {
                                t.includes("maxres") || (e.elements.poster.style.backgroundSize = "cover")
                            }).catch(function() {}), e.embed = new window.YT.Player(a, {
                                videoId: s,
                                playerVars: {
                                    autoplay: e.config.autoplay ? 1 : 0,
                                    hl: e.config.hl,
                                    controls: e.supported.ui ? 0 : 1,
                                    rel: 0,
                                    showinfo: 0,
                                    iv_load_policy: 3,
                                    modestbranding: 1,
                                    disablekb: 1,
                                    playsinline: 1,
                                    widget_referrer: window ? window.location.href : null,
                                    cc_load_policy: e.captions.active ? 1 : 0,
                                    cc_lang_pref: e.config.captions.language
                                },
                                events: {
                                    onError: function(t) {
                                        if (!e.media.error) {
                                            var i = t.data,
                                                n = {
                                                    2: "The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.",
                                                    5: "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.",
                                                    100: "The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.",
                                                    101: "The owner of the requested video does not allow it to be played in embedded players.",
                                                    150: "The owner of the requested video does not allow it to be played in embedded players."
                                                }[i] || "An unknown error occured";
                                            e.media.error = {
                                                code: i,
                                                message: n
                                            }, f.call(e, e.media, "error")
                                        }
                                    },
                                    onPlaybackRateChange: function(t) {
                                        var i = t.target;
                                        e.media.playbackRate = i.getPlaybackRate(), f.call(e, e.media, "ratechange")
                                    },
                                    onReady: function(t) {
                                        if (!l.function(e.media.play)) {
                                            var i = t.target;
                                            Me.getTitle.call(e, s), e.media.play = function() {
                                                Pe.call(e, !0), i.playVideo()
                                            }, e.media.pause = function() {
                                                Pe.call(e, !1), i.pauseVideo()
                                            }, e.media.stop = function() {
                                                i.stopVideo()
                                            }, e.media.duration = i.getDuration(), e.media.paused = !0, e.media.currentTime = 0, Object.defineProperty(e.media, "currentTime", {
                                                get: function() {
                                                    return Number(i.getCurrentTime())
                                                },
                                                set: function(t) {
                                                    e.paused && !e.embed.hasPlayed && e.embed.mute(), e.media.seeking = !0, f.call(e, e.media, "seeking"), i.seekTo(t)
                                                }
                                            }), Object.defineProperty(e.media, "playbackRate", {
                                                get: function() {
                                                    return i.getPlaybackRate()
                                                },
                                                set: function(e) {
                                                    i.setPlaybackRate(e)
                                                }
                                            });
                                            var n = e.config.volume;
                                            Object.defineProperty(e.media, "volume", {
                                                get: function() {
                                                    return n
                                                },
                                                set: function(t) {
                                                    n = t, i.setVolume(100 * n), f.call(e, e.media, "volumechange")
                                                }
                                            });
                                            var a = e.config.muted;
                                            Object.defineProperty(e.media, "muted", {
                                                get: function() {
                                                    return a
                                                },
                                                set: function(t) {
                                                    var n = l.boolean(t) ? t : a;
                                                    a = n, i[n ? "mute" : "unMute"](), f.call(e, e.media, "volumechange")
                                                }
                                            }), Object.defineProperty(e.media, "currentSrc", {
                                                get: function() {
                                                    return i.getVideoUrl()
                                                }
                                            }), Object.defineProperty(e.media, "ended", {
                                                get: function() {
                                                    return e.currentTime === e.duration
                                                }
                                            }), e.options.speed = i.getAvailablePlaybackRates(), e.supported.ui && e.media.setAttribute("tabindex", -1), f.call(e, e.media, "timeupdate"), f.call(e, e.media, "durationchange"), clearInterval(e.timers.buffering), e.timers.buffering = setInterval(function() {
                                                e.media.buffered = i.getVideoLoadedFraction(), (null === e.media.lastBuffered || e.media.lastBuffered < e.media.buffered) && f.call(e, e.media, "progress"), e.media.lastBuffered = e.media.buffered, 1 === e.media.buffered && (clearInterval(e.timers.buffering), f.call(e, e.media, "canplaythrough"))
                                            }, 200), setTimeout(function() {
                                                return be.build.call(e)
                                            }, 50)
                                        }
                                    },
                                    onStateChange: function(t) {
                                        var i = t.target;
                                        switch (clearInterval(e.timers.playing), e.media.seeking && [1, 2].includes(t.data) && (e.media.seeking = !1, f.call(e, e.media, "seeked")), t.data) {
                                            case -1:
                                                f.call(e, e.media, "timeupdate"), e.media.buffered = i.getVideoLoadedFraction(), f.call(e, e.media, "progress");
                                                break;
                                            case 0:
                                                Pe.call(e, !1), e.media.loop ? (i.stopVideo(), i.playVideo()) : f.call(e, e.media, "ended");
                                                break;
                                            case 1:
                                                e.media.paused && !e.embed.hasPlayed ? e.media.pause() : (Pe.call(e, !0), f.call(e, e.media, "playing"), e.timers.playing = setInterval(function() {
                                                    f.call(e, e.media, "timeupdate")
                                                }, 50), e.media.duration !== i.getDuration() && (e.media.duration = i.getDuration(), f.call(e, e.media, "durationchange")));
                                                break;
                                            case 2:
                                                e.muted || e.embed.unMute(), Pe.call(e, !1)
                                        }
                                        f.call(e, e.elements.container, "statechange", !1, {
                                            code: t.data
                                        })
                                    }
                                }
                            })
                        }
                    }
                },
                Ne = {
                    setup: function() {
                        this.media ? (M(this.elements.container, this.config.classNames.type.replace("{0}", this.type), !0), M(this.elements.container, this.config.classNames.provider.replace("{0}", this.provider), !0), this.isEmbed && M(this.elements.container, this.config.classNames.type.replace("{0}", "video"), !0), this.isVideo && (this.elements.wrapper = w("div", {
                            class: this.config.classNames.video
                        }), b(this.media, this.elements.wrapper), this.elements.poster = w("div", {
                            class: this.config.classNames.poster
                        }), this.elements.wrapper.appendChild(this.elements.poster)), this.isHTML5 ? U.extend.call(this) : this.isYouTube ? Me.setup.call(this) : this.isVimeo && Ce.setup.call(this)) : this.debug.warn("No media element found!")
                    }
                },
                Le = function() {
                    function e(t) {
                        var i = this;
                        m(this, e), this.player = t, this.publisherId = t.config.ads.publisherId, this.playing = !1, this.initialized = !1, this.elements = {
                            container: null,
                            displayContainer: null
                        }, this.manager = null, this.loader = null, this.cuePoints = null, this.events = {}, this.safetyTimer = null, this.countdownTimer = null, this.managerPromise = new Promise(function(e, t) {
                            i.on("loaded", e), i.on("error", t)
                        }), this.load()
                    }
                    return g(e, [{
                        key: "load",
                        value: function() {
                            var e = this;
                            this.enabled && (l.object(window.google) && l.object(window.google.ima) ? this.ready() : Ae(this.player.config.urls.googleIMA.sdk).then(function() {
                                e.ready()
                            }).catch(function() {
                                e.trigger("error", new Error("Google IMA SDK failed to load"))
                            }))
                        }
                    }, {
                        key: "ready",
                        value: function() {
                            var e = this;
                            this.startSafetyTimer(12e3, "ready()"), this.managerPromise.then(function() {
                                e.clearSafetyTimer("onAdsManagerLoaded()")
                            }), this.listeners(), this.setupIMA()
                        }
                    }, {
                        key: "setupIMA",
                        value: function() {
                            this.elements.container = w("div", {
                                class: this.player.config.classNames.ads
                            }), this.player.elements.container.appendChild(this.elements.container), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale(this.player.config.ads.language), this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container), this.requestAds()
                        }
                    }, {
                        key: "requestAds",
                        value: function() {
                            var e = this,
                                t = this.player.elements.container;
                            try {
                                this.loader = new google.ima.AdsLoader(this.elements.displayContainer), this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, function(t) {
                                    return e.onAdsManagerLoaded(t)
                                }, !1), this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, function(t) {
                                    return e.onAdError(t)
                                }, !1);
                                var i = new google.ima.AdsRequest;
                                i.adTagUrl = this.tagUrl, i.linearAdSlotWidth = t.offsetWidth, i.linearAdSlotHeight = t.offsetHeight, i.nonLinearAdSlotWidth = t.offsetWidth, i.nonLinearAdSlotHeight = t.offsetHeight, i.forceNonLinearFullSlot = !1, i.setAdWillPlayMuted(!this.player.muted), this.loader.requestAds(i)
                            } catch (e) {
                                this.onAdError(e)
                            }
                        }
                    }, {
                        key: "pollCountdown",
                        value: function() {
                            var e = this;
                            if (!(arguments.length > 0 && void 0 !== arguments[0] && arguments[0])) return clearInterval(this.countdownTimer), void this.elements.container.removeAttribute("data-badge-text");
                            this.countdownTimer = setInterval(function() {
                                var t = ae(Math.max(e.manager.getRemainingTime(), 0)),
                                    i = X("advertisement", e.player.config) + " - " + t;
                                e.elements.container.setAttribute("data-badge-text", i)
                            }, 100)
                        }
                    }, {
                        key: "onAdsManagerLoaded",
                        value: function(e) {
                            var t = this;
                            if (this.enabled) {
                                var i = new google.ima.AdsRenderingSettings;
                                i.restoreCustomPlaybackStateOnAdBreakComplete = !0, i.enablePreloading = !0, this.manager = e.getAdsManager(this.player, i), this.cuePoints = this.manager.getCuePoints(), l.empty(this.cuePoints) || this.cuePoints.forEach(function(e) {
                                    if (0 !== e && -1 !== e && e < t.player.duration) {
                                        var i = t.player.elements.progress;
                                        if (l.element(i)) {
                                            var n = 100 / t.player.duration * e,
                                                s = w("span", {
                                                    class: t.player.config.classNames.cues
                                                });
                                            s.style.left = n.toString() + "%", i.appendChild(s)
                                        }
                                    }
                                }), this.manager.setVolume(this.player.volume), this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, function(e) {
                                    return t.onAdError(e)
                                }), Object.keys(google.ima.AdEvent.Type).forEach(function(e) {
                                    t.manager.addEventListener(google.ima.AdEvent.Type[e], function(e) {
                                        return t.onAdEvent(e)
                                    })
                                }), this.trigger("loaded")
                            }
                        }
                    }, {
                        key: "onAdEvent",
                        value: function(e) {
                            var t = this,
                                i = this.player.elements.container,
                                n = e.getAd(),
                                s = function(e) {
                                    var i = "ads" + e.replace(/_/g, "").toLowerCase();
                                    f.call(t.player, t.player.media, i)
                                };
                            switch (e.type) {
                                case google.ima.AdEvent.Type.LOADED:
                                    this.trigger("loaded"), s(e.type), this.pollCountdown(!0), n.isLinear() || (n.width = i.offsetWidth, n.height = i.offsetHeight);
                                    break;
                                case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
                                    s(e.type), this.loadAds();
                                    break;
                                case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:
                                    s(e.type), this.pauseContent();
                                    break;
                                case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
                                    s(e.type), this.pollCountdown(), this.resumeContent();
                                    break;
                                case google.ima.AdEvent.Type.STARTED:
                                case google.ima.AdEvent.Type.MIDPOINT:
                                case google.ima.AdEvent.Type.COMPLETE:
                                case google.ima.AdEvent.Type.IMPRESSION:
                                case google.ima.AdEvent.Type.CLICK:
                                    s(e.type)
                            }
                        }
                    }, {
                        key: "onAdError",
                        value: function(e) {
                            this.cancel(), this.player.debug.warn("Ads error", e)
                        }
                    }, {
                        key: "listeners",
                        value: function() {
                            var e = this,
                                t = this.player.elements.container,
                                i = void 0;
                            this.player.on("ended", function() {
                                e.loader.contentComplete()
                            }), this.player.on("seeking", function() {
                                return i = e.player.currentTime
                            }), this.player.on("seeked", function() {
                                var t = e.player.currentTime;
                                l.empty(e.cuePoints) || e.cuePoints.forEach(function(n, s) {
                                    i < n && n < t && (e.manager.discardAdBreak(), e.cuePoints.splice(s, 1))
                                })
                            }), window.addEventListener("resize", function() {
                                e.manager && e.manager.resize(t.offsetWidth, t.offsetHeight, google.ima.ViewMode.NORMAL)
                            })
                        }
                    }, {
                        key: "play",
                        value: function() {
                            var e = this,
                                t = this.player.elements.container;
                            this.managerPromise || this.resumeContent(), this.managerPromise.then(function() {
                                e.elements.displayContainer.initialize();
                                try {
                                    e.initialized || (e.manager.init(t.offsetWidth, t.offsetHeight, google.ima.ViewMode.NORMAL), e.manager.start()), e.initialized = !0
                                } catch (t) {
                                    e.onAdError(t)
                                }
                            }).catch(function() {})
                        }
                    }, {
                        key: "resumeContent",
                        value: function() {
                            this.elements.container.style.zIndex = "", this.playing = !1, this.player.currentTime < this.player.duration && this.player.play()
                        }
                    }, {
                        key: "pauseContent",
                        value: function() {
                            this.elements.container.style.zIndex = 3, this.playing = !0, this.player.pause()
                        }
                    }, {
                        key: "cancel",
                        value: function() {
                            this.initialized && this.resumeContent(), this.trigger("error"), this.loadAds()
                        }
                    }, {
                        key: "loadAds",
                        value: function() {
                            var e = this;
                            this.managerPromise.then(function() {
                                e.manager && e.manager.destroy(), e.managerPromise = new Promise(function(t) {
                                    e.on("loaded", t), e.player.debug.log(e.manager)
                                }), e.requestAds()
                            }).catch(function() {})
                        }
                    }, {
                        key: "trigger",
                        value: function(e) {
                            for (var t = this, i = arguments.length, n = Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++) n[s - 1] = arguments[s];
                            var a = this.events[e];
                            l.array(a) && a.forEach(function(e) {
                                l.function(e) && e.apply(t, n)
                            })
                        }
                    }, {
                        key: "on",
                        value: function(e, t) {
                            return l.array(this.events[e]) || (this.events[e] = []), this.events[e].push(t), this
                        }
                    }, {
                        key: "startSafetyTimer",
                        value: function(e, t) {
                            var i = this;
                            this.player.debug.log("Safety timer invoked from: " + t), this.safetyTimer = setTimeout(function() {
                                i.cancel(), i.clearSafetyTimer("startSafetyTimer()")
                            }, e)
                        }
                    }, {
                        key: "clearSafetyTimer",
                        value: function(e) {
                            l.nullOrUndefined(this.safetyTimer) || (this.player.debug.log("Safety timer cleared from: " + e), clearTimeout(this.safetyTimer), this.safetyTimer = null)
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return this.player.isHTML5 && this.player.isVideo && this.player.config.ads.enabled && !l.empty(this.publisherId)
                        }
                    }, {
                        key: "tagUrl",
                        get: function() {
                            return "https://go.aniview.com/api/adserver6/vast/?" + le({
                                AV_PUBLISHERID: "58c25bb0073ef448b1087ad6",
                                AV_CHANNELID: "5a0458dc28a06145e4519d21",
                                AV_URL: window.location.hostname,
                                cb: Date.now(),
                                AV_WIDTH: 640,
                                AV_HEIGHT: 480,
                                AV_CDIM2: this.publisherId
                            })
                        }
                    }]), e
                }(),
                xe = {
                    insertElements: function(e, t) {
                        var i = this;
                        l.string(t) ? T(e, this.media, {
                            src: t
                        }) : l.array(t) && t.forEach(function(t) {
                            T(e, i.media, t)
                        })
                    },
                    change: function(e) {
                        var t = this;
                        W(e, "sources.length") ? (U.cancelRequests.call(this), this.destroy.call(this, function() {
                            t.options.quality = [], A(t.media), t.media = null, l.element(t.elements.container) && t.elements.container.removeAttribute("class");
                            var i = e.sources,
                                n = e.type,
                                s = v(i, 1)[0],
                                a = s.provider,
                                o = void 0 === a ? de.html5 : a,
                                r = s.src,
                                c = "html5" === o ? n : "div",
                                u = "html5" === o ? {} : {
                                    src: r
                                };
                            Object.assign(t, {
                                provider: o,
                                type: n,
                                supported: F.check(n, o, t.config.playsinline),
                                media: w(c, u)
                            }), t.elements.container.appendChild(t.media), l.boolean(e.autoplay) && (t.config.autoplay = e.autoplay), t.isHTML5 && (t.config.crossorigin && t.media.setAttribute("crossorigin", ""), t.config.autoplay && t.media.setAttribute("autoplay", ""), l.empty(e.poster) || (t.poster = e.poster), t.config.loop.active && t.media.setAttribute("loop", ""), t.config.muted && t.media.setAttribute("muted", ""), t.config.playsinline && t.media.setAttribute("playsinline", "")), be.addStyleHook.call(t), t.isHTML5 && xe.insertElements.call(t, "source", i), t.config.title = e.title, Ne.setup.call(t), t.isHTML5 && ("tracks" in e && xe.insertElements.call(t, "track", e.tracks), t.media.load()), (t.isHTML5 || t.isEmbed && !t.supported.ui) && be.build.call(t), t.fullscreen.update()
                        }, !0)) : this.debug.warn("Invalid source format")
                    }
                },
                _e = function() {
                    function e(t, i) {
                        var n = this;
                        if (m(this, e), this.timers = {}, this.ready = !1, this.loading = !1, this.failed = !1, this.touch = F.touch, this.media = t, l.string(this.media) && (this.media = document.querySelectorAll(this.media)), (window.jQuery && this.media instanceof jQuery || l.nodeList(this.media) || l.array(this.media)) && (this.media = this.media[0]), this.config = K({}, ue, e.defaults, i || {}, function() {
                                try {
                                    return JSON.parse(n.media.getAttribute("data-plyr-config"))
                                } catch (e) {
                                    return {}
                                }
                            }()), this.elements = {
                                container: null,
                                captions: null,
                                buttons: {},
                                display: {},
                                progress: {},
                                inputs: {},
                                settings: {
                                    popup: null,
                                    menu: null,
                                    panels: {},
                                    buttons: {}
                                }
                            }, this.captions = {
                                active: null,
                                currentTrack: -1,
                                meta: new WeakMap
                            }, this.fullscreen = {
                                active: !1
                            }, this.options = {
                                speed: [],
                                quality: []
                            }, this.debug = new fe(this.config.debug), this.debug.log("Config", this.config), this.debug.log("Support", F), !l.nullOrUndefined(this.media) && l.element(this.media))
                            if (this.media.plyr) this.debug.warn("Target already setup");
                            else if (this.config.enabled)
                            if (F.check().api) {
                                var s = this.media.cloneNode(!0);
                                s.autoplay = !1, this.elements.original = s;
                                var a = this.media.tagName.toLowerCase(),
                                    o = null,
                                    r = null;
                                switch (a) {
                                    case "div":
                                        if (o = this.media.querySelector("iframe"), l.element(o)) {
                                            if (r = re(o.getAttribute("src")), this.provider = function(e) {
                                                    return /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.?be)\/.+$/.test(e) ? de.youtube : /^https?:\/\/player.vimeo.com\/video\/\d{0,9}(?=\b|\/)/.test(e) ? de.vimeo : null
                                                }(r.toString()), this.elements.container = this.media, this.media = o, this.elements.container.className = "", r.search.length) {
                                                var c = ["1", "true"];
                                                c.includes(r.searchParams.get("autoplay")) && (this.config.autoplay = !0), c.includes(r.searchParams.get("loop")) && (this.config.loop.active = !0), this.isYouTube ? (this.config.playsinline = c.includes(r.searchParams.get("playsinline")), this.config.hl = r.searchParams.get("hl")) : this.config.playsinline = !0
                                            }
                                        } else this.provider = this.media.getAttribute(this.config.attributes.embed.provider), this.media.removeAttribute(this.config.attributes.embed.provider);
                                        if (l.empty(this.provider) || !Object.keys(de).includes(this.provider)) return void this.debug.error("Setup failed: Invalid provider");
                                        this.type = he.video;
                                        break;
                                    case "video":
                                    case "audio":
                                        this.type = a, this.provider = de.html5, this.media.hasAttribute("crossorigin") && (this.config.crossorigin = !0), this.media.hasAttribute("autoplay") && (this.config.autoplay = !0), (this.media.hasAttribute("playsinline") || this.media.hasAttribute("webkit-playsinline")) && (this.config.playsinline = !0), this.media.hasAttribute("muted") && (this.config.muted = !0), this.media.hasAttribute("loop") && (this.config.loop.active = !0);
                                        break;
                                    default:
                                        return void this.debug.error("Setup failed: unsupported type")
                                }
                                this.supported = F.check(this.type, this.provider, this.config.playsinline), this.supported.api ? (this.eventListeners = [], this.listeners = new ke(this), this.storage = new Z(this), this.media.plyr = this, l.element(this.elements.container) || (this.elements.container = w("div"), b(this.media, this.elements.container)), be.addStyleHook.call(this), Ne.setup.call(this), this.config.debug && d.call(this, this.elements.container, this.config.events.join(" "), function(e) {
                                    n.debug.log("event: " + e.type)
                                }), (this.isHTML5 || this.isEmbed && !this.supported.ui) && be.build.call(this), this.listeners.container(), this.listeners.global(), this.fullscreen = new ye(this), this.config.ads.enabled && (this.ads = new Le(this)), this.config.autoplay && this.play()) : this.debug.error("Setup failed: no support")
                            } else this.debug.error("Setup failed: no support");
                        else this.debug.error("Setup failed: disabled by config");
                        else this.debug.error("Setup failed: no suitable element passed")
                    }
                    return g(e, [{
                        key: "play",
                        value: function() {
                            return l.function(this.media.play) ? this.media.play() : null
                        }
                    }, {
                        key: "pause",
                        value: function() {
                            this.playing && l.function(this.media.pause) && this.media.pause()
                        }
                    }, {
                        key: "togglePlay",
                        value: function(e) {
                            (l.boolean(e) ? e : !this.playing) ? this.play(): this.pause()
                        }
                    }, {
                        key: "stop",
                        value: function() {
                            this.isHTML5 ? (this.pause(), this.restart()) : l.function(this.media.stop) && this.media.stop()
                        }
                    }, {
                        key: "restart",
                        value: function() {
                            this.currentTime = 0
                        }
                    }, {
                        key: "rewind",
                        value: function(e) {
                            this.currentTime = this.currentTime - (l.number(e) ? e : this.config.seekTime)
                        }
                    }, {
                        key: "forward",
                        value: function(e) {
                            this.currentTime = this.currentTime + (l.number(e) ? e : this.config.seekTime)
                        }
                    }, {
                        key: "increaseVolume",
                        value: function(e) {
                            var t = this.media.muted ? 0 : this.volume;
                            this.volume = t + (l.number(e) ? e : 0)
                        }
                    }, {
                        key: "decreaseVolume",
                        value: function(e) {
                            this.increaseVolume(-e)
                        }
                    }, {
                        key: "toggleCaptions",
                        value: function(e) {
                            ce.toggle.call(this, e, !1)
                        }
                    }, {
                        key: "airplay",
                        value: function() {
                            F.airplay && this.media.webkitShowPlaybackTargetPicker()
                        }
                    }, {
                        key: "toggleControls",
                        value: function(e) {
                            if (this.supported.ui && !this.isAudio) {
                                var t = N(this.elements.container, this.config.classNames.hideControls),
                                    i = void 0 === e ? void 0 : !e,
                                    n = M(this.elements.container, this.config.classNames.hideControls, i);
                                if (n && this.config.controls.includes("settings") && !l.empty(this.config.settings) && oe.toggleMenu.call(this, !1), n !== t) {
                                    var s = n ? "controlshidden" : "controlsshown";
                                    f.call(this, this.media, s)
                                }
                                return !n
                            }
                            return !1
                        }
                    }, {
                        key: "on",
                        value: function(e, t) {
                            d.call(this, this.elements.container, e, t)
                        }
                    }, {
                        key: "once",
                        value: function(e, t) {
                            p.call(this, this.elements.container, e, t)
                        }
                    }, {
                        key: "off",
                        value: function(e, t) {
                            h(this.elements.container, e, t)
                        }
                    }, {
                        key: "destroy",
                        value: function(e) {
                            var t = this,
                                i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            if (this.ready) {
                                var n = function() {
                                    document.body.style.overflow = "", t.embed = null, i ? (Object.keys(t.elements).length && (A(t.elements.buttons.play), A(t.elements.captions), A(t.elements.controls), A(t.elements.wrapper), t.elements.buttons.play = null, t.elements.captions = null, t.elements.controls = null, t.elements.wrapper = null), l.function(e) && e()) : (function() {
                                        this && this.eventListeners && (this.eventListeners.forEach(function(e) {
                                            var t = e.element,
                                                i = e.type,
                                                n = e.callback,
                                                s = e.options;
                                            t.removeEventListener(i, n, s)
                                        }), this.eventListeners = [])
                                    }.call(t), C(t.elements.original, t.elements.container), f.call(t, t.elements.original, "destroyed", !0), l.function(e) && e.call(t.elements.original), t.ready = !1, setTimeout(function() {
                                        t.elements = null, t.media = null
                                    }, 200))
                                };
                                this.stop(), this.isHTML5 ? (clearTimeout(this.timers.loading), be.toggleNativeControls.call(this, !0), n()) : this.isYouTube ? (clearInterval(this.timers.buffering), clearInterval(this.timers.playing), null !== this.embed && l.function(this.embed.destroy) && this.embed.destroy(), n()) : this.isVimeo && (null !== this.embed && this.embed.unload().then(n), setTimeout(n, 200))
                            }
                        }
                    }, {
                        key: "supports",
                        value: function(e) {
                            return F.mime.call(this, e)
                        }
                    }, {
                        key: "isHTML5",
                        get: function() {
                            return Boolean(this.provider === de.html5)
                        }
                    }, {
                        key: "isEmbed",
                        get: function() {
                            return Boolean(this.isYouTube || this.isVimeo)
                        }
                    }, {
                        key: "isYouTube",
                        get: function() {
                            return Boolean(this.provider === de.youtube)
                        }
                    }, {
                        key: "isVimeo",
                        get: function() {
                            return Boolean(this.provider === de.vimeo)
                        }
                    }, {
                        key: "isVideo",
                        get: function() {
                            return Boolean(this.type === he.video)
                        }
                    }, {
                        key: "isAudio",
                        get: function() {
                            return Boolean(this.type === he.audio)
                        }
                    }, {
                        key: "playing",
                        get: function() {
                            return Boolean(this.ready && !this.paused && !this.ended)
                        }
                    }, {
                        key: "paused",
                        get: function() {
                            return Boolean(this.media.paused)
                        }
                    }, {
                        key: "stopped",
                        get: function() {
                            return Boolean(this.paused && 0 === this.currentTime)
                        }
                    }, {
                        key: "ended",
                        get: function() {
                            return Boolean(this.media.ended)
                        }
                    }, {
                        key: "currentTime",
                        set: function(e) {
                            if (this.duration) {
                                var t = l.number(e) && e > 0;
                                this.media.currentTime = t ? Math.min(e, this.duration) : 0, this.debug.log("Seeking to " + this.currentTime + " seconds")
                            }
                        },
                        get: function() {
                            return Number(this.media.currentTime)
                        }
                    }, {
                        key: "buffered",
                        get: function() {
                            var e = this.media.buffered;
                            return l.number(e) ? e : e && e.length && this.duration > 0 ? e.end(0) / this.duration : 0
                        }
                    }, {
                        key: "seeking",
                        get: function() {
                            return Boolean(this.media.seeking)
                        }
                    }, {
                        key: "duration",
                        get: function() {
                            var e = parseFloat(this.config.duration),
                                t = (this.media || {}).duration,
                                i = l.number(t) && t !== 1 / 0 ? t : 0;
                            return e || i
                        }
                    }, {
                        key: "volume",
                        set: function(e) {
                            var t = e;
                            l.string(t) && (t = Number(t)), l.number(t) || (t = this.storage.get("volume")), l.number(t) || (t = this.config.volume), t > 1 && (t = 1), t < 0 && (t = 0), this.config.volume = t, this.media.volume = t, !l.empty(e) && this.muted && t > 0 && (this.muted = !1)
                        },
                        get: function() {
                            return Number(this.media.volume)
                        }
                    }, {
                        key: "muted",
                        set: function(e) {
                            var t = e;
                            l.boolean(t) || (t = this.storage.get("muted")), l.boolean(t) || (t = this.config.muted), this.config.muted = t, this.media.muted = t
                        },
                        get: function() {
                            return Boolean(this.media.muted)
                        }
                    }, {
                        key: "hasAudio",
                        get: function() {
                            return !this.isHTML5 || (!!this.isAudio || (Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length)))
                        }
                    }, {
                        key: "speed",
                        set: function(e) {
                            var t = null;
                            l.number(e) && (t = e), l.number(t) || (t = this.storage.get("speed")), l.number(t) || (t = this.config.speed.selected), t < .1 && (t = .1), t > 2 && (t = 2), this.config.speed.options.includes(t) ? (this.config.speed.selected = t, this.media.playbackRate = t) : this.debug.warn("Unsupported speed (" + t + ")")
                        },
                        get: function() {
                            return Number(this.media.playbackRate)
                        }
                    }, {
                        key: "quality",
                        set: function(e) {
                            var t = this.config.quality,
                                i = this.options.quality;
                            if (i.length) {
                                var n = [!l.empty(e) && Number(e), this.storage.get("quality"), t.selected, t.default].find(l.number);
                                if (!i.includes(n)) {
                                    var s = function(e, t) {
                                        return l.array(e) && e.length ? e.reduce(function(e, i) {
                                            return Math.abs(i - t) < Math.abs(e - t) ? i : e
                                        }) : null
                                    }(i, n);
                                    this.debug.warn("Unsupported quality option: " + n + ", using " + s + " instead"), n = s
                                }
                                t.selected = n, this.media.quality = n
                            }
                        },
                        get: function() {
                            return this.media.quality
                        }
                    }, {
                        key: "loop",
                        set: function(e) {
                            var t = l.boolean(e) ? e : this.config.loop.active;
                            this.config.loop.active = t, this.media.loop = t
                        },
                        get: function() {
                            return Boolean(this.media.loop)
                        }
                    }, {
                        key: "source",
                        set: function(e) {
                            xe.change.call(this, e)
                        },
                        get: function() {
                            return this.media.currentSrc
                        }
                    }, {
                        key: "poster",
                        set: function(e) {
                            this.isVideo ? be.setPoster.call(this, e, !1).catch(function() {}) : this.debug.warn("Poster can only be set for video")
                        },
                        get: function() {
                            return this.isVideo ? this.media.getAttribute("poster") : null
                        }
                    }, {
                        key: "autoplay",
                        set: function(e) {
                            var t = l.boolean(e) ? e : this.config.autoplay;
                            this.config.autoplay = t
                        },
                        get: function() {
                            return Boolean(this.config.autoplay)
                        }
                    }, {
                        key: "currentTrack",
                        set: function(e) {
                            ce.set.call(this, e, !1)
                        },
                        get: function() {
                            var e = this.captions,
                                t = e.toggled,
                                i = e.currentTrack;
                            return t ? i : -1
                        }
                    }, {
                        key: "language",
                        set: function(e) {
                            ce.setLanguage.call(this, e, !1)
                        },
                        get: function() {
                            return (ce.getCurrentTrack.call(this) || {}).language
                        }
                    }, {
                        key: "pip",
                        set: function(e) {
                            var t = "picture-in-picture",
                                i = "inline";
                            if (F.pip) {
                                var n = l.boolean(e) ? e : this.pip === i;
                                this.media.webkitSetPresentationMode(n ? t : i)
                            }
                        },
                        get: function() {
                            return F.pip ? this.media.webkitPresentationMode : null
                        }
                    }], [{
                        key: "supported",
                        value: function(e, t, i) {
                            return F.check(e, t, i)
                        }
                    }, {
                        key: "loadSprite",
                        value: function(e, t) {
                            return te(e, t)
                        }
                    }, {
                        key: "setup",
                        value: function(t) {
                            var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                n = null;
                            return l.string(t) ? n = Array.from(document.querySelectorAll(t)) : l.nodeList(t) ? n = Array.from(t) : l.array(t) && (n = t.filter(l.element)), l.empty(n) ? null : n.map(function(t) {
                                return new e(t, i)
                            })
                        }
                    }]), e
                }();
            return _e.defaults = (Se = ue, JSON.parse(JSON.stringify(Se))), _e
        });
    }.call(exports, __webpack_require__(6)))
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _utils = __webpack_require__(2);
    var _gsap = __webpack_require__(0);

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var BuffaWordsCarousel = function() {
        function BuffaWordsCarousel(target) {
            _classCallCheck(this, BuffaWordsCarousel);
            this.target = target;
            this.words = (0, _utils.qsa)(".lettering--contacts__path", target);
            this.currentWordIndex = 0;
            this.currentWord = (0, _utils.qs)(".lettering--contacts__path[data-id='0']");
            this.displacementFilter = (0, _utils.qs)("#filter-lettering feDisplacementMap", this.target);
            this.isRunning = true;
            this.init();
        }
        _createClass(BuffaWordsCarousel, [{
            key: "init",
            value: function init() {
                var _this = this;
                this._animateIn().then(function(_) {
                    function tween(ctx) {
                        var tl = new _gsap.TimelineMax({
                            onComplete: function onComplete(_) {
                                if (!ctx.isRunning) return;
                                ctx._nextWord();
                                tween(ctx);
                            }
                        });
                        tl.add("fadeIn").fromTo(ctx.displacementFilter, 0.6, {
                            attr: {
                                scale: -40
                            }
                        }, {
                            attr: {
                                scale: 0
                            }
                        }, "fadeIn").to(ctx.currentWord, 0.5, {
                            "stroke-opacity": 1
                        }, "fadeIn").add("fadeOut").to(ctx.displacementFilter, 0.6, {
                            attr: {
                                scale: 40
                            }
                        }, "fadeOut+=0.8").to(ctx.currentWord, 0.6, {
                            "stroke-opacity": 0
                        }, "fadeOut+=0.8");
                    }
                    tween(_this);
                });
            }
        }, {
            key: "stop",
            value: function stop() {
                this.isRunning = false;
            }
        }, {
            key: "destroy",
            value: function destroy() {}
        }, {
            key: "_animateIn",
            value: function _animateIn() {
                var _this2 = this;
                return new Promise(function(resolve) {
                    var tl = new _gsap.TimelineMax({
                        delay: 0.3,
                        onComplete: function onComplete(_) {
                            _this2._nextWord();
                            resolve();
                        }
                    });
                    tl.add("start").to(_this2.displacementFilter, 0.6, {
                        attr: {
                            scale: 0
                        }
                    }, "start").to(_this2.currentWord, 0.5, {
                        "stroke-opacity": 1
                    }, "start").add("fadeOut").to(_this2.displacementFilter, 0.6, {
                        attr: {
                            scale: 40
                        }
                    }, "fadeOut+=0.8").to(_this2.currentWord, 0.6, {
                        "stroke-opacity": 0
                    }, "fadeOut+=0.8");
                });
            }
        }, {
            key: "_nextWord",
            value: function _nextWord() {
                this.currentWordIndex = this.currentWordIndex < this.words.length - 1 ? this.currentWordIndex + 1 : 0;
                this.currentWord = (0, _utils.qs)(".lettering--contacts__path[data-id='" + this.currentWordIndex + "']");
            }
        }]);
        return BuffaWordsCarousel;
    }();
    exports.default = BuffaWordsCarousel;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _utils = __webpack_require__(2);
    __webpack_require__(68);
    var _gsap = __webpack_require__(0);
    var _const = __webpack_require__(8);
    var _webfontloader = __webpack_require__(70);
    var _webfontloader2 = _interopRequireDefault(_webfontloader);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var BuffaPreload = function() {
        function BuffaPreload() {
            _classCallCheck(this, BuffaPreload);
            this.borderSVG = ".page-border__svg";
            this.borderPath = ".page-border__border";
            this.borderSpacing = {
                x: Foundation.MediaQuery.atLeast("medium") ? 50 * 2 : 24 * 2,
                y: Foundation.MediaQuery.atLeast("medium") ? 50 * 2 : 36 * 2
            };
            this.borderSizes = {
                x: window.innerWidth - this.borderSpacing.x,
                y: window.innerHeight - this.borderSpacing.y
            };
            this.borderTotalLength = this.borderSizes.x * 2 + this.borderSizes.y * 2;
            this.assetsToLoad = [];
            this.queue = null;
        }
        _createClass(BuffaPreload, [{
            key: '_populateAssetsToLoadArray',
            value: function _populateAssetsToLoadArray() {
                var _this = this;
                var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
                this.assetsToLoad = [];
                Array.prototype.slice.call((0, _utils.qsa)("[data-preload]", context)).forEach(function(el) {
                    if (!BUFFA.loaded_assets.includes(el.dataset.preload)) {
                        BUFFA.loaded_assets.push(el.dataset.preload);
                        _this.assetsToLoad.push(el.dataset.preload);
                    }
                });
            }
        }, {
            key: '_setBorder',
            value: function _setBorder() {
                _gsap.TweenMax.set(this.borderSVG, {
                    attr: {
                        viewBox: '0 0 ' + this.borderSizes.x + ' ' + this.borderSizes.y
                    }
                });
                _gsap.TweenMax.set(this.borderPath, {
                    attr: {
                        d: 'M' + this.borderSizes.x + ' 0H0v' + this.borderSizes.y + 'h' + this.borderSizes.x + 'z'
                    }
                });
            }
        }, {
            key: '_drawBorder',
            value: function _drawBorder(loaded) {
                var _this2 = this;
                _gsap.TweenMax.to(this.borderPath, 0.5, {
                    "stroke-dasharray": this.borderTotalLength,
                    "stroke-dashoffset": function strokeDashoffset(_) {
                        return _this2.borderTotalLength - _this2.borderTotalLength * loaded;
                    }
                });
            }
        }, {
            key: '_updateCounter',
            value: function _updateCounter(progress) {
                (0, _utils.qs)(".preload__counter").textContent = progress;
            }
        }, {
            key: '_drawBoat',
            value: function _drawBoat(progress) {
                if (progress >= 1)(0, _utils.qs)(".boat__path--01").classList.add("visible");
                if (progress >= 21)(0, _utils.qs)(".boat__path--02").classList.add("visible");
                if (progress >= 41)(0, _utils.qs)(".boat__path--03").classList.add("visible");
                if (progress >= 61)(0, _utils.qs)(".boat__path--04").classList.add("visible");
                if (progress >= 76)(0, _utils.qs)(".boat__path--05").classList.add("visible");
            }
        }, {
            key: '_handleQueueProgress',
            value: function _handleQueueProgress(e) {
                var firstPageLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
                var progress = parseInt(e.loaded * 100);
                if (progress === 0) return;
                this._updateCounter(progress);
                if (firstPageLoad) {
                    this._drawBorder(e.loaded);
                    this._drawBoat(progress);
                }
            }
        }, {
            key: '_handleQueueComplete',
            value: function _handleQueueComplete() {
                var _this3 = this;
                return new Promise(function(resolve) {
                    CustomEase.create('easingBuffa', _const.BUFFA_EASE_CURVE);
                    var tl = new _gsap.TimelineMax({
                        onComplete: function onComplete() {
                            (0, _utils.qs)(".preload__counter").textContent = "0";
                            _gsap.TweenMax.set(".preload", {
                                className: "+=preload--disabled preload--page-navigation"
                            });
                            _gsap.TweenMax.set(".footer-boat", {
                                clearProps: "all",
                                className: "+=final-position"
                            });
                            _gsap.TweenMax.set(_this3.borderPath, {
                                strokeDasharray: 0,
                                strokeDashoffset: 0,
                                vectorEffect: "non-scaling-stroke"
                            });
                            resolve();
                        }
                    });
                    tl.add("start").to(".preload", 1, {
                        opacity: 0
                    }, "start").to(".footer-boat", 1.2, {
                        top: function top(_) {
                            return Foundation.MediaQuery.atLeast("medium") ? -15 : -14;
                        },
                        ease: "easingBuffa",
                        opacity: 1
                    }, "start");
                });
            }
        }, {
            key: '_runFakePreload',
            value: function _runFakePreload() {
                var _this4 = this;
                var loadPerc = {
                    value: 0
                };
                var _self = this;
                _gsap.TweenMax.to(loadPerc, 2, {
                    value: 100,
                    roundProps: "value",
                    onUpdateScope: _self,
                    onCompleteScope: _self,
                    onUpdate: function onUpdate(_) {
                        (0, _utils.qs)(".preload__counter").textContent = loadPerc.value;
                        _this4._drawBorder(loadPerc.value * 0.01);
                        _this4._drawBoat(loadPerc.value);
                    },
                    onComplete: function onComplete(_) {
                        _this4.queue.dispatchEvent("complete");
                    }
                });
            }
        }, {
            key: '_loadFonts',
            value: function _loadFonts() {
                return new Promise(function(resolve) {
                    _webfontloader2.default.load({
                        google: {
                            families: ["Cardo:700", "Source Sans Pro", "Medula One"]
                        },
                        active: function active(_) {
                            return resolve();
                        }
                    });
                });
            }
        }, {
            key: 'initLoadingCounter',
            value: function initLoadingCounter() {
                var _this5 = this;
                return new Promise(function(resolve) {
                    _this5._populateAssetsToLoadArray();
                    _this5.queue = new createjs.LoadQueue();
                    _this5._setBorder();
                    _this5.queue.on("progress", function(e) {
                        return _this5._handleQueueProgress(e);
                    });
                    _this5.queue.on("complete", function(_) {
                        Promise.all([_this5._handleQueueComplete(), _this5._loadFonts()]).then(function(_) {
                            return resolve();
                        });
                    });
                    if (_this5.assetsToLoad.length) {
                        _this5.queue.loadManifest(_this5.assetsToLoad);
                    } else {
                        _this5._runFakePreload();
                    }
                });
            }
        }, {
            key: 'loadAssets',
            value: function loadAssets() {
                var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
                var _self = this;
                return new Promise(function(resolve) {
                    _self._populateAssetsToLoadArray(context);
                    _self.queue = new createjs.LoadQueue();
                    if (_self.assetsToLoad.length) {
                        _self.queue.loadManifest(_self.assetsToLoad);
                        _self.queue.on("progress", function(e) {
                            return _self._handleQueueProgress(e, false);
                        });
                        _self.queue.on("complete", function(_) {
                            return _self._handleQueueComplete().then(function(_) {
                                return resolve();
                            });
                        });
                        var tl = new _gsap.TimelineMax();
                        tl.add("start").set(".preload", {
                            className: "-=preload--disabled"
                        }, "start").to(".preload", 1, {
                            opacity: 1
                        }, "start");
                    } else {
                        _self.queue.on("complete", function(_) {
                            return resolve();
                        });
                        _self.queue.dispatchEvent("complete");
                    }
                });
            }
        }]);
        return BuffaPreload;
    }();
    exports.default = BuffaPreload;
}), (function(module, exports, __webpack_require__) {
    (function(module, global) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
         * PreloadJS
         * Visit http://createjs.com/ for documentation, updates and examples.
         *
         * Copyright (c) 2010 gskinner.com, inc.
         *
         * Permission is hereby granted, free of charge, to any person
         * obtaining a copy of this software and associated documentation
         * files (the "Software"), to deal in the Software without
         * restriction, including without limitation the rights to use,
         * copy, modify, merge, publish, distribute, sublicense, and/or sell
         * copies of the Software, and to permit persons to whom the
         * Software is furnished to do so, subject to the following
         * conditions:
         *
         * The above copyright notice and this permission notice shall be
         * included in all copies or substantial portions of the Software.
         *
         * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
         * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
         * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
         * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
         * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
         * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
         * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
         * OTHER DEALINGS IN THE SOFTWARE.
         */
        window.createjs = window.createjs || {};
        (function() {
            "use strict";
            var s = createjs.PreloadJS = createjs.PreloadJS || {};
            s.version = "0.6.2";
            s.buildDate = "Thu, 26 Nov 2015 20:44:31 GMT";
        })();
        window.createjs = window.createjs || {};
        createjs.extend = function(subclass, superclass) {
            "use strict";

            function o() {
                this.constructor = subclass;
            }
            o.prototype = superclass.prototype;
            return (subclass.prototype = new o());
        };
        window.createjs = window.createjs || {};
        createjs.promote = function(subclass, prefix) {
            "use strict";
            var subP = subclass.prototype,
                supP = (Object.getPrototypeOf && Object.getPrototypeOf(subP)) || subP.__proto__;
            if (supP) {
                subP[(prefix += "_") + "constructor"] = supP.constructor;
                for (var n in supP) {
                    if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) {
                        subP[prefix + n] = supP[n];
                    }
                }
            }
            return subclass;
        };
        window.createjs = window.createjs || {};
        (function() {
            "use strict";
            createjs.proxy = function(method, scope) {
                var aArgs = Array.prototype.slice.call(arguments, 2);
                return function() {
                    return method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));
                };
            }
        }());
        window.createjs = window.createjs || {};
        createjs.indexOf = function(array, searchElement) {
            "use strict";
            for (var i = 0, l = array.length; i < l; i++) {
                if (searchElement === array[i]) {
                    return i;
                }
            }
            return -1;
        };
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function Event(type, bubbles, cancelable) {
                this.type = type;
                this.target = null;
                this.currentTarget = null;
                this.eventPhase = 0;
                this.bubbles = !!bubbles;
                this.cancelable = !!cancelable;
                this.timeStamp = (new Date()).getTime();
                this.defaultPrevented = false;
                this.propagationStopped = false;
                this.immediatePropagationStopped = false;
                this.removed = false;
            }
            var p = Event.prototype;
            p.preventDefault = function() {
                this.defaultPrevented = this.cancelable && true;
            };
            p.stopPropagation = function() {
                this.propagationStopped = true;
            };
            p.stopImmediatePropagation = function() {
                this.immediatePropagationStopped = this.propagationStopped = true;
            };
            p.remove = function() {
                this.removed = true;
            };
            p.clone = function() {
                return new Event(this.type, this.bubbles, this.cancelable);
            };
            p.set = function(props) {
                for (var n in props) {
                    this[n] = props[n];
                }
                return this;
            };
            p.toString = function() {
                return "[Event (type=" + this.type + ")]";
            };
            createjs.Event = Event;
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function ErrorEvent(title, message, data) {
                this.Event_constructor("error");
                this.title = title;
                this.message = message;
                this.data = data;
            }
            var p = createjs.extend(ErrorEvent, createjs.Event);
            p.clone = function() {
                return new createjs.ErrorEvent(this.title, this.message, this.data);
            };
            createjs.ErrorEvent = createjs.promote(ErrorEvent, "Event");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function EventDispatcher() {
                this._listeners = null;
                this._captureListeners = null;
            }
            var p = EventDispatcher.prototype;
            EventDispatcher.initialize = function(target) {
                target.addEventListener = p.addEventListener;
                target.on = p.on;
                target.removeEventListener = target.off = p.removeEventListener;
                target.removeAllEventListeners = p.removeAllEventListeners;
                target.hasEventListener = p.hasEventListener;
                target.dispatchEvent = p.dispatchEvent;
                target._dispatchEvent = p._dispatchEvent;
                target.willTrigger = p.willTrigger;
            };
            p.addEventListener = function(type, listener, useCapture) {
                var listeners;
                if (useCapture) {
                    listeners = this._captureListeners = this._captureListeners || {};
                } else {
                    listeners = this._listeners = this._listeners || {};
                }
                var arr = listeners[type];
                if (arr) {
                    this.removeEventListener(type, listener, useCapture);
                }
                arr = listeners[type];
                if (!arr) {
                    listeners[type] = [listener];
                } else {
                    arr.push(listener);
                }
                return listener;
            };
            p.on = function(type, listener, scope, once, data, useCapture) {
                if (listener.handleEvent) {
                    scope = scope || listener;
                    listener = listener.handleEvent;
                }
                scope = scope || this;
                return this.addEventListener(type, function(evt) {
                    listener.call(scope, evt, data);
                    once && evt.remove();
                }, useCapture);
            };
            p.removeEventListener = function(type, listener, useCapture) {
                var listeners = useCapture ? this._captureListeners : this._listeners;
                if (!listeners) {
                    return;
                }
                var arr = listeners[type];
                if (!arr) {
                    return;
                }
                for (var i = 0, l = arr.length; i < l; i++) {
                    if (arr[i] == listener) {
                        if (l == 1) {
                            delete(listeners[type]);
                        } else {
                            arr.splice(i, 1);
                        }
                        break;
                    }
                }
            };
            p.off = p.removeEventListener;
            p.removeAllEventListeners = function(type) {
                if (!type) {
                    this._listeners = this._captureListeners = null;
                } else {
                    if (this._listeners) {
                        delete(this._listeners[type]);
                    }
                    if (this._captureListeners) {
                        delete(this._captureListeners[type]);
                    }
                }
            };
            p.dispatchEvent = function(eventObj, bubbles, cancelable) {
                if (typeof eventObj == "string") {
                    var listeners = this._listeners;
                    if (!bubbles && (!listeners || !listeners[eventObj])) {
                        return true;
                    }
                    eventObj = new createjs.Event(eventObj, bubbles, cancelable);
                } else if (eventObj.target && eventObj.clone) {
                    eventObj = eventObj.clone();
                }
                try {
                    eventObj.target = this;
                } catch (e) {}
                if (!eventObj.bubbles || !this.parent) {
                    this._dispatchEvent(eventObj, 2);
                } else {
                    var top = this,
                        list = [top];
                    while (top.parent) {
                        list.push(top = top.parent);
                    }
                    var i, l = list.length;
                    for (i = l - 1; i >= 0 && !eventObj.propagationStopped; i--) {
                        list[i]._dispatchEvent(eventObj, 1 + (i == 0));
                    }
                    for (i = 1; i < l && !eventObj.propagationStopped; i++) {
                        list[i]._dispatchEvent(eventObj, 3);
                    }
                }
                return !eventObj.defaultPrevented;
            };
            p.hasEventListener = function(type) {
                var listeners = this._listeners,
                    captureListeners = this._captureListeners;
                return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
            };
            p.willTrigger = function(type) {
                var o = this;
                while (o) {
                    if (o.hasEventListener(type)) {
                        return true;
                    }
                    o = o.parent;
                }
                return false;
            };
            p.toString = function() {
                return "[EventDispatcher]";
            };
            p._dispatchEvent = function(eventObj, eventPhase) {
                var l, listeners = (eventPhase == 1) ? this._captureListeners : this._listeners;
                if (eventObj && listeners) {
                    var arr = listeners[eventObj.type];
                    if (!arr || !(l = arr.length)) {
                        return;
                    }
                    try {
                        eventObj.currentTarget = this;
                    } catch (e) {}
                    try {
                        eventObj.eventPhase = eventPhase;
                    } catch (e) {}
                    eventObj.removed = false;
                    arr = arr.slice();
                    for (var i = 0; i < l && !eventObj.immediatePropagationStopped; i++) {
                        var o = arr[i];
                        if (o.handleEvent) {
                            o.handleEvent(eventObj);
                        } else {
                            o(eventObj);
                        }
                        if (eventObj.removed) {
                            this.off(eventObj.type, o, eventPhase == 1);
                            eventObj.removed = false;
                        }
                    }
                }
            };
            createjs.EventDispatcher = EventDispatcher;
        }());
        window.createjs = window.createjs || {};
        (function(scope) {
            "use strict";

            function ProgressEvent(loaded, total) {
                this.Event_constructor("progress");
                this.loaded = loaded;
                this.total = (total == null) ? 1 : total;
                this.progress = (total == 0) ? 0 : this.loaded / this.total;
            };
            var p = createjs.extend(ProgressEvent, createjs.Event);
            p.clone = function() {
                return new createjs.ProgressEvent(this.loaded, this.total);
            };
            createjs.ProgressEvent = createjs.promote(ProgressEvent, "Event");
        }(window)); /*!JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org*/ ;
        (function() {
            var isLoader = "function" === "function" && __webpack_require__(69);
            var objectTypes = {
                "function": true,
                "object": true
            };
            var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
            var root = objectTypes[typeof window] && window || this,
                freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
            if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
                root = freeGlobal;
            }

            function runInContext(context, exports) {
                context || (context = root["Object"]());
                exports || (exports = root["Object"]());
                var Number = context["Number"] || root["Number"],
                    String = context["String"] || root["String"],
                    Object = context["Object"] || root["Object"],
                    Date = context["Date"] || root["Date"],
                    SyntaxError = context["SyntaxError"] || root["SyntaxError"],
                    TypeError = context["TypeError"] || root["TypeError"],
                    Math = context["Math"] || root["Math"],
                    nativeJSON = context["JSON"] || root["JSON"];
                if (typeof nativeJSON == "object" && nativeJSON) {
                    exports.stringify = nativeJSON.stringify;
                    exports.parse = nativeJSON.parse;
                }
                var objectProto = Object.prototype,
                    getClass = objectProto.toString,
                    isProperty, forEach, undef;
                var isExtended = new Date(-3509827334573292);
                try {
                    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 && isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
                } catch (exception) {}

                function has(name) {
                    if (has[name] !== undef) {
                        return has[name];
                    }
                    var isSupported;
                    if (name == "bug-string-char-index") {
                        isSupported = "a" [0] != "a";
                    } else if (name == "json") {
                        isSupported = has("json-stringify") && has("json-parse");
                    } else {
                        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
                        if (name == "json-stringify") {
                            var stringify = exports.stringify,
                                stringifySupported = typeof stringify == "function" && isExtended;
                            if (stringifySupported) {
                                (value = function() {
                                    return 1;
                                }).toJSON = value;
                                try {
                                    stringifySupported = stringify(0) === "0" && stringify(new Number()) === "0" && stringify(new String()) == '""' && stringify(getClass) === undef && stringify(undef) === undef && stringify() === undef && stringify(value) === "1" && stringify([value]) == "[1]" && stringify([undef]) == "[null]" && stringify(null) == "null" && stringify([undef, getClass, null]) == "[null,null,null]" && stringify({
                                        "a": [value, true, false, null, "\x00\b\n\f\r\t"]
                                    }) == serialized && stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" && stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' && stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' && stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' && stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
                                } catch (exception) {
                                    stringifySupported = false;
                                }
                            }
                            isSupported = stringifySupported;
                        }
                        if (name == "json-parse") {
                            var parse = exports.parse;
                            if (typeof parse == "function") {
                                try {
                                    if (parse("0") === 0 && !parse(false)) {
                                        value = parse(serialized);
                                        var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                                        if (parseSupported) {
                                            try {
                                                parseSupported = !parse('"\t"');
                                            } catch (exception) {}
                                            if (parseSupported) {
                                                try {
                                                    parseSupported = parse("01") !== 1;
                                                } catch (exception) {}
                                            }
                                            if (parseSupported) {
                                                try {
                                                    parseSupported = parse("1.") !== 1;
                                                } catch (exception) {}
                                            }
                                        }
                                    }
                                } catch (exception) {
                                    parseSupported = false;
                                }
                            }
                            isSupported = parseSupported;
                        }
                    }
                    return has[name] = !!isSupported;
                }
                if (!has("json")) {
                    var functionClass = "[object Function]",
                        dateClass = "[object Date]",
                        numberClass = "[object Number]",
                        stringClass = "[object String]",
                        arrayClass = "[object Array]",
                        booleanClass = "[object Boolean]";
                    var charIndexBuggy = has("bug-string-char-index");
                    if (!isExtended) {
                        var floor = Math.floor;
                        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
                        var getDay = function(year, month) {
                            return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                        };
                    }
                    if (!(isProperty = objectProto.hasOwnProperty)) {
                        isProperty = function(property) {
                            var members = {},
                                constructor;
                            if ((members.__proto__ = null, members.__proto__ = {
                                    "toString": 1
                                }, members).toString != getClass) {
                                isProperty = function(property) {
                                    var original = this.__proto__,
                                        result = property in (this.__proto__ = null, this);
                                    this.__proto__ = original;
                                    return result;
                                };
                            } else {
                                constructor = members.constructor;
                                isProperty = function(property) {
                                    var parent = (this.constructor || constructor).prototype;
                                    return property in this && !(property in parent && this[property] === parent[property]);
                                };
                            }
                            members = null;
                            return isProperty.call(this, property);
                        };
                    }
                    forEach = function(object, callback) {
                        var size = 0,
                            Properties, members, property;
                        (Properties = function() {
                            this.valueOf = 0;
                        }).prototype.valueOf = 0;
                        members = new Properties();
                        for (property in members) {
                            if (isProperty.call(members, property)) {
                                size++;
                            }
                        }
                        Properties = members = null;
                        if (!size) {
                            members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
                            forEach = function(object, callback) {
                                var isFunction = getClass.call(object) == functionClass,
                                    property, length;
                                var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
                                for (property in object) {
                                    if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                                        callback(property);
                                    }
                                }
                                for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
                            };
                        } else if (size == 2) {
                            forEach = function(object, callback) {
                                var members = {},
                                    isFunction = getClass.call(object) == functionClass,
                                    property;
                                for (property in object) {
                                    if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                                        callback(property);
                                    }
                                }
                            };
                        } else {
                            forEach = function(object, callback) {
                                var isFunction = getClass.call(object) == functionClass,
                                    property, isConstructor;
                                for (property in object) {
                                    if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                                        callback(property);
                                    }
                                }
                                if (isConstructor || isProperty.call(object, (property = "constructor"))) {
                                    callback(property);
                                }
                            };
                        }
                        return forEach(object, callback);
                    };
                    if (!has("json-stringify")) {
                        var Escapes = {
                            92: "\\\\",
                            34: '\\"',
                            8: "\\b",
                            12: "\\f",
                            10: "\\n",
                            13: "\\r",
                            9: "\\t"
                        };
                        var leadingZeroes = "000000";
                        var toPaddedString = function(width, value) {
                            return (leadingZeroes + (value || 0)).slice(-width);
                        };
                        var unicodePrefix = "\\u00";
                        var quote = function(value) {
                            var result = '"',
                                index = 0,
                                length = value.length,
                                useCharIndex = !charIndexBuggy || length > 10;
                            var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
                            for (; index < length; index++) {
                                var charCode = value.charCodeAt(index);
                                switch (charCode) {
                                    case 8:
                                    case 9:
                                    case 10:
                                    case 12:
                                    case 13:
                                    case 34:
                                    case 92:
                                        result += Escapes[charCode];
                                        break;
                                    default:
                                        if (charCode < 32) {
                                            result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                                            break;
                                        }
                                        result += useCharIndex ? symbols[index] : value.charAt(index);
                                }
                            }
                            return result + '"';
                        };
                        var serialize = function(property, object, callback, properties, whitespace, indentation, stack) {
                            var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
                            try {
                                value = object[property];
                            } catch (exception) {}
                            if (typeof value == "object" && value) {
                                className = getClass.call(value);
                                if (className == dateClass && !isProperty.call(value, "toJSON")) {
                                    if (value > -1 / 0 && value < 1 / 0) {
                                        if (getDay) {
                                            date = floor(value / 864e5);
                                            for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                                            for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                                            date = 1 + date - getDay(year, month);
                                            time = (value % 864e5 + 864e5) % 864e5;
                                            hours = floor(time / 36e5) % 24;
                                            minutes = floor(time / 6e4) % 60;
                                            seconds = floor(time / 1e3) % 60;
                                            milliseconds = time % 1e3;
                                        } else {
                                            year = value.getUTCFullYear();
                                            month = value.getUTCMonth();
                                            date = value.getUTCDate();
                                            hours = value.getUTCHours();
                                            minutes = value.getUTCMinutes();
                                            seconds = value.getUTCSeconds();
                                            milliseconds = value.getUTCMilliseconds();
                                        }
                                        value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                                            "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                                            "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                                            "." + toPaddedString(3, milliseconds) + "Z";
                                    } else {
                                        value = null;
                                    }
                                } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
                                    value = value.toJSON(property);
                                }
                            }
                            if (callback) {
                                value = callback.call(object, property, value);
                            }
                            if (value === null) {
                                return "null";
                            }
                            className = getClass.call(value);
                            if (className == booleanClass) {
                                return "" + value;
                            } else if (className == numberClass) {
                                return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
                            } else if (className == stringClass) {
                                return quote("" + value);
                            }
                            if (typeof value == "object") {
                                for (length = stack.length; length--;) {
                                    if (stack[length] === value) {
                                        throw TypeError();
                                    }
                                }
                                stack.push(value);
                                results = [];
                                prefix = indentation;
                                indentation += whitespace;
                                if (className == arrayClass) {
                                    for (index = 0, length = value.length; index < length; index++) {
                                        element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                                        results.push(element === undef ? "null" : element);
                                    }
                                    result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
                                } else {
                                    forEach(properties || value, function(property) {
                                        var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                                        if (element !== undef) {
                                            results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                                        }
                                    });
                                    result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
                                }
                                stack.pop();
                                return result;
                            }
                        };
                        exports.stringify = function(source, filter, width) {
                            var whitespace, callback, properties, className;
                            if (objectTypes[typeof filter] && filter) {
                                if ((className = getClass.call(filter)) == functionClass) {
                                    callback = filter;
                                } else if (className == arrayClass) {
                                    properties = {};
                                    for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
                                }
                            }
                            if (width) {
                                if ((className = getClass.call(width)) == numberClass) {
                                    if ((width -= width % 1) > 0) {
                                        for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
                                    }
                                } else if (className == stringClass) {
                                    whitespace = width.length <= 10 ? width : width.slice(0, 10);
                                }
                            }
                            return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
                        };
                    }
                    if (!has("json-parse")) {
                        var fromCharCode = String.fromCharCode;
                        var Unescapes = {
                            92: "\\",
                            34: '"',
                            47: "/",
                            98: "\b",
                            116: "\t",
                            110: "\n",
                            102: "\f",
                            114: "\r"
                        };
                        var Index, Source;
                        var abort = function() {
                            Index = Source = null;
                            throw SyntaxError();
                        };
                        var lex = function() {
                            var source = Source,
                                length = source.length,
                                value, begin, position, isSigned, charCode;
                            while (Index < length) {
                                charCode = source.charCodeAt(Index);
                                switch (charCode) {
                                    case 9:
                                    case 10:
                                    case 13:
                                    case 32:
                                        Index++;
                                        break;
                                    case 123:
                                    case 125:
                                    case 91:
                                    case 93:
                                    case 58:
                                    case 44:
                                        value = charIndexBuggy ? source.charAt(Index) : source[Index];
                                        Index++;
                                        return value;
                                    case 34:
                                        for (value = "@", Index++; Index < length;) {
                                            charCode = source.charCodeAt(Index);
                                            if (charCode < 32) {
                                                abort();
                                            } else if (charCode == 92) {
                                                charCode = source.charCodeAt(++Index);
                                                switch (charCode) {
                                                    case 92:
                                                    case 34:
                                                    case 47:
                                                    case 98:
                                                    case 116:
                                                    case 110:
                                                    case 102:
                                                    case 114:
                                                        value += Unescapes[charCode];
                                                        Index++;
                                                        break;
                                                    case 117:
                                                        begin = ++Index;
                                                        for (position = Index + 4; Index < position; Index++) {
                                                            charCode = source.charCodeAt(Index);
                                                            if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                                                abort();
                                                            }
                                                        }
                                                        value += fromCharCode("0x" + source.slice(begin, Index));
                                                        break;
                                                    default:
                                                        abort();
                                                }
                                            } else {
                                                if (charCode == 34) {
                                                    break;
                                                }
                                                charCode = source.charCodeAt(Index);
                                                begin = Index;
                                                while (charCode >= 32 && charCode != 92 && charCode != 34) {
                                                    charCode = source.charCodeAt(++Index);
                                                }
                                                value += source.slice(begin, Index);
                                            }
                                        }
                                        if (source.charCodeAt(Index) == 34) {
                                            Index++;
                                            return value;
                                        }
                                        abort();
                                    default:
                                        begin = Index;
                                        if (charCode == 45) {
                                            isSigned = true;
                                            charCode = source.charCodeAt(++Index);
                                        }
                                        if (charCode >= 48 && charCode <= 57) {
                                            if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                                                abort();
                                            }
                                            isSigned = false;
                                            for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                                            if (source.charCodeAt(Index) == 46) {
                                                position = ++Index;
                                                for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                                                if (position == Index) {
                                                    abort();
                                                }
                                                Index = position;
                                            }
                                            charCode = source.charCodeAt(Index);
                                            if (charCode == 101 || charCode == 69) {
                                                charCode = source.charCodeAt(++Index);
                                                if (charCode == 43 || charCode == 45) {
                                                    Index++;
                                                }
                                                for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                                                if (position == Index) {
                                                    abort();
                                                }
                                                Index = position;
                                            }
                                            return +source.slice(begin, Index);
                                        }
                                        if (isSigned) {
                                            abort();
                                        }
                                        if (source.slice(Index, Index + 4) == "true") {
                                            Index += 4;
                                            return true;
                                        } else if (source.slice(Index, Index + 5) == "false") {
                                            Index += 5;
                                            return false;
                                        } else if (source.slice(Index, Index + 4) == "null") {
                                            Index += 4;
                                            return null;
                                        }
                                        abort();
                                }
                            }
                            return "$";
                        };
                        var get = function(value) {
                            var results, hasMembers;
                            if (value == "$") {
                                abort();
                            }
                            if (typeof value == "string") {
                                if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                                    return value.slice(1);
                                }
                                if (value == "[") {
                                    results = [];
                                    for (;; hasMembers || (hasMembers = true)) {
                                        value = lex();
                                        if (value == "]") {
                                            break;
                                        }
                                        if (hasMembers) {
                                            if (value == ",") {
                                                value = lex();
                                                if (value == "]") {
                                                    abort();
                                                }
                                            } else {
                                                abort();
                                            }
                                        }
                                        if (value == ",") {
                                            abort();
                                        }
                                        results.push(get(value));
                                    }
                                    return results;
                                } else if (value == "{") {
                                    results = {};
                                    for (;; hasMembers || (hasMembers = true)) {
                                        value = lex();
                                        if (value == "}") {
                                            break;
                                        }
                                        if (hasMembers) {
                                            if (value == ",") {
                                                value = lex();
                                                if (value == "}") {
                                                    abort();
                                                }
                                            } else {
                                                abort();
                                            }
                                        }
                                        if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                                            abort();
                                        }
                                        results[value.slice(1)] = get(lex());
                                    }
                                    return results;
                                }
                                abort();
                            }
                            return value;
                        };
                        var update = function(source, property, callback) {
                            var element = walk(source, property, callback);
                            if (element === undef) {
                                delete source[property];
                            } else {
                                source[property] = element;
                            }
                        };
                        var walk = function(source, property, callback) {
                            var value = source[property],
                                length;
                            if (typeof value == "object" && value) {
                                if (getClass.call(value) == arrayClass) {
                                    for (length = value.length; length--;) {
                                        update(value, length, callback);
                                    }
                                } else {
                                    forEach(value, function(property) {
                                        update(value, property, callback);
                                    });
                                }
                            }
                            return callback.call(source, property, value);
                        };
                        exports.parse = function(source, callback) {
                            var result, value;
                            Index = 0;
                            Source = "" + source;
                            result = get(lex());
                            if (lex() != "$") {
                                abort();
                            }
                            Index = Source = null;
                            return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
                        };
                    }
                }
                exports["runInContext"] = runInContext;
                return exports;
            }
            if (freeExports && !isLoader) {
                runInContext(root, freeExports);
            } else {
                var nativeJSON = root.JSON,
                    previousJSON = root["JSON3"],
                    isRestored = false;
                var JSON3 = runInContext(root, (root["JSON3"] = {
                    "noConflict": function() {
                        if (!isRestored) {
                            isRestored = true;
                            root.JSON = nativeJSON;
                            root["JSON3"] = previousJSON;
                            nativeJSON = previousJSON = null;
                        }
                        return JSON3;
                    }
                }));
                root.JSON = {
                    "parse": JSON3.parse,
                    "stringify": JSON3.stringify
                };
            }
            if (isLoader) {
                !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                    return JSON3;
                }).call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }
        }).call(this);
        (function() {
            var s = {};
            s.appendToHead = function(el) {
                s.getHead().appendChild(el)
            }
            s.getHead = function() {
                return document.head || document.getElementsByTagName("head")[0];
            }
            s.getBody = function() {
                return document.body || document.getElementsByTagName("body")[0];
            }
            createjs.DomUtils = s;
        }());
        (function() {
            var s = {};
            s.parseXML = function(text, type) {
                var xml = null;
                try {
                    if (window.DOMParser) {
                        var parser = new DOMParser();
                        xml = parser.parseFromString(text, type);
                    }
                } catch (e) {}
                if (!xml) {
                    try {
                        xml = new ActiveXObject("Microsoft.XMLDOM");
                        xml.async = false;
                        xml.loadXML(text);
                    } catch (e) {
                        xml = null;
                    }
                }
                return xml;
            };
            s.parseJSON = function(value) {
                if (value == null) {
                    return null;
                }
                try {
                    return JSON.parse(value);
                } catch (e) {
                    throw e;
                }
            };
            createjs.DataUtils = s;
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function LoadItem() {
                this.src = null;
                this.type = null;
                this.id = null;
                this.maintainOrder = false;
                this.callback = null;
                this.data = null;
                this.method = createjs.LoadItem.GET;
                this.values = null;
                this.headers = null;
                this.withCredentials = false;
                this.mimeType = null;
                this.crossOrigin = null;
                this.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
            };
            var p = LoadItem.prototype = {};
            var s = LoadItem;
            s.LOAD_TIMEOUT_DEFAULT = 8000;
            s.create = function(value) {
                if (typeof value == "string") {
                    var item = new LoadItem();
                    item.src = value;
                    return item;
                } else if (value instanceof s) {
                    return value;
                } else if (value instanceof Object && value.src) {
                    if (value.loadTimeout == null) {
                        value.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
                    }
                    return value;
                } else {
                    throw new Error("Type not recognized.");
                }
            };
            p.set = function(props) {
                for (var n in props) {
                    this[n] = props[n];
                }
                return this;
            };
            createjs.LoadItem = s;
        }());
        (function() {
            var s = {};
            s.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i;
            s.RELATIVE_PATT = (/^[./]*?\//i);
            s.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i;
            s.parseURI = function(path) {
                var info = {
                    absolute: false,
                    relative: false
                };
                if (path == null) {
                    return info;
                }
                var queryIndex = path.indexOf("?");
                if (queryIndex > -1) {
                    path = path.substr(0, queryIndex);
                }
                var match;
                if (s.ABSOLUTE_PATT.test(path)) {
                    info.absolute = true;
                } else if (s.RELATIVE_PATT.test(path)) {
                    info.relative = true;
                }
                if (match = path.match(s.EXTENSION_PATT)) {
                    info.extension = match[1].toLowerCase();
                }
                return info;
            };
            s.formatQueryString = function(data, query) {
                if (data == null) {
                    throw new Error('You must specify data.');
                }
                var params = [];
                for (var n in data) {
                    params.push(n + '=' + escape(data[n]));
                }
                if (query) {
                    params = params.concat(query);
                }
                return params.join('&');
            };
            s.buildPath = function(src, data) {
                if (data == null) {
                    return src;
                }
                var query = [];
                var idx = src.indexOf('?');
                if (idx != -1) {
                    var q = src.slice(idx + 1);
                    query = query.concat(q.split('&'));
                }
                if (idx != -1) {
                    return src.slice(0, idx) + '?' + this.formatQueryString(data, query);
                } else {
                    return src + '?' + this.formatQueryString(data, query);
                }
            };
            s.isCrossDomain = function(item) {
                var target = document.createElement("a");
                target.href = item.src;
                var host = document.createElement("a");
                host.href = location.href;
                var crossdomain = (target.hostname != "") && (target.port != host.port || target.protocol != host.protocol || target.hostname != host.hostname);
                return crossdomain;
            };
            s.isLocal = function(item) {
                var target = document.createElement("a");
                target.href = item.src;
                return target.hostname == "" && target.protocol == "file:";
            };
            s.isBinary = function(type) {
                switch (type) {
                    case createjs.AbstractLoader.IMAGE:
                    case createjs.AbstractLoader.BINARY:
                        return true;
                    default:
                        return false;
                }
            };
            s.isImageTag = function(item) {
                return item instanceof HTMLImageElement;
            };
            s.isAudioTag = function(item) {
                if (window.HTMLAudioElement) {
                    return item instanceof HTMLAudioElement;
                } else {
                    return false;
                }
            };
            s.isVideoTag = function(item) {
                if (window.HTMLVideoElement) {
                    return item instanceof HTMLVideoElement;
                } else {
                    return false;
                }
            };
            s.isText = function(type) {
                switch (type) {
                    case createjs.AbstractLoader.TEXT:
                    case createjs.AbstractLoader.JSON:
                    case createjs.AbstractLoader.MANIFEST:
                    case createjs.AbstractLoader.XML:
                    case createjs.AbstractLoader.CSS:
                    case createjs.AbstractLoader.SVG:
                    case createjs.AbstractLoader.JAVASCRIPT:
                    case createjs.AbstractLoader.SPRITESHEET:
                        return true;
                    default:
                        return false;
                }
            };
            s.getTypeByExtension = function(extension) {
                if (extension == null) {
                    return createjs.AbstractLoader.TEXT;
                }
                switch (extension.toLowerCase()) {
                    case "jpeg":
                    case "jpg":
                    case "gif":
                    case "png":
                    case "webp":
                    case "bmp":
                        return createjs.AbstractLoader.IMAGE;
                    case "ogg":
                    case "mp3":
                    case "webm":
                        return createjs.AbstractLoader.SOUND;
                    case "mp4":
                    case "webm":
                    case "ts":
                        return createjs.AbstractLoader.VIDEO;
                    case "json":
                        return createjs.AbstractLoader.JSON;
                    case "xml":
                        return createjs.AbstractLoader.XML;
                    case "css":
                        return createjs.AbstractLoader.CSS;
                    case "js":
                        return createjs.AbstractLoader.JAVASCRIPT;
                    case 'svg':
                        return createjs.AbstractLoader.SVG;
                    default:
                        return createjs.AbstractLoader.TEXT;
                }
            };
            createjs.RequestUtils = s;
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function AbstractLoader(loadItem, preferXHR, type) {
                this.EventDispatcher_constructor();
                this.loaded = false;
                this.canceled = false;
                this.progress = 0;
                this.type = type;
                this.resultFormatter = null;
                if (loadItem) {
                    this._item = createjs.LoadItem.create(loadItem);
                } else {
                    this._item = null;
                }
                this._preferXHR = preferXHR;
                this._result = null;
                this._rawResult = null;
                this._loadedItems = null;
                this._tagSrcAttribute = null;
                this._tag = null;
            };
            var p = createjs.extend(AbstractLoader, createjs.EventDispatcher);
            var s = AbstractLoader;
            s.POST = "POST";
            s.GET = "GET";
            s.BINARY = "binary";
            s.CSS = "css";
            s.IMAGE = "image";
            s.JAVASCRIPT = "javascript";
            s.JSON = "json";
            s.JSONP = "jsonp";
            s.MANIFEST = "manifest";
            s.SOUND = "sound";
            s.VIDEO = "video";
            s.SPRITESHEET = "spritesheet";
            s.SVG = "svg";
            s.TEXT = "text";
            s.XML = "xml";
            p.getItem = function() {
                return this._item;
            };
            p.getResult = function(raw) {
                return raw ? this._rawResult : this._result;
            };
            p.getTag = function() {
                return this._tag;
            };
            p.setTag = function(tag) {
                this._tag = tag;
            };
            p.load = function() {
                this._createRequest();
                this._request.on("complete", this, this);
                this._request.on("progress", this, this);
                this._request.on("loadStart", this, this);
                this._request.on("abort", this, this);
                this._request.on("timeout", this, this);
                this._request.on("error", this, this);
                var evt = new createjs.Event("initialize");
                evt.loader = this._request;
                this.dispatchEvent(evt);
                this._request.load();
            };
            p.cancel = function() {
                this.canceled = true;
                this.destroy();
            };
            p.destroy = function() {
                if (this._request) {
                    this._request.removeAllEventListeners();
                    this._request.destroy();
                }
                this._request = null;
                this._item = null;
                this._rawResult = null;
                this._result = null;
                this._loadItems = null;
                this.removeAllEventListeners();
            };
            p.getLoadedItems = function() {
                return this._loadedItems;
            };
            p._createRequest = function() {
                if (!this._preferXHR) {
                    this._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
                } else {
                    this._request = new createjs.XHRRequest(this._item);
                }
            };
            p._createTag = function(src) {
                return null;
            };
            p._sendLoadStart = function() {
                if (this._isCanceled()) {
                    return;
                }
                this.dispatchEvent("loadstart");
            };
            p._sendProgress = function(value) {
                if (this._isCanceled()) {
                    return;
                }
                var event = null;
                if (typeof(value) == "number") {
                    this.progress = value;
                    event = new createjs.ProgressEvent(this.progress);
                } else {
                    event = value;
                    this.progress = value.loaded / value.total;
                    event.progress = this.progress;
                    if (isNaN(this.progress) || this.progress == Infinity) {
                        this.progress = 0;
                    }
                }
                this.hasEventListener("progress") && this.dispatchEvent(event);
            };
            p._sendComplete = function() {
                if (this._isCanceled()) {
                    return;
                }
                this.loaded = true;
                var event = new createjs.Event("complete");
                event.rawResult = this._rawResult;
                if (this._result != null) {
                    event.result = this._result;
                }
                this.dispatchEvent(event);
            };
            p._sendError = function(event) {
                if (this._isCanceled() || !this.hasEventListener("error")) {
                    return;
                }
                if (event == null) {
                    event = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY");
                }
                this.dispatchEvent(event);
            };
            p._isCanceled = function() {
                if (window.createjs == null || this.canceled) {
                    return true;
                }
                return false;
            };
            p.resultFormatter = null;
            p.handleEvent = function(event) {
                switch (event.type) {
                    case "complete":
                        this._rawResult = event.target._response;
                        var result = this.resultFormatter && this.resultFormatter(this);
                        if (result instanceof Function) {
                            result.call(this, createjs.proxy(this._resultFormatSuccess, this), createjs.proxy(this._resultFormatFailed, this));
                        } else {
                            this._result = result || this._rawResult;
                            this._sendComplete();
                        }
                        break;
                    case "progress":
                        this._sendProgress(event);
                        break;
                    case "error":
                        this._sendError(event);
                        break;
                    case "loadstart":
                        this._sendLoadStart();
                        break;
                    case "abort":
                    case "timeout":
                        if (!this._isCanceled()) {
                            this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_" + event.type.toUpperCase() + "_ERROR"));
                        }
                        break;
                }
            };
            p._resultFormatSuccess = function(result) {
                this._result = result;
                this._sendComplete();
            };
            p._resultFormatFailed = function(event) {
                this._sendError(event);
            };
            p.buildPath = function(src, data) {
                return createjs.RequestUtils.buildPath(src, data);
            };
            p.toString = function() {
                return "[PreloadJS AbstractLoader]";
            };
            createjs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function AbstractMediaLoader(loadItem, preferXHR, type) {
                this.AbstractLoader_constructor(loadItem, preferXHR, type);
                this.resultFormatter = this._formatResult;
                this._tagSrcAttribute = "src";
                this.on("initialize", this._updateXHR, this);
            };
            var p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);
            p.load = function() {
                if (!this._tag) {
                    this._tag = this._createTag(this._item.src);
                }
                this._tag.preload = "auto";
                this._tag.load();
                this.AbstractLoader_load();
            };
            p._createTag = function() {};
            p._createRequest = function() {
                if (!this._preferXHR) {
                    this._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
                } else {
                    this._request = new createjs.XHRRequest(this._item);
                }
            };
            p._updateXHR = function(event) {
                if (event.loader.setResponseType) {
                    event.loader.setResponseType("blob");
                }
            };
            p._formatResult = function(loader) {
                this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
                this._tag.onstalled = null;
                if (this._preferXHR) {
                    var URL = window.URL || window.webkitURL;
                    var result = loader.getResult(true);
                    loader.getTag().src = URL.createObjectURL(result);
                }
                return loader.getTag();
            };
            createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";
            var AbstractRequest = function(item) {
                this._item = item;
            };
            var p = createjs.extend(AbstractRequest, createjs.EventDispatcher);
            p.load = function() {};
            p.destroy = function() {};
            p.cancel = function() {};
            createjs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function TagRequest(loadItem, tag, srcAttribute) {
                this.AbstractRequest_constructor(loadItem);
                this._tag = tag;
                this._tagSrcAttribute = srcAttribute;
                this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
                this._addedToDOM = false;
                this._startTagVisibility = null;
            };
            var p = createjs.extend(TagRequest, createjs.AbstractRequest);
            p.load = function() {
                this._tag.onload = createjs.proxy(this._handleTagComplete, this);
                this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
                this._tag.onerror = createjs.proxy(this._handleError, this);
                var evt = new createjs.Event("initialize");
                evt.loader = this._tag;
                this.dispatchEvent(evt);
                this._hideTag();
                this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);
                this._tag[this._tagSrcAttribute] = this._item.src;
                if (this._tag.parentNode == null) {
                    window.document.body.appendChild(this._tag);
                    this._addedToDOM = true;
                }
            };
            p.destroy = function() {
                this._clean();
                this._tag = null;
                this.AbstractRequest_destroy();
            };
            p._handleReadyStateChange = function() {
                clearTimeout(this._loadTimeout);
                var tag = this._tag;
                if (tag.readyState == "loaded" || tag.readyState == "complete") {
                    this._handleTagComplete();
                }
            };
            p._handleError = function() {
                this._clean();
                this.dispatchEvent("error");
            };
            p._handleTagComplete = function() {
                this._rawResult = this._tag;
                this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;
                this._clean();
                this._showTag();
                this.dispatchEvent("complete");
            };
            p._handleTimeout = function() {
                this._clean();
                this.dispatchEvent(new createjs.Event("timeout"));
            };
            p._clean = function() {
                this._tag.onload = null;
                this._tag.onreadystatechange = null;
                this._tag.onerror = null;
                if (this._addedToDOM && this._tag.parentNode != null) {
                    this._tag.parentNode.removeChild(this._tag);
                }
                clearTimeout(this._loadTimeout);
            };
            p._hideTag = function() {
                this._startTagVisibility = this._tag.style.visibility;
                this._tag.style.visibility = "hidden";
            };
            p._showTag = function() {
                this._tag.style.visibility = this._startTagVisibility;
            };
            p._handleStalled = function() {};
            createjs.TagRequest = createjs.promote(TagRequest, "AbstractRequest");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function MediaTagRequest(loadItem, tag, srcAttribute) {
                this.AbstractRequest_constructor(loadItem);
                this._tag = tag;
                this._tagSrcAttribute = srcAttribute;
                this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
            };
            var p = createjs.extend(MediaTagRequest, createjs.TagRequest);
            var s = MediaTagRequest;
            p.load = function() {
                var sc = createjs.proxy(this._handleStalled, this);
                this._stalledCallback = sc;
                var pc = createjs.proxy(this._handleProgress, this);
                this._handleProgress = pc;
                this._tag.addEventListener("stalled", sc);
                this._tag.addEventListener("progress", pc);
                this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, false);
                this.TagRequest_load();
            };
            p._handleReadyStateChange = function() {
                clearTimeout(this._loadTimeout);
                var tag = this._tag;
                if (tag.readyState == "loaded" || tag.readyState == "complete") {
                    this._handleTagComplete();
                }
            };
            p._handleStalled = function() {};
            p._handleProgress = function(event) {
                if (!event || event.loaded > 0 && event.total == 0) {
                    return;
                }
                var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
                this.dispatchEvent(newEvent);
            };
            p._clean = function() {
                this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
                this._tag.removeEventListener("stalled", this._stalledCallback);
                this._tag.removeEventListener("progress", this._progressCallback);
                this.TagRequest__clean();
            };
            createjs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function XHRRequest(item) {
                this.AbstractRequest_constructor(item);
                this._request = null;
                this._loadTimeout = null;
                this._xhrLevel = 1;
                this._response = null;
                this._rawResponse = null;
                this._canceled = false;
                this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);
                this._handleProgressProxy = createjs.proxy(this._handleProgress, this);
                this._handleAbortProxy = createjs.proxy(this._handleAbort, this);
                this._handleErrorProxy = createjs.proxy(this._handleError, this);
                this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);
                this._handleLoadProxy = createjs.proxy(this._handleLoad, this);
                this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);
                if (!this._createXHR(item)) {}
            };
            var p = createjs.extend(XHRRequest, createjs.AbstractRequest);
            XHRRequest.ACTIVEX_VERSIONS = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.5.0", "Msxml2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"];
            p.getResult = function(raw) {
                if (raw && this._rawResponse) {
                    return this._rawResponse;
                }
                return this._response;
            };
            p.cancel = function() {
                this.canceled = true;
                this._clean();
                this._request.abort();
            };
            p.load = function() {
                if (this._request == null) {
                    this._handleError();
                    return;
                }
                if (this._request.addEventListener != null) {
                    this._request.addEventListener("loadstart", this._handleLoadStartProxy, false);
                    this._request.addEventListener("progress", this._handleProgressProxy, false);
                    this._request.addEventListener("abort", this._handleAbortProxy, false);
                    this._request.addEventListener("error", this._handleErrorProxy, false);
                    this._request.addEventListener("timeout", this._handleTimeoutProxy, false);
                    this._request.addEventListener("load", this._handleLoadProxy, false);
                    this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, false);
                } else {
                    this._request.onloadstart = this._handleLoadStartProxy;
                    this._request.onprogress = this._handleProgressProxy;
                    this._request.onabort = this._handleAbortProxy;
                    this._request.onerror = this._handleErrorProxy;
                    this._request.ontimeout = this._handleTimeoutProxy;
                    this._request.onload = this._handleLoadProxy;
                    this._request.onreadystatechange = this._handleReadyStateChangeProxy;
                }
                if (this._xhrLevel == 1) {
                    this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);
                }
                try {
                    if (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {
                        this._request.send();
                    } else if (this._item.method == createjs.AbstractLoader.POST) {
                        this._request.send(createjs.RequestUtils.formatQueryString(this._item.values));
                    }
                } catch (error) {
                    this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, error));
                }
            };
            p.setResponseType = function(type) {
                if (type === 'blob') {
                    type = window.URL ? 'blob' : 'arraybuffer';
                    this._responseType = type;
                }
                this._request.responseType = type;
            };
            p.getAllResponseHeaders = function() {
                if (this._request.getAllResponseHeaders instanceof Function) {
                    return this._request.getAllResponseHeaders();
                } else {
                    return null;
                }
            };
            p.getResponseHeader = function(header) {
                if (this._request.getResponseHeader instanceof Function) {
                    return this._request.getResponseHeader(header);
                } else {
                    return null;
                }
            };
            p._handleProgress = function(event) {
                if (!event || event.loaded > 0 && event.total == 0) {
                    return;
                }
                var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
                this.dispatchEvent(newEvent);
            };
            p._handleLoadStart = function(event) {
                clearTimeout(this._loadTimeout);
                this.dispatchEvent("loadstart");
            };
            p._handleAbort = function(event) {
                this._clean();
                this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, event));
            };
            p._handleError = function(event) {
                this._clean();
                this.dispatchEvent(new createjs.ErrorEvent(event.message));
            };
            p._handleReadyStateChange = function(event) {
                if (this._request.readyState == 4) {
                    this._handleLoad();
                }
            };
            p._handleLoad = function(event) {
                if (this.loaded) {
                    return;
                }
                this.loaded = true;
                var error = this._checkError();
                if (error) {
                    this._handleError(error);
                    return;
                }
                this._response = this._getResponse();
                if (this._responseType === 'arraybuffer') {
                    try {
                        this._response = new Blob([this._response]);
                    } catch (e) {
                        window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                        if (e.name === 'TypeError' && window.BlobBuilder) {
                            var builder = new BlobBuilder();
                            builder.append(this._response);
                            this._response = builder.getBlob();
                        }
                    }
                }
                this._clean();
                this.dispatchEvent(new createjs.Event("complete"));
            };
            p._handleTimeout = function(event) {
                this._clean();
                this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, event));
            };
            p._checkError = function() {
                var status = parseInt(this._request.status);
                switch (status) {
                    case 404:
                    case 0:
                        return new Error(status);
                }
                return null;
            };
            p._getResponse = function() {
                if (this._response != null) {
                    return this._response;
                }
                if (this._request.response != null) {
                    return this._request.response;
                }
                try {
                    if (this._request.responseText != null) {
                        return this._request.responseText;
                    }
                } catch (e) {}
                try {
                    if (this._request.responseXML != null) {
                        return this._request.responseXML;
                    }
                } catch (e) {}
                return null;
            };
            p._createXHR = function(item) {
                var crossdomain = createjs.RequestUtils.isCrossDomain(item);
                var headers = {};
                var req = null;
                if (window.XMLHttpRequest) {
                    req = new XMLHttpRequest();
                    if (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {
                        req = new XDomainRequest();
                    }
                } else {
                    for (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {
                        var axVersion = s.ACTIVEX_VERSIONS[i];
                        try {
                            req = new ActiveXObject(axVersion);
                            break;
                        } catch (e) {}
                    }
                    if (req == null) {
                        return false;
                    }
                }
                if (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {
                    item.mimeType = "text/plain; charset=utf-8";
                }
                if (item.mimeType && req.overrideMimeType) {
                    req.overrideMimeType(item.mimeType);
                }
                this._xhrLevel = (typeof req.responseType === "string") ? 2 : 1;
                var src = null;
                if (item.method == createjs.AbstractLoader.GET) {
                    src = createjs.RequestUtils.buildPath(item.src, item.values);
                } else {
                    src = item.src;
                }
                req.open(item.method || createjs.AbstractLoader.GET, src, true);
                if (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {
                    headers["Origin"] = location.origin;
                }
                if (item.values && item.method == createjs.AbstractLoader.POST) {
                    headers["Content-Type"] = "application/x-www-form-urlencoded";
                }
                if (!crossdomain && !headers["X-Requested-With"]) {
                    headers["X-Requested-With"] = "XMLHttpRequest";
                }
                if (item.headers) {
                    for (var n in item.headers) {
                        headers[n] = item.headers[n];
                    }
                }
                for (n in headers) {
                    req.setRequestHeader(n, headers[n])
                }
                if (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {
                    req.withCredentials = item.withCredentials;
                }
                this._request = req;
                return true;
            };
            p._clean = function() {
                clearTimeout(this._loadTimeout);
                if (this._request.removeEventListener != null) {
                    this._request.removeEventListener("loadstart", this._handleLoadStartProxy);
                    this._request.removeEventListener("progress", this._handleProgressProxy);
                    this._request.removeEventListener("abort", this._handleAbortProxy);
                    this._request.removeEventListener("error", this._handleErrorProxy);
                    this._request.removeEventListener("timeout", this._handleTimeoutProxy);
                    this._request.removeEventListener("load", this._handleLoadProxy);
                    this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);
                } else {
                    this._request.onloadstart = null;
                    this._request.onprogress = null;
                    this._request.onabort = null;
                    this._request.onerror = null;
                    this._request.ontimeout = null;
                    this._request.onload = null;
                    this._request.onreadystatechange = null;
                }
            };
            p.toString = function() {
                return "[PreloadJS XHRRequest]";
            };
            createjs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function LoadQueue(preferXHR, basePath, crossOrigin) {
                this.AbstractLoader_constructor();
                this._plugins = [];
                this._typeCallbacks = {};
                this._extensionCallbacks = {};
                this.next = null;
                this.maintainScriptOrder = true;
                this.stopOnError = false;
                this._maxConnections = 1;
                this._availableLoaders = [createjs.ImageLoader, createjs.JavaScriptLoader, createjs.CSSLoader, createjs.JSONLoader, createjs.JSONPLoader, createjs.SoundLoader, createjs.ManifestLoader, createjs.SpriteSheetLoader, createjs.XMLLoader, createjs.SVGLoader, createjs.BinaryLoader, createjs.VideoLoader, createjs.TextLoader];
                this._defaultLoaderLength = this._availableLoaders.length;
                this.init(preferXHR, basePath, crossOrigin);
            }
            var p = createjs.extend(LoadQueue, createjs.AbstractLoader);
            var s = LoadQueue;
            p.init = function(preferXHR, basePath, crossOrigin) {
                this.useXHR = true;
                this.preferXHR = true;
                this._preferXHR = true;
                this.setPreferXHR(preferXHR);
                this._paused = false;
                this._basePath = basePath;
                this._crossOrigin = crossOrigin;
                this._loadStartWasDispatched = false;
                this._currentlyLoadingScript = null;
                this._currentLoads = [];
                this._loadQueue = [];
                this._loadQueueBackup = [];
                this._loadItemsById = {};
                this._loadItemsBySrc = {};
                this._loadedResults = {};
                this._loadedRawResults = {};
                this._numItems = 0;
                this._numItemsLoaded = 0;
                this._scriptOrder = [];
                this._loadedScripts = [];
                this._lastProgress = NaN;
            };
            s.loadTimeout = 8000;
            s.LOAD_TIMEOUT = 0;
            s.BINARY = createjs.AbstractLoader.BINARY;
            s.CSS = createjs.AbstractLoader.CSS;
            s.IMAGE = createjs.AbstractLoader.IMAGE;
            s.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT;
            s.JSON = createjs.AbstractLoader.JSON;
            s.JSONP = createjs.AbstractLoader.JSONP;
            s.MANIFEST = createjs.AbstractLoader.MANIFEST;
            s.SOUND = createjs.AbstractLoader.SOUND;
            s.VIDEO = createjs.AbstractLoader.VIDEO;
            s.SVG = createjs.AbstractLoader.SVG;
            s.TEXT = createjs.AbstractLoader.TEXT;
            s.XML = createjs.AbstractLoader.XML;
            s.POST = createjs.AbstractLoader.POST;
            s.GET = createjs.AbstractLoader.GET;
            p.registerLoader = function(loader) {
                if (!loader || !loader.canLoadItem) {
                    throw new Error("loader is of an incorrect type.");
                } else if (this._availableLoaders.indexOf(loader) != -1) {
                    throw new Error("loader already exists.");
                }
                this._availableLoaders.unshift(loader);
            };
            p.unregisterLoader = function(loader) {
                var idx = this._availableLoaders.indexOf(loader);
                if (idx != -1 && idx < this._defaultLoaderLength - 1) {
                    this._availableLoaders.splice(idx, 1);
                }
            };
            p.setUseXHR = function(value) {
                return this.setPreferXHR(value);
            };
            p.setPreferXHR = function(value) {
                this.preferXHR = (value != false && window.XMLHttpRequest != null);
                return this.preferXHR;
            };
            p.removeAll = function() {
                this.remove();
            };
            p.remove = function(idsOrUrls) {
                var args = null;
                if (idsOrUrls && !Array.isArray(idsOrUrls)) {
                    args = [idsOrUrls];
                } else if (idsOrUrls) {
                    args = idsOrUrls;
                } else if (arguments.length > 0) {
                    return;
                }
                var itemsWereRemoved = false;
                if (!args) {
                    this.close();
                    for (var n in this._loadItemsById) {
                        this._disposeItem(this._loadItemsById[n]);
                    }
                    this.init(this.preferXHR, this._basePath);
                } else {
                    while (args.length) {
                        var item = args.pop();
                        var r = this.getResult(item);
                        for (i = this._loadQueue.length - 1; i >= 0; i--) {
                            loadItem = this._loadQueue[i].getItem();
                            if (loadItem.id == item || loadItem.src == item) {
                                this._loadQueue.splice(i, 1)[0].cancel();
                                break;
                            }
                        }
                        for (i = this._loadQueueBackup.length - 1; i >= 0; i--) {
                            loadItem = this._loadQueueBackup[i].getItem();
                            if (loadItem.id == item || loadItem.src == item) {
                                this._loadQueueBackup.splice(i, 1)[0].cancel();
                                break;
                            }
                        }
                        if (r) {
                            this._disposeItem(this.getItem(item));
                        } else {
                            for (var i = this._currentLoads.length - 1; i >= 0; i--) {
                                var loadItem = this._currentLoads[i].getItem();
                                if (loadItem.id == item || loadItem.src == item) {
                                    this._currentLoads.splice(i, 1)[0].cancel();
                                    itemsWereRemoved = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (itemsWereRemoved) {
                        this._loadNext();
                    }
                }
            };
            p.reset = function() {
                this.close();
                for (var n in this._loadItemsById) {
                    this._disposeItem(this._loadItemsById[n]);
                }
                var a = [];
                for (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {
                    a.push(this._loadQueueBackup[i].getItem());
                }
                this.loadManifest(a, false);
            };
            p.installPlugin = function(plugin) {
                if (plugin == null) {
                    return;
                }
                if (plugin.getPreloadHandlers != null) {
                    this._plugins.push(plugin);
                    var map = plugin.getPreloadHandlers();
                    map.scope = plugin;
                    if (map.types != null) {
                        for (var i = 0, l = map.types.length; i < l; i++) {
                            this._typeCallbacks[map.types[i]] = map;
                        }
                    }
                    if (map.extensions != null) {
                        for (i = 0, l = map.extensions.length; i < l; i++) {
                            this._extensionCallbacks[map.extensions[i]] = map;
                        }
                    }
                }
            };
            p.setMaxConnections = function(value) {
                this._maxConnections = value;
                if (!this._paused && this._loadQueue.length > 0) {
                    this._loadNext();
                }
            };
            p.loadFile = function(file, loadNow, basePath) {
                if (file == null) {
                    var event = new createjs.ErrorEvent("PRELOAD_NO_FILE");
                    this._sendError(event);
                    return;
                }
                this._addItem(file, null, basePath);
                if (loadNow !== false) {
                    this.setPaused(false);
                } else {
                    this.setPaused(true);
                }
            };
            p.loadManifest = function(manifest, loadNow, basePath) {
                var fileList = null;
                var path = null;
                if (Array.isArray(manifest)) {
                    if (manifest.length == 0) {
                        var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_EMPTY");
                        this._sendError(event);
                        return;
                    }
                    fileList = manifest;
                } else if (typeof(manifest) === "string") {
                    fileList = [{
                        src: manifest,
                        type: s.MANIFEST
                    }];
                } else if (typeof(manifest) == "object") {
                    if (manifest.src !== undefined) {
                        if (manifest.type == null) {
                            manifest.type = s.MANIFEST;
                        } else if (manifest.type != s.MANIFEST) {
                            var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_TYPE");
                            this._sendError(event);
                        }
                        fileList = [manifest];
                    } else if (manifest.manifest !== undefined) {
                        fileList = manifest.manifest;
                        path = manifest.path;
                    }
                } else {
                    var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_NULL");
                    this._sendError(event);
                    return;
                }
                for (var i = 0, l = fileList.length; i < l; i++) {
                    this._addItem(fileList[i], path, basePath);
                }
                if (loadNow !== false) {
                    this.setPaused(false);
                } else {
                    this.setPaused(true);
                }
            };
            p.load = function() {
                this.setPaused(false);
            };
            p.getItem = function(value) {
                return this._loadItemsById[value] || this._loadItemsBySrc[value];
            };
            p.getResult = function(value, rawResult) {
                var item = this._loadItemsById[value] || this._loadItemsBySrc[value];
                if (item == null) {
                    return null;
                }
                var id = item.id;
                if (rawResult && this._loadedRawResults[id]) {
                    return this._loadedRawResults[id];
                }
                return this._loadedResults[id];
            };
            p.getItems = function(loaded) {
                var arr = [];
                for (var n in this._loadItemsById) {
                    var item = this._loadItemsById[n];
                    var result = this.getResult(n);
                    if (loaded === true && result == null) {
                        continue;
                    }
                    arr.push({
                        item: item,
                        result: result,
                        rawResult: this.getResult(n, true)
                    });
                }
                return arr;
            };
            p.setPaused = function(value) {
                this._paused = value;
                if (!this._paused) {
                    this._loadNext();
                }
            };
            p.close = function() {
                while (this._currentLoads.length) {
                    this._currentLoads.pop().cancel();
                }
                this._scriptOrder.length = 0;
                this._loadedScripts.length = 0;
                this.loadStartWasDispatched = false;
                this._itemCount = 0;
                this._lastProgress = NaN;
            };
            p._addItem = function(value, path, basePath) {
                var item = this._createLoadItem(value, path, basePath);
                if (item == null) {
                    return;
                }
                var loader = this._createLoader(item);
                if (loader != null) {
                    if ("plugins" in loader) {
                        loader.plugins = this._plugins;
                    }
                    item._loader = loader;
                    this._loadQueue.push(loader);
                    this._loadQueueBackup.push(loader);
                    this._numItems++;
                    this._updateProgress();
                    if ((this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) || item.maintainOrder === true) {
                        this._scriptOrder.push(item);
                        this._loadedScripts.push(null);
                    }
                }
            };
            p._createLoadItem = function(value, path, basePath) {
                var item = createjs.LoadItem.create(value);
                if (item == null) {
                    return null;
                }
                var bp = "";
                var useBasePath = basePath || this._basePath;
                if (item.src instanceof Object) {
                    if (!item.type) {
                        return null;
                    }
                    if (path) {
                        bp = path;
                        var pathMatch = createjs.RequestUtils.parseURI(path);
                        if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
                            bp = useBasePath + bp;
                        }
                    } else if (useBasePath != null) {
                        bp = useBasePath;
                    }
                } else {
                    var match = createjs.RequestUtils.parseURI(item.src);
                    if (match.extension) {
                        item.ext = match.extension;
                    }
                    if (item.type == null) {
                        item.type = createjs.RequestUtils.getTypeByExtension(item.ext);
                    }
                    var autoId = item.src;
                    if (!match.absolute && !match.relative) {
                        if (path) {
                            bp = path;
                            var pathMatch = createjs.RequestUtils.parseURI(path);
                            autoId = path + autoId;
                            if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
                                bp = useBasePath + bp;
                            }
                        } else if (useBasePath != null) {
                            bp = useBasePath;
                        }
                    }
                    item.src = bp + item.src;
                }
                item.path = bp;
                if (item.id === undefined || item.id === null || item.id === "") {
                    item.id = autoId;
                }
                var customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];
                if (customHandler) {
                    var result = customHandler.callback.call(customHandler.scope, item, this);
                    if (result === false) {
                        return null;
                    } else if (result === true) {} else if (result != null) {
                        item._loader = result;
                    }
                    match = createjs.RequestUtils.parseURI(item.src);
                    if (match.extension != null) {
                        item.ext = match.extension;
                    }
                }
                this._loadItemsById[item.id] = item;
                this._loadItemsBySrc[item.src] = item;
                if (item.crossOrigin == null) {
                    item.crossOrigin = this._crossOrigin;
                }
                return item;
            };
            p._createLoader = function(item) {
                if (item._loader != null) {
                    return item._loader;
                }
                var preferXHR = this.preferXHR;
                for (var i = 0; i < this._availableLoaders.length; i++) {
                    var loader = this._availableLoaders[i];
                    if (loader && loader.canLoadItem(item)) {
                        return new loader(item, preferXHR);
                    }
                }
                return null;
            };
            p._loadNext = function() {
                if (this._paused) {
                    return;
                }
                if (!this._loadStartWasDispatched) {
                    this._sendLoadStart();
                    this._loadStartWasDispatched = true;
                }
                if (this._numItems == this._numItemsLoaded) {
                    this.loaded = true;
                    this._sendComplete();
                    if (this.next && this.next.load) {
                        this.next.load();
                    }
                } else {
                    this.loaded = false;
                }
                for (var i = 0; i < this._loadQueue.length; i++) {
                    if (this._currentLoads.length >= this._maxConnections) {
                        break;
                    }
                    var loader = this._loadQueue[i];
                    if (!this._canStartLoad(loader)) {
                        continue;
                    }
                    this._loadQueue.splice(i, 1);
                    i--;
                    this._loadItem(loader);
                }
            };
            p._loadItem = function(loader) {
                loader.on("fileload", this._handleFileLoad, this);
                loader.on("progress", this._handleProgress, this);
                loader.on("complete", this._handleFileComplete, this);
                loader.on("error", this._handleError, this);
                loader.on("fileerror", this._handleFileError, this);
                this._currentLoads.push(loader);
                this._sendFileStart(loader.getItem());
                loader.load();
            };
            p._handleFileLoad = function(event) {
                event.target = null;
                this.dispatchEvent(event);
            };
            p._handleFileError = function(event) {
                var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, event.item);
                this._sendError(newEvent);
            };
            p._handleError = function(event) {
                var loader = event.target;
                this._numItemsLoaded++;
                this._finishOrderedItem(loader, true);
                this._updateProgress();
                var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, loader.getItem());
                this._sendError(newEvent);
                if (!this.stopOnError) {
                    this._removeLoadItem(loader);
                    this._cleanLoadItem(loader);
                    this._loadNext();
                } else {
                    this.setPaused(true);
                }
            };
            p._handleFileComplete = function(event) {
                var loader = event.target;
                var item = loader.getItem();
                var result = loader.getResult();
                this._loadedResults[item.id] = result;
                var rawResult = loader.getResult(true);
                if (rawResult != null && rawResult !== result) {
                    this._loadedRawResults[item.id] = rawResult;
                }
                this._saveLoadedItems(loader);
                this._removeLoadItem(loader);
                if (!this._finishOrderedItem(loader)) {
                    this._processFinishedLoad(item, loader);
                }
                this._cleanLoadItem(loader);
            };
            p._saveLoadedItems = function(loader) {
                var list = loader.getLoadedItems();
                if (list === null) {
                    return;
                }
                for (var i = 0; i < list.length; i++) {
                    var item = list[i].item;
                    this._loadItemsBySrc[item.src] = item;
                    this._loadItemsById[item.id] = item;
                    this._loadedResults[item.id] = list[i].result;
                    this._loadedRawResults[item.id] = list[i].rawResult;
                }
            };
            p._finishOrderedItem = function(loader, loadFailed) {
                var item = loader.getItem();
                if ((this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) || item.maintainOrder) {
                    if (loader instanceof createjs.JavaScriptLoader) {
                        this._currentlyLoadingScript = false;
                    }
                    var index = createjs.indexOf(this._scriptOrder, item);
                    if (index == -1) {
                        return false;
                    }
                    this._loadedScripts[index] = (loadFailed === true) ? true : item;
                    this._checkScriptLoadOrder();
                    return true;
                }
                return false;
            };
            p._checkScriptLoadOrder = function() {
                var l = this._loadedScripts.length;
                for (var i = 0; i < l; i++) {
                    var item = this._loadedScripts[i];
                    if (item === null) {
                        break;
                    }
                    if (item === true) {
                        continue;
                    }
                    var loadItem = this._loadedResults[item.id];
                    if (item.type == createjs.LoadQueue.JAVASCRIPT) {
                        createjs.DomUtils.appendToHead(loadItem);
                    }
                    var loader = item._loader;
                    this._processFinishedLoad(item, loader);
                    this._loadedScripts[i] = true;
                }
            };
            p._processFinishedLoad = function(item, loader) {
                this._numItemsLoaded++;
                if (!this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) {
                    var tag = loader.getTag();
                    createjs.DomUtils.appendToHead(tag);
                }
                this._updateProgress();
                this._sendFileComplete(item, loader);
                this._loadNext();
            };
            p._canStartLoad = function(loader) {
                if (!this.maintainScriptOrder || loader.preferXHR) {
                    return true;
                }
                var item = loader.getItem();
                if (item.type != createjs.LoadQueue.JAVASCRIPT) {
                    return true;
                }
                if (this._currentlyLoadingScript) {
                    return false;
                }
                var index = this._scriptOrder.indexOf(item);
                var i = 0;
                while (i < index) {
                    var checkItem = this._loadedScripts[i];
                    if (checkItem == null) {
                        return false;
                    }
                    i++;
                }
                this._currentlyLoadingScript = true;
                return true;
            };
            p._removeLoadItem = function(loader) {
                var l = this._currentLoads.length;
                for (var i = 0; i < l; i++) {
                    if (this._currentLoads[i] == loader) {
                        this._currentLoads.splice(i, 1);
                        break;
                    }
                }
            };
            p._cleanLoadItem = function(loader) {
                var item = loader.getItem();
                if (item) {
                    delete item._loader;
                }
            }
            p._handleProgress = function(event) {
                var loader = event.target;
                this._sendFileProgress(loader.getItem(), loader.progress);
                this._updateProgress();
            };
            p._updateProgress = function() {
                var loaded = this._numItemsLoaded / this._numItems;
                var remaining = this._numItems - this._numItemsLoaded;
                if (remaining > 0) {
                    var chunk = 0;
                    for (var i = 0, l = this._currentLoads.length; i < l; i++) {
                        chunk += this._currentLoads[i].progress;
                    }
                    loaded += (chunk / remaining) * (remaining / this._numItems);
                }
                if (this._lastProgress != loaded) {
                    this._sendProgress(loaded);
                    this._lastProgress = loaded;
                }
            };
            p._disposeItem = function(item) {
                delete this._loadedResults[item.id];
                delete this._loadedRawResults[item.id];
                delete this._loadItemsById[item.id];
                delete this._loadItemsBySrc[item.src];
            };
            p._sendFileProgress = function(item, progress) {
                if (this._isCanceled() || this._paused) {
                    return;
                }
                if (!this.hasEventListener("fileprogress")) {
                    return;
                }
                var event = new createjs.Event("fileprogress");
                event.progress = progress;
                event.loaded = progress;
                event.total = 1;
                event.item = item;
                this.dispatchEvent(event);
            };
            p._sendFileComplete = function(item, loader) {
                if (this._isCanceled() || this._paused) {
                    return;
                }
                var event = new createjs.Event("fileload");
                event.loader = loader;
                event.item = item;
                event.result = this._loadedResults[item.id];
                event.rawResult = this._loadedRawResults[item.id];
                if (item.completeHandler) {
                    item.completeHandler(event);
                }
                this.hasEventListener("fileload") && this.dispatchEvent(event);
            };
            p._sendFileStart = function(item) {
                var event = new createjs.Event("filestart");
                event.item = item;
                this.hasEventListener("filestart") && this.dispatchEvent(event);
            };
            p.toString = function() {
                return "[PreloadJS LoadQueue]";
            };
            createjs.LoadQueue = createjs.promote(LoadQueue, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function TextLoader(loadItem) {
                this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.TEXT);
            };
            var p = createjs.extend(TextLoader, createjs.AbstractLoader);
            var s = TextLoader;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.TEXT;
            };
            createjs.TextLoader = createjs.promote(TextLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function BinaryLoader(loadItem) {
                this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.BINARY);
                this.on("initialize", this._updateXHR, this);
            };
            var p = createjs.extend(BinaryLoader, createjs.AbstractLoader);
            var s = BinaryLoader;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.BINARY;
            };
            p._updateXHR = function(event) {
                event.loader.setResponseType("arraybuffer");
            };
            createjs.BinaryLoader = createjs.promote(BinaryLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function CSSLoader(loadItem, preferXHR) {
                this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.CSS);
                this.resultFormatter = this._formatResult;
                this._tagSrcAttribute = "href";
                if (preferXHR) {
                    this._tag = document.createElement("style");
                } else {
                    this._tag = document.createElement("link");
                }
                this._tag.rel = "stylesheet";
                this._tag.type = "text/css";
            };
            var p = createjs.extend(CSSLoader, createjs.AbstractLoader);
            var s = CSSLoader;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.CSS;
            };
            p._formatResult = function(loader) {
                if (this._preferXHR) {
                    var tag = loader.getTag();
                    if (tag.styleSheet) {
                        tag.styleSheet.cssText = loader.getResult(true);
                    } else {
                        var textNode = document.createTextNode(loader.getResult(true));
                        tag.appendChild(textNode);
                    }
                } else {
                    tag = this._tag;
                }
                createjs.DomUtils.appendToHead(tag);
                return tag;
            };
            createjs.CSSLoader = createjs.promote(CSSLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function ImageLoader(loadItem, preferXHR) {
                this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.IMAGE);
                this.resultFormatter = this._formatResult;
                this._tagSrcAttribute = "src";
                if (createjs.RequestUtils.isImageTag(loadItem)) {
                    this._tag = loadItem;
                } else if (createjs.RequestUtils.isImageTag(loadItem.src)) {
                    this._tag = loadItem.src;
                } else if (createjs.RequestUtils.isImageTag(loadItem.tag)) {
                    this._tag = loadItem.tag;
                }
                if (this._tag != null) {
                    this._preferXHR = false;
                } else {
                    this._tag = document.createElement("img");
                }
                this.on("initialize", this._updateXHR, this);
            };
            var p = createjs.extend(ImageLoader, createjs.AbstractLoader);
            var s = ImageLoader;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.IMAGE;
            };
            p.load = function() {
                if (this._tag.src != "" && this._tag.complete) {
                    this._sendComplete();
                    return;
                }
                var crossOrigin = this._item.crossOrigin;
                if (crossOrigin == true) {
                    crossOrigin = "Anonymous";
                }
                if (crossOrigin != null && !createjs.RequestUtils.isLocal(this._item.src)) {
                    this._tag.crossOrigin = crossOrigin;
                }
                this.AbstractLoader_load();
            };
            p._updateXHR = function(event) {
                event.loader.mimeType = 'text/plain; charset=x-user-defined-binary';
                if (event.loader.setResponseType) {
                    event.loader.setResponseType("blob");
                }
            };
            p._formatResult = function(loader) {
                return this._formatImage;
            };
            p._formatImage = function(successCallback, errorCallback) {
                var tag = this._tag;
                var URL = window.URL || window.webkitURL;
                if (!this._preferXHR) {} else if (URL) {
                    var objURL = URL.createObjectURL(this.getResult(true));
                    tag.src = objURL;
                    tag.addEventListener("load", this._cleanUpURL, false);
                    tag.addEventListener("error", this._cleanUpURL, false);
                } else {
                    tag.src = this._item.src;
                }
                if (tag.complete) {
                    successCallback(tag);
                } else {
                    tag.onload = createjs.proxy(function() {
                        successCallback(this._tag);
                    }, this);
                    tag.onerror = createjs.proxy(function() {
                        errorCallback(_this._tag);
                    }, this);
                }
            };
            p._cleanUpURL = function(event) {
                var URL = window.URL || window.webkitURL;
                URL.revokeObjectURL(event.target.src);
            };
            createjs.ImageLoader = createjs.promote(ImageLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function JavaScriptLoader(loadItem, preferXHR) {
                this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.JAVASCRIPT);
                this.resultFormatter = this._formatResult;
                this._tagSrcAttribute = "src";
                this.setTag(document.createElement("script"));
            };
            var p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);
            var s = JavaScriptLoader;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.JAVASCRIPT;
            };
            p._formatResult = function(loader) {
                var tag = loader.getTag();
                if (this._preferXHR) {
                    tag.text = loader.getResult(true);
                }
                return tag;
            };
            createjs.JavaScriptLoader = createjs.promote(JavaScriptLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function JSONLoader(loadItem) {
                this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.JSON);
                this.resultFormatter = this._formatResult;
            };
            var p = createjs.extend(JSONLoader, createjs.AbstractLoader);
            var s = JSONLoader;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.JSON;
            };
            p._formatResult = function(loader) {
                var json = null;
                try {
                    json = createjs.DataUtils.parseJSON(loader.getResult(true));
                } catch (e) {
                    var event = new createjs.ErrorEvent("JSON_FORMAT", null, e);
                    this._sendError(event);
                    return e;
                }
                return json;
            };
            createjs.JSONLoader = createjs.promote(JSONLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function JSONPLoader(loadItem) {
                this.AbstractLoader_constructor(loadItem, false, createjs.AbstractLoader.JSONP);
                this.setTag(document.createElement("script"));
                this.getTag().type = "text/javascript";
            };
            var p = createjs.extend(JSONPLoader, createjs.AbstractLoader);
            var s = JSONPLoader;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.JSONP;
            };
            p.cancel = function() {
                this.AbstractLoader_cancel();
                this._dispose();
            };
            p.load = function() {
                if (this._item.callback == null) {
                    throw new Error('callback is required for loading JSONP requests.');
                }
                if (window[this._item.callback] != null) {
                    throw new Error("JSONP callback '" +
                        this._item.callback +
                        "' already exists on window. You need to specify a different callback or re-name the current one.");
                }
                window[this._item.callback] = createjs.proxy(this._handleLoad, this);
                window.document.body.appendChild(this._tag);
                this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);
                this._tag.src = this._item.src;
            };
            p._handleLoad = function(data) {
                this._result = this._rawResult = data;
                this._sendComplete();
                this._dispose();
            };
            p._handleTimeout = function() {
                this._dispose();
                this.dispatchEvent(new createjs.ErrorEvent("timeout"));
            };
            p._dispose = function() {
                window.document.body.removeChild(this._tag);
                delete window[this._item.callback];
                clearTimeout(this._loadTimeout);
            };
            createjs.JSONPLoader = createjs.promote(JSONPLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function ManifestLoader(loadItem) {
                this.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.MANIFEST);
                this.plugins = null;
                this._manifestQueue = null;
            };
            var p = createjs.extend(ManifestLoader, createjs.AbstractLoader);
            var s = ManifestLoader;
            s.MANIFEST_PROGRESS = 0.25;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.MANIFEST;
            };
            p.load = function() {
                this.AbstractLoader_load();
            };
            p._createRequest = function() {
                var callback = this._item.callback;
                if (callback != null) {
                    this._request = new createjs.JSONPLoader(this._item);
                } else {
                    this._request = new createjs.JSONLoader(this._item);
                }
            };
            p.handleEvent = function(event) {
                switch (event.type) {
                    case "complete":
                        this._rawResult = event.target.getResult(true);
                        this._result = event.target.getResult();
                        this._sendProgress(s.MANIFEST_PROGRESS);
                        this._loadManifest(this._result);
                        return;
                    case "progress":
                        event.loaded *= s.MANIFEST_PROGRESS;
                        this.progress = event.loaded / event.total;
                        if (isNaN(this.progress) || this.progress == Infinity) {
                            this.progress = 0;
                        }
                        this._sendProgress(event);
                        return;
                }
                this.AbstractLoader_handleEvent(event);
            };
            p.destroy = function() {
                this.AbstractLoader_destroy();
                this._manifestQueue.close();
            };
            p._loadManifest = function(json) {
                if (json && json.manifest) {
                    var queue = this._manifestQueue = new createjs.LoadQueue();
                    queue.on("fileload", this._handleManifestFileLoad, this);
                    queue.on("progress", this._handleManifestProgress, this);
                    queue.on("complete", this._handleManifestComplete, this, true);
                    queue.on("error", this._handleManifestError, this, true);
                    for (var i = 0, l = this.plugins.length; i < l; i++) {
                        queue.installPlugin(this.plugins[i]);
                    }
                    queue.loadManifest(json);
                } else {
                    this._sendComplete();
                }
            };
            p._handleManifestFileLoad = function(event) {
                event.target = null;
                this.dispatchEvent(event);
            };
            p._handleManifestComplete = function(event) {
                this._loadedItems = this._manifestQueue.getItems(true);
                this._sendComplete();
            };
            p._handleManifestProgress = function(event) {
                this.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;
                this._sendProgress(this.progress);
            };
            p._handleManifestError = function(event) {
                var newEvent = new createjs.Event("fileerror");
                newEvent.item = event.data;
                this.dispatchEvent(newEvent);
            };
            createjs.ManifestLoader = createjs.promote(ManifestLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function SoundLoader(loadItem, preferXHR) {
                this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);
                if (createjs.RequestUtils.isAudioTag(loadItem)) {
                    this._tag = loadItem;
                } else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {
                    this._tag = loadItem;
                } else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {
                    this._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;
                }
                if (this._tag != null) {
                    this._preferXHR = false;
                }
            };
            var p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);
            var s = SoundLoader;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.SOUND;
            };
            p._createTag = function(src) {
                var tag = document.createElement("audio");
                tag.autoplay = false;
                tag.preload = "none";
                tag.src = src;
                return tag;
            };
            createjs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function VideoLoader(loadItem, preferXHR) {
                this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.VIDEO);
                if (createjs.RequestUtils.isVideoTag(loadItem) || createjs.RequestUtils.isVideoTag(loadItem.src)) {
                    this.setTag(createjs.RequestUtils.isVideoTag(loadItem) ? loadItem : loadItem.src);
                    this._preferXHR = false;
                } else {
                    this.setTag(this._createTag());
                }
            };
            var p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);
            var s = VideoLoader;
            p._createTag = function() {
                return document.createElement("video");
            };
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.VIDEO;
            };
            createjs.VideoLoader = createjs.promote(VideoLoader, "AbstractMediaLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function SpriteSheetLoader(loadItem, preferXHR) {
                this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SPRITESHEET);
                this._manifestQueue = null;
            }
            var p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);
            var s = SpriteSheetLoader;
            s.SPRITESHEET_PROGRESS = 0.25;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.SPRITESHEET;
            };
            p.destroy = function() {
                this.AbstractLoader_destroy;
                this._manifestQueue.close();
            };
            p._createRequest = function() {
                var callback = this._item.callback;
                if (callback != null) {
                    this._request = new createjs.JSONPLoader(this._item);
                } else {
                    this._request = new createjs.JSONLoader(this._item);
                }
            };
            p.handleEvent = function(event) {
                switch (event.type) {
                    case "complete":
                        this._rawResult = event.target.getResult(true);
                        this._result = event.target.getResult();
                        this._sendProgress(s.SPRITESHEET_PROGRESS);
                        this._loadManifest(this._result);
                        return;
                    case "progress":
                        event.loaded *= s.SPRITESHEET_PROGRESS;
                        this.progress = event.loaded / event.total;
                        if (isNaN(this.progress) || this.progress == Infinity) {
                            this.progress = 0;
                        }
                        this._sendProgress(event);
                        return;
                }
                this.AbstractLoader_handleEvent(event);
            };
            p._loadManifest = function(json) {
                if (json && json.images) {
                    var queue = this._manifestQueue = new createjs.LoadQueue(this._preferXHR, this._item.path, this._item.crossOrigin);
                    queue.on("complete", this._handleManifestComplete, this, true);
                    queue.on("fileload", this._handleManifestFileLoad, this);
                    queue.on("progress", this._handleManifestProgress, this);
                    queue.on("error", this._handleManifestError, this, true);
                    queue.loadManifest(json.images);
                }
            };
            p._handleManifestFileLoad = function(event) {
                var image = event.result;
                if (image != null) {
                    var images = this.getResult().images;
                    var pos = images.indexOf(event.item.src);
                    images[pos] = image;
                }
            };
            p._handleManifestComplete = function(event) {
                this._result = new createjs.SpriteSheet(this._result);
                this._loadedItems = this._manifestQueue.getItems(true);
                this._sendComplete();
            };
            p._handleManifestProgress = function(event) {
                this.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;
                this._sendProgress(this.progress);
            };
            p._handleManifestError = function(event) {
                var newEvent = new createjs.Event("fileerror");
                newEvent.item = event.data;
                this.dispatchEvent(newEvent);
            };
            createjs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function SVGLoader(loadItem, preferXHR) {
                this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SVG);
                this.resultFormatter = this._formatResult;
                this._tagSrcAttribute = "data";
                if (preferXHR) {
                    this.setTag(document.createElement("svg"));
                } else {
                    this.setTag(document.createElement("object"));
                    this.getTag().type = "image/svg+xml";
                }
            };
            var p = createjs.extend(SVGLoader, createjs.AbstractLoader);
            var s = SVGLoader;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.SVG;
            };
            p._formatResult = function(loader) {
                var xml = createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");
                var tag = loader.getTag();
                if (!this._preferXHR && document.body.contains(tag)) {
                    document.body.removeChild(tag);
                }
                if (xml.documentElement != null) {
                    tag.appendChild(xml.documentElement);
                    tag.style.visibility = "visible";
                    return tag;
                } else {
                    return xml;
                }
            };
            createjs.SVGLoader = createjs.promote(SVGLoader, "AbstractLoader");
        }());
        window.createjs = window.createjs || {};
        (function() {
            "use strict";

            function XMLLoader(loadItem) {
                this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.XML);
                this.resultFormatter = this._formatResult;
            };
            var p = createjs.extend(XMLLoader, createjs.AbstractLoader);
            var s = XMLLoader;
            s.canLoadItem = function(item) {
                return item.type == createjs.AbstractLoader.XML;
            };
            p._formatResult = function(loader) {
                return createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");
            };
            createjs.XMLLoader = createjs.promote(XMLLoader, "AbstractLoader");
        }());
    }.call(exports, __webpack_require__(23)(module), __webpack_require__(6)))
}), (function(module, exports) {
    (function(__webpack_amd_options__) {
        module.exports = __webpack_amd_options__;
    }.call(exports, {}))
}), (function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    (function() {
        function aa(a, b, c) {
            return a.call.apply(a.bind, arguments)
        }

        function ba(a, b, c) {
            if (!a) throw Error();
            if (2 < arguments.length) {
                var d = Array.prototype.slice.call(arguments, 2);
                return function() {
                    var c = Array.prototype.slice.call(arguments);
                    Array.prototype.unshift.apply(c, d);
                    return a.apply(b, c)
                }
            }
            return function() {
                return a.apply(b, arguments)
            }
        }

        function p(a, b, c) {
            p = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? aa : ba;
            return p.apply(null, arguments)
        }
        var q = Date.now || function() {
            return +new Date
        };

        function ca(a, b) {
            this.a = a;
            this.o = b || a;
            this.c = this.o.document
        }
        var da = !!window.FontFace;

        function t(a, b, c, d) {
            b = a.c.createElement(b);
            if (c)
                for (var e in c) c.hasOwnProperty(e) && ("style" == e ? b.style.cssText = c[e] : b.setAttribute(e, c[e]));
            d && b.appendChild(a.c.createTextNode(d));
            return b
        }

        function u(a, b, c) {
            a = a.c.getElementsByTagName(b)[0];
            a || (a = document.documentElement);
            a.insertBefore(c, a.lastChild)
        }

        function v(a) {
            a.parentNode && a.parentNode.removeChild(a)
        }

        function w(a, b, c) {
            b = b || [];
            c = c || [];
            for (var d = a.className.split(/\s+/), e = 0; e < b.length; e += 1) {
                for (var f = !1, g = 0; g < d.length; g += 1)
                    if (b[e] === d[g]) {
                        f = !0;
                        break
                    }
                f || d.push(b[e])
            }
            b = [];
            for (e = 0; e < d.length; e += 1) {
                f = !1;
                for (g = 0; g < c.length; g += 1)
                    if (d[e] === c[g]) {
                        f = !0;
                        break
                    }
                f || b.push(d[e])
            }
            a.className = b.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
        }

        function y(a, b) {
            for (var c = a.className.split(/\s+/), d = 0, e = c.length; d < e; d++)
                if (c[d] == b) return !0;
            return !1
        }

        function ea(a) {
            return a.o.location.hostname || a.a.location.hostname
        }

        function z(a, b, c) {
            function d() {
                m && e && f && (m(g), m = null)
            }
            b = t(a, "link", {
                rel: "stylesheet",
                href: b,
                media: "all"
            });
            var e = !1,
                f = !0,
                g = null,
                m = c || null;
            da ? (b.onload = function() {
                e = !0;
                d()
            }, b.onerror = function() {
                e = !0;
                g = Error("Stylesheet failed to load");
                d()
            }) : setTimeout(function() {
                e = !0;
                d()
            }, 0);
            u(a, "head", b)
        }

        function A(a, b, c, d) {
            var e = a.c.getElementsByTagName("head")[0];
            if (e) {
                var f = t(a, "script", {
                        src: b
                    }),
                    g = !1;
                f.onload = f.onreadystatechange = function() {
                    g || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (g = !0, c && c(null), f.onload = f.onreadystatechange = null, "HEAD" == f.parentNode.tagName && e.removeChild(f))
                };
                e.appendChild(f);
                setTimeout(function() {
                    g || (g = !0, c && c(Error("Script load timeout")))
                }, d || 5E3);
                return f
            }
            return null
        };

        function B() {
            this.a = 0;
            this.c = null
        }

        function C(a) {
            a.a++;
            return function() {
                a.a--;
                D(a)
            }
        }

        function E(a, b) {
            a.c = b;
            D(a)
        }

        function D(a) {
            0 == a.a && a.c && (a.c(), a.c = null)
        };

        function F(a) {
            this.a = a || "-"
        }
        F.prototype.c = function(a) {
            for (var b = [], c = 0; c < arguments.length; c++) b.push(arguments[c].replace(/[\W_]+/g, "").toLowerCase());
            return b.join(this.a)
        };

        function G(a, b) {
            this.c = a;
            this.f = 4;
            this.a = "n";
            var c = (b || "n4").match(/^([nio])([1-9])$/i);
            c && (this.a = c[1], this.f = parseInt(c[2], 10))
        }

        function fa(a) {
            return H(a) + " " + (a.f + "00") + " 300px " + I(a.c)
        }

        function I(a) {
            var b = [];
            a = a.split(/,\s*/);
            for (var c = 0; c < a.length; c++) {
                var d = a[c].replace(/['"]/g, ""); - 1 != d.indexOf(" ") || /^\d/.test(d) ? b.push("'" + d + "'") : b.push(d)
            }
            return b.join(",")
        }

        function J(a) {
            return a.a + a.f
        }

        function H(a) {
            var b = "normal";
            "o" === a.a ? b = "oblique" : "i" === a.a && (b = "italic");
            return b
        }

        function ga(a) {
            var b = 4,
                c = "n",
                d = null;
            a && ((d = a.match(/(normal|oblique|italic)/i)) && d[1] && (c = d[1].substr(0, 1).toLowerCase()), (d = a.match(/([1-9]00|normal|bold)/i)) && d[1] && (/bold/i.test(d[1]) ? b = 7 : /[1-9]00/.test(d[1]) && (b = parseInt(d[1].substr(0, 1), 10))));
            return c + b
        };

        function ha(a, b) {
            this.c = a;
            this.f = a.o.document.documentElement;
            this.h = b;
            this.a = new F("-");
            this.j = !1 !== b.events;
            this.g = !1 !== b.classes
        }

        function ia(a) {
            a.g && w(a.f, [a.a.c("wf", "loading")]);
            K(a, "loading")
        }

        function L(a) {
            if (a.g) {
                var b = y(a.f, a.a.c("wf", "active")),
                    c = [],
                    d = [a.a.c("wf", "loading")];
                b || c.push(a.a.c("wf", "inactive"));
                w(a.f, c, d)
            }
            K(a, "inactive")
        }

        function K(a, b, c) {
            if (a.j && a.h[b])
                if (c) a.h[b](c.c, J(c));
                else a.h[b]()
        };

        function ja() {
            this.c = {}
        }

        function ka(a, b, c) {
            var d = [],
                e;
            for (e in b)
                if (b.hasOwnProperty(e)) {
                    var f = a.c[e];
                    f && d.push(f(b[e], c))
                }
            return d
        };

        function M(a, b) {
            this.c = a;
            this.f = b;
            this.a = t(this.c, "span", {
                "aria-hidden": "true"
            }, this.f)
        }

        function N(a) {
            u(a.c, "body", a.a)
        }

        function O(a) {
            return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + I(a.c) + ";" + ("font-style:" + H(a) + ";font-weight:" + (a.f + "00") + ";")
        };

        function P(a, b, c, d, e, f) {
            this.g = a;
            this.j = b;
            this.a = d;
            this.c = c;
            this.f = e || 3E3;
            this.h = f || void 0
        }
        P.prototype.start = function() {
            var a = this.c.o.document,
                b = this,
                c = q(),
                d = new Promise(function(d, e) {
                    function f() {
                        q() - c >= b.f ? e() : a.fonts.load(fa(b.a), b.h).then(function(a) {
                            1 <= a.length ? d() : setTimeout(f, 25)
                        }, function() {
                            e()
                        })
                    }
                    f()
                }),
                e = null,
                f = new Promise(function(a, d) {
                    e = setTimeout(d, b.f)
                });
            Promise.race([f, d]).then(function() {
                e && (clearTimeout(e), e = null);
                b.g(b.a)
            }, function() {
                b.j(b.a)
            })
        };

        function Q(a, b, c, d, e, f, g) {
            this.v = a;
            this.B = b;
            this.c = c;
            this.a = d;
            this.s = g || "BESbswy";
            this.f = {};
            this.w = e || 3E3;
            this.u = f || null;
            this.m = this.j = this.h = this.g = null;
            this.g = new M(this.c, this.s);
            this.h = new M(this.c, this.s);
            this.j = new M(this.c, this.s);
            this.m = new M(this.c, this.s);
            a = new G(this.a.c + ",serif", J(this.a));
            a = O(a);
            this.g.a.style.cssText = a;
            a = new G(this.a.c + ",sans-serif", J(this.a));
            a = O(a);
            this.h.a.style.cssText = a;
            a = new G("serif", J(this.a));
            a = O(a);
            this.j.a.style.cssText = a;
            a = new G("sans-serif", J(this.a));
            a = O(a);
            this.m.a.style.cssText = a;
            N(this.g);
            N(this.h);
            N(this.j);
            N(this.m)
        }
        var R = {
                D: "serif",
                C: "sans-serif"
            },
            S = null;

        function T() {
            if (null === S) {
                var a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
                S = !!a && (536 > parseInt(a[1], 10) || 536 === parseInt(a[1], 10) && 11 >= parseInt(a[2], 10))
            }
            return S
        }
        Q.prototype.start = function() {
            this.f.serif = this.j.a.offsetWidth;
            this.f["sans-serif"] = this.m.a.offsetWidth;
            this.A = q();
            U(this)
        };

        function la(a, b, c) {
            for (var d in R)
                if (R.hasOwnProperty(d) && b === a.f[R[d]] && c === a.f[R[d]]) return !0;
            return !1
        }

        function U(a) {
            var b = a.g.a.offsetWidth,
                c = a.h.a.offsetWidth,
                d;
            (d = b === a.f.serif && c === a.f["sans-serif"]) || (d = T() && la(a, b, c));
            d ? q() - a.A >= a.w ? T() && la(a, b, c) && (null === a.u || a.u.hasOwnProperty(a.a.c)) ? V(a, a.v) : V(a, a.B) : ma(a) : V(a, a.v)
        }

        function ma(a) {
            setTimeout(p(function() {
                U(this)
            }, a), 50)
        }

        function V(a, b) {
            setTimeout(p(function() {
                v(this.g.a);
                v(this.h.a);
                v(this.j.a);
                v(this.m.a);
                b(this.a)
            }, a), 0)
        };

        function W(a, b, c) {
            this.c = a;
            this.a = b;
            this.f = 0;
            this.m = this.j = !1;
            this.s = c
        }
        var X = null;
        W.prototype.g = function(a) {
            var b = this.a;
            b.g && w(b.f, [b.a.c("wf", a.c, J(a).toString(), "active")], [b.a.c("wf", a.c, J(a).toString(), "loading"), b.a.c("wf", a.c, J(a).toString(), "inactive")]);
            K(b, "fontactive", a);
            this.m = !0;
            na(this)
        };
        W.prototype.h = function(a) {
            var b = this.a;
            if (b.g) {
                var c = y(b.f, b.a.c("wf", a.c, J(a).toString(), "active")),
                    d = [],
                    e = [b.a.c("wf", a.c, J(a).toString(), "loading")];
                c || d.push(b.a.c("wf", a.c, J(a).toString(), "inactive"));
                w(b.f, d, e)
            }
            K(b, "fontinactive", a);
            na(this)
        };

        function na(a) {
            0 == --a.f && a.j && (a.m ? (a = a.a, a.g && w(a.f, [a.a.c("wf", "active")], [a.a.c("wf", "loading"), a.a.c("wf", "inactive")]), K(a, "active")) : L(a.a))
        };

        function oa(a) {
            this.j = a;
            this.a = new ja;
            this.h = 0;
            this.f = this.g = !0
        }
        oa.prototype.load = function(a) {
            this.c = new ca(this.j, a.context || this.j);
            this.g = !1 !== a.events;
            this.f = !1 !== a.classes;
            pa(this, new ha(this.c, a), a)
        };

        function qa(a, b, c, d, e) {
            var f = 0 == --a.h;
            (a.f || a.g) && setTimeout(function() {
                var a = e || null,
                    m = d || null || {};
                if (0 === c.length && f) L(b.a);
                else {
                    b.f += c.length;
                    f && (b.j = f);
                    var h, l = [];
                    for (h = 0; h < c.length; h++) {
                        var k = c[h],
                            n = m[k.c],
                            r = b.a,
                            x = k;
                        r.g && w(r.f, [r.a.c("wf", x.c, J(x).toString(), "loading")]);
                        K(r, "fontloading", x);
                        r = null;
                        if (null === X)
                            if (window.FontFace) {
                                var x = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                    xa = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                X = x ? 42 < parseInt(x[1], 10) : xa ? !1 : !0
                            } else X = !1;
                        X ? r = new P(p(b.g, b), p(b.h, b), b.c, k, b.s, n) : r = new Q(p(b.g, b), p(b.h, b), b.c, k, b.s, a, n);
                        l.push(r)
                    }
                    for (h = 0; h < l.length; h++) l[h].start()
                }
            }, 0)
        }

        function pa(a, b, c) {
            var d = [],
                e = c.timeout;
            ia(b);
            var d = ka(a.a, c, a.c),
                f = new W(a.c, b, e);
            a.h = d.length;
            b = 0;
            for (c = d.length; b < c; b++) d[b].load(function(b, d, c) {
                qa(a, f, b, d, c)
            })
        };

        function ra(a, b) {
            this.c = a;
            this.a = b
        }
        ra.prototype.load = function(a) {
            function b() {
                if (f["__mti_fntLst" + d]) {
                    var c = f["__mti_fntLst" + d](),
                        e = [],
                        h;
                    if (c)
                        for (var l = 0; l < c.length; l++) {
                            var k = c[l].fontfamily;
                            void 0 != c[l].fontStyle && void 0 != c[l].fontWeight ? (h = c[l].fontStyle + c[l].fontWeight, e.push(new G(k, h))) : e.push(new G(k))
                        }
                    a(e)
                } else setTimeout(function() {
                    b()
                }, 50)
            }
            var c = this,
                d = c.a.projectId,
                e = c.a.version;
            if (d) {
                var f = c.c.o;
                A(this.c, (c.a.api || "https://fast.fonts.net/jsapi") + "/" + d + ".js" + (e ? "?v=" + e : ""), function(e) {
                    e ? a([]) : (f["__MonotypeConfiguration__" +
                        d] = function() {
                        return c.a
                    }, b())
                }).id = "__MonotypeAPIScript__" + d
            } else a([])
        };

        function sa(a, b) {
            this.c = a;
            this.a = b
        }
        sa.prototype.load = function(a) {
            var b, c, d = this.a.urls || [],
                e = this.a.families || [],
                f = this.a.testStrings || {},
                g = new B;
            b = 0;
            for (c = d.length; b < c; b++) z(this.c, d[b], C(g));
            var m = [];
            b = 0;
            for (c = e.length; b < c; b++)
                if (d = e[b].split(":"), d[1])
                    for (var h = d[1].split(","), l = 0; l < h.length; l += 1) m.push(new G(d[0], h[l]));
                else m.push(new G(d[0]));
            E(g, function() {
                a(m, f)
            })
        };

        function ta(a, b) {
            a ? this.c = a : this.c = ua;
            this.a = [];
            this.f = [];
            this.g = b || ""
        }
        var ua = "https://fonts.googleapis.com/css";

        function va(a, b) {
            for (var c = b.length, d = 0; d < c; d++) {
                var e = b[d].split(":");
                3 == e.length && a.f.push(e.pop());
                var f = "";
                2 == e.length && "" != e[1] && (f = ":");
                a.a.push(e.join(f))
            }
        }

        function wa(a) {
            if (0 == a.a.length) throw Error("No fonts to load!");
            if (-1 != a.c.indexOf("kit=")) return a.c;
            for (var b = a.a.length, c = [], d = 0; d < b; d++) c.push(a.a[d].replace(/ /g, "+"));
            b = a.c + "?family=" + c.join("%7C");
            0 < a.f.length && (b += "&subset=" + a.f.join(","));
            0 < a.g.length && (b += "&text=" + encodeURIComponent(a.g));
            return b
        };

        function ya(a) {
            this.f = a;
            this.a = [];
            this.c = {}
        }
        var za = {
                latin: "BESbswy",
                "latin-ext": "\u00e7\u00f6\u00fc\u011f\u015f",
                cyrillic: "\u0439\u044f\u0416",
                greek: "\u03b1\u03b2\u03a3",
                khmer: "\u1780\u1781\u1782",
                Hanuman: "\u1780\u1781\u1782"
            },
            Aa = {
                thin: "1",
                extralight: "2",
                "extra-light": "2",
                ultralight: "2",
                "ultra-light": "2",
                light: "3",
                regular: "4",
                book: "4",
                medium: "5",
                "semi-bold": "6",
                semibold: "6",
                "demi-bold": "6",
                demibold: "6",
                bold: "7",
                "extra-bold": "8",
                extrabold: "8",
                "ultra-bold": "8",
                ultrabold: "8",
                black: "9",
                heavy: "9",
                l: "3",
                r: "4",
                b: "7"
            },
            Ba = {
                i: "i",
                italic: "i",
                n: "n",
                normal: "n"
            },
            Ca = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;

        function Da(a) {
            for (var b = a.f.length, c = 0; c < b; c++) {
                var d = a.f[c].split(":"),
                    e = d[0].replace(/\+/g, " "),
                    f = ["n4"];
                if (2 <= d.length) {
                    var g;
                    var m = d[1];
                    g = [];
                    if (m)
                        for (var m = m.split(","), h = m.length, l = 0; l < h; l++) {
                            var k;
                            k = m[l];
                            if (k.match(/^[\w-]+$/)) {
                                var n = Ca.exec(k.toLowerCase());
                                if (null == n) k = "";
                                else {
                                    k = n[2];
                                    k = null == k || "" == k ? "n" : Ba[k];
                                    n = n[1];
                                    if (null == n || "" == n) n = "4";
                                    else var r = Aa[n],
                                        n = r ? r : isNaN(n) ? "4" : n.substr(0, 1);
                                    k = [k, n].join("")
                                }
                            } else k = "";
                            k && g.push(k)
                        }
                    0 < g.length && (f = g);
                    3 == d.length && (d = d[2], g = [], d = d ? d.split(",") : g, 0 < d.length && (d = za[d[0]]) && (a.c[e] = d))
                }
                a.c[e] || (d = za[e]) && (a.c[e] = d);
                for (d = 0; d < f.length; d += 1) a.a.push(new G(e, f[d]))
            }
        };

        function Ea(a, b) {
            this.c = a;
            this.a = b
        }
        var Fa = {
            Arimo: !0,
            Cousine: !0,
            Tinos: !0
        };
        Ea.prototype.load = function(a) {
            var b = new B,
                c = this.c,
                d = new ta(this.a.api, this.a.text),
                e = this.a.families;
            va(d, e);
            var f = new ya(e);
            Da(f);
            z(c, wa(d), C(b));
            E(b, function() {
                a(f.a, f.c, Fa)
            })
        };

        function Ga(a, b) {
            this.c = a;
            this.a = b
        }
        Ga.prototype.load = function(a) {
            var b = this.a.id,
                c = this.c.o;
            b ? A(this.c, (this.a.api || "https://use.typekit.net") + "/" + b + ".js", function(b) {
                if (b) a([]);
                else if (c.Typekit && c.Typekit.config && c.Typekit.config.fn) {
                    b = c.Typekit.config.fn;
                    for (var e = [], f = 0; f < b.length; f += 2)
                        for (var g = b[f], m = b[f + 1], h = 0; h < m.length; h++) e.push(new G(g, m[h]));
                    try {
                        c.Typekit.load({
                            events: !1,
                            classes: !1,
                            async: !0
                        })
                    } catch (l) {}
                    a(e)
                }
            }, 2E3) : a([])
        };

        function Ha(a, b) {
            this.c = a;
            this.f = b;
            this.a = []
        }
        Ha.prototype.load = function(a) {
            var b = this.f.id,
                c = this.c.o,
                d = this;
            b ? (c.__webfontfontdeckmodule__ || (c.__webfontfontdeckmodule__ = {}), c.__webfontfontdeckmodule__[b] = function(b, c) {
                for (var g = 0, m = c.fonts.length; g < m; ++g) {
                    var h = c.fonts[g];
                    d.a.push(new G(h.name, ga("font-weight:" + h.weight + ";font-style:" + h.style)))
                }
                a(d.a)
            }, A(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + ea(this.c) + "/" + b + ".js", function(b) {
                b && a([])
            })) : a([])
        };
        var Y = new oa(window);
        Y.a.c.custom = function(a, b) {
            return new sa(b, a)
        };
        Y.a.c.fontdeck = function(a, b) {
            return new Ha(b, a)
        };
        Y.a.c.monotype = function(a, b) {
            return new ra(b, a)
        };
        Y.a.c.typekit = function(a, b) {
            return new Ga(b, a)
        };
        Y.a.c.google = function(a, b) {
            return new Ea(b, a)
        };
        var Z = {
            load: p(Y.load, Y)
        };
        true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return Z
        }).call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : "undefined" !== typeof module && module.exports ? module.exports = Z : (window.WebFont = Z, window.WebFontConfig && Y.load(window.WebFontConfig));
    }());
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _utils = __webpack_require__(2);

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var BuffaSideMenu = function() {
        function BuffaSideMenu() {
            _classCallCheck(this, BuffaSideMenu);
            this.menu = (0, _utils.qs)(".side-menu");
            this.activeLink = null;
        }
        _createClass(BuffaSideMenu, [{
            key: "animateLinkIn",
            value: function animateLinkIn(namespace) {
                if (namespace === "single-work") namespace = "works-page";
                this.activeLink = (0, _utils.qs)("[data-ns='" + namespace + "'] a", this.menu);
                if (this.activeLink) {
                    (0, _utils.addClass)(this.activeLink, "current");
                    (0, _utils.addClass)(this.activeLink, "current-animate");
                }
            }
        }, {
            key: "animateLinkOut",
            value: function animateLinkOut(HTMLElement) {
                if (HTMLElement.dataset.animateSideMenuLink === "false") return;
                var link = (0, _utils.qs)(".current.current-animate");
                if (link) {
                    (0, _utils.removeClass)(link, "current");
                    (0, _utils.removeClass)(link, "current-animate");
                }
            }
        }]);
        return BuffaSideMenu;
    }();
    exports.default = BuffaSideMenu;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _utils = __webpack_require__(2);

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var BuffaSingleProject = function() {
        function BuffaSingleProject() {
            var _this = this;
            _classCallCheck(this, BuffaSingleProject);
            this.parent = (0, _utils.qs)(".single-work__composer");
            this.child = (0, _utils.qs)(".single-work__composer__inner");
            this.scrolled = 0;
            this.maxScroll = 0;
            this.scrollPerc = 0;
            this.progressBar = (0, _utils.qs)(".progress-bar__status");
            this.scrollCallback = function(_) {
                return _this._scrollCallback();
            };
            this.resizeCallback = function(_) {
                return _this._resizeCallback();
            };
            this.init();
        }
        _createClass(BuffaSingleProject, [{
            key: "init",
            value: function init() {
                this._setValues();
                this.parent.addEventListener("scroll", this.scrollCallback, {
                    passive: true
                });
                window.addEventListener("resize", this.resizeCallback);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                this.parent.removeEventListener("scroll", this.scrollCallback, {
                    passive: true
                });
                window.removeEventListener("resize", this.resizeCallback);
            }
        }, {
            key: "_scrollCallback",
            value: function _scrollCallback() {
                this.scrolled = this.parent.scrollTop;
                this.scrollPerc = this.scrolled / this.maxScroll;
                this._animateBar();
            }
        }, {
            key: "_resizeCallback",
            value: function _resizeCallback() {
                this._setValues();
                this._scrollCallback();
            }
        }, {
            key: "_setValues",
            value: function _setValues() {
                this.maxScroll = (0, _utils.qs)(".single-work__composer__inner").clientHeight - (0, _utils.qs)(".single-work__composer").clientHeight;
            }
        }, {
            key: "_animateBar",
            value: function _animateBar() {
                TweenLite.to(this.progressBar, 0.4, {
                    scaleY: this.scrollPerc
                });
            }
        }]);
        return BuffaSingleProject;
    }();
    exports.default = BuffaSingleProject;
}), (function(module, exports, __webpack_require__) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
        value: true
    });
    var _createClass = function() {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function(Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _swiper = __webpack_require__(74);
    var _swiper2 = _interopRequireDefault(_swiper);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }
    var BuffaVerticalCarousel = function() {
        function BuffaVerticalCarousel(target) {
            var _this = this;
            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, BuffaVerticalCarousel);
            this.target = target;
            this.instance = null;
            this.translate = 0;
            this.speed = args.speed || 60;
            this.slidesTotalHeight = 0;
            this.resizeCallback = function(_) {
                return _this.calculateSlidesHeight();
            };
            this.init();
        }
        _createClass(BuffaVerticalCarousel, [{
            key: "init",
            value: function init() {
                var _this2 = this;
                this.instance = new _swiper2.default(this.target, {
                    slidesPerView: "auto",
                    direction: "vertical",
                    loop: true,
                    allowTouchMove: false,
                    on: {
                        init: function init(_) {
                            return _this2.render();
                        }
                    }
                });
                this.calculateSlidesHeight();
                window.addEventListener("resize", this.resizeCallback);
            }
        }, {
            key: "destroy",
            value: function destroy() {
                window.removeEventListener("resize", this.resizeCallback);
            }
        }, {
            key: "calculateSlidesHeight",
            value: function calculateSlidesHeight() {
                var height = 0;
                for (var j = 0; j < this.instance.slides.length; j++) {
                    var s = this.instance.slides[j];
                    if (!s.classList.contains('swiper-slide-duplicate')) height += s.clientHeight;
                }
                this.slidesTotalHeight = height;
            }
        }, {
            key: "render",
            value: function render() {
                var _this3 = this;
                requestAnimationFrame(function(_) {
                    var translate = _this3.instance.getTranslate() - _this3.speed / 60;
                    if (Math.abs(translate) > _this3.slidesTotalHeight) {
                        var delta = translate < 0 ? _this3.slidesTotalHeight : -_this3.slidesTotalHeight;
                        translate = translate + delta;
                    }
                    _this3.instance.setTranslate(translate);
                    _this3.render();
                });
            }
        }]);
        return BuffaVerticalCarousel;
    }();
    exports.default = BuffaVerticalCarousel;
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
    });
    var __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__ = __webpack_require__(75);
    var __WEBPACK_IMPORTED_MODULE_1_ssr_window__ = __webpack_require__(26);
    const Methods = {
        addClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["c"],
        removeClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["E"],
        hasClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["m"],
        toggleClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["H"],
        attr: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["e"],
        removeAttr: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["D"],
        data: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["i"],
        transform: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["I"],
        transition: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["J"],
        on: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["u"],
        off: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["s"],
        trigger: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L"],
        transitionEnd: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["K"],
        outerWidth: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["w"],
        outerHeight: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["v"],
        offset: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["t"],
        css: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["h"],
        each: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["j"],
        html: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["n"],
        text: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["G"],
        is: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["p"],
        index: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["o"],
        eq: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["k"],
        append: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["d"],
        prepend: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["z"],
        next: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["q"],
        nextAll: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["r"],
        prev: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["A"],
        prevAll: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["B"],
        parent: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["x"],
        parents: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["y"],
        closest: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["g"],
        find: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["l"],
        children: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["f"],
        remove: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["C"],
        add: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["b"],
        styles: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["F"],
    };
    Object.keys(Methods).forEach((methodName) => {
        __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"].fn[methodName] = Methods[methodName];
    });
    const Utils = {
        deleteProps(obj) {
            const object = obj;
            Object.keys(object).forEach((key) => {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            });
        }, nextTick(callback, delay = 0) {
            return setTimeout(callback, delay);
        }, now() {
            return Date.now();
        }, getTranslate(el, axis = 'x') {
            let matrix;
            let curTransform;
            let transformMatrix;
            const curStyle = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].getComputedStyle(el, null);
            if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(',').length > 6) {
                    curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
                }
                transformMatrix = new __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
                matrix = transformMatrix.toString().split(',');
            }
            if (axis === 'x') {
                if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].WebKitCSSMatrix) curTransform = transformMatrix.m41;
                else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
                else curTransform = parseFloat(matrix[4]);
            }
            if (axis === 'y') {
                if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].WebKitCSSMatrix) curTransform = transformMatrix.m42;
                else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
                else curTransform = parseFloat(matrix[5]);
            }
            return curTransform || 0;
        }, parseUrlQuery(url) {
            const query = {};
            let urlToParse = url || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].location.href;
            let i;
            let params;
            let param;
            let length;
            if (typeof urlToParse === 'string' && urlToParse.length) {
                urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
                params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');
                length = params.length;
                for (i = 0; i < length; i += 1) {
                    param = params[i].replace(/#\S+/g, '').split('=');
                    query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
                }
            }
            return query;
        }, isObject(o) {
            return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
        }, extend(...args) {
            const to = Object(args[0]);
            for (let i = 1; i < args.length; i += 1) {
                const nextSource = args[i];
                if (nextSource !== undefined && nextSource !== null) {
                    const keysArray = Object.keys(Object(nextSource));
                    for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        const nextKey = keysArray[nextIndex];
                        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== undefined && desc.enumerable) {
                            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                                Utils.extend(to[nextKey], nextSource[nextKey]);
                            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                                to[nextKey] = {};
                                Utils.extend(to[nextKey], nextSource[nextKey]);
                            } else {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                }
            }
            return to;
        },
    };
    const Support = (function Support() {
        const testDiv = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].createElement('div');
        return {
            touch: (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].Modernizr && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].Modernizr.touch === true) || (function checkTouch() {
                return !!(('ontouchstart' in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"]) || (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].DocumentTouch && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"] instanceof __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].DocumentTouch));
            }()),
            pointerEvents: !!(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].navigator.pointerEnabled || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].PointerEvent),
            prefixedPointerEvents: !!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].navigator.msPointerEnabled,
            transition: (function checkTransition() {
                const style = testDiv.style;
                return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);
            }()),
            transforms3d: (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].Modernizr && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].Modernizr.csstransforms3d === true) || (function checkTransforms3d() {
                const style = testDiv.style;
                return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);
            }()),
            flexbox: (function checkFlexbox() {
                const style = testDiv.style;
                const styles$$1 = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
                for (let i = 0; i < styles$$1.length; i += 1) {
                    if (styles$$1[i] in style) return true;
                }
                return false;
            }()),
            observer: (function checkObserver() {
                return ('MutationObserver' in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"] || 'WebkitMutationObserver' in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"]);
            }()),
            passiveListener: (function checkPassiveListener() {
                let supportsPassive = false;
                try {
                    const opts = Object.defineProperty({}, 'passive', {
                        get() {
                            supportsPassive = true;
                        },
                    });
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].addEventListener('testPassiveListener', null, opts);
                } catch (e) {}
                return supportsPassive;
            }()),
            gestures: (function checkGestures() {
                return 'ongesturestart' in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"];
            }()),
        };
    }());
    class SwiperClass {
        constructor(params = {}) {
            const self = this;
            self.params = params;
            self.eventsListeners = {};
            if (self.params && self.params.on) {
                Object.keys(self.params.on).forEach((eventName) => {
                    self.on(eventName, self.params.on[eventName]);
                });
            }
        }
        on(events, handler, priority) {
            const self = this;
            if (typeof handler !== 'function') return self;
            const method = priority ? 'unshift' : 'push';
            events.split(' ').forEach((event) => {
                if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                self.eventsListeners[event][method](handler);
            });
            return self;
        }
        once(events, handler, priority) {
            const self = this;
            if (typeof handler !== 'function') return self;

            function onceHandler(...args) {
                handler.apply(self, args);
                self.off(events, onceHandler);
            }
            return self.on(events, onceHandler, priority);
        }
        off(events, handler) {
            const self = this;
            if (!self.eventsListeners) return self;
            events.split(' ').forEach((event) => {
                if (typeof handler === 'undefined') {
                    self.eventsListeners[event] = [];
                } else {
                    self.eventsListeners[event].forEach((eventHandler, index$$1) => {
                        if (eventHandler === handler) {
                            self.eventsListeners[event].splice(index$$1, 1);
                        }
                    });
                }
            });
            return self;
        }
        emit(...args) {
            const self = this;
            if (!self.eventsListeners) return self;
            let events;
            let data$$1;
            let context;
            if (typeof args[0] === 'string' || Array.isArray(args[0])) {
                events = args[0];
                data$$1 = args.slice(1, args.length);
                context = self;
            } else {
                events = args[0].events;
                data$$1 = args[0].data;
                context = args[0].context || self;
            }
            const eventsArray = Array.isArray(events) ? events : events.split(' ');
            eventsArray.forEach((event) => {
                if (self.eventsListeners && self.eventsListeners[event]) {
                    const handlers = [];
                    self.eventsListeners[event].forEach((eventHandler) => {
                        handlers.push(eventHandler);
                    });
                    handlers.forEach((eventHandler) => {
                        eventHandler.apply(context, data$$1);
                    });
                }
            });
            return self;
        }
        useModulesParams(instanceParams) {
            const instance = this;
            if (!instance.modules) return;
            Object.keys(instance.modules).forEach((moduleName) => {
                const module = instance.modules[moduleName];
                if (module.params) {
                    Utils.extend(instanceParams, module.params);
                }
            });
        }
        useModules(modulesParams = {}) {
            const instance = this;
            if (!instance.modules) return;
            Object.keys(instance.modules).forEach((moduleName) => {
                const module = instance.modules[moduleName];
                const moduleParams = modulesParams[moduleName] || {};
                if (module.instance) {
                    Object.keys(module.instance).forEach((modulePropName) => {
                        const moduleProp = module.instance[modulePropName];
                        if (typeof moduleProp === 'function') {
                            instance[modulePropName] = moduleProp.bind(instance);
                        } else {
                            instance[modulePropName] = moduleProp;
                        }
                    });
                }
                if (module.on && instance.on) {
                    Object.keys(module.on).forEach((moduleEventName) => {
                        instance.on(moduleEventName, module.on[moduleEventName]);
                    });
                }
                if (module.create) {
                    module.create.bind(instance)(moduleParams);
                }
            });
        }
        static set components(components) {
            const Class = this;
            if (!Class.use) return;
            Class.use(components);
        }
        static installModule(module, ...params) {
            const Class = this;
            if (!Class.prototype.modules) Class.prototype.modules = {};
            const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);
            Class.prototype.modules[name] = module;
            if (module.proto) {
                Object.keys(module.proto).forEach((key) => {
                    Class.prototype[key] = module.proto[key];
                });
            }
            if (module.static) {
                Object.keys(module.static).forEach((key) => {
                    Class[key] = module.static[key];
                });
            }
            if (module.install) {
                module.install.apply(Class, params);
            }
            return Class;
        }
        static use(module, ...params) {
            const Class = this;
            if (Array.isArray(module)) {
                module.forEach(m => Class.installModule(m));
                return Class;
            }
            return Class.installModule(module, ...params);
        }
    }

    function updateSize() {
        const swiper = this;
        let width;
        let height;
        const $el = swiper.$el;
        if (typeof swiper.params.width !== 'undefined') {
            width = swiper.params.width;
        } else {
            width = $el[0].clientWidth;
        }
        if (typeof swiper.params.height !== 'undefined') {
            height = swiper.params.height;
        } else {
            height = $el[0].clientHeight;
        }
        if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
            return;
        }
        width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
        height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);
        Utils.extend(swiper, {
            width, height, size: swiper.isHorizontal() ? width : height,
        });
    }

    function updateSlides() {
        const swiper = this;
        const params = swiper.params;
        const {
            $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,
        } = swiper;
        const isVirtual = swiper.virtual && params.virtual.enabled;
        const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
        const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
        const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
        let snapGrid = [];
        const slidesGrid = [];
        const slidesSizesGrid = [];
        let offsetBefore = params.slidesOffsetBefore;
        if (typeof offsetBefore === 'function') {
            offsetBefore = params.slidesOffsetBefore.call(swiper);
        }
        let offsetAfter = params.slidesOffsetAfter;
        if (typeof offsetAfter === 'function') {
            offsetAfter = params.slidesOffsetAfter.call(swiper);
        }
        const previousSnapGridLength = swiper.snapGrid.length;
        const previousSlidesGridLength = swiper.snapGrid.length;
        let spaceBetween = params.spaceBetween;
        let slidePosition = -offsetBefore;
        let prevSlideSize = 0;
        let index$$1 = 0;
        if (typeof swiperSize === 'undefined') {
            return;
        }
        if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
            spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
        }
        swiper.virtualSize = -spaceBetween;
        if (rtl) slides.css({
            marginLeft: '',
            marginTop: ''
        });
        else slides.css({
            marginRight: '',
            marginBottom: ''
        });
        let slidesNumberEvenToRows;
        if (params.slidesPerColumn > 1) {
            if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
                slidesNumberEvenToRows = slidesLength;
            } else {
                slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
            }
            if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
                slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
            }
        }
        let slideSize;
        const slidesPerColumn = params.slidesPerColumn;
        const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
        const numFullColumns = slidesPerRow - ((params.slidesPerColumn * slidesPerRow) - slidesLength);
        for (let i = 0; i < slidesLength; i += 1) {
            slideSize = 0;
            const slide = slides.eq(i);
            if (params.slidesPerColumn > 1) {
                let newSlideOrderIndex;
                let column;
                let row;
                if (params.slidesPerColumnFill === 'column') {
                    column = Math.floor(i / slidesPerColumn);
                    row = i - (column * slidesPerColumn);
                    if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
                        row += 1;
                        if (row >= slidesPerColumn) {
                            row = 0;
                            column += 1;
                        }
                    }
                    newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
                    slide.css({
                        '-webkit-box-ordinal-group': newSlideOrderIndex,
                        '-moz-box-ordinal-group': newSlideOrderIndex,
                        '-ms-flex-order': newSlideOrderIndex,
                        '-webkit-order': newSlideOrderIndex,
                        order: newSlideOrderIndex,
                    });
                } else {
                    row = Math.floor(i / slidesPerRow);
                    column = i - (row * slidesPerRow);
                }
                slide.css(`margin-${swiper.isHorizontal()?'top':'left'}`, (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)).attr('data-swiper-column', column).attr('data-swiper-row', row);
            }
            if (slide.css('display') === 'none') continue;
            if (params.slidesPerView === 'auto') {
                const slideStyles = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].getComputedStyle(slide[0], null);
                const currentTransform = slide[0].style.transform;
                const currentWebKitTransform = slide[0].style.webkitTransform;
                if (currentTransform) {
                    slide[0].style.transform = 'none';
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = 'none';
                }
                if (swiper.isHorizontal()) {
                    slideSize = slide[0].getBoundingClientRect().width + parseFloat(slideStyles.getPropertyValue('margin-left')) + parseFloat(slideStyles.getPropertyValue('margin-right'));
                } else {
                    slideSize = slide[0].getBoundingClientRect().height + parseFloat(slideStyles.getPropertyValue('margin-top')) + parseFloat(slideStyles.getPropertyValue('margin-bottom'));
                }
                if (currentTransform) {
                    slide[0].style.transform = currentTransform;
                }
                if (currentWebKitTransform) {
                    slide[0].style.webkitTransform = currentWebKitTransform;
                }
                if (params.roundLengths) slideSize = Math.floor(slideSize);
            } else {
                slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
                if (params.roundLengths) slideSize = Math.floor(slideSize);
                if (slides[i]) {
                    if (swiper.isHorizontal()) {
                        slides[i].style.width = `${slideSize}px`;
                    } else {
                        slides[i].style.height = `${slideSize}px`;
                    }
                }
            }
            if (slides[i]) {
                slides[i].swiperSlideSize = slideSize;
            }
            slidesSizesGrid.push(slideSize);
            if (params.centeredSlides) {
                slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
                if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
                if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
                if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                if ((index$$1) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                slidesGrid.push(slidePosition);
            } else {
                if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                if ((index$$1) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                slidesGrid.push(slidePosition);
                slidePosition = slidePosition + slideSize + spaceBetween;
            }
            swiper.virtualSize += slideSize + spaceBetween;
            prevSlideSize = slideSize;
            index$$1 += 1;
        }
        swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
        let newSlidesGrid;
        if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
            $wrapperEl.css({
                width: `${swiper.virtualSize+params.spaceBetween}px`
            });
        }
        if (!Support.flexbox || params.setWrapperSize) {
            if (swiper.isHorizontal()) $wrapperEl.css({
                width: `${swiper.virtualSize+params.spaceBetween}px`
            });
            else $wrapperEl.css({
                height: `${swiper.virtualSize+params.spaceBetween}px`
            });
        }
        if (params.slidesPerColumn > 1) {
            swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
            swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
            if (swiper.isHorizontal()) $wrapperEl.css({
                width: `${swiper.virtualSize+params.spaceBetween}px`
            });
            else $wrapperEl.css({
                height: `${swiper.virtualSize+params.spaceBetween}px`
            });
            if (params.centeredSlides) {
                newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid = newSlidesGrid;
            }
        }
        if (!params.centeredSlides) {
            newSlidesGrid = [];
            for (let i = 0; i < snapGrid.length; i += 1) {
                let slidesGridItem = snapGrid[i];
                if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
                    newSlidesGrid.push(slidesGridItem);
                }
            }
            snapGrid = newSlidesGrid;
            if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
                snapGrid.push(swiper.virtualSize - swiperSize);
            }
        }
        if (snapGrid.length === 0) snapGrid = [0];
        if (params.spaceBetween !== 0) {
            if (swiper.isHorizontal()) {
                if (rtl) slides.css({
                    marginLeft: `${spaceBetween}px`
                });
                else slides.css({
                    marginRight: `${spaceBetween}px`
                });
            } else slides.css({
                marginBottom: `${spaceBetween}px`
            });
        }
        Utils.extend(swiper, {
            slides, snapGrid, slidesGrid, slidesSizesGrid,
        });
        if (slidesLength !== previousSlidesLength) {
            swiper.emit('slidesLengthChange');
        }
        if (snapGrid.length !== previousSnapGridLength) {
            if (swiper.params.watchOverflow) swiper.checkOverflow();
            swiper.emit('snapGridLengthChange');
        }
        if (slidesGrid.length !== previousSlidesGridLength) {
            swiper.emit('slidesGridLengthChange');
        }
        if (params.watchSlidesProgress || params.watchSlidesVisibility) {
            swiper.updateSlidesOffset();
        }
    }

    function updateAutoHeight(speed) {
        const swiper = this;
        const activeSlides = [];
        let newHeight = 0;
        let i;
        if (typeof speed === 'number') {
            swiper.setTransition(speed);
        } else if (speed === true) {
            swiper.setTransition(swiper.params.speed);
        }
        if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
            for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index$$1 = swiper.activeIndex + i;
                if (index$$1 > swiper.slides.length) break;
                activeSlides.push(swiper.slides.eq(index$$1)[0]);
            }
        } else {
            activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
        }
        for (i = 0; i < activeSlides.length; i += 1) {
            if (typeof activeSlides[i] !== 'undefined') {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
        }
        if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
    }

    function updateSlidesOffset() {
        const swiper = this;
        const slides = swiper.slides;
        for (let i = 0; i < slides.length; i += 1) {
            slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
        }
    }

    function updateSlidesProgress(translate = (this && this.translate) || 0) {
        const swiper = this;
        const params = swiper.params;
        const {
            slides, rtlTranslate: rtl
        } = swiper;
        if (slides.length === 0) return;
        if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
        let offsetCenter = -translate;
        if (rtl) offsetCenter = translate;
        slides.removeClass(params.slideVisibleClass);
        for (let i = 0; i < slides.length; i += 1) {
            const slide = slides[i];
            const slideProgress = ((offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);
            if (params.watchSlidesVisibility) {
                const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isVisible = (slideBefore >= 0 && slideBefore < swiper.size) || (slideAfter > 0 && slideAfter <= swiper.size) || (slideBefore <= 0 && slideAfter >= swiper.size);
                if (isVisible) {
                    slides.eq(i).addClass(params.slideVisibleClass);
                }
            }
            slide.progress = rtl ? -slideProgress : slideProgress;
        }
    }

    function updateProgress(translate = (this && this.translate) || 0) {
        const swiper = this;
        const params = swiper.params;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        let {
            progress, isBeginning, isEnd
        } = swiper;
        const wasBeginning = isBeginning;
        const wasEnd = isEnd;
        if (translatesDiff === 0) {
            progress = 0;
            isBeginning = true;
            isEnd = true;
        } else {
            progress = (translate - swiper.minTranslate()) / (translatesDiff);
            isBeginning = progress <= 0;
            isEnd = progress >= 1;
        }
        Utils.extend(swiper, {
            progress, isBeginning, isEnd,
        });
        if (params.watchSlidesProgress || params.watchSlidesVisibility) swiper.updateSlidesProgress(translate);
        if (isBeginning && !wasBeginning) {
            swiper.emit('reachBeginning toEdge');
        }
        if (isEnd && !wasEnd) {
            swiper.emit('reachEnd toEdge');
        }
        if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
            swiper.emit('fromEdge');
        }
        swiper.emit('progress', progress);
    }

    function updateSlidesClasses() {
        const swiper = this;
        const {
            slides, params, $wrapperEl, activeIndex, realIndex,
        } = swiper;
        const isVirtual = swiper.virtual && params.virtual.enabled;
        slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
        let activeSlide;
        if (isVirtual) {
            activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
        } else {
            activeSlide = slides.eq(activeIndex);
        }
        activeSlide.addClass(params.slideActiveClass);
        if (params.loop) {
            if (activeSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
            }
        }
        let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
        if (params.loop && nextSlide.length === 0) {
            nextSlide = slides.eq(0);
            nextSlide.addClass(params.slideNextClass);
        }
        let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
        if (params.loop && prevSlide.length === 0) {
            prevSlide = slides.eq(-1);
            prevSlide.addClass(params.slidePrevClass);
        }
        if (params.loop) {
            if (nextSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicateNextClass);
            }
            if (prevSlide.hasClass(params.slideDuplicateClass)) {
                $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
            } else {
                $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`).addClass(params.slideDuplicatePrevClass);
            }
        }
    }

    function updateActiveIndex(newActiveIndex) {
        const swiper = this;
        const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
        const {
            slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,
        } = swiper;
        let activeIndex = newActiveIndex;
        let snapIndex;
        if (typeof activeIndex === 'undefined') {
            for (let i = 0; i < slidesGrid.length; i += 1) {
                if (typeof slidesGrid[i + 1] !== 'undefined') {
                    if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
                        activeIndex = i;
                    } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                        activeIndex = i + 1;
                    }
                } else if (translate >= slidesGrid[i]) {
                    activeIndex = i;
                }
            }
            if (params.normalizeSlideIndex) {
                if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
            }
        }
        if (snapGrid.indexOf(translate) >= 0) {
            snapIndex = snapGrid.indexOf(translate);
        } else {
            snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
        }
        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
        if (activeIndex === previousIndex) {
            if (snapIndex !== previousSnapIndex) {
                swiper.snapIndex = snapIndex;
                swiper.emit('snapIndexChange');
            }
            return;
        }
        const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
        Utils.extend(swiper, {
            snapIndex, realIndex, previousIndex, activeIndex,
        });
        swiper.emit('activeIndexChange');
        swiper.emit('snapIndexChange');
        if (previousRealIndex !== realIndex) {
            swiper.emit('realIndexChange');
        }
        swiper.emit('slideChange');
    }

    function updateClickedSlide(e) {
        const swiper = this;
        const params = swiper.params;
        const slide = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(e.target).closest(`.${params.slideClass}`)[0];
        let slideFound = false;
        if (slide) {
            for (let i = 0; i < swiper.slides.length; i += 1) {
                if (swiper.slides[i] === slide) slideFound = true;
            }
        }
        if (slide && slideFound) {
            swiper.clickedSlide = slide;
            if (swiper.virtual && swiper.params.virtual.enabled) {
                swiper.clickedIndex = parseInt(Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(slide).attr('data-swiper-slide-index'), 10);
            } else {
                swiper.clickedIndex = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(slide).index();
            }
        } else {
            swiper.clickedSlide = undefined;
            swiper.clickedIndex = undefined;
            return;
        }
        if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
            swiper.slideToClickedSlide();
        }
    }
    var update = {
        updateSize, updateSlides, updateAutoHeight, updateSlidesOffset, updateSlidesProgress, updateProgress, updateSlidesClasses, updateActiveIndex, updateClickedSlide,
    };

    function getTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
        const swiper = this;
        const {
            params, rtlTranslate: rtl, translate, $wrapperEl,
        } = swiper;
        if (params.virtualTranslate) {
            return rtl ? -translate : translate;
        }
        let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
        if (rtl) currentTranslate = -currentTranslate;
        return currentTranslate || 0;
    }

    function setTranslate(translate, byController) {
        const swiper = this;
        const {
            rtlTranslate: rtl,
            params,
            $wrapperEl,
            progress,
        } = swiper;
        let x = 0;
        let y = 0;
        const z = 0;
        if (swiper.isHorizontal()) {
            x = rtl ? -translate : translate;
        } else {
            y = translate;
        }
        if (params.roundLengths) {
            x = Math.floor(x);
            y = Math.floor(y);
        }
        if (!params.virtualTranslate) {
            if (Support.transforms3d) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
            else $wrapperEl.transform(`translate(${x}px, ${y}px)`);
        }
        swiper.previousTranslate = swiper.translate;
        swiper.translate = swiper.isHorizontal() ? x : y;
        let newProgress;
        const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
        if (translatesDiff === 0) {
            newProgress = 0;
        } else {
            newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
        }
        if (newProgress !== progress) {
            swiper.updateProgress(translate);
        }
        swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate() {
        return (-this.snapGrid[0]);
    }

    function maxTranslate() {
        return (-this.snapGrid[this.snapGrid.length - 1]);
    }
    var translate = {
        getTranslate, setTranslate, minTranslate, maxTranslate,
    };

    function setTransition(duration, byController) {
        const swiper = this;
        swiper.$wrapperEl.transition(duration);
        swiper.emit('setTransition', duration, byController);
    }

    function transitionStart(runCallbacks = true, direction) {
        const swiper = this;
        const {
            activeIndex, params, previousIndex
        } = swiper;
        if (params.autoHeight) {
            swiper.updateAutoHeight();
        }
        let dir = direction;
        if (!dir) {
            if (activeIndex > previousIndex) dir = 'next';
            else if (activeIndex < previousIndex) dir = 'prev';
            else dir = 'reset';
        }
        swiper.emit('transitionStart');
        if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === 'reset') {
                swiper.emit('slideResetTransitionStart');
                return;
            }
            swiper.emit('slideChangeTransitionStart');
            if (dir === 'next') {
                swiper.emit('slideNextTransitionStart');
            } else {
                swiper.emit('slidePrevTransitionStart');
            }
        }
    }

    function transitionEnd$1(runCallbacks = true, direction) {
        const swiper = this;
        const {
            activeIndex, previousIndex
        } = swiper;
        swiper.animating = false;
        swiper.setTransition(0);
        let dir = direction;
        if (!dir) {
            if (activeIndex > previousIndex) dir = 'next';
            else if (activeIndex < previousIndex) dir = 'prev';
            else dir = 'reset';
        }
        swiper.emit('transitionEnd');
        if (runCallbacks && activeIndex !== previousIndex) {
            if (dir === 'reset') {
                swiper.emit('slideResetTransitionEnd');
                return;
            }
            swiper.emit('slideChangeTransitionEnd');
            if (dir === 'next') {
                swiper.emit('slideNextTransitionEnd');
            } else {
                swiper.emit('slidePrevTransitionEnd');
            }
        }
    }
    var transition$1 = {
        setTransition, transitionStart, transitionEnd: transitionEnd$1,
    };

    function slideTo(index$$1 = 0, speed = this.params.speed, runCallbacks = true, internal) {
        const swiper = this;
        let slideIndex = index$$1;
        if (slideIndex < 0) slideIndex = 0;
        const {
            params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl,
        } = swiper;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return false;
        }
        let snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
        if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
        if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
            swiper.emit('beforeSlideChangeStart');
        }
        const translate = -snapGrid[snapIndex];
        swiper.updateProgress(translate);
        if (params.normalizeSlideIndex) {
            for (let i = 0; i < slidesGrid.length; i += 1) {
                if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
                    slideIndex = i;
                }
            }
        }
        if (swiper.initialized && slideIndex !== activeIndex) {
            if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
                return false;
            }
            if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
                if ((activeIndex || 0) !== slideIndex) return false;
            }
        }
        let direction;
        if (slideIndex > activeIndex) direction = 'next';
        else if (slideIndex < activeIndex) direction = 'prev';
        else direction = 'reset';
        if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
            swiper.updateActiveIndex(slideIndex);
            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
            swiper.updateSlidesClasses();
            if (params.effect !== 'slide') {
                swiper.setTranslate(translate);
            }
            if (direction !== 'reset') {
                swiper.transitionStart(runCallbacks, direction);
                swiper.transitionEnd(runCallbacks, direction);
            }
            return false;
        }
        if (speed === 0 || !Support.transition) {
            swiper.setTransition(0);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit('beforeTransitionStart', speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
        } else {
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit('beforeTransitionStart', speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) {
                    swiper.onSlideToWrapperTransitionEnd = function transitionEnd$$1(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
                        swiper.onSlideToWrapperTransitionEnd = null;
                        delete swiper.onSlideToWrapperTransitionEnd;
                        swiper.transitionEnd(runCallbacks, direction);
                    };
                }
                swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
                swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            }
        }
        return true;
    }

    function slideToLoop(index$$1 = 0, speed = this.params.speed, runCallbacks = true, internal) {
        const swiper = this;
        let newIndex = index$$1;
        if (swiper.params.loop) {
            newIndex += swiper.loopedSlides;
        }
        return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
        const swiper = this;
        const {
            params, animating
        } = swiper;
        if (params.loop) {
            if (animating) return false;
            swiper.loopFix();
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
            return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
        }
        return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
    }

    function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
        const swiper = this;
        const {
            params, animating, snapGrid, slidesGrid, rtlTranslate,
        } = swiper;
        if (params.loop) {
            if (animating) return false;
            swiper.loopFix();
            swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        }
        const translate = rtlTranslate ? swiper.translate : -swiper.translate;

        function normalize(val) {
            if (val < 0) return -Math.floor(Math.abs(val));
            return Math.floor(val);
        }
        const normalizedTranslate = normalize(translate);
        const normalizedSnapGrid = snapGrid.map(val => normalize(val));
        const normalizedSlidesGrid = slidesGrid.map(val => normalize(val));
        const currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
        const prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
        let prevIndex;
        if (typeof prevSnap !== 'undefined') {
            prevIndex = slidesGrid.indexOf(prevSnap);
            if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
        }
        return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
        const swiper = this;
        return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    function slideToClosest(speed = this.params.speed, runCallbacks = true, internal) {
        const swiper = this;
        let index$$1 = swiper.activeIndex;
        const snapIndex = Math.floor(index$$1 / swiper.params.slidesPerGroup);
        if (snapIndex < swiper.snapGrid.length - 1) {
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            const currentSnap = swiper.snapGrid[snapIndex];
            const nextSnap = swiper.snapGrid[snapIndex + 1];
            if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {
                index$$1 = swiper.params.slidesPerGroup;
            }
        }
        return swiper.slideTo(index$$1, speed, runCallbacks, internal);
    }

    function slideToClickedSlide() {
        const swiper = this;
        const {
            params, $wrapperEl
        } = swiper;
        const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
        let slideToIndex = swiper.clickedIndex;
        let realIndex;
        if (params.loop) {
            if (swiper.animating) return;
            realIndex = parseInt(Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
            if (params.centeredSlides) {
                if ((slideToIndex < swiper.loopedSlides - (slidesPerView / 2)) || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))) {
                    swiper.loopFix();
                    slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                    Utils.nextTick(() => {
                        swiper.slideTo(slideToIndex);
                    });
                } else {
                    swiper.slideTo(slideToIndex);
                }
            } else if (slideToIndex > swiper.slides.length - slidesPerView) {
                swiper.loopFix();
                slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                Utils.nextTick(() => {
                    swiper.slideTo(slideToIndex);
                });
            } else {
                swiper.slideTo(slideToIndex);
            }
        } else {
            swiper.slideTo(slideToIndex);
        }
    }
    var slide = {
        slideTo, slideToLoop, slideNext, slidePrev, slideReset, slideToClosest, slideToClickedSlide,
    };

    function loopCreate() {
        const swiper = this;
        const {
            params, $wrapperEl
        } = swiper;
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
        let slides = $wrapperEl.children(`.${params.slideClass}`);
        if (params.loopFillGroupWithBlank) {
            const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
            if (blankSlidesNum !== params.slidesPerGroup) {
                for (let i = 0; i < blankSlidesNum; i += 1) {
                    const blankNode = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
                    $wrapperEl.append(blankNode);
                }
                slides = $wrapperEl.children(`.${params.slideClass}`);
            }
        }
        if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
        swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
        swiper.loopedSlides += params.loopAdditionalSlides;
        if (swiper.loopedSlides > slides.length) {
            swiper.loopedSlides = slides.length;
        }
        const prependSlides = [];
        const appendSlides = [];
        slides.each((index$$1, el) => {
            const slide = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(el);
            if (index$$1 < swiper.loopedSlides) appendSlides.push(el);
            if (index$$1 < slides.length && index$$1 >= slides.length - swiper.loopedSlides) prependSlides.push(el);
            slide.attr('data-swiper-slide-index', index$$1);
        });
        for (let i = 0; i < appendSlides.length; i += 1) {
            $wrapperEl.append(Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
        for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
            $wrapperEl.prepend(Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
    }

    function loopFix() {
        const swiper = this;
        const {
            params, activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,
        } = swiper;
        let newIndex;
        swiper.allowSlidePrev = true;
        swiper.allowSlideNext = true;
        const snapTranslate = -snapGrid[activeIndex];
        const diff = snapTranslate - swiper.getTranslate();
        if (activeIndex < loopedSlides) {
            newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
            newIndex += loopedSlides;
            const slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex >= slides.length - loopedSlides)) {
            newIndex = -slides.length + activeIndex + loopedSlides;
            newIndex += loopedSlides;
            const slideChanged = swiper.slideTo(newIndex, 0, false, true);
            if (slideChanged && diff !== 0) {
                swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
        }
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
    }

    function loopDestroy() {
        const swiper = this;
        const {
            $wrapperEl, params, slides
        } = swiper;
        $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
        slides.removeAttr('data-swiper-slide-index');
    }
    var loop = {
        loopCreate, loopFix, loopDestroy,
    };

    function setGrabCursor(moving) {
        const swiper = this;
        if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) return;
        const el = swiper.el;
        el.style.cursor = 'move';
        el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
        el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
        el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor() {
        const swiper = this;
        if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) return;
        swiper.el.style.cursor = '';
    }
    var grabCursor = {
        setGrabCursor, unsetGrabCursor,
    };

    function appendSlide(slides) {
        const swiper = this;
        const {
            $wrapperEl, params
        } = swiper;
        if (params.loop) {
            swiper.loopDestroy();
        }
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.append(slides[i]);
            }
        } else {
            $wrapperEl.append(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
    }

    function prependSlide(slides) {
        const swiper = this;
        const {
            params, $wrapperEl, activeIndex
        } = swiper;
        if (params.loop) {
            swiper.loopDestroy();
        }
        let newActiveIndex = activeIndex + 1;
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.prepend(slides[i]);
            }
            newActiveIndex = activeIndex + slides.length;
        } else {
            $wrapperEl.prepend(slides);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
        swiper.slideTo(newActiveIndex, 0, false);
    }

    function addSlide(index$$1, slides) {
        const swiper = this;
        const {
            $wrapperEl, params, activeIndex
        } = swiper;
        let activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
        }
        const baseLength = swiper.slides.length;
        if (index$$1 <= 0) {
            swiper.prependSlide(slides);
            return;
        }
        if (index$$1 >= baseLength) {
            swiper.appendSlide(slides);
            return;
        }
        let newActiveIndex = activeIndexBuffer > index$$1 ? activeIndexBuffer + 1 : activeIndexBuffer;
        const slidesBuffer = [];
        for (let i = baseLength - 1; i >= index$$1; i -= 1) {
            const currentSlide = swiper.slides.eq(i);
            currentSlide.remove();
            slidesBuffer.unshift(currentSlide);
        }
        if (typeof slides === 'object' && 'length' in slides) {
            for (let i = 0; i < slides.length; i += 1) {
                if (slides[i]) $wrapperEl.append(slides[i]);
            }
            newActiveIndex = activeIndexBuffer > index$$1 ? activeIndexBuffer + slides.length : activeIndexBuffer;
        } else {
            $wrapperEl.append(slides);
        }
        for (let i = 0; i < slidesBuffer.length; i += 1) {
            $wrapperEl.append(slidesBuffer[i]);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }

    function removeSlide(slidesIndexes) {
        const swiper = this;
        const {
            params, $wrapperEl, activeIndex
        } = swiper;
        let activeIndexBuffer = activeIndex;
        if (params.loop) {
            activeIndexBuffer -= swiper.loopedSlides;
            swiper.loopDestroy();
            swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
        }
        let newActiveIndex = activeIndexBuffer;
        let indexToRemove;
        if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
            for (let i = 0; i < slidesIndexes.length; i += 1) {
                indexToRemove = slidesIndexes[i];
                if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
                if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
        } else {
            indexToRemove = slidesIndexes;
            if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
            newActiveIndex = Math.max(newActiveIndex, 0);
        }
        if (params.loop) {
            swiper.loopCreate();
        }
        if (!(params.observer && Support.observer)) {
            swiper.update();
        }
        if (params.loop) {
            swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
        } else {
            swiper.slideTo(newActiveIndex, 0, false);
        }
    }

    function removeAllSlides() {
        const swiper = this;
        const slidesIndexes = [];
        for (let i = 0; i < swiper.slides.length; i += 1) {
            slidesIndexes.push(i);
        }
        swiper.removeSlide(slidesIndexes);
    }
    var manipulation = {
        appendSlide, prependSlide, addSlide, removeSlide, removeAllSlides,
    };
    const Device = (function Device() {
        const ua = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].navigator.userAgent;
        const device = {
            ios: false,
            android: false,
            androidChrome: false,
            desktop: false,
            windows: false,
            iphone: false,
            ipod: false,
            ipad: false,
            cordova: __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].cordova || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].phonegap,
            phonegap: __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].cordova || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].phonegap,
        };
        const windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/);
        const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
        const ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
        if (windows) {
            device.os = 'windows';
            device.osVersion = windows[2];
            device.windows = true;
        }
        if (android && !windows) {
            device.os = 'android';
            device.osVersion = android[2];
            device.android = true;
            device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
        }
        if (ipad || iphone || ipod) {
            device.os = 'ios';
            device.ios = true;
        }
        if (iphone && !ipod) {
            device.osVersion = iphone[2].replace(/_/g, '.');
            device.iphone = true;
        }
        if (ipad) {
            device.osVersion = ipad[2].replace(/_/g, '.');
            device.ipad = true;
        }
        if (ipod) {
            device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
            device.iphone = true;
        }
        if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
            if (device.osVersion.split('.')[0] === '10') {
                device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
            }
        }
        device.desktop = !(device.os || device.android || device.webView);
        device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);
        if (device.os && device.os === 'ios') {
            const osVersionArr = device.osVersion.split('.');
            const metaViewport = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].querySelector('meta[name="viewport"]');
            device.minimalUi = !device.webView && (ipod || iphone) && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7) && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;
        }
        device.pixelRatio = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].devicePixelRatio || 1;
        return device;
    }());

    function onTouchStart(event) {
        const swiper = this;
        const data$$1 = swiper.touchEventsData;
        const {
            params, touches
        } = swiper;
        if (swiper.animating && params.preventInteractionOnTransition) {
            return;
        }
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        data$$1.isTouchEvent = e.type === 'touchstart';
        if (!data$$1.isTouchEvent && 'which' in e && e.which === 3) return;
        if (data$$1.isTouched && data$$1.isMoved) return;
        if (params.noSwiping && Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {
            swiper.allowClick = true;
            return;
        }
        if (params.swipeHandler) {
            if (!Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(e).closest(params.swipeHandler)[0]) return;
        }
        touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        const startX = touches.currentX;
        const startY = touches.currentY;
        const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
        const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
        if (edgeSwipeDetection && ((startX <= edgeSwipeThreshold) || (startX >= __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].screen.width - edgeSwipeThreshold))) {
            return;
        }
        Utils.extend(data$$1, {
            isTouched: true,
            isMoved: false,
            allowTouchCallbacks: true,
            isScrolling: undefined,
            startMoving: undefined,
        });
        touches.startX = startX;
        touches.startY = startY;
        data$$1.touchStartTime = Utils.now();
        swiper.allowClick = true;
        swiper.updateSize();
        swiper.swipeDirection = undefined;
        if (params.threshold > 0) data$$1.allowThresholdMove = false;
        if (e.type !== 'touchstart') {
            let preventDefault = true;
            if (Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(e.target).is(data$$1.formElements)) preventDefault = false;
            if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].activeElement && Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].activeElement).is(data$$1.formElements) && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].activeElement !== e.target) {
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].activeElement.blur();
            }
            if (preventDefault && swiper.allowTouchMove) {
                e.preventDefault();
            }
        }
        swiper.emit('touchStart', e);
    }

    function onTouchMove(event) {
        const swiper = this;
        const data$$1 = swiper.touchEventsData;
        const {
            params, touches, rtlTranslate: rtl
        } = swiper;
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        if (!data$$1.isTouched) {
            if (data$$1.startMoving && data$$1.isScrolling) {
                swiper.emit('touchMoveOpposite', e);
            }
            return;
        }
        if (data$$1.isTouchEvent && e.type === 'mousemove') return;
        const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        if (e.preventedByNestedSwiper) {
            touches.startX = pageX;
            touches.startY = pageY;
            return;
        }
        if (!swiper.allowTouchMove) {
            swiper.allowClick = false;
            if (data$$1.isTouched) {
                Utils.extend(touches, {
                    startX: pageX,
                    startY: pageY,
                    currentX: pageX,
                    currentY: pageY,
                });
                data$$1.touchStartTime = Utils.now();
            }
            return;
        }
        if (data$$1.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
            if (swiper.isVertical()) {
                if ((pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())) {
                    data$$1.isTouched = false;
                    data$$1.isMoved = false;
                    return;
                }
            } else if ((pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())) {
                return;
            }
        }
        if (data$$1.isTouchEvent && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].activeElement) {
            if (e.target === __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].activeElement && Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(e.target).is(data$$1.formElements)) {
                data$$1.isMoved = true;
                swiper.allowClick = false;
                return;
            }
        }
        if (data$$1.allowTouchCallbacks) {
            swiper.emit('touchMove', e);
        }
        if (e.targetTouches && e.targetTouches.length > 1) return;
        touches.currentX = pageX;
        touches.currentY = pageY;
        const diffX = touches.currentX - touches.startX;
        const diffY = touches.currentY - touches.startY;
        if (swiper.params.threshold && Math.sqrt((diffX ** 2) + (diffY ** 2)) < swiper.params.threshold) return;
        if (typeof data$$1.isScrolling === 'undefined') {
            let touchAngle;
            if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
                data$$1.isScrolling = false;
            } else {
                if ((diffX * diffX) + (diffY * diffY) >= 25) {
                    touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
                    data$$1.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
                }
            }
        }
        if (data$$1.isScrolling) {
            swiper.emit('touchMoveOpposite', e);
        }
        if (typeof data$$1.startMoving === 'undefined') {
            if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
                data$$1.startMoving = true;
            }
        }
        if (data$$1.isScrolling) {
            data$$1.isTouched = false;
            return;
        }
        if (!data$$1.startMoving) {
            return;
        }
        swiper.allowClick = false;
        e.preventDefault();
        if (params.touchMoveStopPropagation && !params.nested) {
            e.stopPropagation();
        }
        if (!data$$1.isMoved) {
            if (params.loop) {
                swiper.loopFix();
            }
            data$$1.startTranslate = swiper.getTranslate();
            swiper.setTransition(0);
            if (swiper.animating) {
                swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
            }
            data$$1.allowMomentumBounce = false;
            if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
                swiper.setGrabCursor(true);
            }
            swiper.emit('sliderFirstMove', e);
        }
        swiper.emit('sliderMove', e);
        data$$1.isMoved = true;
        let diff = swiper.isHorizontal() ? diffX : diffY;
        touches.diff = diff;
        diff *= params.touchRatio;
        if (rtl) diff = -diff;
        swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
        data$$1.currentTranslate = diff + data$$1.startTranslate;
        let disableParentSwiper = true;
        let resistanceRatio = params.resistanceRatio;
        if (params.touchReleaseOnEdges) {
            resistanceRatio = 0;
        }
        if ((diff > 0 && data$$1.currentTranslate > swiper.minTranslate())) {
            disableParentSwiper = false;
            if (params.resistance) data$$1.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data$$1.startTranslate + diff) ** resistanceRatio);
        } else if (diff < 0 && data$$1.currentTranslate < swiper.maxTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) data$$1.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data$$1.startTranslate - diff) ** resistanceRatio);
        }
        if (disableParentSwiper) {
            e.preventedByNestedSwiper = true;
        }
        if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data$$1.currentTranslate < data$$1.startTranslate) {
            data$$1.currentTranslate = data$$1.startTranslate;
        }
        if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data$$1.currentTranslate > data$$1.startTranslate) {
            data$$1.currentTranslate = data$$1.startTranslate;
        }
        if (params.threshold > 0) {
            if (Math.abs(diff) > params.threshold || data$$1.allowThresholdMove) {
                if (!data$$1.allowThresholdMove) {
                    data$$1.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data$$1.currentTranslate = data$$1.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data$$1.currentTranslate = data$$1.startTranslate;
                return;
            }
        }
        if (!params.followFinger) return;
        if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        if (params.freeMode) {
            if (data$$1.velocities.length === 0) {
                data$$1.velocities.push({
                    position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
                    time: data$$1.touchStartTime,
                });
            }
            data$$1.velocities.push({
                position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
                time: Utils.now(),
            });
        }
        swiper.updateProgress(data$$1.currentTranslate);
        swiper.setTranslate(data$$1.currentTranslate);
    }

    function onTouchEnd(event) {
        const swiper = this;
        const data$$1 = swiper.touchEventsData;
        const {
            params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,
        } = swiper;
        let e = event;
        if (e.originalEvent) e = e.originalEvent;
        if (data$$1.allowTouchCallbacks) {
            swiper.emit('touchEnd', e);
        }
        data$$1.allowTouchCallbacks = false;
        if (!data$$1.isTouched) {
            if (data$$1.isMoved && params.grabCursor) {
                swiper.setGrabCursor(false);
            }
            data$$1.isMoved = false;
            data$$1.startMoving = false;
            return;
        }
        if (params.grabCursor && data$$1.isMoved && data$$1.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(false);
        }
        const touchEndTime = Utils.now();
        const timeDiff = touchEndTime - data$$1.touchStartTime;
        if (swiper.allowClick) {
            swiper.updateClickedSlide(e);
            swiper.emit('tap', e);
            if (timeDiff < 300 && (touchEndTime - data$$1.lastClickTime) > 300) {
                if (data$$1.clickTimeout) clearTimeout(data$$1.clickTimeout);
                data$$1.clickTimeout = Utils.nextTick(() => {
                    if (!swiper || swiper.destroyed) return;
                    swiper.emit('click', e);
                }, 300);
            }
            if (timeDiff < 300 && (touchEndTime - data$$1.lastClickTime) < 300) {
                if (data$$1.clickTimeout) clearTimeout(data$$1.clickTimeout);
                swiper.emit('doubleTap', e);
            }
        }
        data$$1.lastClickTime = Utils.now();
        Utils.nextTick(() => {
            if (!swiper.destroyed) swiper.allowClick = true;
        });
        if (!data$$1.isTouched || !data$$1.isMoved || !swiper.swipeDirection || touches.diff === 0 || data$$1.currentTranslate === data$$1.startTranslate) {
            data$$1.isTouched = false;
            data$$1.isMoved = false;
            data$$1.startMoving = false;
            return;
        }
        data$$1.isTouched = false;
        data$$1.isMoved = false;
        data$$1.startMoving = false;
        let currentPos;
        if (params.followFinger) {
            currentPos = rtl ? swiper.translate : -swiper.translate;
        } else {
            currentPos = -data$$1.currentTranslate;
        }
        if (params.freeMode) {
            if (currentPos < -swiper.minTranslate()) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (currentPos > -swiper.maxTranslate()) {
                if (swiper.slides.length < snapGrid.length) {
                    swiper.slideTo(snapGrid.length - 1);
                } else {
                    swiper.slideTo(swiper.slides.length - 1);
                }
                return;
            }
            if (params.freeModeMomentum) {
                if (data$$1.velocities.length > 1) {
                    const lastMoveEvent = data$$1.velocities.pop();
                    const velocityEvent = data$$1.velocities.pop();
                    const distance = lastMoveEvent.position - velocityEvent.position;
                    const time = lastMoveEvent.time - velocityEvent.time;
                    swiper.velocity = distance / time;
                    swiper.velocity /= 2;
                    if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
                        swiper.velocity = 0;
                    }
                    if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
                        swiper.velocity = 0;
                    }
                } else {
                    swiper.velocity = 0;
                }
                swiper.velocity *= params.freeModeMomentumVelocityRatio;
                data$$1.velocities.length = 0;
                let momentumDuration = 1000 * params.freeModeMomentumRatio;
                const momentumDistance = swiper.velocity * momentumDuration;
                let newPosition = swiper.translate + momentumDistance;
                if (rtl) newPosition = -newPosition;
                let doBounce = false;
                let afterBouncePosition;
                const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
                let needsLoopFix;
                if (newPosition < swiper.maxTranslate()) {
                    if (params.freeModeMomentumBounce) {
                        if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                            newPosition = swiper.maxTranslate() - bounceAmount;
                        }
                        afterBouncePosition = swiper.maxTranslate();
                        doBounce = true;
                        data$$1.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.maxTranslate();
                    }
                    if (params.loop && params.centeredSlides) needsLoopFix = true;
                } else if (newPosition > swiper.minTranslate()) {
                    if (params.freeModeMomentumBounce) {
                        if (newPosition - swiper.minTranslate() > bounceAmount) {
                            newPosition = swiper.minTranslate() + bounceAmount;
                        }
                        afterBouncePosition = swiper.minTranslate();
                        doBounce = true;
                        data$$1.allowMomentumBounce = true;
                    } else {
                        newPosition = swiper.minTranslate();
                    }
                    if (params.loop && params.centeredSlides) needsLoopFix = true;
                } else if (params.freeModeSticky) {
                    let nextSlide;
                    for (let j = 0; j < snapGrid.length; j += 1) {
                        if (snapGrid[j] > -newPosition) {
                            nextSlide = j;
                            break;
                        }
                    }
                    if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
                        newPosition = snapGrid[nextSlide];
                    } else {
                        newPosition = snapGrid[nextSlide - 1];
                    }
                    newPosition = -newPosition;
                }
                if (needsLoopFix) {
                    swiper.once('transitionEnd', () => {
                        swiper.loopFix();
                    });
                }
                if (swiper.velocity !== 0) {
                    if (rtl) {
                        momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                    } else {
                        momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                    }
                } else if (params.freeModeSticky) {
                    swiper.slideToClosest();
                    return;
                }
                if (params.freeModeMomentumBounce && doBounce) {
                    swiper.updateProgress(afterBouncePosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    swiper.animating = true;
                    $wrapperEl.transitionEnd(() => {
                        if (!swiper || swiper.destroyed || !data$$1.allowMomentumBounce) return;
                        swiper.emit('momentumBounce');
                        swiper.setTransition(params.speed);
                        swiper.setTranslate(afterBouncePosition);
                        $wrapperEl.transitionEnd(() => {
                            if (!swiper || swiper.destroyed) return;
                            swiper.transitionEnd();
                        });
                    });
                } else if (swiper.velocity) {
                    swiper.updateProgress(newPosition);
                    swiper.setTransition(momentumDuration);
                    swiper.setTranslate(newPosition);
                    swiper.transitionStart(true, swiper.swipeDirection);
                    if (!swiper.animating) {
                        swiper.animating = true;
                        $wrapperEl.transitionEnd(() => {
                            if (!swiper || swiper.destroyed) return;
                            swiper.transitionEnd();
                        });
                    }
                } else {
                    swiper.updateProgress(newPosition);
                }
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            } else if (params.freeModeSticky) {
                swiper.slideToClosest();
                return;
            }
            if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            return;
        }
        let stopIndex = 0;
        let groupSize = swiper.slidesSizesGrid[0];
        for (let i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
            if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
                if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
                    stopIndex = i;
                    groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
                }
            } else if (currentPos >= slidesGrid[i]) {
                stopIndex = i;
                groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
            }
        }
        const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
        if (timeDiff > params.longSwipesMs) {
            if (!params.longSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (swiper.swipeDirection === 'next') {
                if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);
                else swiper.slideTo(stopIndex);
            }
            if (swiper.swipeDirection === 'prev') {
                if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + params.slidesPerGroup);
                else swiper.slideTo(stopIndex);
            }
        } else {
            if (!params.shortSwipes) {
                swiper.slideTo(swiper.activeIndex);
                return;
            }
            if (swiper.swipeDirection === 'next') {
                swiper.slideTo(stopIndex + params.slidesPerGroup);
            }
            if (swiper.swipeDirection === 'prev') {
                swiper.slideTo(stopIndex);
            }
        }
    }

    function onResize() {
        const swiper = this;
        const {
            params, el
        } = swiper;
        if (el && el.offsetWidth === 0) return;
        if (params.breakpoints) {
            swiper.setBreakpoint();
        }
        const {
            allowSlideNext, allowSlidePrev, snapGrid
        } = swiper;
        swiper.allowSlideNext = true;
        swiper.allowSlidePrev = true;
        swiper.updateSize();
        swiper.updateSlides();
        if (params.freeMode) {
            const newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
        } else {
            swiper.updateSlidesClasses();
            if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                swiper.slideTo(swiper.slides.length - 1, 0, false, true);
            } else {
                swiper.slideTo(swiper.activeIndex, 0, false, true);
            }
        }
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
        }
    }

    function onClick(e) {
        const swiper = this;
        if (!swiper.allowClick) {
            if (swiper.params.preventClicks) e.preventDefault();
            if (swiper.params.preventClicksPropagation && swiper.animating) {
                e.stopPropagation();
                e.stopImmediatePropagation();
            }
        }
    }

    function attachEvents() {
        const swiper = this;
        const {
            params, touchEvents, el, wrapperEl,
        } = swiper; {
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
        }
        swiper.onClick = onClick.bind(swiper);
        const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
        const capture = !!params.nested; {
            if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].addEventListener(touchEvents.move, swiper.onTouchMove, capture);
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].addEventListener(touchEvents.end, swiper.onTouchEnd, false);
            } else {
                if (Support.touch) {
                    const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? {
                        passive: true,
                        capture: false
                    } : false;
                    target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
                    target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? {
                        passive: false,
                        capture
                    } : capture);
                    target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
                }
                if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
                    target.addEventListener('mousedown', swiper.onTouchStart, false);
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].addEventListener('mousemove', swiper.onTouchMove, capture);
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].addEventListener('mouseup', swiper.onTouchEnd, false);
                }
            }
            if (params.preventClicks || params.preventClicksPropagation) {
                target.addEventListener('click', swiper.onClick, true);
            }
        }
        swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
    }

    function detachEvents() {
        const swiper = this;
        const {
            params, touchEvents, el, wrapperEl,
        } = swiper;
        const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
        const capture = !!params.nested; {
            if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
            } else {
                if (Support.touch) {
                    const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? {
                        passive: true,
                        capture: false
                    } : false;
                    target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
                    target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
                    target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
                }
                if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
                    target.removeEventListener('mousedown', swiper.onTouchStart, false);
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].removeEventListener('mousemove', swiper.onTouchMove, capture);
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].removeEventListener('mouseup', swiper.onTouchEnd, false);
                }
            }
            if (params.preventClicks || params.preventClicksPropagation) {
                target.removeEventListener('click', swiper.onClick, true);
            }
        }
        swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
    }
    var events = {
        attachEvents, detachEvents,
    };

    function setBreakpoint() {
        const swiper = this;
        const {
            activeIndex, initialized, loopedSlides = 0, params,
        } = swiper;
        const breakpoints = params.breakpoints;
        if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;
        const breakpoint = swiper.getBreakpoint(breakpoints);
        if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
            const breakPointsParams = breakpoint in breakpoints ? breakpoints[breakpoint] : swiper.originalParams;
            const needsReLoop = params.loop && (breakPointsParams.slidesPerView !== params.slidesPerView);
            Utils.extend(swiper.params, breakPointsParams);
            Utils.extend(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev,
            });
            swiper.currentBreakpoint = breakpoint;
            if (needsReLoop && initialized) {
                swiper.loopDestroy();
                swiper.loopCreate();
                swiper.updateSlides();
                swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
            }
            swiper.emit('breakpoint', breakPointsParams);
        }
    }

    function getBreakpoint(breakpoints) {
        if (!breakpoints) return undefined;
        let breakpoint = false;
        const points = [];
        Object.keys(breakpoints).forEach((point) => {
            points.push(point);
        });
        points.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
        for (let i = 0; i < points.length; i += 1) {
            const point = points[i];
            if (point >= __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].innerWidth && !breakpoint) {
                breakpoint = point;
            }
        }
        return breakpoint || 'max';
    }
    var breakpoints = {
        setBreakpoint, getBreakpoint
    };
    const Browser = (function Browser() {
        function isSafari() {
            const ua = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].navigator.userAgent.toLowerCase();
            return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
        }
        return {
            isIE: !!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].navigator.userAgent.match(/Trident/g) || !!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].navigator.userAgent.match(/MSIE/g),
            isSafari: isSafari(),
            isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].navigator.userAgent),
        };
    }());

    function addClasses() {
        const swiper = this;
        const {
            classNames, params, rtl, $el,
        } = swiper;
        const suffixes = [];
        suffixes.push(params.direction);
        if (params.freeMode) {
            suffixes.push('free-mode');
        }
        if (!Support.flexbox) {
            suffixes.push('no-flexbox');
        }
        if (params.autoHeight) {
            suffixes.push('autoheight');
        }
        if (rtl) {
            suffixes.push('rtl');
        }
        if (params.slidesPerColumn > 1) {
            suffixes.push('multirow');
        }
        if (Device.android) {
            suffixes.push('android');
        }
        if (Device.ios) {
            suffixes.push('ios');
        }
        if (Browser.isIE && (Support.pointerEvents || Support.prefixedPointerEvents)) {
            suffixes.push(`wp8-${params.direction}`);
        }
        suffixes.forEach((suffix) => {
            classNames.push(params.containerModifierClass + suffix);
        });
        $el.addClass(classNames.join(' '));
    }

    function removeClasses() {
        const swiper = this;
        const {
            $el, classNames
        } = swiper;
        $el.removeClass(classNames.join(' '));
    }
    var classes = {
        addClasses, removeClasses
    };

    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
        let image;

        function onReady() {
            if (callback) callback();
        }
        if (!imageEl.complete || !checkForComplete) {
            if (src) {
                image = new __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].Image();
                image.onload = onReady;
                image.onerror = onReady;
                if (sizes) {
                    image.sizes = sizes;
                }
                if (srcset) {
                    image.srcset = srcset;
                }
                if (src) {
                    image.src = src;
                }
            } else {
                onReady();
            }
        } else {
            onReady();
        }
    }

    function preloadImages() {
        const swiper = this;
        swiper.imagesToLoad = swiper.$el.find('img');

        function onReady() {
            if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
            if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
            if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
                if (swiper.params.updateOnImagesReady) swiper.update();
                swiper.emit('imagesReady');
            }
        }
        for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
            const imageEl = swiper.imagesToLoad[i];
            swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
        }
    }
    var images = {
        loadImage, preloadImages,
    };

    function checkOverflow() {
        const swiper = this;
        const wasLocked = swiper.isLocked;
        swiper.isLocked = swiper.snapGrid.length === 1;
        swiper.allowSlideNext = !swiper.isLocked;
        swiper.allowSlidePrev = !swiper.isLocked;
        if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
        if (wasLocked && wasLocked !== swiper.isLocked) {
            swiper.isEnd = false;
            swiper.navigation.update();
        }
    }
    var checkOverflow$1 = {
        checkOverflow
    };
    var defaults = {
        init: true,
        direction: 'horizontal',
        touchEventsTarget: 'container',
        initialSlide: 0,
        speed: 300,
        preventInteractionOnTransition: false,
        edgeSwipeDetection: false,
        edgeSwipeThreshold: 20,
        freeMode: false,
        freeModeMomentum: true,
        freeModeMomentumRatio: 1,
        freeModeMomentumBounce: true,
        freeModeMomentumBounceRatio: 1,
        freeModeMomentumVelocityRatio: 1,
        freeModeSticky: false,
        freeModeMinimumVelocity: 0.02,
        autoHeight: false,
        setWrapperSize: false,
        virtualTranslate: false,
        effect: 'slide',
        breakpoints: undefined,
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerColumnFill: 'column',
        slidesPerGroup: 1,
        centeredSlides: false,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: true,
        watchOverflow: false,
        roundLengths: false,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: true,
        shortSwipes: true,
        longSwipes: true,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: true,
        allowTouchMove: true,
        threshold: 0,
        touchMoveStopPropagation: true,
        touchReleaseOnEdges: false,
        uniqueNavElements: true,
        resistance: true,
        resistanceRatio: 0.85,
        watchSlidesProgress: false,
        watchSlidesVisibility: false,
        grabCursor: false,
        preventClicks: true,
        preventClicksPropagation: true,
        slideToClickedSlide: false,
        preloadImages: true,
        updateOnImagesReady: true,
        loop: false,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: false,
        allowSlidePrev: true,
        allowSlideNext: true,
        swipeHandler: null,
        noSwiping: true,
        noSwipingClass: 'swiper-no-swiping',
        noSwipingSelector: null,
        passiveListeners: true,
        containerModifierClass: 'swiper-container-',
        slideClass: 'swiper-slide',
        slideBlankClass: 'swiper-slide-invisible-blank',
        slideActiveClass: 'swiper-slide-active',
        slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
        slideVisibleClass: 'swiper-slide-visible',
        slideDuplicateClass: 'swiper-slide-duplicate',
        slideNextClass: 'swiper-slide-next',
        slideDuplicateNextClass: 'swiper-slide-duplicate-next',
        slidePrevClass: 'swiper-slide-prev',
        slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
        wrapperClass: 'swiper-wrapper',
        runCallbacksOnInit: true,
    };
    const prototypes = {
        update, translate, transition: transition$1, slide, loop, grabCursor, manipulation, events, breakpoints, checkOverflow: checkOverflow$1, classes, images,
    };
    const extendedDefaults = {};
    class Swiper extends SwiperClass {
        constructor(...args) {
            let el;
            let params;
            if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
                params = args[0];
            } else {
                [el, params] = args;
            }
            if (!params) params = {};
            params = Utils.extend({}, params);
            if (el && !params.el) params.el = el;
            super(params);
            Object.keys(prototypes).forEach((prototypeGroup) => {
                Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
                    if (!Swiper.prototype[protoMethod]) {
                        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
                    }
                });
            });
            const swiper = this;
            if (typeof swiper.modules === 'undefined') {
                swiper.modules = {};
            }
            Object.keys(swiper.modules).forEach((moduleName) => {
                const module = swiper.modules[moduleName];
                if (module.params) {
                    const moduleParamName = Object.keys(module.params)[0];
                    const moduleParams = module.params[moduleParamName];
                    if (typeof moduleParams !== 'object') return;
                    if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
                    if (params[moduleParamName] === true) {
                        params[moduleParamName] = {
                            enabled: true
                        };
                    }
                    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
                        params[moduleParamName].enabled = true;
                    }
                    if (!params[moduleParamName]) params[moduleParamName] = {
                        enabled: false
                    };
                }
            });
            const swiperParams = Utils.extend({}, defaults);
            swiper.useModulesParams(swiperParams);
            swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
            swiper.originalParams = Utils.extend({}, swiper.params);
            swiper.passedParams = Utils.extend({}, params);
            swiper.$ = __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"];
            const $el = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(swiper.params.el);
            el = $el[0];
            if (!el) {
                return undefined;
            }
            if ($el.length > 1) {
                const swipers = [];
                $el.each((index$$1, containerEl) => {
                    const newParams = Utils.extend({}, params, {
                        el: containerEl
                    });
                    swipers.push(new Swiper(newParams));
                });
                return swipers;
            }
            el.swiper = swiper;
            $el.data('swiper', swiper);
            const $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);
            Utils.extend(swiper, {
                $el, el, $wrapperEl, wrapperEl: $wrapperEl[0], classNames: [], slides: Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() {
                    return swiper.params.direction === 'horizontal';
                }, isVertical() {
                    return swiper.params.direction === 'vertical';
                }, rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'), rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'), wrongRTL: $wrapperEl.css('display') === '-webkit-box', activeIndex: 0, realIndex: 0, isBeginning: true, isEnd: false, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: false, allowSlideNext: swiper.params.allowSlideNext, allowSlidePrev: swiper.params.allowSlidePrev, touchEvents: (function touchEvents() {
                    const touch = ['touchstart', 'touchmove', 'touchend'];
                    let desktop = ['mousedown', 'mousemove', 'mouseup'];
                    if (Support.pointerEvents) {
                        desktop = ['pointerdown', 'pointermove', 'pointerup'];
                    } else if (Support.prefixedPointerEvents) {
                        desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
                    }
                    swiper.touchEventsTouch = {
                        start: touch[0],
                        move: touch[1],
                        end: touch[2],
                    };
                    swiper.touchEventsDesktop = {
                        start: desktop[0],
                        move: desktop[1],
                        end: desktop[2],
                    };
                    return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
                }()), touchEventsData: {
                    isTouched: undefined,
                    isMoved: undefined,
                    allowTouchCallbacks: undefined,
                    touchStartTime: undefined,
                    isScrolling: undefined,
                    currentTranslate: undefined,
                    startTranslate: undefined,
                    allowThresholdMove: undefined,
                    formElements: 'input, select, option, textarea, button, video',
                    lastClickTime: Utils.now(),
                    clickTimeout: undefined,
                    velocities: [],
                    allowMomentumBounce: undefined,
                    isTouchEvent: undefined,
                    startMoving: undefined,
                }, allowClick: true, allowTouchMove: swiper.params.allowTouchMove, touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0,
                }, imagesToLoad: [], imagesLoaded: 0,
            });
            swiper.useModules();
            if (swiper.params.init) {
                swiper.init();
            }
            return swiper;
        }
        slidesPerViewDynamic() {
            const swiper = this;
            const {
                params, slides, slidesGrid, size: swiperSize, activeIndex,
            } = swiper;
            let spv = 1;
            if (params.centeredSlides) {
                let slideSize = slides[activeIndex].swiperSlideSize;
                let breakLoop;
                for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                }
                for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                }
            } else {
                for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
                        spv += 1;
                    }
                }
            }
            return spv;
        }
        update() {
            const swiper = this;
            if (!swiper || swiper.destroyed) return;
            const {
                snapGrid, params
            } = swiper;
            if (params.breakpoints) {
                swiper.setBreakpoint();
            }
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();

            function setTranslate() {
                const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                swiper.setTranslate(newTranslate);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            let translated;
            if (swiper.params.freeMode) {
                setTranslate();
                if (swiper.params.autoHeight) {
                    swiper.updateAutoHeight();
                }
            } else {
                if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                    translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
                } else {
                    translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                }
                if (!translated) {
                    setTranslate();
                }
            }
            if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
                swiper.checkOverflow();
            }
            swiper.emit('update');
        }
        init() {
            const swiper = this;
            if (swiper.initialized) return;
            swiper.emit('beforeInit');
            if (swiper.params.breakpoints) {
                swiper.setBreakpoint();
            }
            swiper.addClasses();
            if (swiper.params.loop) {
                swiper.loopCreate();
            }
            swiper.updateSize();
            swiper.updateSlides();
            if (swiper.params.watchOverflow) {
                swiper.checkOverflow();
            }
            if (swiper.params.grabCursor) {
                swiper.setGrabCursor();
            }
            if (swiper.params.preloadImages) {
                swiper.preloadImages();
            }
            if (swiper.params.loop) {
                swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
            } else {
                swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
            }
            swiper.attachEvents();
            swiper.initialized = true;
            swiper.emit('init');
        }
        destroy(deleteInstance = true, cleanStyles = true) {
            const swiper = this;
            const {
                params, $el, $wrapperEl, slides,
            } = swiper;
            if (typeof swiper.params === 'undefined' || swiper.destroyed) {
                return null;
            }
            swiper.emit('beforeDestroy');
            swiper.initialized = false;
            swiper.detachEvents();
            if (params.loop) {
                swiper.loopDestroy();
            }
            if (cleanStyles) {
                swiper.removeClasses();
                $el.removeAttr('style');
                $wrapperEl.removeAttr('style');
                if (slides && slides.length) {
                    slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass, ].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index').removeAttr('data-swiper-column').removeAttr('data-swiper-row');
                }
            }
            swiper.emit('destroy');
            Object.keys(swiper.eventsListeners).forEach((eventName) => {
                swiper.off(eventName);
            });
            if (deleteInstance !== false) {
                swiper.$el[0].swiper = null;
                swiper.$el.data('swiper', null);
                Utils.deleteProps(swiper);
            }
            swiper.destroyed = true;
            return null;
        }
        static extendDefaults(newDefaults) {
            Utils.extend(extendedDefaults, newDefaults);
        }
        static get extendedDefaults() {
            return extendedDefaults;
        }
        static get defaults() {
            return defaults;
        }
        static get Class() {
            return SwiperClass;
        }
        static get $() {
            return __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"];
        }
    }
    var Device$1 = {
        name: 'device',
        proto: {
            device: Device,
        },
        static: {
            device: Device,
        },
    };
    var Support$1 = {
        name: 'support',
        proto: {
            support: Support,
        },
        static: {
            support: Support,
        },
    };
    var Browser$1 = {
        name: 'browser',
        proto: {
            browser: Browser,
        },
        static: {
            browser: Browser,
        },
    };
    var Resize = {
        name: 'resize',
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                resize: {
                    resizeHandler() {
                        if (!swiper || swiper.destroyed || !swiper.initialized) return;
                        swiper.emit('beforeResize');
                        swiper.emit('resize');
                    }, orientationChangeHandler() {
                        if (!swiper || swiper.destroyed || !swiper.initialized) return;
                        swiper.emit('orientationchange');
                    },
                },
            });
        },
        on: {
            init() {
                const swiper = this;
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].addEventListener('resize', swiper.resize.resizeHandler);
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
            }, destroy() {
                const swiper = this;
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].removeEventListener('resize', swiper.resize.resizeHandler);
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
            },
        },
    };
    const Observer = {
        func: __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].MutationObserver || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].WebkitMutationObserver,
        attach(target, options = {}) {
            const swiper = this;
            const ObserverFunc = Observer.func;
            const observer = new ObserverFunc((mutations) => {
                if (mutations.length === 1) {
                    swiper.emit('observerUpdate', mutations[0]);
                    return;
                }
                const observerUpdate = function observerUpdate() {
                    swiper.emit('observerUpdate', mutations[0]);
                };
                if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].requestAnimationFrame) {
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].requestAnimationFrame(observerUpdate);
                } else {
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].setTimeout(observerUpdate, 0);
                }
            });
            observer.observe(target, {
                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
                childList: typeof options.childList === 'undefined' ? true : options.childList,
                characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
            });
            swiper.observer.observers.push(observer);
        },
        init() {
            const swiper = this;
            if (!Support.observer || !swiper.params.observer) return;
            if (swiper.params.observeParents) {
                const containerParents = swiper.$el.parents();
                for (let i = 0; i < containerParents.length; i += 1) {
                    swiper.observer.attach(containerParents[i]);
                }
            }
            swiper.observer.attach(swiper.$el[0], {
                childList: false
            });
            swiper.observer.attach(swiper.$wrapperEl[0], {
                attributes: false
            });
        },
        destroy() {
            const swiper = this;
            swiper.observer.observers.forEach((observer) => {
                observer.disconnect();
            });
            swiper.observer.observers = [];
        },
    };
    var Observer$1 = {
        name: 'observer',
        params: {
            observer: false,
            observeParents: false,
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                observer: {
                    init: Observer.init.bind(swiper),
                    attach: Observer.attach.bind(swiper),
                    destroy: Observer.destroy.bind(swiper),
                    observers: [],
                },
            });
        },
        on: {
            init() {
                const swiper = this;
                swiper.observer.init();
            }, destroy() {
                const swiper = this;
                swiper.observer.destroy();
            },
        },
    };
    const Virtual = {
        update(force) {
            const swiper = this;
            const {
                slidesPerView, slidesPerGroup, centeredSlides
            } = swiper.params;
            const {
                from: previousFrom,
                to: previousTo,
                slides,
                slidesGrid: previousSlidesGrid,
                renderSlide,
                offset: previousOffset,
            } = swiper.virtual;
            swiper.updateActiveIndex();
            const activeIndex = swiper.activeIndex || 0;
            let offsetProp;
            if (swiper.rtlTranslate) offsetProp = 'right';
            else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
            let slidesAfter;
            let slidesBefore;
            if (centeredSlides) {
                slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup;
                slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup;
            } else {
                slidesAfter = slidesPerView + (slidesPerGroup - 1);
                slidesBefore = slidesPerGroup;
            }
            const from = Math.max((activeIndex || 0) - slidesBefore, 0);
            const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
            const offset$$1 = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
            Utils.extend(swiper.virtual, {
                from, to, offset: offset$$1, slidesGrid: swiper.slidesGrid,
            });

            function onRendered() {
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                if (swiper.lazy && swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
            }
            if (previousFrom === from && previousTo === to && !force) {
                if (swiper.slidesGrid !== previousSlidesGrid && offset$$1 !== previousOffset) {
                    swiper.slides.css(offsetProp, `${offset$$1}px`);
                }
                swiper.updateProgress();
                return;
            }
            if (swiper.params.virtual.renderExternal) {
                swiper.params.virtual.renderExternal.call(swiper, {
                    offset: offset$$1,
                    from,
                    to,
                    slides: (function getSlides() {
                        const slidesToRender = [];
                        for (let i = from; i <= to; i += 1) {
                            slidesToRender.push(slides[i]);
                        }
                        return slidesToRender;
                    }()),
                });
                onRendered();
                return;
            }
            const prependIndexes = [];
            const appendIndexes = [];
            if (force) {
                swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
            } else {
                for (let i = previousFrom; i <= previousTo; i += 1) {
                    if (i < from || i > to) {
                        swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
                    }
                }
            }
            for (let i = 0; i < slides.length; i += 1) {
                if (i >= from && i <= to) {
                    if (typeof previousTo === 'undefined' || force) {
                        appendIndexes.push(i);
                    } else {
                        if (i > previousTo) appendIndexes.push(i);
                        if (i < previousFrom) prependIndexes.push(i);
                    }
                }
            }
            appendIndexes.forEach((index$$1) => {
                swiper.$wrapperEl.append(renderSlide(slides[index$$1], index$$1));
            });
            prependIndexes.sort((a, b) => a < b).forEach((index$$1) => {
                swiper.$wrapperEl.prepend(renderSlide(slides[index$$1], index$$1));
            });
            swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset$$1}px`);
            onRendered();
        }, renderSlide(slide, index$$1) {
            const swiper = this;
            const params = swiper.params.virtual;
            if (params.cache && swiper.virtual.cache[index$$1]) {
                return swiper.virtual.cache[index$$1];
            }
            const $slideEl = params.renderSlide ? Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(params.renderSlide.call(swiper, slide, index$$1)) : Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index$$1}">${slide}</div>`);
            if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index$$1);
            if (params.cache) swiper.virtual.cache[index$$1] = $slideEl;
            return $slideEl;
        }, appendSlide(slide) {
            const swiper = this;
            swiper.virtual.slides.push(slide);
            swiper.virtual.update(true);
        }, prependSlide(slide) {
            const swiper = this;
            swiper.virtual.slides.unshift(slide);
            if (swiper.params.virtual.cache) {
                const cache = swiper.virtual.cache;
                const newCache = {};
                Object.keys(cache).forEach((cachedIndex) => {
                    newCache[cachedIndex + 1] = cache[cachedIndex];
                });
                swiper.virtual.cache = newCache;
            }
            swiper.virtual.update(true);
            swiper.slideNext(0);
        },
    };
    var Virtual$1 = {
        name: 'virtual',
        params: {
            virtual: {
                enabled: false,
                slides: [],
                cache: true,
                renderSlide: null,
                renderExternal: null,
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                virtual: {
                    update: Virtual.update.bind(swiper),
                    appendSlide: Virtual.appendSlide.bind(swiper),
                    prependSlide: Virtual.prependSlide.bind(swiper),
                    renderSlide: Virtual.renderSlide.bind(swiper),
                    slides: swiper.params.virtual.slides,
                    cache: {},
                },
            });
        },
        on: {
            beforeInit() {
                const swiper = this;
                if (!swiper.params.virtual.enabled) return;
                swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
                const overwriteParams = {
                    watchSlidesProgress: true,
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
                swiper.virtual.update();
            }, setTranslate() {
                const swiper = this;
                if (!swiper.params.virtual.enabled) return;
                swiper.virtual.update();
            },
        },
    };
    const Keyboard = {
        handle(event) {
            const swiper = this;
            const {
                rtlTranslate: rtl
            } = swiper;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            const kc = e.keyCode || e.charCode;
            if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40))) {
                return false;
            }
            if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38))) {
                return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return undefined;
            }
            if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].activeElement && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].activeElement.nodeName && (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].activeElement.nodeName.toLowerCase() === 'input' || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].activeElement.nodeName.toLowerCase() === 'textarea')) {
                return undefined;
            }
            if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
                let inView = false;
                if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
                    return undefined;
                }
                const windowWidth = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].innerWidth;
                const windowHeight = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].innerHeight;
                const swiperOffset = swiper.$el.offset();
                if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
                const swiperCoord = [
                    [swiperOffset.left, swiperOffset.top],
                    [swiperOffset.left + swiper.width, swiperOffset.top],
                    [swiperOffset.left, swiperOffset.top + swiper.height],
                    [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],
                ];
                for (let i = 0; i < swiperCoord.length; i += 1) {
                    const point = swiperCoord[i];
                    if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                        inView = true;
                    }
                }
                if (!inView) return undefined;
            }
            if (swiper.isHorizontal()) {
                if (kc === 37 || kc === 39) {
                    if (e.preventDefault) e.preventDefault();
                    else e.returnValue = false;
                }
                if ((kc === 39 && !rtl) || (kc === 37 && rtl)) swiper.slideNext();
                if ((kc === 37 && !rtl) || (kc === 39 && rtl)) swiper.slidePrev();
            } else {
                if (kc === 38 || kc === 40) {
                    if (e.preventDefault) e.preventDefault();
                    else e.returnValue = false;
                }
                if (kc === 40) swiper.slideNext();
                if (kc === 38) swiper.slidePrev();
            }
            swiper.emit('keyPress', kc);
            return undefined;
        }, enable() {
            const swiper = this;
            if (swiper.keyboard.enabled) return;
            Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"]).on('keydown', swiper.keyboard.handle);
            swiper.keyboard.enabled = true;
        }, disable() {
            const swiper = this;
            if (!swiper.keyboard.enabled) return;
            Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"]).off('keydown', swiper.keyboard.handle);
            swiper.keyboard.enabled = false;
        },
    };
    var Keyboard$1 = {
        name: 'keyboard',
        params: {
            keyboard: {
                enabled: false,
                onlyInViewport: true,
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                keyboard: {
                    enabled: false,
                    enable: Keyboard.enable.bind(swiper),
                    disable: Keyboard.disable.bind(swiper),
                    handle: Keyboard.handle.bind(swiper),
                },
            });
        },
        on: {
            init() {
                const swiper = this;
                if (swiper.params.keyboard.enabled) {
                    swiper.keyboard.enable();
                }
            }, destroy() {
                const swiper = this;
                if (swiper.keyboard.enabled) {
                    swiper.keyboard.disable();
                }
            },
        },
    };

    function isEventSupported() {
        const eventName = 'onwheel';
        let isSupported = eventName in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"];
        if (!isSupported) {
            const element = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].createElement('div');
            element.setAttribute(eventName, 'return;');
            isSupported = typeof element[eventName] === 'function';
        }
        if (!isSupported && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].implementation && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].implementation.hasFeature && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].implementation.hasFeature('', '') !== true) {
            isSupported = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].implementation.hasFeature('Events.wheel', '3.0');
        }
        return isSupported;
    }
    const Mousewheel = {
        lastScrollTime: Utils.now(),
        event: (function getEvent() {
            if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
            return isEventSupported() ? 'wheel' : 'mousewheel';
        }()),
        normalize(e) {
            const PIXEL_STEP = 10;
            const LINE_HEIGHT = 40;
            const PAGE_HEIGHT = 800;
            let sX = 0;
            let sY = 0;
            let pX = 0;
            let pY = 0;
            if ('detail' in e) {
                sY = e.detail;
            }
            if ('wheelDelta' in e) {
                sY = -e.wheelDelta / 120;
            }
            if ('wheelDeltaY' in e) {
                sY = -e.wheelDeltaY / 120;
            }
            if ('wheelDeltaX' in e) {
                sX = -e.wheelDeltaX / 120;
            }
            if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
                sX = sY;
                sY = 0;
            }
            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;
            if ('deltaY' in e) {
                pY = e.deltaY;
            }
            if ('deltaX' in e) {
                pX = e.deltaX;
            }
            if ((pX || pY) && e.deltaMode) {
                if (e.deltaMode === 1) {
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            }
            if (pX && !sX) {
                sX = (pX < 1) ? -1 : 1;
            }
            if (pY && !sY) {
                sY = (pY < 1) ? -1 : 1;
            }
            return {
                spinX: sX,
                spinY: sY,
                pixelX: pX,
                pixelY: pY,
            };
        },
        handleMouseEnter() {
            const swiper = this;
            swiper.mouseEntered = true;
        },
        handleMouseLeave() {
            const swiper = this;
            swiper.mouseEntered = false;
        },
        handle(event) {
            let e = event;
            const swiper = this;
            const params = swiper.params.mousewheel;
            if (!swiper.mouseEntered && !params.releaseOnEdges) return true;
            if (e.originalEvent) e = e.originalEvent;
            let delta = 0;
            const rtlFactor = swiper.rtlTranslate ? -1 : 1;
            const data$$1 = Mousewheel.normalize(e);
            if (params.forceToAxis) {
                if (swiper.isHorizontal()) {
                    if (Math.abs(data$$1.pixelX) > Math.abs(data$$1.pixelY)) delta = data$$1.pixelX * rtlFactor;
                    else return true;
                } else if (Math.abs(data$$1.pixelY) > Math.abs(data$$1.pixelX)) delta = data$$1.pixelY;
                else return true;
            } else {
                delta = Math.abs(data$$1.pixelX) > Math.abs(data$$1.pixelY) ? -data$$1.pixelX * rtlFactor : -data$$1.pixelY;
            }
            if (delta === 0) return true;
            if (params.invert) delta = -delta;
            if (!swiper.params.freeMode) {
                if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
                    if (delta < 0) {
                        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                            swiper.slideNext();
                            swiper.emit('scroll', e);
                        } else if (params.releaseOnEdges) return true;
                    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
                        swiper.slidePrev();
                        swiper.emit('scroll', e);
                    } else if (params.releaseOnEdges) return true;
                }
                swiper.mousewheel.lastScrollTime = (new __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].Date()).getTime();
            } else {
                if (swiper.params.loop) {
                    swiper.loopFix();
                }
                let position = swiper.getTranslate() + (delta * params.sensitivity);
                const wasBeginning = swiper.isBeginning;
                const wasEnd = swiper.isEnd;
                if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                swiper.setTransition(0);
                swiper.setTranslate(position);
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
                if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
                    swiper.updateSlidesClasses();
                }
                if (swiper.params.freeModeSticky) {
                    clearTimeout(swiper.mousewheel.timeout);
                    swiper.mousewheel.timeout = Utils.nextTick(() => {
                        swiper.slideToClosest();
                    }, 300);
                }
                swiper.emit('scroll', e);
                if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
                if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
            }
            if (e.preventDefault) e.preventDefault();
            else e.returnValue = false;
            return false;
        },
        enable() {
            const swiper = this;
            if (!Mousewheel.event) return false;
            if (swiper.mousewheel.enabled) return false;
            let target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarged !== 'container') {
                target = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(swiper.params.mousewheel.eventsTarged);
            }
            target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
            target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
            target.on(Mousewheel.event, swiper.mousewheel.handle);
            swiper.mousewheel.enabled = true;
            return true;
        },
        disable() {
            const swiper = this;
            if (!Mousewheel.event) return false;
            if (!swiper.mousewheel.enabled) return false;
            let target = swiper.$el;
            if (swiper.params.mousewheel.eventsTarged !== 'container') {
                target = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(swiper.params.mousewheel.eventsTarged);
            }
            target.off(Mousewheel.event, swiper.mousewheel.handle);
            swiper.mousewheel.enabled = false;
            return true;
        },
    };
    var Mousewheel$1 = {
        name: 'mousewheel',
        params: {
            mousewheel: {
                enabled: false,
                releaseOnEdges: false,
                invert: false,
                forceToAxis: false,
                sensitivity: 1,
                eventsTarged: 'container',
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                mousewheel: {
                    enabled: false,
                    enable: Mousewheel.enable.bind(swiper),
                    disable: Mousewheel.disable.bind(swiper),
                    handle: Mousewheel.handle.bind(swiper),
                    handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
                    handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
                    lastScrollTime: Utils.now(),
                },
            });
        },
        on: {
            init() {
                const swiper = this;
                if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
            }, destroy() {
                const swiper = this;
                if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
            },
        },
    };
    const Navigation = {
        update() {
            const swiper = this;
            const params = swiper.params.navigation;
            if (swiper.params.loop) return;
            const {
                $nextEl, $prevEl
            } = swiper.navigation;
            if ($prevEl && $prevEl.length > 0) {
                if (swiper.isBeginning) {
                    $prevEl.addClass(params.disabledClass);
                } else {
                    $prevEl.removeClass(params.disabledClass);
                }
                $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
            }
            if ($nextEl && $nextEl.length > 0) {
                if (swiper.isEnd) {
                    $nextEl.addClass(params.disabledClass);
                } else {
                    $nextEl.removeClass(params.disabledClass);
                }
                $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
            }
        }, init() {
            const swiper = this;
            const params = swiper.params.navigation;
            if (!(params.nextEl || params.prevEl)) return;
            let $nextEl;
            let $prevEl;
            if (params.nextEl) {
                $nextEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(params.nextEl);
                if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
                    $nextEl = swiper.$el.find(params.nextEl);
                }
            }
            if (params.prevEl) {
                $prevEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(params.prevEl);
                if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
                    $prevEl = swiper.$el.find(params.prevEl);
                }
            }
            if ($nextEl && $nextEl.length > 0) {
                $nextEl.on('click', (e) => {
                    e.preventDefault();
                    if (swiper.isEnd && !swiper.params.loop) return;
                    swiper.slideNext();
                });
            }
            if ($prevEl && $prevEl.length > 0) {
                $prevEl.on('click', (e) => {
                    e.preventDefault();
                    if (swiper.isBeginning && !swiper.params.loop) return;
                    swiper.slidePrev();
                });
            }
            Utils.extend(swiper.navigation, {
                $nextEl, nextEl: $nextEl && $nextEl[0], $prevEl, prevEl: $prevEl && $prevEl[0],
            });
        }, destroy() {
            const swiper = this;
            const {
                $nextEl, $prevEl
            } = swiper.navigation;
            if ($nextEl && $nextEl.length) {
                $nextEl.off('click');
                $nextEl.removeClass(swiper.params.navigation.disabledClass);
            }
            if ($prevEl && $prevEl.length) {
                $prevEl.off('click');
                $prevEl.removeClass(swiper.params.navigation.disabledClass);
            }
        },
    };
    var Navigation$1 = {
        name: 'navigation',
        params: {
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: false,
                disabledClass: 'swiper-button-disabled',
                hiddenClass: 'swiper-button-hidden',
                lockClass: 'swiper-button-lock',
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                navigation: {
                    init: Navigation.init.bind(swiper),
                    update: Navigation.update.bind(swiper),
                    destroy: Navigation.destroy.bind(swiper),
                },
            });
        },
        on: {
            init() {
                const swiper = this;
                swiper.navigation.init();
                swiper.navigation.update();
            }, toEdge() {
                const swiper = this;
                swiper.navigation.update();
            }, fromEdge() {
                const swiper = this;
                swiper.navigation.update();
            }, destroy() {
                const swiper = this;
                swiper.navigation.destroy();
            }, click(e) {
                const swiper = this;
                const {
                    $nextEl, $prevEl
                } = swiper.navigation;
                if (swiper.params.navigation.hideOnClick && !Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(e.target).is($prevEl) && !Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(e.target).is($nextEl)) {
                    if ($nextEl) $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                    if ($prevEl) $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
            },
        },
    };
    const Pagination = {
        update() {
            const swiper = this;
            const rtl = swiper.rtl;
            const params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            const $el = swiper.pagination.$el;
            let current;
            const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.loop) {
                current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
                if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
                    current -= (slidesLength - (swiper.loopedSlides * 2));
                }
                if (current > total - 1) current -= total;
                if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
            } else if (typeof swiper.snapIndex !== 'undefined') {
                current = swiper.snapIndex;
            } else {
                current = swiper.activeIndex || 0;
            }
            if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                const bullets = swiper.pagination.bullets;
                let firstIndex;
                let lastIndex;
                let midIndex;
                if (params.dynamicBullets) {
                    swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
                    $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize*(params.dynamicMainBullets+4)}px`);
                    if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
                        swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
                        if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
                            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
                        } else if (swiper.pagination.dynamicBulletIndex < 0) {
                            swiper.pagination.dynamicBulletIndex = 0;
                        }
                    }
                    firstIndex = current - swiper.pagination.dynamicBulletIndex;
                    lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                    midIndex = (lastIndex + firstIndex) / 2;
                }
                bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);
                if ($el.length > 1) {
                    bullets.each((index$$1, bullet) => {
                        const $bullet = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(bullet);
                        const bulletIndex = $bullet.index();
                        if (bulletIndex === current) {
                            $bullet.addClass(params.bulletActiveClass);
                        }
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                                $bullet.addClass(`${params.bulletActiveClass}-main`);
                            }
                            if (bulletIndex === firstIndex) {
                                $bullet.prev().addClass(`${params.bulletActiveClass}-prev`).prev().addClass(`${params.bulletActiveClass}-prev-prev`);
                            }
                            if (bulletIndex === lastIndex) {
                                $bullet.next().addClass(`${params.bulletActiveClass}-next`).next().addClass(`${params.bulletActiveClass}-next-next`);
                            }
                        }
                    });
                } else {
                    const $bullet = bullets.eq(current);
                    $bullet.addClass(params.bulletActiveClass);
                    if (params.dynamicBullets) {
                        const $firstDisplayedBullet = bullets.eq(firstIndex);
                        const $lastDisplayedBullet = bullets.eq(lastIndex);
                        for (let i = firstIndex; i <= lastIndex; i += 1) {
                            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
                        }
                        $firstDisplayedBullet.prev().addClass(`${params.bulletActiveClass}-prev`).prev().addClass(`${params.bulletActiveClass}-prev-prev`);
                        $lastDisplayedBullet.next().addClass(`${params.bulletActiveClass}-next`).next().addClass(`${params.bulletActiveClass}-next-next`);
                    }
                }
                if (params.dynamicBullets) {
                    const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                    const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
                    const offsetProp = rtl ? 'right' : 'left';
                    bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
                }
            }
            if (params.type === 'fraction') {
                $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));
                $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));
            }
            if (params.type === 'progressbar') {
                let progressbarDirection;
                if (params.progressbarOpposite) {
                    progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
                } else {
                    progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
                }
                const scale = (current + 1) / total;
                let scaleX = 1;
                let scaleY = 1;
                if (progressbarDirection === 'horizontal') {
                    scaleX = scale;
                } else {
                    scaleY = scale;
                }
                $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
            }
            if (params.type === 'custom' && params.renderCustom) {
                $el.html(params.renderCustom(swiper, current + 1, total));
                swiper.emit('paginationRender', swiper, $el[0]);
            } else {
                swiper.emit('paginationUpdate', swiper, $el[0]);
            }
            $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }, render() {
            const swiper = this;
            const params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
            const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
            const $el = swiper.pagination.$el;
            let paginationHTML = '';
            if (params.type === 'bullets') {
                const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                for (let i = 0; i < numberOfBullets; i += 1) {
                    if (params.renderBullet) {
                        paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
                    } else {
                        paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
                    }
                }
                $el.html(paginationHTML);
                swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
            }
            if (params.type === 'fraction') {
                if (params.renderFraction) {
                    paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
                } else {
                    paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
                }
                $el.html(paginationHTML);
            }
            if (params.type === 'progressbar') {
                if (params.renderProgressbar) {
                    paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
                } else {
                    paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                }
                $el.html(paginationHTML);
            }
            if (params.type !== 'custom') {
                swiper.emit('paginationRender', swiper.pagination.$el[0]);
            }
        }, init() {
            const swiper = this;
            const params = swiper.params.pagination;
            if (!params.el) return;
            let $el = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(params.el);
            if ($el.length === 0) return;
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && swiper.$el.find(params.el).length === 1) {
                $el = swiper.$el.find(params.el);
            }
            if (params.type === 'bullets' && params.clickable) {
                $el.addClass(params.clickableClass);
            }
            $el.addClass(params.modifierClass + params.type);
            if (params.type === 'bullets' && params.dynamicBullets) {
                $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
                swiper.pagination.dynamicBulletIndex = 0;
                if (params.dynamicMainBullets < 1) {
                    params.dynamicMainBullets = 1;
                }
            }
            if (params.type === 'progressbar' && params.progressbarOpposite) {
                $el.addClass(params.progressbarOppositeClass);
            }
            if (params.clickable) {
                $el.on('click', `.${params.bulletClass}`, function onClick(e) {
                    e.preventDefault();
                    let index$$1 = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(this).index() * swiper.params.slidesPerGroup;
                    if (swiper.params.loop) index$$1 += swiper.loopedSlides;
                    swiper.slideTo(index$$1);
                });
            }
            Utils.extend(swiper.pagination, {
                $el, el: $el[0],
            });
        }, destroy() {
            const swiper = this;
            const params = swiper.params.pagination;
            if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
            const $el = swiper.pagination.$el;
            $el.removeClass(params.hiddenClass);
            $el.removeClass(params.modifierClass + params.type);
            if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
            if (params.clickable) {
                $el.off('click', `.${params.bulletClass}`);
            }
        },
    };
    var Pagination$1 = {
        name: 'pagination',
        params: {
            pagination: {
                el: null,
                bulletElement: 'span',
                clickable: false,
                hideOnClick: false,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: false,
                type: 'bullets',
                dynamicBullets: false,
                dynamicMainBullets: 1,
                formatFractionCurrent: number => number,
                formatFractionTotal: number => number,
                bulletClass: 'swiper-pagination-bullet',
                bulletActiveClass: 'swiper-pagination-bullet-active',
                modifierClass: 'swiper-pagination-',
                currentClass: 'swiper-pagination-current',
                totalClass: 'swiper-pagination-total',
                hiddenClass: 'swiper-pagination-hidden',
                progressbarFillClass: 'swiper-pagination-progressbar-fill',
                progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
                clickableClass: 'swiper-pagination-clickable',
                lockClass: 'swiper-pagination-lock',
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                pagination: {
                    init: Pagination.init.bind(swiper),
                    render: Pagination.render.bind(swiper),
                    update: Pagination.update.bind(swiper),
                    destroy: Pagination.destroy.bind(swiper),
                    dynamicBulletIndex: 0,
                },
            });
        },
        on: {
            init() {
                const swiper = this;
                swiper.pagination.init();
                swiper.pagination.render();
                swiper.pagination.update();
            }, activeIndexChange() {
                const swiper = this;
                if (swiper.params.loop) {
                    swiper.pagination.update();
                } else if (typeof swiper.snapIndex === 'undefined') {
                    swiper.pagination.update();
                }
            }, snapIndexChange() {
                const swiper = this;
                if (!swiper.params.loop) {
                    swiper.pagination.update();
                }
            }, slidesLengthChange() {
                const swiper = this;
                if (swiper.params.loop) {
                    swiper.pagination.render();
                    swiper.pagination.update();
                }
            }, snapGridLengthChange() {
                const swiper = this;
                if (!swiper.params.loop) {
                    swiper.pagination.render();
                    swiper.pagination.update();
                }
            }, destroy() {
                const swiper = this;
                swiper.pagination.destroy();
            }, click(e) {
                const swiper = this;
                if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(e.target).hasClass(swiper.params.pagination.bulletClass)) {
                    swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
                }
            },
        },
    };
    const Scrollbar = {
        setTranslate() {
            const swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            const {
                scrollbar, rtlTranslate: rtl, progress
            } = swiper;
            const {
                dragSize, trackSize, $dragEl, $el,
            } = scrollbar;
            const params = swiper.params.scrollbar;
            let newSize = dragSize;
            let newPos = (trackSize - dragSize) * progress;
            if (rtl) {
                newPos = -newPos;
                if (newPos > 0) {
                    newSize = dragSize - newPos;
                    newPos = 0;
                } else if (-newPos + dragSize > trackSize) {
                    newSize = trackSize + newPos;
                }
            } else if (newPos < 0) {
                newSize = dragSize + newPos;
                newPos = 0;
            } else if (newPos + dragSize > trackSize) {
                newSize = trackSize - newPos;
            }
            if (swiper.isHorizontal()) {
                if (Support.transforms3d) {
                    $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
                } else {
                    $dragEl.transform(`translateX(${newPos}px)`);
                }
                $dragEl[0].style.width = `${newSize}px`;
            } else {
                if (Support.transforms3d) {
                    $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
                } else {
                    $dragEl.transform(`translateY(${newPos}px)`);
                }
                $dragEl[0].style.height = `${newSize}px`;
            }
            if (params.hide) {
                clearTimeout(swiper.scrollbar.timeout);
                $el[0].style.opacity = 1;
                swiper.scrollbar.timeout = setTimeout(() => {
                    $el[0].style.opacity = 0;
                    $el.transition(400);
                }, 1000);
            }
        }, setTransition(duration) {
            const swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            swiper.scrollbar.$dragEl.transition(duration);
        }, updateSize() {
            const swiper = this;
            if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
            const {
                scrollbar
            } = swiper;
            const {
                $dragEl, $el
            } = scrollbar;
            $dragEl[0].style.width = '';
            $dragEl[0].style.height = '';
            const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
            const divider = swiper.size / swiper.virtualSize;
            const moveDivider = divider * (trackSize / swiper.size);
            let dragSize;
            if (swiper.params.scrollbar.dragSize === 'auto') {
                dragSize = trackSize * divider;
            } else {
                dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
            }
            if (swiper.isHorizontal()) {
                $dragEl[0].style.width = `${dragSize}px`;
            } else {
                $dragEl[0].style.height = `${dragSize}px`;
            }
            if (divider >= 1) {
                $el[0].style.display = 'none';
            } else {
                $el[0].style.display = '';
            }
            if (swiper.params.scrollbarHide) {
                $el[0].style.opacity = 0;
            }
            Utils.extend(scrollbar, {
                trackSize, divider, moveDivider, dragSize,
            });
            scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
        }, setDragPosition(e) {
            const swiper = this;
            const {
                scrollbar, rtlTranslate: rtl
            } = swiper;
            const {
                $el, dragSize, trackSize
            } = scrollbar;
            let pointerPosition;
            if (swiper.isHorizontal()) {
                pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);
            } else {
                pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
            }
            let positionRatio;
            positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);
            positionRatio = Math.max(Math.min(positionRatio, 1), 0);
            if (rtl) {
                positionRatio = 1 - positionRatio;
            }
            const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);
            swiper.updateProgress(position);
            swiper.setTranslate(position);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }, onDragStart(e) {
            const swiper = this;
            const params = swiper.params.scrollbar;
            const {
                scrollbar, $wrapperEl
            } = swiper;
            const {
                $el, $dragEl
            } = scrollbar;
            swiper.scrollbar.isTouched = true;
            e.preventDefault();
            e.stopPropagation();
            $wrapperEl.transition(100);
            $dragEl.transition(100);
            scrollbar.setDragPosition(e);
            clearTimeout(swiper.scrollbar.dragTimeout);
            $el.transition(0);
            if (params.hide) {
                $el.css('opacity', 1);
            }
            swiper.emit('scrollbarDragStart', e);
        }, onDragMove(e) {
            const swiper = this;
            const {
                scrollbar, $wrapperEl
            } = swiper;
            const {
                $el, $dragEl
            } = scrollbar;
            if (!swiper.scrollbar.isTouched) return;
            if (e.preventDefault) e.preventDefault();
            else e.returnValue = false;
            scrollbar.setDragPosition(e);
            $wrapperEl.transition(0);
            $el.transition(0);
            $dragEl.transition(0);
            swiper.emit('scrollbarDragMove', e);
        }, onDragEnd(e) {
            const swiper = this;
            const params = swiper.params.scrollbar;
            const {
                scrollbar
            } = swiper;
            const {
                $el
            } = scrollbar;
            if (!swiper.scrollbar.isTouched) return;
            swiper.scrollbar.isTouched = false;
            if (params.hide) {
                clearTimeout(swiper.scrollbar.dragTimeout);
                swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
                    $el.css('opacity', 0);
                    $el.transition(400);
                }, 1000);
            }
            swiper.emit('scrollbarDragEnd', e);
            if (params.snapOnRelease) {
                swiper.slideToClosest();
            }
        }, enableDraggable() {
            const swiper = this;
            if (!swiper.params.scrollbar.el) return;
            const {
                scrollbar, touchEvents, touchEventsDesktop, params,
            } = swiper;
            const $el = scrollbar.$el;
            const target = $el[0];
            const activeListener = Support.passiveListener && params.passiveListeners ? {
                passive: false,
                capture: false
            } : false;
            const passiveListener = Support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
            } else {
                if (Support.touch) {
                    target.addEventListener(touchEvents.start, swiper.scrollbar.onDragStart, activeListener);
                    target.addEventListener(touchEvents.move, swiper.scrollbar.onDragMove, activeListener);
                    target.addEventListener(touchEvents.end, swiper.scrollbar.onDragEnd, passiveListener);
                }
                if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
                    target.addEventListener('mousedown', swiper.scrollbar.onDragStart, activeListener);
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].addEventListener('mousemove', swiper.scrollbar.onDragMove, activeListener);
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].addEventListener('mouseup', swiper.scrollbar.onDragEnd, passiveListener);
                }
            }
        }, disableDraggable() {
            const swiper = this;
            if (!swiper.params.scrollbar.el) return;
            const {
                scrollbar, touchEvents, touchEventsDesktop, params,
            } = swiper;
            const $el = scrollbar.$el;
            const target = $el[0];
            const activeListener = Support.passiveListener && params.passiveListeners ? {
                passive: false,
                capture: false
            } : false;
            const passiveListener = Support.passiveListener && params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
                target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
            } else {
                if (Support.touch) {
                    target.removeEventListener(touchEvents.start, swiper.scrollbar.onDragStart, activeListener);
                    target.removeEventListener(touchEvents.move, swiper.scrollbar.onDragMove, activeListener);
                    target.removeEventListener(touchEvents.end, swiper.scrollbar.onDragEnd, passiveListener);
                }
                if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
                    target.removeEventListener('mousedown', swiper.scrollbar.onDragStart, activeListener);
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].removeEventListener('mousemove', swiper.scrollbar.onDragMove, activeListener);
                    __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].removeEventListener('mouseup', swiper.scrollbar.onDragEnd, passiveListener);
                }
            }
        }, init() {
            const swiper = this;
            if (!swiper.params.scrollbar.el) return;
            const {
                scrollbar, $el: $swiperEl
            } = swiper;
            const params = swiper.params.scrollbar;
            let $el = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(params.el);
            if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
                $el = $swiperEl.find(params.el);
            }
            let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
            if ($dragEl.length === 0) {
                $dragEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
                $el.append($dragEl);
            }
            Utils.extend(scrollbar, {
                $el, el: $el[0], $dragEl, dragEl: $dragEl[0],
            });
            if (params.draggable) {
                scrollbar.enableDraggable();
            }
        }, destroy() {
            const swiper = this;
            swiper.scrollbar.disableDraggable();
        },
    };
    var Scrollbar$1 = {
        name: 'scrollbar',
        params: {
            scrollbar: {
                el: null,
                dragSize: 'auto',
                hide: false,
                draggable: false,
                snapOnRelease: true,
                lockClass: 'swiper-scrollbar-lock',
                dragClass: 'swiper-scrollbar-drag',
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                scrollbar: {
                    init: Scrollbar.init.bind(swiper),
                    destroy: Scrollbar.destroy.bind(swiper),
                    updateSize: Scrollbar.updateSize.bind(swiper),
                    setTranslate: Scrollbar.setTranslate.bind(swiper),
                    setTransition: Scrollbar.setTransition.bind(swiper),
                    enableDraggable: Scrollbar.enableDraggable.bind(swiper),
                    disableDraggable: Scrollbar.disableDraggable.bind(swiper),
                    setDragPosition: Scrollbar.setDragPosition.bind(swiper),
                    onDragStart: Scrollbar.onDragStart.bind(swiper),
                    onDragMove: Scrollbar.onDragMove.bind(swiper),
                    onDragEnd: Scrollbar.onDragEnd.bind(swiper),
                    isTouched: false,
                    timeout: null,
                    dragTimeout: null,
                },
            });
        },
        on: {
            init() {
                const swiper = this;
                swiper.scrollbar.init();
                swiper.scrollbar.updateSize();
                swiper.scrollbar.setTranslate();
            }, update() {
                const swiper = this;
                swiper.scrollbar.updateSize();
            }, resize() {
                const swiper = this;
                swiper.scrollbar.updateSize();
            }, observerUpdate() {
                const swiper = this;
                swiper.scrollbar.updateSize();
            }, setTranslate() {
                const swiper = this;
                swiper.scrollbar.setTranslate();
            }, setTransition(duration) {
                const swiper = this;
                swiper.scrollbar.setTransition(duration);
            }, destroy() {
                const swiper = this;
                swiper.scrollbar.destroy();
            },
        },
    };
    const Parallax = {
        setTransform(el, progress) {
            const swiper = this;
            const {
                rtl
            } = swiper;
            const $el = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(el);
            const rtlFactor = rtl ? -1 : 1;
            const p = $el.attr('data-swiper-parallax') || '0';
            let x = $el.attr('data-swiper-parallax-x');
            let y = $el.attr('data-swiper-parallax-y');
            const scale = $el.attr('data-swiper-parallax-scale');
            const opacity = $el.attr('data-swiper-parallax-opacity');
            if (x || y) {
                x = x || '0';
                y = y || '0';
            } else if (swiper.isHorizontal()) {
                x = p;
                y = '0';
            } else {
                y = p;
                x = '0';
            }
            if ((x).indexOf('%') >= 0) {
                x = `${parseInt(x,10)*progress*rtlFactor}%`;
            } else {
                x = `${x*progress*rtlFactor}px`;
            }
            if ((y).indexOf('%') >= 0) {
                y = `${parseInt(y,10)*progress}%`;
            } else {
                y = `${y*progress}px`;
            }
            if (typeof opacity !== 'undefined' && opacity !== null) {
                const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
                $el[0].style.opacity = currentOpacity;
            }
            if (typeof scale === 'undefined' || scale === null) {
                $el.transform(`translate3d(${x}, ${y}, 0px)`);
            } else {
                const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
                $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
            }
        }, setTranslate() {
            const swiper = this;
            const {
                $el, slides, progress, snapGrid,
            } = swiper;
            $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each((index$$1, el) => {
                swiper.parallax.setTransform(el, progress);
            });
            slides.each((slideIndex, slideEl) => {
                let slideProgress = slideEl.progress;
                if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
                    slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
                }
                slideProgress = Math.min(Math.max(slideProgress, -1), 1);
                Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each((index$$1, el) => {
                    swiper.parallax.setTransform(el, slideProgress);
                });
            });
        }, setTransition(duration = this.params.speed) {
            const swiper = this;
            const {
                $el
            } = swiper;
            $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each((index$$1, parallaxEl) => {
                const $parallaxEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(parallaxEl);
                let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
                if (duration === 0) parallaxDuration = 0;
                $parallaxEl.transition(parallaxDuration);
            });
        },
    };
    var Parallax$1 = {
        name: 'parallax',
        params: {
            parallax: {
                enabled: false,
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                parallax: {
                    setTransform: Parallax.setTransform.bind(swiper),
                    setTranslate: Parallax.setTranslate.bind(swiper),
                    setTransition: Parallax.setTransition.bind(swiper),
                },
            });
        },
        on: {
            beforeInit() {
                const swiper = this;
                if (!swiper.params.parallax.enabled) return;
                swiper.params.watchSlidesProgress = true;
            }, init() {
                const swiper = this;
                if (!swiper.params.parallax) return;
                swiper.parallax.setTranslate();
            }, setTranslate() {
                const swiper = this;
                if (!swiper.params.parallax) return;
                swiper.parallax.setTranslate();
            }, setTransition(duration) {
                const swiper = this;
                if (!swiper.params.parallax) return;
                swiper.parallax.setTransition(duration);
            },
        },
    };
    const Zoom = {
        getDistanceBetweenTouches(e) {
            if (e.targetTouches.length < 2) return 1;
            const x1 = e.targetTouches[0].pageX;
            const y1 = e.targetTouches[0].pageY;
            const x2 = e.targetTouches[1].pageX;
            const y2 = e.targetTouches[1].pageY;
            const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));
            return distance;
        }, onGestureStart(e) {
            const swiper = this;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            const {
                gesture
            } = zoom;
            zoom.fakeGestureTouched = false;
            zoom.fakeGestureMoved = false;
            if (!Support.gestures) {
                if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
                    return;
                }
                zoom.fakeGestureTouched = true;
                gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
            }
            if (!gesture.$slideEl || !gesture.$slideEl.length) {
                gesture.$slideEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(e.target).closest('.swiper-slide');
                if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
                gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
                gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
                if (gesture.$imageWrapEl.length === 0) {
                    gesture.$imageEl = undefined;
                    return;
                }
            }
            gesture.$imageEl.transition(0);
            swiper.zoom.isScaling = true;
        }, onGestureChange(e) {
            const swiper = this;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            const {
                gesture
            } = zoom;
            if (!Support.gestures) {
                if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
                    return;
                }
                zoom.fakeGestureMoved = true;
                gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            if (Support.gestures) {
                swiper.zoom.scale = e.scale * zoom.currentScale;
            } else {
                zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
            }
            if (zoom.scale > gesture.maxRatio) {
                zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);
            }
            if (zoom.scale < params.minRatio) {
                zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);
            }
            gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        }, onGestureEnd(e) {
            const swiper = this;
            const params = swiper.params.zoom;
            const zoom = swiper.zoom;
            const {
                gesture
            } = zoom;
            if (!Support.gestures) {
                if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
                    return;
                }
                if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
                    return;
                }
                zoom.fakeGestureTouched = false;
                zoom.fakeGestureMoved = false;
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
            gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
            zoom.currentScale = zoom.scale;
            zoom.isScaling = false;
            if (zoom.scale === 1) gesture.$slideEl = undefined;
        }, onTouchStart(e) {
            const swiper = this;
            const zoom = swiper.zoom;
            const {
                gesture, image
            } = zoom;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            if (image.isTouched) return;
            if (Device.android) e.preventDefault();
            image.isTouched = true;
            image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        }, onTouchMove(e) {
            const swiper = this;
            const zoom = swiper.zoom;
            const {
                gesture, image, velocity
            } = zoom;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            swiper.allowClick = false;
            if (!image.isTouched || !gesture.$slideEl) return;
            if (!image.isMoved) {
                image.width = gesture.$imageEl[0].offsetWidth;
                image.height = gesture.$imageEl[0].offsetHeight;
                image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
                image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
                gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
                gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
                gesture.$imageWrapEl.transition(0);
                if (swiper.rtl) {
                    image.startX = -image.startX;
                    image.startY = -image.startY;
                }
            }
            const scaledWidth = image.width * zoom.scale;
            const scaledHeight = image.height * zoom.scale;
            if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
            image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
            image.maxX = -image.minX;
            image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
            image.maxY = -image.minY;
            image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
            if (!image.isMoved && !zoom.isScaling) {
                if (swiper.isHorizontal() && ((Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x) || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x))) {
                    image.isTouched = false;
                    return;
                }
                if (!swiper.isHorizontal() && ((Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y) || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y))) {
                    image.isTouched = false;
                    return;
                }
            }
            e.preventDefault();
            e.stopPropagation();
            image.isMoved = true;
            image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
            image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;
            if (image.currentX < image.minX) {
                image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);
            }
            if (image.currentX > image.maxX) {
                image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);
            }
            if (image.currentY < image.minY) {
                image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);
            }
            if (image.currentY > image.maxY) {
                image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);
            }
            if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
            if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
            if (!velocity.prevTime) velocity.prevTime = Date.now();
            velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
            velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
            if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
            if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
            velocity.prevPositionX = image.touchesCurrent.x;
            velocity.prevPositionY = image.touchesCurrent.y;
            velocity.prevTime = Date.now();
            gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
        }, onTouchEnd() {
            const swiper = this;
            const zoom = swiper.zoom;
            const {
                gesture, image, velocity
            } = zoom;
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            if (!image.isTouched || !image.isMoved) {
                image.isTouched = false;
                image.isMoved = false;
                return;
            }
            image.isTouched = false;
            image.isMoved = false;
            let momentumDurationX = 300;
            let momentumDurationY = 300;
            const momentumDistanceX = velocity.x * momentumDurationX;
            const newPositionX = image.currentX + momentumDistanceX;
            const momentumDistanceY = velocity.y * momentumDurationY;
            const newPositionY = image.currentY + momentumDistanceY;
            if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
            if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
            const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
            image.currentX = newPositionX;
            image.currentY = newPositionY;
            const scaledWidth = image.width * zoom.scale;
            const scaledHeight = image.height * zoom.scale;
            image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
            image.maxX = -image.minX;
            image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
            image.maxY = -image.minY;
            image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
            image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
            gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
        }, onTransitionEnd() {
            const swiper = this;
            const zoom = swiper.zoom;
            const {
                gesture
            } = zoom;
            if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
                gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
                gesture.$imageWrapEl.transform('translate3d(0,0,0)');
                gesture.$slideEl = undefined;
                gesture.$imageEl = undefined;
                gesture.$imageWrapEl = undefined;
                zoom.scale = 1;
                zoom.currentScale = 1;
            }
        }, toggle(e) {
            const swiper = this;
            const zoom = swiper.zoom;
            if (zoom.scale && zoom.scale !== 1) {
                zoom.out();
            } else {
                zoom.in(e);
            }
        }, in (e) {
            const swiper = this;
            const zoom = swiper.zoom;
            const params = swiper.params.zoom;
            const {
                gesture, image
            } = zoom;
            if (!gesture.$slideEl) {
                gesture.$slideEl = swiper.clickedSlide ? Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
                gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
            let touchX;
            let touchY;
            let offsetX;
            let offsetY;
            let diffX;
            let diffY;
            let translateX;
            let translateY;
            let imageWidth;
            let imageHeight;
            let scaledWidth;
            let scaledHeight;
            let translateMinX;
            let translateMinY;
            let translateMaxX;
            let translateMaxY;
            let slideWidth;
            let slideHeight;
            if (typeof image.touchesStart.x === 'undefined' && e) {
                touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
                touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
            } else {
                touchX = image.touchesStart.x;
                touchY = image.touchesStart.y;
            }
            zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
            if (e) {
                slideWidth = gesture.$slideEl[0].offsetWidth;
                slideHeight = gesture.$slideEl[0].offsetHeight;
                offsetX = gesture.$slideEl.offset().left;
                offsetY = gesture.$slideEl.offset().top;
                diffX = (offsetX + (slideWidth / 2)) - touchX;
                diffY = (offsetY + (slideHeight / 2)) - touchY;
                imageWidth = gesture.$imageEl[0].offsetWidth;
                imageHeight = gesture.$imageEl[0].offsetHeight;
                scaledWidth = imageWidth * zoom.scale;
                scaledHeight = imageHeight * zoom.scale;
                translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
                translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
                translateMaxX = -translateMinX;
                translateMaxY = -translateMinY;
                translateX = diffX * zoom.scale;
                translateY = diffY * zoom.scale;
                if (translateX < translateMinX) {
                    translateX = translateMinX;
                }
                if (translateX > translateMaxX) {
                    translateX = translateMaxX;
                }
                if (translateY < translateMinY) {
                    translateY = translateMinY;
                }
                if (translateY > translateMaxY) {
                    translateY = translateMaxY;
                }
            } else {
                translateX = 0;
                translateY = 0;
            }
            gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
            gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        }, out() {
            const swiper = this;
            const zoom = swiper.zoom;
            const params = swiper.params.zoom;
            const {
                gesture
            } = zoom;
            if (!gesture.$slideEl) {
                gesture.$slideEl = swiper.clickedSlide ? Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
                gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
                gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
            }
            if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
            zoom.scale = 1;
            zoom.currentScale = 1;
            gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
            gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
            gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
            gesture.$slideEl = undefined;
        }, enable() {
            const swiper = this;
            const zoom = swiper.zoom;
            if (zoom.enabled) return;
            zoom.enabled = true;
            const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (Support.gestures) {
                swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
                swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
            }
            swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);
        }, disable() {
            const swiper = this;
            const zoom = swiper.zoom;
            if (!zoom.enabled) return;
            swiper.zoom.enabled = false;
            const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
                passive: true,
                capture: false
            } : false;
            if (Support.gestures) {
                swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
            } else if (swiper.touchEvents.start === 'touchstart') {
                swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
                swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
            }
            swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);
        },
    };
    var Zoom$1 = {
        name: 'zoom',
        params: {
            zoom: {
                enabled: false,
                maxRatio: 3,
                minRatio: 1,
                toggle: true,
                containerClass: 'swiper-zoom-container',
                zoomedSlideClass: 'swiper-slide-zoomed',
            },
        },
        create() {
            const swiper = this;
            const zoom = {
                enabled: false,
                scale: 1,
                currentScale: 1,
                isScaling: false,
                gesture: {
                    $slideEl: undefined,
                    slideWidth: undefined,
                    slideHeight: undefined,
                    $imageEl: undefined,
                    $imageWrapEl: undefined,
                    maxRatio: 3,
                },
                image: {
                    isTouched: undefined,
                    isMoved: undefined,
                    currentX: undefined,
                    currentY: undefined,
                    minX: undefined,
                    minY: undefined,
                    maxX: undefined,
                    maxY: undefined,
                    width: undefined,
                    height: undefined,
                    startX: undefined,
                    startY: undefined,
                    touchesStart: {},
                    touchesCurrent: {},
                },
                velocity: {
                    x: undefined,
                    y: undefined,
                    prevPositionX: undefined,
                    prevPositionY: undefined,
                    prevTime: undefined,
                },
            };
            ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {
                zoom[methodName] = Zoom[methodName].bind(swiper);
            });
            Utils.extend(swiper, {
                zoom,
            });
        },
        on: {
            init() {
                const swiper = this;
                if (swiper.params.zoom.enabled) {
                    swiper.zoom.enable();
                }
            }, destroy() {
                const swiper = this;
                swiper.zoom.disable();
            }, touchStart(e) {
                const swiper = this;
                if (!swiper.zoom.enabled) return;
                swiper.zoom.onTouchStart(e);
            }, touchEnd(e) {
                const swiper = this;
                if (!swiper.zoom.enabled) return;
                swiper.zoom.onTouchEnd(e);
            }, doubleTap(e) {
                const swiper = this;
                if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
                    swiper.zoom.toggle(e);
                }
            }, transitionEnd() {
                const swiper = this;
                if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                    swiper.zoom.onTransitionEnd();
                }
            },
        },
    };
    const Lazy = {
        loadInSlide(index$$1, loadInDuplicate = true) {
            const swiper = this;
            const params = swiper.params.lazy;
            if (typeof index$$1 === 'undefined') return;
            if (swiper.slides.length === 0) return;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index$$1}"]`) : swiper.slides.eq(index$$1);
            let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
            if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
                $images = $images.add($slideEl[0]);
            }
            if ($images.length === 0) return;
            $images.each((imageIndex, imageEl) => {
                const $imageEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(imageEl);
                $imageEl.addClass(params.loadingClass);
                const background = $imageEl.attr('data-background');
                const src = $imageEl.attr('data-src');
                const srcset = $imageEl.attr('data-srcset');
                const sizes = $imageEl.attr('data-sizes');
                swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {
                    if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;
                    if (background) {
                        $imageEl.css('background-image', `url("${background}")`);
                        $imageEl.removeAttr('data-background');
                    } else {
                        if (srcset) {
                            $imageEl.attr('srcset', srcset);
                            $imageEl.removeAttr('data-srcset');
                        }
                        if (sizes) {
                            $imageEl.attr('sizes', sizes);
                            $imageEl.removeAttr('data-sizes');
                        }
                        if (src) {
                            $imageEl.attr('src', src);
                            $imageEl.removeAttr('data-src');
                        }
                    }
                    $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
                    $slideEl.find(`.${params.preloaderClass}`).remove();
                    if (swiper.params.loop && loadInDuplicate) {
                        const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
                        if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
                            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
                            swiper.lazy.loadInSlide(originalSlide.index(), false);
                        } else {
                            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
                            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
                        }
                    }
                    swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
                });
                swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
            });
        }, load() {
            const swiper = this;
            const {
                $wrapperEl, params: swiperParams, slides, activeIndex,
            } = swiper;
            const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
            const params = swiperParams.lazy;
            let slidesPerView = swiperParams.slidesPerView;
            if (slidesPerView === 'auto') {
                slidesPerView = 0;
            }

            function slideExist(index$$1) {
                if (isVirtual) {
                    if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index$$1}"]`).length) {
                        return true;
                    }
                } else if (slides[index$$1]) return true;
                return false;
            }

            function slideIndex(slideEl) {
                if (isVirtual) {
                    return Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(slideEl).attr('data-swiper-slide-index');
                }
                return Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(slideEl).index();
            }
            if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
            if (swiper.params.watchSlidesVisibility) {
                $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {
                    const index$$1 = isVirtual ? Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(slideEl).attr('data-swiper-slide-index') : Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(slideEl).index();
                    swiper.lazy.loadInSlide(index$$1);
                });
            } else if (slidesPerView > 1) {
                for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
                    if (slideExist(i)) swiper.lazy.loadInSlide(i);
                }
            } else {
                swiper.lazy.loadInSlide(activeIndex);
            }
            if (params.loadPrevNext) {
                if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
                    const amount = params.loadPrevNextAmount;
                    const spv = slidesPerView;
                    const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
                    const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
                    for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
                        if (slideExist(i)) swiper.lazy.loadInSlide(i);
                    }
                    for (let i = minIndex; i < activeIndex; i += 1) {
                        if (slideExist(i)) swiper.lazy.loadInSlide(i);
                    }
                } else {
                    const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
                    if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));
                    const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
                    if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
                }
            }
        },
    };
    var Lazy$1 = {
        name: 'lazy',
        params: {
            lazy: {
                enabled: false,
                loadPrevNext: false,
                loadPrevNextAmount: 1,
                loadOnTransitionStart: false,
                elementClass: 'swiper-lazy',
                loadingClass: 'swiper-lazy-loading',
                loadedClass: 'swiper-lazy-loaded',
                preloaderClass: 'swiper-lazy-preloader',
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                lazy: {
                    initialImageLoaded: false,
                    load: Lazy.load.bind(swiper),
                    loadInSlide: Lazy.loadInSlide.bind(swiper),
                },
            });
        },
        on: {
            beforeInit() {
                const swiper = this;
                if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
                    swiper.params.preloadImages = false;
                }
            }, init() {
                const swiper = this;
                if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
                    swiper.lazy.load();
                }
            }, scroll() {
                const swiper = this;
                if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
                    swiper.lazy.load();
                }
            }, resize() {
                const swiper = this;
                if (swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
            }, scrollbarDragMove() {
                const swiper = this;
                if (swiper.params.lazy.enabled) {
                    swiper.lazy.load();
                }
            }, transitionStart() {
                const swiper = this;
                if (swiper.params.lazy.enabled) {
                    if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
                        swiper.lazy.load();
                    }
                }
            }, transitionEnd() {
                const swiper = this;
                if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
                    swiper.lazy.load();
                }
            },
        },
    };
    const Controller = {
        LinearSpline: function LinearSpline(x, y) {
            const binarySearch = (function search() {
                let maxIndex;
                let minIndex;
                let guess;
                return (array, val) => {
                    minIndex = -1;
                    maxIndex = array.length;
                    while (maxIndex - minIndex > 1) {
                        guess = maxIndex + minIndex >> 1;
                        if (array[guess] <= val) {
                            minIndex = guess;
                        } else {
                            maxIndex = guess;
                        }
                    }
                    return maxIndex;
                };
            }());
            this.x = x;
            this.y = y;
            this.lastIndex = x.length - 1;
            let i1;
            let i3;
            this.interpolate = function interpolate(x2) {
                if (!x2) return 0;
                i3 = binarySearch(this.x, x2);
                i1 = i3 - 1;
                return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
            };
            return this;
        },
        getInterpolateFunction(c) {
            const swiper = this;
            if (!swiper.controller.spline) {
                swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
            }
        },
        setTranslate(setTranslate, byController) {
            const swiper = this;
            const controlled = swiper.controller.control;
            let multiplier;
            let controlledTranslate;

            function setControlledTranslate(c) {
                const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
                if (swiper.params.controller.by === 'slide') {
                    swiper.controller.getInterpolateFunction(c);
                    controlledTranslate = -swiper.controller.spline.interpolate(-translate);
                }
                if (!controlledTranslate || swiper.params.controller.by === 'container') {
                    multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                    controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
                }
                if (swiper.params.controller.inverse) {
                    controlledTranslate = c.maxTranslate() - controlledTranslate;
                }
                c.updateProgress(controlledTranslate);
                c.setTranslate(controlledTranslate, swiper);
                c.updateActiveIndex();
                c.updateSlidesClasses();
            }
            if (Array.isArray(controlled)) {
                for (let i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTranslate(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTranslate(controlled);
            }
        },
        setTransition(duration, byController) {
            const swiper = this;
            const controlled = swiper.controller.control;
            let i;

            function setControlledTransition(c) {
                c.setTransition(duration, swiper);
                if (duration !== 0) {
                    c.transitionStart();
                    if (c.params.autoHeight) {
                        Utils.nextTick(() => {
                            c.updateAutoHeight();
                        });
                    }
                    c.$wrapperEl.transitionEnd(() => {
                        if (!controlled) return;
                        if (c.params.loop && swiper.params.controller.by === 'slide') {
                            c.loopFix();
                        }
                        c.transitionEnd();
                    });
                }
            }
            if (Array.isArray(controlled)) {
                for (i = 0; i < controlled.length; i += 1) {
                    if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                        setControlledTransition(controlled[i]);
                    }
                }
            } else if (controlled instanceof Swiper && byController !== controlled) {
                setControlledTransition(controlled);
            }
        },
    };
    var Controller$1 = {
        name: 'controller',
        params: {
            controller: {
                control: undefined,
                inverse: false,
                by: 'slide',
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                controller: {
                    control: swiper.params.controller.control,
                    getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
                    setTranslate: Controller.setTranslate.bind(swiper),
                    setTransition: Controller.setTransition.bind(swiper),
                },
            });
        },
        on: {
            update() {
                const swiper = this;
                if (!swiper.controller.control) return;
                if (swiper.controller.spline) {
                    swiper.controller.spline = undefined;
                    delete swiper.controller.spline;
                }
            }, resize() {
                const swiper = this;
                if (!swiper.controller.control) return;
                if (swiper.controller.spline) {
                    swiper.controller.spline = undefined;
                    delete swiper.controller.spline;
                }
            }, observerUpdate() {
                const swiper = this;
                if (!swiper.controller.control) return;
                if (swiper.controller.spline) {
                    swiper.controller.spline = undefined;
                    delete swiper.controller.spline;
                }
            }, setTranslate(translate, byController) {
                const swiper = this;
                if (!swiper.controller.control) return;
                swiper.controller.setTranslate(translate, byController);
            }, setTransition(duration, byController) {
                const swiper = this;
                if (!swiper.controller.control) return;
                swiper.controller.setTransition(duration, byController);
            },
        },
    };
    const a11y = {
        makeElFocusable($el) {
            $el.attr('tabIndex', '0');
            return $el;
        }, addElRole($el, role) {
            $el.attr('role', role);
            return $el;
        }, addElLabel($el, label) {
            $el.attr('aria-label', label);
            return $el;
        }, disableEl($el) {
            $el.attr('aria-disabled', true);
            return $el;
        }, enableEl($el) {
            $el.attr('aria-disabled', false);
            return $el;
        }, onEnterKey(e) {
            const swiper = this;
            const params = swiper.params.a11y;
            if (e.keyCode !== 13) return;
            const $targetEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(e.target);
            if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
                if (!(swiper.isEnd && !swiper.params.loop)) {
                    swiper.slideNext();
                }
                if (swiper.isEnd) {
                    swiper.a11y.notify(params.lastSlideMessage);
                } else {
                    swiper.a11y.notify(params.nextSlideMessage);
                }
            }
            if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
                if (!(swiper.isBeginning && !swiper.params.loop)) {
                    swiper.slidePrev();
                }
                if (swiper.isBeginning) {
                    swiper.a11y.notify(params.firstSlideMessage);
                } else {
                    swiper.a11y.notify(params.prevSlideMessage);
                }
            }
            if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {
                $targetEl[0].click();
            }
        }, notify(message) {
            const swiper = this;
            const notification = swiper.a11y.liveRegion;
            if (notification.length === 0) return;
            notification.html('');
            notification.html(message);
        }, updateNavigation() {
            const swiper = this;
            if (swiper.params.loop) return;
            const {
                $nextEl, $prevEl
            } = swiper.navigation;
            if ($prevEl && $prevEl.length > 0) {
                if (swiper.isBeginning) {
                    swiper.a11y.disableEl($prevEl);
                } else {
                    swiper.a11y.enableEl($prevEl);
                }
            }
            if ($nextEl && $nextEl.length > 0) {
                if (swiper.isEnd) {
                    swiper.a11y.disableEl($nextEl);
                } else {
                    swiper.a11y.enableEl($nextEl);
                }
            }
        }, updatePagination() {
            const swiper = this;
            const params = swiper.params.a11y;
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
                swiper.pagination.bullets.each((bulletIndex, bulletEl) => {
                    const $bulletEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(bulletEl);
                    swiper.a11y.makeElFocusable($bulletEl);
                    swiper.a11y.addElRole($bulletEl, 'button');
                    swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
                });
            }
        }, init() {
            const swiper = this;
            swiper.$el.append(swiper.a11y.liveRegion);
            const params = swiper.params.a11y;
            let $nextEl;
            let $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
                swiper.a11y.makeElFocusable($nextEl);
                swiper.a11y.addElRole($nextEl, 'button');
                swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
                $nextEl.on('keydown', swiper.a11y.onEnterKey);
            }
            if ($prevEl) {
                swiper.a11y.makeElFocusable($prevEl);
                swiper.a11y.addElRole($prevEl, 'button');
                swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
                $prevEl.on('keydown', swiper.a11y.onEnterKey);
            }
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
                swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
            }
        }, destroy() {
            const swiper = this;
            if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();
            let $nextEl;
            let $prevEl;
            if (swiper.navigation && swiper.navigation.$nextEl) {
                $nextEl = swiper.navigation.$nextEl;
            }
            if (swiper.navigation && swiper.navigation.$prevEl) {
                $prevEl = swiper.navigation.$prevEl;
            }
            if ($nextEl) {
                $nextEl.off('keydown', swiper.a11y.onEnterKey);
            }
            if ($prevEl) {
                $prevEl.off('keydown', swiper.a11y.onEnterKey);
            }
            if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
                swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
            }
        },
    };
    var A11y = {
        name: 'a11y',
        params: {
            a11y: {
                enabled: true,
                notificationClass: 'swiper-notification',
                prevSlideMessage: 'Previous slide',
                nextSlideMessage: 'Next slide',
                firstSlideMessage: 'This is the first slide',
                lastSlideMessage: 'This is the last slide',
                paginationBulletMessage: 'Go to slide {{index}}',
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                a11y: {
                    liveRegion: Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`),
                },
            });
            Object.keys(a11y).forEach((methodName) => {
                swiper.a11y[methodName] = a11y[methodName].bind(swiper);
            });
        },
        on: {
            init() {
                const swiper = this;
                if (!swiper.params.a11y.enabled) return;
                swiper.a11y.init();
                swiper.a11y.updateNavigation();
            }, toEdge() {
                const swiper = this;
                if (!swiper.params.a11y.enabled) return;
                swiper.a11y.updateNavigation();
            }, fromEdge() {
                const swiper = this;
                if (!swiper.params.a11y.enabled) return;
                swiper.a11y.updateNavigation();
            }, paginationUpdate() {
                const swiper = this;
                if (!swiper.params.a11y.enabled) return;
                swiper.a11y.updatePagination();
            }, destroy() {
                const swiper = this;
                if (!swiper.params.a11y.enabled) return;
                swiper.a11y.destroy();
            },
        },
    };
    const History = {
        init() {
            const swiper = this;
            if (!swiper.params.history) return;
            if (!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].history || !__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].history.pushState) {
                swiper.params.history.enabled = false;
                swiper.params.hashNavigation.enabled = true;
                return;
            }
            const history = swiper.history;
            history.initialized = true;
            history.paths = History.getPathValues();
            if (!history.paths.key && !history.paths.value) return;
            history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
            if (!swiper.params.history.replaceState) {
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].addEventListener('popstate', swiper.history.setHistoryPopState);
            }
        }, destroy() {
            const swiper = this;
            if (!swiper.params.history.replaceState) {
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].removeEventListener('popstate', swiper.history.setHistoryPopState);
            }
        }, setHistoryPopState() {
            const swiper = this;
            swiper.history.paths = History.getPathValues();
            swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
        }, getPathValues() {
            const pathArray = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].location.pathname.slice(1).split('/').filter(part => part !== '');
            const total = pathArray.length;
            const key = pathArray[total - 2];
            const value = pathArray[total - 1];
            return {
                key, value
            };
        }, setHistory(key, index$$1) {
            const swiper = this;
            if (!swiper.history.initialized || !swiper.params.history.enabled) return;
            const slide = swiper.slides.eq(index$$1);
            let value = History.slugify(slide.attr('data-history'));
            if (!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].location.pathname.includes(key)) {
                value = `${key}/${value}`;
            }
            const currentState = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].history.state;
            if (currentState && currentState.value === value) {
                return;
            }
            if (swiper.params.history.replaceState) {
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].history.replaceState({
                    value
                }, null, value);
            } else {
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].history.pushState({
                    value
                }, null, value);
            }
        }, slugify(text$$1) {
            return text$$1.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
        }, scrollToSlide(speed, value, runCallbacks) {
            const swiper = this;
            if (value) {
                for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                    const slide = swiper.slides.eq(i);
                    const slideHistory = History.slugify(slide.attr('data-history'));
                    if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        const index$$1 = slide.index();
                        swiper.slideTo(index$$1, speed, runCallbacks);
                    }
                }
            } else {
                swiper.slideTo(0, speed, runCallbacks);
            }
        },
    };
    var History$1 = {
        name: 'history',
        params: {
            history: {
                enabled: false,
                replaceState: false,
                key: 'slides',
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                history: {
                    init: History.init.bind(swiper),
                    setHistory: History.setHistory.bind(swiper),
                    setHistoryPopState: History.setHistoryPopState.bind(swiper),
                    scrollToSlide: History.scrollToSlide.bind(swiper),
                    destroy: History.destroy.bind(swiper),
                },
            });
        },
        on: {
            init() {
                const swiper = this;
                if (swiper.params.history.enabled) {
                    swiper.history.init();
                }
            }, destroy() {
                const swiper = this;
                if (swiper.params.history.enabled) {
                    swiper.history.destroy();
                }
            }, transitionEnd() {
                const swiper = this;
                if (swiper.history.initialized) {
                    swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
                }
            },
        },
    };
    const HashNavigation = {
        onHashCange() {
            const swiper = this;
            const newHash = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].location.hash.replace('#', '');
            const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
            if (newHash !== activeSlideHash) {
                swiper.slideTo(swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index());
            }
        }, setHash() {
            const swiper = this;
            if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;
            if (swiper.params.hashNavigation.replaceState && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].history && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].history.replaceState) {
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"].history.replaceState(null, null, (`#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || ''));
            } else {
                const slide = swiper.slides.eq(swiper.activeIndex);
                const hash = slide.attr('data-hash') || slide.attr('data-history');
                __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].location.hash = hash || '';
            }
        }, init() {
            const swiper = this;
            if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;
            swiper.hashNavigation.initialized = true;
            const hash = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a"].location.hash.replace('#', '');
            if (hash) {
                const speed = 0;
                for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                    const slide = swiper.slides.eq(i);
                    const slideHash = slide.attr('data-hash') || slide.attr('data-history');
                    if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
                        const index$$1 = slide.index();
                        swiper.slideTo(index$$1, speed, swiper.params.runCallbacksOnInit, true);
                    }
                }
            }
            if (swiper.params.hashNavigation.watchState) {
                Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"]).on('hashchange', swiper.hashNavigation.onHashCange);
            }
        }, destroy() {
            const swiper = this;
            if (swiper.params.hashNavigation.watchState) {
                Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b"]).off('hashchange', swiper.hashNavigation.onHashCange);
            }
        },
    };
    var HashNavigation$1 = {
        name: 'hash-navigation',
        params: {
            hashNavigation: {
                enabled: false,
                replaceState: false,
                watchState: false,
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                hashNavigation: {
                    initialized: false,
                    init: HashNavigation.init.bind(swiper),
                    destroy: HashNavigation.destroy.bind(swiper),
                    setHash: HashNavigation.setHash.bind(swiper),
                    onHashCange: HashNavigation.onHashCange.bind(swiper),
                },
            });
        },
        on: {
            init() {
                const swiper = this;
                if (swiper.params.hashNavigation.enabled) {
                    swiper.hashNavigation.init();
                }
            }, destroy() {
                const swiper = this;
                if (swiper.params.hashNavigation.enabled) {
                    swiper.hashNavigation.destroy();
                }
            }, transitionEnd() {
                const swiper = this;
                if (swiper.hashNavigation.initialized) {
                    swiper.hashNavigation.setHash();
                }
            },
        },
    };
    const Autoplay = {
        run() {
            const swiper = this;
            const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
            let delay = swiper.params.autoplay.delay;
            if ($activeSlideEl.attr('data-swiper-autoplay')) {
                delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
            }
            swiper.autoplay.timeout = Utils.nextTick(() => {
                if (swiper.params.autoplay.reverseDirection) {
                    if (swiper.params.loop) {
                        swiper.loopFix();
                        swiper.slidePrev(swiper.params.speed, true, true);
                        swiper.emit('autoplay');
                    } else if (!swiper.isBeginning) {
                        swiper.slidePrev(swiper.params.speed, true, true);
                        swiper.emit('autoplay');
                    } else if (!swiper.params.autoplay.stopOnLastSlide) {
                        swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
                        swiper.emit('autoplay');
                    } else {
                        swiper.autoplay.stop();
                    }
                } else if (swiper.params.loop) {
                    swiper.loopFix();
                    swiper.slideNext(swiper.params.speed, true, true);
                    swiper.emit('autoplay');
                } else if (!swiper.isEnd) {
                    swiper.slideNext(swiper.params.speed, true, true);
                    swiper.emit('autoplay');
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    swiper.slideTo(0, swiper.params.speed, true, true);
                    swiper.emit('autoplay');
                } else {
                    swiper.autoplay.stop();
                }
            }, delay);
        }, start() {
            const swiper = this;
            if (typeof swiper.autoplay.timeout !== 'undefined') return false;
            if (swiper.autoplay.running) return false;
            swiper.autoplay.running = true;
            swiper.emit('autoplayStart');
            swiper.autoplay.run();
            return true;
        }, stop() {
            const swiper = this;
            if (!swiper.autoplay.running) return false;
            if (typeof swiper.autoplay.timeout === 'undefined') return false;
            if (swiper.autoplay.timeout) {
                clearTimeout(swiper.autoplay.timeout);
                swiper.autoplay.timeout = undefined;
            }
            swiper.autoplay.running = false;
            swiper.emit('autoplayStop');
            return true;
        }, pause(speed) {
            const swiper = this;
            if (!swiper.autoplay.running) return;
            if (swiper.autoplay.paused) return;
            if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
            swiper.autoplay.paused = true;
            if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
                swiper.autoplay.paused = false;
                swiper.autoplay.run();
            } else {
                swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
                swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
            }
        },
    };
    var Autoplay$1 = {
        name: 'autoplay',
        params: {
            autoplay: {
                enabled: false,
                delay: 3000,
                waitForTransition: true,
                disableOnInteraction: true,
                stopOnLastSlide: false,
                reverseDirection: false,
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                autoplay: {
                    running: false,
                    paused: false,
                    run: Autoplay.run.bind(swiper),
                    start: Autoplay.start.bind(swiper),
                    stop: Autoplay.stop.bind(swiper),
                    pause: Autoplay.pause.bind(swiper),
                    onTransitionEnd(e) {
                        if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
                        if (e.target !== this) return;
                        swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
                        swiper.autoplay.paused = false;
                        if (!swiper.autoplay.running) {
                            swiper.autoplay.stop();
                        } else {
                            swiper.autoplay.run();
                        }
                    },
                },
            });
        },
        on: {
            init() {
                const swiper = this;
                if (swiper.params.autoplay.enabled) {
                    swiper.autoplay.start();
                }
            }, beforeTransitionStart(speed, internal) {
                const swiper = this;
                if (swiper.autoplay.running) {
                    if (internal || !swiper.params.autoplay.disableOnInteraction) {
                        swiper.autoplay.pause(speed);
                    } else {
                        swiper.autoplay.stop();
                    }
                }
            }, sliderFirstMove() {
                const swiper = this;
                if (swiper.autoplay.running) {
                    if (swiper.params.autoplay.disableOnInteraction) {
                        swiper.autoplay.stop();
                    } else {
                        swiper.autoplay.pause();
                    }
                }
            }, destroy() {
                const swiper = this;
                if (swiper.autoplay.running) {
                    swiper.autoplay.stop();
                }
            },
        },
    };
    const Fade = {
        setTranslate() {
            const swiper = this;
            const {
                slides
            } = swiper;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = swiper.slides.eq(i);
                const offset$$1 = $slideEl[0].swiperSlideOffset;
                let tx = -offset$$1;
                if (!swiper.params.virtualTranslate) tx -= swiper.translate;
                let ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                }
                const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
                $slideEl.css({
                    opacity: slideOpacity,
                }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
            }
        }, setTransition(duration) {
            const swiper = this;
            const {
                slides, $wrapperEl
            } = swiper;
            slides.transition(duration);
            if (swiper.params.virtualTranslate && duration !== 0) {
                let eventTriggered = false;
                slides.transitionEnd(() => {
                    if (eventTriggered) return;
                    if (!swiper || swiper.destroyed) return;
                    eventTriggered = true;
                    swiper.animating = false;
                    const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
                    for (let i = 0; i < triggerEvents.length; i += 1) {
                        $wrapperEl.trigger(triggerEvents[i]);
                    }
                });
            }
        },
    };
    var EffectFade = {
        name: 'effect-fade',
        params: {
            fadeEffect: {
                crossFade: false,
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                fadeEffect: {
                    setTranslate: Fade.setTranslate.bind(swiper),
                    setTransition: Fade.setTransition.bind(swiper),
                },
            });
        },
        on: {
            beforeInit() {
                const swiper = this;
                if (swiper.params.effect !== 'fade') return;
                swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);
                const overwriteParams = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    spaceBetween: 0,
                    virtualTranslate: true,
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
            }, setTranslate() {
                const swiper = this;
                if (swiper.params.effect !== 'fade') return;
                swiper.fadeEffect.setTranslate();
            }, setTransition(duration) {
                const swiper = this;
                if (swiper.params.effect !== 'fade') return;
                swiper.fadeEffect.setTransition(duration);
            },
        },
    };
    const Cube = {
        setTranslate() {
            const swiper = this;
            const {
                $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,
            } = swiper;
            const params = swiper.params.cubeEffect;
            const isHorizontal = swiper.isHorizontal();
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let wrapperRotate = 0;
            let $cubeShadowEl;
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])('<div class="swiper-cube-shadow"></div>');
                        $wrapperEl.append($cubeShadowEl);
                    }
                    $cubeShadowEl.css({
                        height: `${swiperWidth}px`
                    });
                } else {
                    $cubeShadowEl = $el.find('.swiper-cube-shadow');
                    if ($cubeShadowEl.length === 0) {
                        $cubeShadowEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])('<div class="swiper-cube-shadow"></div>');
                        $el.append($cubeShadowEl);
                    }
                }
            }
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                let slideIndex = i;
                if (isVirtual) {
                    slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
                }
                let slideAngle = slideIndex * 90;
                let round = Math.floor(slideAngle / 360);
                if (rtl) {
                    slideAngle = -slideAngle;
                    round = Math.floor(-slideAngle / 360);
                }
                const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                let tx = 0;
                let ty = 0;
                let tz = 0;
                if (slideIndex % 4 === 0) {
                    tx = -round * 4 * swiperSize;
                    tz = 0;
                } else if ((slideIndex - 1) % 4 === 0) {
                    tx = 0;
                    tz = -round * 4 * swiperSize;
                } else if ((slideIndex - 2) % 4 === 0) {
                    tx = swiperSize + (round * 4 * swiperSize);
                    tz = swiperSize;
                } else if ((slideIndex - 3) % 4 === 0) {
                    tx = -swiperSize;
                    tz = (3 * swiperSize) + (swiperSize * 4 * round);
                }
                if (rtl) {
                    tx = -tx;
                }
                if (!isHorizontal) {
                    ty = tx;
                    tx = 0;
                }
                const transform$$1 = `rotateX(${isHorizontal?0:-slideAngle}deg) rotateY(${isHorizontal?slideAngle:0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
                if (progress <= 1 && progress > -1) {
                    wrapperRotate = (slideIndex * 90) + (progress * 90);
                    if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);
                }
                $slideEl.transform(transform$$1);
                if (params.slideShadows) {
                    let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                    let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                    if (shadowBefore.length === 0) {
                        shadowBefore = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(`<div class="swiper-slide-shadow-${isHorizontal?'left':'top'}"></div>`);
                        $slideEl.append(shadowBefore);
                    }
                    if (shadowAfter.length === 0) {
                        shadowAfter = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(`<div class="swiper-slide-shadow-${isHorizontal?'right':'bottom'}"></div>`);
                        $slideEl.append(shadowAfter);
                    }
                    if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                    if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
                }
            }
            $wrapperEl.css({
                '-webkit-transform-origin': `50% 50% -${swiperSize/2}px`,
                '-moz-transform-origin': `50% 50% -${swiperSize/2}px`,
                '-ms-transform-origin': `50% 50% -${swiperSize/2}px`,
                'transform-origin': `50% 50% -${swiperSize/2}px`,
            });
            if (params.shadow) {
                if (isHorizontal) {
                    $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth/2)+params.shadowOffset}px, ${-swiperWidth/2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
                } else {
                    const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
                    const multiplier = 1.5 - ((Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2) + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2));
                    const scale1 = params.shadowScale;
                    const scale2 = params.shadowScale / multiplier;
                    const offset$$1 = params.shadowOffset;
                    $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight/2)+offset$$1}px, ${-swiperHeight/2/scale2}px) rotateX(-90deg)`);
                }
            }
            const zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
            $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal()?0:wrapperRotate}deg) rotateY(${swiper.isHorizontal()?-wrapperRotate:0}deg)`);
        }, setTransition(duration) {
            const swiper = this;
            const {
                $el, slides
            } = swiper;
            slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
            if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
                $el.find('.swiper-cube-shadow').transition(duration);
            }
        },
    };
    var EffectCube = {
        name: 'effect-cube',
        params: {
            cubeEffect: {
                slideShadows: true,
                shadow: true,
                shadowOffset: 20,
                shadowScale: 0.94,
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                cubeEffect: {
                    setTranslate: Cube.setTranslate.bind(swiper),
                    setTransition: Cube.setTransition.bind(swiper),
                },
            });
        },
        on: {
            beforeInit() {
                const swiper = this;
                if (swiper.params.effect !== 'cube') return;
                swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);
                swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
                const overwriteParams = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    resistanceRatio: 0,
                    spaceBetween: 0,
                    centeredSlides: false,
                    virtualTranslate: true,
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
            }, setTranslate() {
                const swiper = this;
                if (swiper.params.effect !== 'cube') return;
                swiper.cubeEffect.setTranslate();
            }, setTransition(duration) {
                const swiper = this;
                if (swiper.params.effect !== 'cube') return;
                swiper.cubeEffect.setTransition(duration);
            },
        },
    };
    const Flip = {
        setTranslate() {
            const swiper = this;
            const {
                slides, rtlTranslate: rtl
            } = swiper;
            for (let i = 0; i < slides.length; i += 1) {
                const $slideEl = slides.eq(i);
                let progress = $slideEl[0].progress;
                if (swiper.params.flipEffect.limitRotation) {
                    progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
                }
                const offset$$1 = $slideEl[0].swiperSlideOffset;
                const rotate = -180 * progress;
                let rotateY = rotate;
                let rotateX = 0;
                let tx = -offset$$1;
                let ty = 0;
                if (!swiper.isHorizontal()) {
                    ty = tx;
                    tx = 0;
                    rotateX = -rotateY;
                    rotateY = 0;
                } else if (rtl) {
                    rotateY = -rotateY;
                }
                $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
                if (swiper.params.flipEffect.slideShadows) {
                    let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                    let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                    if (shadowBefore.length === 0) {
                        shadowBefore = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(`<div class="swiper-slide-shadow-${swiper.isHorizontal()?'left':'top'}"></div>`);
                        $slideEl.append(shadowBefore);
                    }
                    if (shadowAfter.length === 0) {
                        shadowAfter = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(`<div class="swiper-slide-shadow-${swiper.isHorizontal()?'right':'bottom'}"></div>`);
                        $slideEl.append(shadowAfter);
                    }
                    if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                    if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
                }
                $slideEl.transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);
            }
        }, setTransition(duration) {
            const swiper = this;
            const {
                slides, activeIndex, $wrapperEl
            } = swiper;
            slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
            if (swiper.params.virtualTranslate && duration !== 0) {
                let eventTriggered = false;
                slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
                    if (eventTriggered) return;
                    if (!swiper || swiper.destroyed) return;
                    eventTriggered = true;
                    swiper.animating = false;
                    const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
                    for (let i = 0; i < triggerEvents.length; i += 1) {
                        $wrapperEl.trigger(triggerEvents[i]);
                    }
                });
            }
        },
    };
    var EffectFlip = {
        name: 'effect-flip',
        params: {
            flipEffect: {
                slideShadows: true,
                limitRotation: true,
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                flipEffect: {
                    setTranslate: Flip.setTranslate.bind(swiper),
                    setTransition: Flip.setTransition.bind(swiper),
                },
            });
        },
        on: {
            beforeInit() {
                const swiper = this;
                if (swiper.params.effect !== 'flip') return;
                swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);
                swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
                const overwriteParams = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    spaceBetween: 0,
                    virtualTranslate: true,
                };
                Utils.extend(swiper.params, overwriteParams);
                Utils.extend(swiper.originalParams, overwriteParams);
            }, setTranslate() {
                const swiper = this;
                if (swiper.params.effect !== 'flip') return;
                swiper.flipEffect.setTranslate();
            }, setTransition(duration) {
                const swiper = this;
                if (swiper.params.effect !== 'flip') return;
                swiper.flipEffect.setTransition(duration);
            },
        },
    };
    const Coverflow = {
        setTranslate() {
            const swiper = this;
            const {
                width: swiperWidth,
                height: swiperHeight,
                slides,
                $wrapperEl,
                slidesSizesGrid,
            } = swiper;
            const params = swiper.params.coverflowEffect;
            const isHorizontal = swiper.isHorizontal();
            const transform$$1 = swiper.translate;
            const center = isHorizontal ? -transform$$1 + (swiperWidth / 2) : -transform$$1 + (swiperHeight / 2);
            const rotate = isHorizontal ? params.rotate : -params.rotate;
            const translate = params.depth;
            for (let i = 0, length = slides.length; i < length; i += 1) {
                const $slideEl = slides.eq(i);
                const slideSize = slidesSizesGrid[i];
                const slideOffset = $slideEl[0].swiperSlideOffset;
                const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;
                let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
                let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
                let translateZ = -translate * Math.abs(offsetMultiplier);
                let translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);
                let translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;
                if (Math.abs(translateX) < 0.001) translateX = 0;
                if (Math.abs(translateY) < 0.001) translateY = 0;
                if (Math.abs(translateZ) < 0.001) translateZ = 0;
                if (Math.abs(rotateY) < 0.001) rotateY = 0;
                if (Math.abs(rotateX) < 0.001) rotateX = 0;
                const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                $slideEl.transform(slideTransform);
                $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                if (params.slideShadows) {
                    let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
                    let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
                    if ($shadowBeforeEl.length === 0) {
                        $shadowBeforeEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(`<div class="swiper-slide-shadow-${isHorizontal?'left':'top'}"></div>`);
                        $slideEl.append($shadowBeforeEl);
                    }
                    if ($shadowAfterEl.length === 0) {
                        $shadowAfterEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a"])(`<div class="swiper-slide-shadow-${isHorizontal?'right':'bottom'}"></div>`);
                        $slideEl.append($shadowAfterEl);
                    }
                    if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                    if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
                }
            }
            if (Support.pointerEvents || Support.prefixedPointerEvents) {
                const ws = $wrapperEl[0].style;
                ws.perspectiveOrigin = `${center}px 50%`;
            }
        }, setTransition(duration) {
            const swiper = this;
            swiper.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
        },
    };
    var EffectCoverflow = {
        name: 'effect-coverflow',
        params: {
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                modifier: 1,
                slideShadows: true,
            },
        },
        create() {
            const swiper = this;
            Utils.extend(swiper, {
                coverflowEffect: {
                    setTranslate: Coverflow.setTranslate.bind(swiper),
                    setTransition: Coverflow.setTransition.bind(swiper),
                },
            });
        },
        on: {
            beforeInit() {
                const swiper = this;
                if (swiper.params.effect !== 'coverflow') return;
                swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);
                swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
                swiper.params.watchSlidesProgress = true;
                swiper.originalParams.watchSlidesProgress = true;
            }, setTranslate() {
                const swiper = this;
                if (swiper.params.effect !== 'coverflow') return;
                swiper.coverflowEffect.setTranslate();
            }, setTransition(duration) {
                const swiper = this;
                if (swiper.params.effect !== 'coverflow') return;
                swiper.coverflowEffect.setTransition(duration);
            },
        },
    };
    const components = [Device$1, Support$1, Browser$1, Resize, Observer$1, Virtual$1, Keyboard$1, Mousewheel$1, Navigation$1, Pagination$1, Scrollbar$1, Parallax$1, Zoom$1, Lazy$1, Controller$1, A11y, History$1, HashNavigation$1, Autoplay$1, EffectFade, EffectCube, EffectFlip, EffectCoverflow];
    if (typeof Swiper.use === 'undefined') {
        Swiper.use = Swiper.Class.use;
        Swiper.installModule = Swiper.Class.installModule;
    }
    Swiper.use(components);
    __webpack_exports__["default"] = (Swiper);
}), (function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", function() {
        return $;
    });
    __webpack_require__.d(__webpack_exports__, "c", function() {
        return addClass;
    });
    __webpack_require__.d(__webpack_exports__, "E", function() {
        return removeClass;
    });
    __webpack_require__.d(__webpack_exports__, "m", function() {
        return hasClass;
    });
    __webpack_require__.d(__webpack_exports__, "H", function() {
        return toggleClass;
    });
    __webpack_require__.d(__webpack_exports__, "e", function() {
        return attr;
    });
    __webpack_require__.d(__webpack_exports__, "D", function() {
        return removeAttr;
    });
    __webpack_require__.d(__webpack_exports__, "i", function() {
        return data;
    });
    __webpack_require__.d(__webpack_exports__, "I", function() {
        return transform;
    });
    __webpack_require__.d(__webpack_exports__, "J", function() {
        return transition;
    });
    __webpack_require__.d(__webpack_exports__, "u", function() {
        return on;
    });
    __webpack_require__.d(__webpack_exports__, "s", function() {
        return off;
    });
    __webpack_require__.d(__webpack_exports__, "L", function() {
        return trigger;
    });
    __webpack_require__.d(__webpack_exports__, "K", function() {
        return transitionEnd;
    });
    __webpack_require__.d(__webpack_exports__, "w", function() {
        return outerWidth;
    });
    __webpack_require__.d(__webpack_exports__, "v", function() {
        return outerHeight;
    });
    __webpack_require__.d(__webpack_exports__, "t", function() {
        return offset;
    });
    __webpack_require__.d(__webpack_exports__, "F", function() {
        return styles;
    });
    __webpack_require__.d(__webpack_exports__, "h", function() {
        return css;
    });
    __webpack_require__.d(__webpack_exports__, "j", function() {
        return each;
    });
    __webpack_require__.d(__webpack_exports__, "n", function() {
        return html;
    });
    __webpack_require__.d(__webpack_exports__, "G", function() {
        return text;
    });
    __webpack_require__.d(__webpack_exports__, "p", function() {
        return is;
    });
    __webpack_require__.d(__webpack_exports__, "o", function() {
        return index;
    });
    __webpack_require__.d(__webpack_exports__, "k", function() {
        return eq;
    });
    __webpack_require__.d(__webpack_exports__, "d", function() {
        return append;
    });
    __webpack_require__.d(__webpack_exports__, "z", function() {
        return prepend;
    });
    __webpack_require__.d(__webpack_exports__, "q", function() {
        return next;
    });
    __webpack_require__.d(__webpack_exports__, "r", function() {
        return nextAll;
    });
    __webpack_require__.d(__webpack_exports__, "A", function() {
        return prev;
    });
    __webpack_require__.d(__webpack_exports__, "B", function() {
        return prevAll;
    });
    __webpack_require__.d(__webpack_exports__, "x", function() {
        return parent;
    });
    __webpack_require__.d(__webpack_exports__, "y", function() {
        return parents;
    });
    __webpack_require__.d(__webpack_exports__, "g", function() {
        return closest;
    });
    __webpack_require__.d(__webpack_exports__, "l", function() {
        return find;
    });
    __webpack_require__.d(__webpack_exports__, "f", function() {
        return children;
    });
    __webpack_require__.d(__webpack_exports__, "C", function() {
        return remove;
    });
    __webpack_require__.d(__webpack_exports__, "b", function() {
        return add;
    });
    var __WEBPACK_IMPORTED_MODULE_0_ssr_window__ = __webpack_require__(26);
    class Dom7 {
        constructor(arr) {
            const self = this;
            for (let i = 0; i < arr.length; i += 1) {
                self[i] = arr[i];
            }
            self.length = arr.length;
            return this;
        }
    }

    function $(selector, context) {
        const arr = [];
        let i = 0;
        if (selector && !context) {
            if (selector instanceof Dom7) {
                return selector;
            }
        }
        if (selector) {
            if (typeof selector === 'string') {
                let els;
                let tempParent;
                const html = selector.trim();
                if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                    let toCreate = 'div';
                    if (html.indexOf('<li') === 0) toCreate = 'ul';
                    if (html.indexOf('<tr') === 0) toCreate = 'tbody';
                    if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
                    if (html.indexOf('<tbody') === 0) toCreate = 'table';
                    if (html.indexOf('<option') === 0) toCreate = 'select';
                    tempParent = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a"].createElement(toCreate);
                    tempParent.innerHTML = html;
                    for (i = 0; i < tempParent.childNodes.length; i += 1) {
                        arr.push(tempParent.childNodes[i]);
                    }
                } else {
                    if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                        els = [__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a"].getElementById(selector.trim().split('#')[1])];
                    } else {
                        els = (context || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a"]).querySelectorAll(selector.trim());
                    }
                    for (i = 0; i < els.length; i += 1) {
                        if (els[i]) arr.push(els[i]);
                    }
                }
            } else if (selector.nodeType || selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"] || selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a"]) {
                arr.push(selector);
            } else if (selector.length > 0 && selector[0].nodeType) {
                for (i = 0; i < selector.length; i += 1) {
                    arr.push(selector[i]);
                }
            }
        }
        return new Dom7(arr);
    }
    $.fn = Dom7.prototype;
    $.Class = Dom7;
    $.Dom7 = Dom7;

    function unique(arr) {
        const uniqueArray = [];
        for (let i = 0; i < arr.length; i += 1) {
            if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
        }
        return uniqueArray;
    }

    function toCamelCase(string) {
        return string.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());
    }

    function requestAnimationFrame(callback) {
        if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].requestAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].requestAnimationFrame(callback);
        else if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].webkitRequestAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].webkitRequestAnimationFrame(callback);
        return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].setTimeout(callback, 1000 / 60);
    }

    function cancelAnimationFrame(id) {
        if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].cancelAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].cancelAnimationFrame(id);
        else if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].webkitCancelAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].webkitCancelAnimationFrame(id);
        return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].clearTimeout(id);
    }

    function addClass(className) {
        if (typeof className === 'undefined') {
            return this;
        }
        const classes = className.split(' ');
        for (let i = 0; i < classes.length; i += 1) {
            for (let j = 0; j < this.length; j += 1) {
                if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
            }
        }
        return this;
    }

    function removeClass(className) {
        const classes = className.split(' ');
        for (let i = 0; i < classes.length; i += 1) {
            for (let j = 0; j < this.length; j += 1) {
                if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
            }
        }
        return this;
    }

    function hasClass(className) {
        if (!this[0]) return false;
        return this[0].classList.contains(className);
    }

    function toggleClass(className) {
        const classes = className.split(' ');
        for (let i = 0; i < classes.length; i += 1) {
            for (let j = 0; j < this.length; j += 1) {
                if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
            }
        }
        return this;
    }

    function attr(attrs, value) {
        if (arguments.length === 1 && typeof attrs === 'string') {
            if (this[0]) return this[0].getAttribute(attrs);
            return undefined;
        }
        for (let i = 0; i < this.length; i += 1) {
            if (arguments.length === 2) {
                this[i].setAttribute(attrs, value);
            } else {
                for (const attrName in attrs) {
                    this[i][attrName] = attrs[attrName];
                    this[i].setAttribute(attrName, attrs[attrName]);
                }
            }
        }
        return this;
    }

    function removeAttr(attr) {
        for (let i = 0; i < this.length; i += 1) {
            this[i].removeAttribute(attr);
        }
        return this;
    }

    function prop(props, value) {
        if (arguments.length === 1 && typeof props === 'string') {
            if (this[0]) return this[0][props];
        } else {
            for (let i = 0; i < this.length; i += 1) {
                if (arguments.length === 2) {
                    this[i][props] = value;
                } else {
                    for (const propName in props) {
                        this[i][propName] = props[propName];
                    }
                }
            }
            return this;
        }
    }

    function data(key, value) {
        let el;
        if (typeof value === 'undefined') {
            el = this[0];
            if (el) {
                if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
                    return el.dom7ElementDataStorage[key];
                }
                const dataKey = el.getAttribute(`data-${key}`);
                if (dataKey) {
                    return dataKey;
                }
                return undefined;
            }
            return undefined;
        }
        for (let i = 0; i < this.length; i += 1) {
            el = this[i];
            if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
            el.dom7ElementDataStorage[key] = value;
        }
        return this;
    }

    function removeData(key) {
        for (let i = 0; i < this.length; i += 1) {
            const el = this[i];
            if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
                el.dom7ElementDataStorage[key] = null;
                delete el.dom7ElementDataStorage[key];
            }
        }
    }

    function dataset() {
        const el = this[0];
        if (!el) return undefined;
        const dataset = {};
        if (el.dataset) {
            for (const dataKey in el.dataset) {
                dataset[dataKey] = el.dataset[dataKey];
            }
        } else {
            for (let i = 0; i < el.attributes.length; i += 1) {
                const attr = el.attributes[i];
                if (attr.name.indexOf('data-') >= 0) {
                    dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
                }
            }
        }
        for (const key in dataset) {
            if (dataset[key] === 'false') dataset[key] = false;
            else if (dataset[key] === 'true') dataset[key] = true;
            else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
        }
        return dataset;
    }

    function val(value) {
        const dom = this;
        if (typeof value === 'undefined') {
            if (dom[0]) {
                if (dom[0].multiple && dom[0].nodeName.toLowerCase() === 'select') {
                    const values = [];
                    for (let i = 0; i < dom[0].selectedOptions.length; i += 1) {
                        values.push(dom[0].selectedOptions[i].value);
                    }
                    return values;
                }
                return dom[0].value;
            }
            return undefined;
        }
        for (let i = 0; i < dom.length; i += 1) {
            const el = dom[i];
            if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {
                for (let j = 0; j < el.options.length; j += 1) {
                    el.options[j].selected = value.indexOf(el.options[j].value) >= 0;
                }
            } else {
                el.value = value;
            }
        }
        return dom;
    }

    function transform(transform) {
        for (let i = 0; i < this.length; i += 1) {
            const elStyle = this[i].style;
            elStyle.webkitTransform = transform;
            elStyle.transform = transform;
        }
        return this;
    }

    function transition(duration) {
        if (typeof duration !== 'string') {
            duration = `${duration}ms`;
        }
        for (let i = 0; i < this.length; i += 1) {
            const elStyle = this[i].style;
            elStyle.webkitTransitionDuration = duration;
            elStyle.transitionDuration = duration;
        }
        return this;
    }

    function on(...args) {
        let [eventType, targetSelector, listener, capture] = args;
        if (typeof args[1] === 'function') {
            [eventType, listener, capture] = args;
            targetSelector = undefined;
        }
        if (!capture) capture = false;

        function handleLiveEvent(e) {
            const target = e.target;
            if (!target) return;
            const eventData = e.target.dom7EventData || [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            if ($(target).is(targetSelector)) listener.apply(target, eventData);
            else {
                const parents = $(target).parents();
                for (let k = 0; k < parents.length; k += 1) {
                    if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
                }
            }
        }

        function handleEvent(e) {
            const eventData = e && e.target ? e.target.dom7EventData || [] : [];
            if (eventData.indexOf(e) < 0) {
                eventData.unshift(e);
            }
            listener.apply(this, eventData);
        }
        const events = eventType.split(' ');
        let j;
        for (let i = 0; i < this.length; i += 1) {
            const el = this[i];
            if (!targetSelector) {
                for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7Listeners) el.dom7Listeners = {};
                    if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
                    el.dom7Listeners[event].push({
                        listener, proxyListener: handleEvent,
                    });
                    el.addEventListener(event, handleEvent, capture);
                }
            } else {
                for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
                    if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
                    el.dom7LiveListeners[event].push({
                        listener, proxyListener: handleLiveEvent,
                    });
                    el.addEventListener(event, handleLiveEvent, capture);
                }
            }
        }
        return this;
    }

    function off(...args) {
        let [eventType, targetSelector, listener, capture] = args;
        if (typeof args[1] === 'function') {
            [eventType, listener, capture] = args;
            targetSelector = undefined;
        }
        if (!capture) capture = false;
        const events = eventType.split(' ');
        for (let i = 0; i < events.length; i += 1) {
            const event = events[i];
            for (let j = 0; j < this.length; j += 1) {
                const el = this[j];
                let handlers;
                if (!targetSelector && el.dom7Listeners) {
                    handlers = el.dom7Listeners[event];
                } else if (targetSelector && el.dom7LiveListeners) {
                    handlers = el.dom7LiveListeners[event];
                }
                if (handlers && handlers.length) {
                    for (let k = handlers.length - 1; k >= 0; k -= 1) {
                        const handler = handlers[k];
                        if (listener && handler.listener === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (!listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        }
                    }
                }
            }
        }
        return this;
    }

    function once(...args) {
        const dom = this;
        let [eventName, targetSelector, listener, capture] = args;
        if (typeof args[1] === 'function') {
            [eventName, listener, capture] = args;
            targetSelector = undefined;
        }

        function proxy(...eventArgs) {
            listener.apply(this, eventArgs);
            dom.off(eventName, targetSelector, proxy, capture);
        }
        return dom.on(eventName, targetSelector, proxy, capture);
    }

    function trigger(...args) {
        const events = args[0].split(' ');
        const eventData = args[1];
        for (let i = 0; i < events.length; i += 1) {
            const event = events[i];
            for (let j = 0; j < this.length; j += 1) {
                const el = this[j];
                let evt;
                try {
                    evt = new __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].CustomEvent(event, {
                        detail: eventData,
                        bubbles: true,
                        cancelable: true,
                    });
                } catch (e) {
                    evt = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a"].createEvent('Event');
                    evt.initEvent(event, true, true);
                    evt.detail = eventData;
                }
                el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
                el.dispatchEvent(evt);
                el.dom7EventData = [];
                delete el.dom7EventData;
            }
        }
        return this;
    }

    function transitionEnd(callback) {
        const events = ['webkitTransitionEnd', 'transitionend'];
        const dom = this;
        let i;

        function fireCallBack(e) {
            if (e.target !== this) return;
            callback.call(this, e);
            for (i = 0; i < events.length; i += 1) {
                dom.off(events[i], fireCallBack);
            }
        }
        if (callback) {
            for (i = 0; i < events.length; i += 1) {
                dom.on(events[i], fireCallBack);
            }
        }
        return this;
    }

    function animationEnd(callback) {
        const events = ['webkitAnimationEnd', 'animationend'];
        const dom = this;
        let i;

        function fireCallBack(e) {
            if (e.target !== this) return;
            callback.call(this, e);
            for (i = 0; i < events.length; i += 1) {
                dom.off(events[i], fireCallBack);
            }
        }
        if (callback) {
            for (i = 0; i < events.length; i += 1) {
                dom.on(events[i], fireCallBack);
            }
        }
        return this;
    }

    function width() {
        if (this[0] === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"]) {
            return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].innerWidth;
        }
        if (this.length > 0) {
            return parseFloat(this.css('width'));
        }
        return null;
    }

    function outerWidth(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                const styles = this.styles();
                return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
            }
            return this[0].offsetWidth;
        }
        return null;
    }

    function height() {
        if (this[0] === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"]) {
            return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].innerHeight;
        }
        if (this.length > 0) {
            return parseFloat(this.css('height'));
        }
        return null;
    }

    function outerHeight(includeMargins) {
        if (this.length > 0) {
            if (includeMargins) {
                const styles = this.styles();
                return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
            }
            return this[0].offsetHeight;
        }
        return null;
    }

    function offset() {
        if (this.length > 0) {
            const el = this[0];
            const box = el.getBoundingClientRect();
            const body = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a"].body;
            const clientTop = el.clientTop || body.clientTop || 0;
            const clientLeft = el.clientLeft || body.clientLeft || 0;
            const scrollTop = el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"] ? __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].scrollY : el.scrollTop;
            const scrollLeft = el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"] ? __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].scrollX : el.scrollLeft;
            return {
                top: (box.top + scrollTop) - clientTop,
                left: (box.left + scrollLeft) - clientLeft,
            };
        }
        return null;
    }

    function hide() {
        for (let i = 0; i < this.length; i += 1) {
            this[i].style.display = 'none';
        }
        return this;
    }

    function show() {
        for (let i = 0; i < this.length; i += 1) {
            const el = this[i];
            if (el.style.display === 'none') {
                el.style.display = '';
            }
            if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].getComputedStyle(el, null).getPropertyValue('display') === 'none') {
                el.style.display = 'block';
            }
        }
        return this;
    }

    function styles() {
        if (this[0]) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].getComputedStyle(this[0], null);
        return {};
    }

    function css(props, value) {
        let i;
        if (arguments.length === 1) {
            if (typeof props === 'string') {
                if (this[0]) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].getComputedStyle(this[0], null).getPropertyValue(props);
            } else {
                for (i = 0; i < this.length; i += 1) {
                    for (let prop in props) {
                        this[i].style[prop] = props[prop];
                    }
                }
                return this;
            }
        }
        if (arguments.length === 2 && typeof props === 'string') {
            for (i = 0; i < this.length; i += 1) {
                this[i].style[props] = value;
            }
            return this;
        }
        return this;
    }

    function toArray() {
        const arr = [];
        for (let i = 0; i < this.length; i += 1) {
            arr.push(this[i]);
        }
        return arr;
    }

    function each(callback) {
        if (!callback) return this;
        for (let i = 0; i < this.length; i += 1) {
            if (callback.call(this[i], i, this[i]) === false) {
                return this;
            }
        }
        return this;
    }

    function forEach(callback) {
        if (!callback) return this;
        for (let i = 0; i < this.length; i += 1) {
            if (callback.call(this[i], this[i], i) === false) {
                return this;
            }
        }
        return this;
    }

    function filter(callback) {
        const matchedItems = [];
        const dom = this;
        for (let i = 0; i < dom.length; i += 1) {
            if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);
        }
        return new Dom7(matchedItems);
    }

    function map(callback) {
        const modifiedItems = [];
        const dom = this;
        for (let i = 0; i < dom.length; i += 1) {
            modifiedItems.push(callback.call(dom[i], i, dom[i]));
        }
        return new Dom7(modifiedItems);
    }

    function html(html) {
        if (typeof html === 'undefined') {
            return this[0] ? this[0].innerHTML : undefined;
        }
        for (let i = 0; i < this.length; i += 1) {
            this[i].innerHTML = html;
        }
        return this;
    }

    function text(text) {
        if (typeof text === 'undefined') {
            if (this[0]) {
                return this[0].textContent.trim();
            }
            return null;
        }
        for (let i = 0; i < this.length; i += 1) {
            this[i].textContent = text;
        }
        return this;
    }

    function is(selector) {
        const el = this[0];
        let compareWith;
        let i;
        if (!el || typeof selector === 'undefined') return false;
        if (typeof selector === 'string') {
            if (el.matches) return el.matches(selector);
            else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
            else if (el.msMatchesSelector) return el.msMatchesSelector(selector);
            compareWith = $(selector);
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) return true;
            }
            return false;
        } else if (selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a"]) return el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a"];
        else if (selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"]) return el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"];
        if (selector.nodeType || selector instanceof Dom7) {
            compareWith = selector.nodeType ? [selector] : selector;
            for (i = 0; i < compareWith.length; i += 1) {
                if (compareWith[i] === el) return true;
            }
            return false;
        }
        return false;
    }

    function indexOf(el) {
        for (let i = 0; i < this.length; i += 1) {
            if (this[i] === el) return i;
        }
        return -1;
    }

    function index() {
        let child = this[0];
        let i;
        if (child) {
            i = 0;
            while ((child = child.previousSibling) !== null) {
                if (child.nodeType === 1) i += 1;
            }
            return i;
        }
        return undefined;
    }

    function eq(index) {
        if (typeof index === 'undefined') return this;
        const length = this.length;
        let returnIndex;
        if (index > length - 1) {
            return new Dom7([]);
        }
        if (index < 0) {
            returnIndex = length + index;
            if (returnIndex < 0) return new Dom7([]);
            return new Dom7([this[returnIndex]]);
        }
        return new Dom7([this[index]]);
    }

    function append(...args) {
        let newChild;
        for (let k = 0; k < args.length; k += 1) {
            newChild = args[k];
            for (let i = 0; i < this.length; i += 1) {
                if (typeof newChild === 'string') {
                    const tempDiv = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a"].createElement('div');
                    tempDiv.innerHTML = newChild;
                    while (tempDiv.firstChild) {
                        this[i].appendChild(tempDiv.firstChild);
                    }
                } else if (newChild instanceof Dom7) {
                    for (let j = 0; j < newChild.length; j += 1) {
                        this[i].appendChild(newChild[j]);
                    }
                } else {
                    this[i].appendChild(newChild);
                }
            }
        }
        return this;
    }

    function appendTo(parent) {
        $(parent).append(this);
        return this;
    }

    function prepend(newChild) {
        let i;
        let j;
        for (i = 0; i < this.length; i += 1) {
            if (typeof newChild === 'string') {
                const tempDiv = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a"].createElement('div');
                tempDiv.innerHTML = newChild;
                for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
                    this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                }
            } else if (newChild instanceof Dom7) {
                for (j = 0; j < newChild.length; j += 1) {
                    this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                }
            } else {
                this[i].insertBefore(newChild, this[i].childNodes[0]);
            }
        }
        return this;
    }

    function prependTo(parent) {
        $(parent).prepend(this);
        return this;
    }

    function insertBefore(selector) {
        const before = $(selector);
        for (let i = 0; i < this.length; i += 1) {
            if (before.length === 1) {
                before[0].parentNode.insertBefore(this[i], before[0]);
            } else if (before.length > 1) {
                for (let j = 0; j < before.length; j += 1) {
                    before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
                }
            }
        }
    }

    function insertAfter(selector) {
        const after = $(selector);
        for (let i = 0; i < this.length; i += 1) {
            if (after.length === 1) {
                after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
            } else if (after.length > 1) {
                for (let j = 0; j < after.length; j += 1) {
                    after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
                }
            }
        }
    }

    function next(selector) {
        if (this.length > 0) {
            if (selector) {
                if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
                    return new Dom7([this[0].nextElementSibling]);
                }
                return new Dom7([]);
            }
            if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
            return new Dom7([]);
        }
        return new Dom7([]);
    }

    function nextAll(selector) {
        const nextEls = [];
        let el = this[0];
        if (!el) return new Dom7([]);
        while (el.nextElementSibling) {
            const next = el.nextElementSibling;
            if (selector) {
                if ($(next).is(selector)) nextEls.push(next);
            } else nextEls.push(next);
            el = next;
        }
        return new Dom7(nextEls);
    }

    function prev(selector) {
        if (this.length > 0) {
            const el = this[0];
            if (selector) {
                if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
                    return new Dom7([el.previousElementSibling]);
                }
                return new Dom7([]);
            }
            if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
            return new Dom7([]);
        }
        return new Dom7([]);
    }

    function prevAll(selector) {
        const prevEls = [];
        let el = this[0];
        if (!el) return new Dom7([]);
        while (el.previousElementSibling) {
            const prev = el.previousElementSibling;
            if (selector) {
                if ($(prev).is(selector)) prevEls.push(prev);
            } else prevEls.push(prev);
            el = prev;
        }
        return new Dom7(prevEls);
    }

    function siblings(selector) {
        return this.nextAll(selector).add(this.prevAll(selector));
    }

    function parent(selector) {
        const parents = [];
        for (let i = 0; i < this.length; i += 1) {
            if (this[i].parentNode !== null) {
                if (selector) {
                    if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
                } else {
                    parents.push(this[i].parentNode);
                }
            }
        }
        return $(unique(parents));
    }

    function parents(selector) {
        const parents = [];
        for (let i = 0; i < this.length; i += 1) {
            let parent = this[i].parentNode;
            while (parent) {
                if (selector) {
                    if ($(parent).is(selector)) parents.push(parent);
                } else {
                    parents.push(parent);
                }
                parent = parent.parentNode;
            }
        }
        return $(unique(parents));
    }

    function closest(selector) {
        let closest = this;
        if (typeof selector === 'undefined') {
            return new Dom7([]);
        }
        if (!closest.is(selector)) {
            closest = closest.parents(selector).eq(0);
        }
        return closest;
    }

    function find(selector) {
        const foundElements = [];
        for (let i = 0; i < this.length; i += 1) {
            const found = this[i].querySelectorAll(selector);
            for (let j = 0; j < found.length; j += 1) {
                foundElements.push(found[j]);
            }
        }
        return new Dom7(foundElements);
    }

    function children(selector) {
        const children = [];
        for (let i = 0; i < this.length; i += 1) {
            const childNodes = this[i].childNodes;
            for (let j = 0; j < childNodes.length; j += 1) {
                if (!selector) {
                    if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
                } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
                    children.push(childNodes[j]);
                }
            }
        }
        return new Dom7(unique(children));
    }

    function remove() {
        for (let i = 0; i < this.length; i += 1) {
            if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
        }
        return this;
    }

    function detach() {
        return this.remove();
    }

    function add(...args) {
        const dom = this;
        let i;
        let j;
        for (i = 0; i < args.length; i += 1) {
            const toAdd = $(args[i]);
            for (j = 0; j < toAdd.length; j += 1) {
                dom[dom.length] = toAdd[j];
                dom.length += 1;
            }
        }
        return dom;
    }

    function empty() {
        for (let i = 0; i < this.length; i += 1) {
            const el = this[i];
            if (el.nodeType === 1) {
                for (let j = 0; j < el.childNodes.length; j += 1) {
                    if (el.childNodes[j].parentNode) {
                        el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
                    }
                }
                el.textContent = '';
            }
        }
        return this;
    }

    function scrollTo(...args) {
        let [left, top, duration, easing, callback] = args;
        if (args.length === 4 && typeof easing === 'function') {
            callback = easing;
            [left, top, duration, callback, easing] = args;
        }
        if (typeof easing === 'undefined') easing = 'swing';
        return this.each(function animate() {
            const el = this;
            let currentTop;
            let currentLeft;
            let maxTop;
            let maxLeft;
            let newTop;
            let newLeft;
            let scrollTop;
            let scrollLeft;
            let animateTop = top > 0 || top === 0;
            let animateLeft = left > 0 || left === 0;
            if (typeof easing === 'undefined') {
                easing = 'swing';
            }
            if (animateTop) {
                currentTop = el.scrollTop;
                if (!duration) {
                    el.scrollTop = top;
                }
            }
            if (animateLeft) {
                currentLeft = el.scrollLeft;
                if (!duration) {
                    el.scrollLeft = left;
                }
            }
            if (!duration) return;
            if (animateTop) {
                maxTop = el.scrollHeight - el.offsetHeight;
                newTop = Math.max(Math.min(top, maxTop), 0);
            }
            if (animateLeft) {
                maxLeft = el.scrollWidth - el.offsetWidth;
                newLeft = Math.max(Math.min(left, maxLeft), 0);
            }
            let startTime = null;
            if (animateTop && newTop === currentTop) animateTop = false;
            if (animateLeft && newLeft === currentLeft) animateLeft = false;

            function render(time = new Date().getTime()) {
                if (startTime === null) {
                    startTime = time;
                }
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                const easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));
                let done;
                if (animateTop) scrollTop = currentTop + (easeProgress * (newTop - currentTop));
                if (animateLeft) scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft));
                if (animateTop && newTop > currentTop && scrollTop >= newTop) {
                    el.scrollTop = newTop;
                    done = true;
                }
                if (animateTop && newTop < currentTop && scrollTop <= newTop) {
                    el.scrollTop = newTop;
                    done = true;
                }
                if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
                    el.scrollLeft = newLeft;
                    done = true;
                }
                if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
                    el.scrollLeft = newLeft;
                    done = true;
                }
                if (done) {
                    if (callback) callback();
                    return;
                }
                if (animateTop) el.scrollTop = scrollTop;
                if (animateLeft) el.scrollLeft = scrollLeft;
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        });
    }

    function scrollTop(...args) {
        let [top, duration, easing, callback] = args;
        if (args.length === 3 && typeof easing === 'function') {
            [top, duration, callback, easing] = args;
        }
        const dom = this;
        if (typeof top === 'undefined') {
            if (dom.length > 0) return dom[0].scrollTop;
            return null;
        }
        return dom.scrollTo(undefined, top, duration, easing, callback);
    }

    function scrollLeft(...args) {
        let [left, duration, easing, callback] = args;
        if (args.length === 3 && typeof easing === 'function') {
            [left, duration, callback, easing] = args;
        }
        const dom = this;
        if (typeof left === 'undefined') {
            if (dom.length > 0) return dom[0].scrollLeft;
            return null;
        }
        return dom.scrollTo(left, undefined, duration, easing, callback);
    }

    function animate(initialProps, initialParams) {
        const els = this;
        const a = {
            props: Object.assign({}, initialProps),
            params: Object.assign({
                duration: 300,
                easing: 'swing',
            }, initialParams),
            elements: els,
            animating: false,
            que: [],
            easingProgress(easing, progress) {
                if (easing === 'swing') {
                    return 0.5 - (Math.cos(progress * Math.PI) / 2);
                }
                if (typeof easing === 'function') {
                    return easing(progress);
                }
                return progress;
            },
            stop() {
                if (a.frameId) {
                    cancelAnimationFrame(a.frameId);
                }
                a.animating = false;
                a.elements.each((index, el) => {
                    const element = el;
                    delete element.dom7AnimateInstance;
                });
                a.que = [];
            },
            done(complete) {
                a.animating = false;
                a.elements.each((index, el) => {
                    const element = el;
                    delete element.dom7AnimateInstance;
                });
                if (complete) complete(els);
                if (a.que.length > 0) {
                    const que = a.que.shift();
                    a.animate(que[0], que[1]);
                }
            },
            animate(props, params) {
                if (a.animating) {
                    a.que.push([props, params]);
                    return a;
                }
                const elements = [];
                a.elements.each((index, el) => {
                    let initialFullValue;
                    let initialValue;
                    let unit;
                    let finalValue;
                    let finalFullValue;
                    if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;
                    elements[index] = {
                        container: el,
                    };
                    Object.keys(props).forEach((prop) => {
                        initialFullValue = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b"].getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
                        initialValue = parseFloat(initialFullValue);
                        unit = initialFullValue.replace(initialValue, '');
                        finalValue = parseFloat(props[prop]);
                        finalFullValue = props[prop] + unit;
                        elements[index][prop] = {
                            initialFullValue, initialValue, unit, finalValue, finalFullValue, currentValue: initialValue,
                        };
                    });
                });
                let startTime = null;
                let time;
                let elementsDone = 0;
                let propsDone = 0;
                let done;
                let began = false;
                a.animating = true;

                function render() {
                    time = new Date().getTime();
                    let progress;
                    let easeProgress;
                    if (!began) {
                        began = true;
                        if (params.begin) params.begin(els);
                    }
                    if (startTime === null) {
                        startTime = time;
                    }
                    if (params.progress) {
                        params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);
                    }
                    elements.forEach((element) => {
                        const el = element;
                        if (done || el.done) return;
                        Object.keys(props).forEach((prop) => {
                            if (done || el.done) return;
                            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
                            easeProgress = a.easingProgress(params.easing, progress);
                            const {
                                initialValue, finalValue, unit
                            } = el[prop];
                            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));
                            const currentValue = el[prop].currentValue;
                            if ((finalValue > initialValue && currentValue >= finalValue) || (finalValue < initialValue && currentValue <= finalValue)) {
                                el.container.style[prop] = finalValue + unit;
                                propsDone += 1;
                                if (propsDone === Object.keys(props).length) {
                                    el.done = true;
                                    elementsDone += 1;
                                }
                                if (elementsDone === elements.length) {
                                    done = true;
                                }
                            }
                            if (done) {
                                a.done(params.complete);
                                return;
                            }
                            el.container.style[prop] = currentValue + unit;
                        });
                    });
                    if (done) return;
                    a.frameId = requestAnimationFrame(render);
                }
                a.frameId = requestAnimationFrame(render);
                return a;
            },
        };
        if (a.elements.length === 0) {
            return els;
        }
        let animateInstance;
        for (let i = 0; i < a.elements.length; i += 1) {
            if (a.elements[i].dom7AnimateInstance) {
                animateInstance = a.elements[i].dom7AnimateInstance;
            } else a.elements[i].dom7AnimateInstance = a;
        }
        if (!animateInstance) {
            animateInstance = a;
        }
        if (initialProps === 'stop') {
            animateInstance.stop();
        } else {
            animateInstance.animate(a.props, a.params);
        }
        return els;
    }

    function stop() {
        const els = this;
        for (let i = 0; i < els.length; i += 1) {
            if (els[i].dom7AnimateInstance) {
                els[i].dom7AnimateInstance.stop();
            }
        }
    }
    const noTrigger = ('resize scroll').split(' ');

    function eventShortcut(name, ...args) {
        if (typeof args[0] === 'undefined') {
            for (let i = 0; i < this.length; i += 1) {
                if (noTrigger.indexOf(name) < 0) {
                    if (name in this[i]) this[i][name]();
                    else {
                        $(this[i]).trigger(name);
                    }
                }
            }
            return this;
        }
        return this.on(name, ...args);
    }

    function click(...args) {
        return eventShortcut.bind(this)('click', ...args);
    }

    function blur(...args) {
        return eventShortcut.bind(this)('blur', ...args);
    }

    function focus(...args) {
        return eventShortcut.bind(this)('focus', ...args);
    }

    function focusin(...args) {
        return eventShortcut.bind(this)('focusin', ...args);
    }

    function focusout(...args) {
        return eventShortcut.bind(this)('focusout', ...args);
    }

    function keyup(...args) {
        return eventShortcut.bind(this)('keyup', ...args);
    }

    function keydown(...args) {
        return eventShortcut.bind(this)('keydown', ...args);
    }

    function keypress(...args) {
        return eventShortcut.bind(this)('keypress', ...args);
    }

    function submit(...args) {
        return eventShortcut.bind(this)('submit', ...args);
    }

    function change(...args) {
        return eventShortcut.bind(this)('change', ...args);
    }

    function mousedown(...args) {
        return eventShortcut.bind(this)('mousedown', ...args);
    }

    function mousemove(...args) {
        return eventShortcut.bind(this)('mousemove', ...args);
    }

    function mouseup(...args) {
        return eventShortcut.bind(this)('mouseup', ...args);
    }

    function mouseenter(...args) {
        return eventShortcut.bind(this)('mouseenter', ...args);
    }

    function mouseleave(...args) {
        return eventShortcut.bind(this)('mouseleave', ...args);
    }

    function mouseout(...args) {
        return eventShortcut.bind(this)('mouseout', ...args);
    }

    function mouseover(...args) {
        return eventShortcut.bind(this)('mouseover', ...args);
    }

    function touchstart(...args) {
        return eventShortcut.bind(this)('touchstart', ...args);
    }

    function touchend(...args) {
        return eventShortcut.bind(this)('touchend', ...args);
    }

    function touchmove(...args) {
        return eventShortcut.bind(this)('touchmove', ...args);
    }

    function resize(...args) {
        return eventShortcut.bind(this)('resize', ...args);
    }

    function scroll(...args) {
        return eventShortcut.bind(this)('scroll', ...args);
    }
}), (function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    (function() {
        var defaultOptions = {
            frameRate: 150,
            animationTime: 400,
            stepSize: 100,
            pulseAlgorithm: true,
            pulseScale: 4,
            pulseNormalize: 1,
            accelerationDelta: 50,
            accelerationMax: 3,
            keyboardSupport: true,
            arrowScroll: 50,
            fixedBackground: true,
            excluded: ''
        };
        var options = defaultOptions;
        var isExcluded = false;
        var isFrame = false;
        var direction = {
            x: 0,
            y: 0
        };
        var initDone = false;
        var root = document.documentElement;
        var activeElement;
        var observer;
        var refreshSize;
        var deltaBuffer = [];
        var isMac = /^Mac/.test(navigator.platform);
        var key = {
            left: 37,
            up: 38,
            right: 39,
            down: 40,
            spacebar: 32,
            pageup: 33,
            pagedown: 34,
            end: 35,
            home: 36
        };
        var arrowKeys = {
            37: 1,
            38: 1,
            39: 1,
            40: 1
        };

        function initTest() {
            if (options.keyboardSupport) {
                addEvent('keydown', keydown);
            }
        }

        function init() {
            if (initDone || !document.body) return;
            initDone = true;
            var body = document.body;
            var html = document.documentElement;
            var windowHeight = window.innerHeight;
            var scrollHeight = body.scrollHeight;
            root = (document.compatMode.indexOf('CSS') >= 0) ? html : body;
            activeElement = body;
            initTest();
            if (top != self) {
                isFrame = true;
            } else if (isOldSafari && scrollHeight > windowHeight && (body.offsetHeight <= windowHeight || html.offsetHeight <= windowHeight)) {
                var fullPageElem = document.createElement('div');
                fullPageElem.style.cssText = 'position:absolute; z-index:-10000; ' +
                    'top:0; left:0; right:0; height:' +
                    root.scrollHeight + 'px';
                document.body.appendChild(fullPageElem);
                var pendingRefresh;
                refreshSize = function() {
                    if (pendingRefresh) return;
                    pendingRefresh = setTimeout(function() {
                        if (isExcluded) return;
                        fullPageElem.style.height = '0';
                        fullPageElem.style.height = root.scrollHeight + 'px';
                        pendingRefresh = null;
                    }, 500);
                };
                setTimeout(refreshSize, 10);
                addEvent('resize', refreshSize);
                var config = {
                    attributes: true,
                    childList: true,
                    characterData: false
                };
                observer = new MutationObserver(refreshSize);
                observer.observe(body, config);
                if (root.offsetHeight <= windowHeight) {
                    var clearfix = document.createElement('div');
                    clearfix.style.clear = 'both';
                    body.appendChild(clearfix);
                }
            }
            if (!options.fixedBackground && !isExcluded) {
                body.style.backgroundAttachment = 'scroll';
                html.style.backgroundAttachment = 'scroll';
            }
        }

        function cleanup() {
            observer && observer.disconnect();
            removeEvent(wheelEvent, wheel);
            removeEvent('mousedown', mousedown);
            removeEvent('keydown', keydown);
            removeEvent('resize', refreshSize);
            removeEvent('load', init);
        }
        var que = [];
        var pending = false;
        var lastScroll = Date.now();

        function scrollArray(elem, left, top) {
            directionCheck(left, top);
            if (options.accelerationMax != 1) {
                var now = Date.now();
                var elapsed = now - lastScroll;
                if (elapsed < options.accelerationDelta) {
                    var factor = (1 + (50 / elapsed)) / 2;
                    if (factor > 1) {
                        factor = Math.min(factor, options.accelerationMax);
                        left *= factor;
                        top *= factor;
                    }
                }
                lastScroll = Date.now();
            }
            que.push({
                x: left,
                y: top,
                lastX: (left < 0) ? 0.99 : -0.99,
                lastY: (top < 0) ? 0.99 : -0.99,
                start: Date.now()
            });
            if (pending) {
                return;
            }
            var scrollWindow = (elem === document.body);
            var step = function(time) {
                var now = Date.now();
                var scrollX = 0;
                var scrollY = 0;
                for (var i = 0; i < que.length; i++) {
                    var item = que[i];
                    var elapsed = now - item.start;
                    var finished = (elapsed >= options.animationTime);
                    var position = (finished) ? 1 : elapsed / options.animationTime;
                    if (options.pulseAlgorithm) {
                        position = pulse(position);
                    }
                    var x = (item.x * position - item.lastX) >> 0;
                    var y = (item.y * position - item.lastY) >> 0;
                    scrollX += x;
                    scrollY += y;
                    item.lastX += x;
                    item.lastY += y;
                    if (finished) {
                        que.splice(i, 1);
                        i--;
                    }
                }
                if (scrollWindow) {
                    window.scrollBy(scrollX, scrollY);
                } else {
                    if (scrollX) elem.scrollLeft += scrollX;
                    if (scrollY) elem.scrollTop += scrollY;
                }
                if (!left && !top) {
                    que = [];
                }
                if (que.length) {
                    requestFrame(step, elem, (1000 / options.frameRate + 1));
                } else {
                    pending = false;
                }
            };
            requestFrame(step, elem, 0);
            pending = true;
        }

        function wheel(event) {
            if (!initDone) {
                init();
            }
            var target = event.target;
            if (event.defaultPrevented || event.ctrlKey) {
                return true;
            }
            if (isNodeName(activeElement, 'embed') || (isNodeName(target, 'embed') && /\.pdf/i.test(target.src)) || isNodeName(activeElement, 'object') || target.shadowRoot) {
                return true;
            }
            var deltaX = -event.wheelDeltaX || event.deltaX || 0;
            var deltaY = -event.wheelDeltaY || event.deltaY || 0;
            if (isMac) {
                if (event.wheelDeltaX && isDivisible(event.wheelDeltaX, 120)) {
                    deltaX = -120 * (event.wheelDeltaX / Math.abs(event.wheelDeltaX));
                }
                if (event.wheelDeltaY && isDivisible(event.wheelDeltaY, 120)) {
                    deltaY = -120 * (event.wheelDeltaY / Math.abs(event.wheelDeltaY));
                }
            }
            if (!deltaX && !deltaY) {
                deltaY = -event.wheelDelta || 0;
            }
            if (event.deltaMode === 1) {
                deltaX *= 40;
                deltaY *= 40;
            }
            var overflowing = overflowingAncestor(target);
            if (!overflowing) {
                if (isFrame && isChrome) {
                    Object.defineProperty(event, "target", {
                        value: window.frameElement
                    });
                    return parent.wheel(event);
                }
                return true;
            }
            if (isTouchpad(deltaY)) {
                return true;
            }
            if (Math.abs(deltaX) > 1.2) {
                deltaX *= options.stepSize / 120;
            }
            if (Math.abs(deltaY) > 1.2) {
                deltaY *= options.stepSize / 120;
            }
            scrollArray(overflowing, deltaX, deltaY);
            event.preventDefault();
            scheduleClearCache();
        }

        function keydown(event) {
            var target = event.target;
            var modifier = event.ctrlKey || event.altKey || event.metaKey || (event.shiftKey && event.keyCode !== key.spacebar);
            if (!document.body.contains(activeElement)) {
                activeElement = document.activeElement;
            }
            var inputNodeNames = /^(textarea|select|embed|object)$/i;
            var buttonTypes = /^(button|submit|radio|checkbox|file|color|image)$/i;
            if (event.defaultPrevented || inputNodeNames.test(target.nodeName) || isNodeName(target, 'input') && !buttonTypes.test(target.type) || isNodeName(activeElement, 'video') || isInsideYoutubeVideo(event) || target.isContentEditable || modifier) {
                return true;
            }
            if ((isNodeName(target, 'button') || isNodeName(target, 'input') && buttonTypes.test(target.type)) && event.keyCode === key.spacebar) {
                return true;
            }
            if (isNodeName(target, 'input') && target.type == 'radio' && arrowKeys[event.keyCode]) {
                return true;
            }
            var shift, x = 0,
                y = 0;
            var overflowing = overflowingAncestor(activeElement);
            if (!overflowing) {
                return (isFrame && isChrome) ? parent.keydown(event) : true;
            }
            var clientHeight = overflowing.clientHeight;
            if (overflowing == document.body) {
                clientHeight = window.innerHeight;
            }
            switch (event.keyCode) {
                case key.up:
                    y = -options.arrowScroll;
                    break;
                case key.down:
                    y = options.arrowScroll;
                    break;
                case key.spacebar:
                    shift = event.shiftKey ? 1 : -1;
                    y = -shift * clientHeight * 0.9;
                    break;
                case key.pageup:
                    y = -clientHeight * 0.9;
                    break;
                case key.pagedown:
                    y = clientHeight * 0.9;
                    break;
                case key.home:
                    y = -overflowing.scrollTop;
                    break;
                case key.end:
                    var scroll = overflowing.scrollHeight - overflowing.scrollTop;
                    var scrollRemaining = scroll - clientHeight;
                    y = (scrollRemaining > 0) ? scrollRemaining + 10 : 0;
                    break;
                case key.left:
                    x = -options.arrowScroll;
                    break;
                case key.right:
                    x = options.arrowScroll;
                    break;
                default:
                    return true;
            }
            scrollArray(overflowing, x, y);
            event.preventDefault();
            scheduleClearCache();
        }

        function mousedown(event) {
            activeElement = event.target;
        }
        var uniqueID = (function() {
            var i = 0;
            return function(el) {
                return el.uniqueID || (el.uniqueID = i++);
            };
        })();
        var cache = {};
        var clearCacheTimer;

        function scheduleClearCache() {
            clearTimeout(clearCacheTimer);
            clearCacheTimer = setInterval(function() {
                cache = {};
            }, 1 * 1000);
        }

        function setCache(elems, overflowing) {
            for (var i = elems.length; i--;)
                cache[uniqueID(elems[i])] = overflowing;
            return overflowing;
        }

        function overflowingAncestor(el) {
            var elems = [];
            var body = document.body;
            var rootScrollHeight = root.scrollHeight;
            do {
                var cached = cache[uniqueID(el)];
                if (cached) {
                    return setCache(elems, cached);
                }
                elems.push(el);
                if (rootScrollHeight === el.scrollHeight) {
                    var topOverflowsNotHidden = overflowNotHidden(root) && overflowNotHidden(body);
                    var isOverflowCSS = topOverflowsNotHidden || overflowAutoOrScroll(root);
                    if (isFrame && isContentOverflowing(root) || !isFrame && isOverflowCSS) {
                        return setCache(elems, getScrollRoot());
                    }
                } else if (isContentOverflowing(el) && overflowAutoOrScroll(el)) {
                    return setCache(elems, el);
                }
            } while (el = el.parentElement);
        }

        function isContentOverflowing(el) {
            return (el.clientHeight + 10 < el.scrollHeight);
        }

        function overflowNotHidden(el) {
            var overflow = getComputedStyle(el, '').getPropertyValue('overflow-y');
            return (overflow !== 'hidden');
        }

        function overflowAutoOrScroll(el) {
            var overflow = getComputedStyle(el, '').getPropertyValue('overflow-y');
            return (overflow === 'scroll' || overflow === 'auto');
        }

        function addEvent(type, fn) {
            window.addEventListener(type, fn, false);
        }

        function removeEvent(type, fn) {
            window.removeEventListener(type, fn, false);
        }

        function isNodeName(el, tag) {
            return (el.nodeName || '').toLowerCase() === tag.toLowerCase();
        }

        function directionCheck(x, y) {
            x = (x > 0) ? 1 : -1;
            y = (y > 0) ? 1 : -1;
            if (direction.x !== x || direction.y !== y) {
                direction.x = x;
                direction.y = y;
                que = [];
                lastScroll = 0;
            }
        }
        var deltaBufferTimer;
        if (window.localStorage && localStorage.SS_deltaBuffer) {
            try {
                deltaBuffer = localStorage.SS_deltaBuffer.split(',');
            } catch (e) {}
        }

        function isTouchpad(deltaY) {
            if (!deltaY) return;
            if (!deltaBuffer.length) {
                deltaBuffer = [deltaY, deltaY, deltaY];
            }
            deltaY = Math.abs(deltaY);
            deltaBuffer.push(deltaY);
            deltaBuffer.shift();
            clearTimeout(deltaBufferTimer);
            deltaBufferTimer = setTimeout(function() {
                try {
                    localStorage.SS_deltaBuffer = deltaBuffer.join(',');
                } catch (e) {}
            }, 1000);
            return !allDeltasDivisableBy(120) && !allDeltasDivisableBy(100);
        }

        function isDivisible(n, divisor) {
            return (Math.floor(n / divisor) == n / divisor);
        }

        function allDeltasDivisableBy(divisor) {
            return (isDivisible(deltaBuffer[0], divisor) && isDivisible(deltaBuffer[1], divisor) && isDivisible(deltaBuffer[2], divisor));
        }

        function isInsideYoutubeVideo(event) {
            var elem = event.target;
            var isControl = false;
            if (document.URL.indexOf('www.youtube.com/watch') != -1) {
                do {
                    isControl = (elem.classList && elem.classList.contains('html5-video-controls'));
                    if (isControl) break;
                } while (elem = elem.parentNode);
            }
            return isControl;
        }
        var requestFrame = (function() {
            return (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback, element, delay) {
                window.setTimeout(callback, delay || (1000 / 60));
            });
        })();
        var MutationObserver = (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver);
        var getScrollRoot = (function() {
            var SCROLL_ROOT;
            return function() {
                if (!SCROLL_ROOT) {
                    var dummy = document.createElement('div');
                    dummy.style.cssText = 'height:10000px;width:1px;';
                    document.body.appendChild(dummy);
                    var bodyScrollTop = document.body.scrollTop;
                    var docElScrollTop = document.documentElement.scrollTop;
                    window.scrollBy(0, 3);
                    if (document.body.scrollTop != bodyScrollTop)
                        (SCROLL_ROOT = document.body);
                    else
                        (SCROLL_ROOT = document.documentElement);
                    window.scrollBy(0, -3);
                    document.body.removeChild(dummy);
                }
                return SCROLL_ROOT;
            };
        })();

        function pulse_(x) {
            var val, start, expx;
            x = x * options.pulseScale;
            if (x < 1) {
                val = x - (1 - Math.exp(-x));
            } else {
                start = Math.exp(-1);
                x -= 1;
                expx = 1 - Math.exp(-x);
                val = start + (expx * (1 - start));
            }
            return val * options.pulseNormalize;
        }

        function pulse(x) {
            if (x >= 1) return 1;
            if (x <= 0) return 0;
            if (options.pulseNormalize == 1) {
                options.pulseNormalize /= pulse_(1);
            }
            return pulse_(x);
        }
        var userAgent = window.navigator.userAgent;
        var isEdge = /Edge/.test(userAgent);
        var isChrome = /chrome/i.test(userAgent) && !isEdge;
        var isSafari = /safari/i.test(userAgent) && !isEdge;
        var isMobile = /mobile/i.test(userAgent);
        var isIEWin7 = /Windows NT 6.1/i.test(userAgent) && /rv:11/i.test(userAgent);
        var isOldSafari = isSafari && (/Version\/8/i.test(userAgent) || /Version\/9/i.test(userAgent));
        var isEnabledForBrowser = (isChrome || isSafari || isIEWin7) && !isMobile;
        var wheelEvent;
        if ('onwheel' in document.createElement('div'))
            wheelEvent = 'wheel';
        else if ('onmousewheel' in document.createElement('div'))
            wheelEvent = 'mousewheel';
        if (wheelEvent && isEnabledForBrowser) {
            addEvent(wheelEvent, wheel);
            addEvent('mousedown', mousedown);
            addEvent('load', init);
        }

        function SmoothScroll(optionsToSet) {
            for (var key in optionsToSet)
                if (defaultOptions.hasOwnProperty(key))
                    options[key] = optionsToSet[key];
        }
        SmoothScroll.destroy = cleanup;
        if (window.SmoothScrollOptions)
            SmoothScroll(window.SmoothScrollOptions);
        if (true)
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                return SmoothScroll;
            }).call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        else if ('object' == typeof exports)
            module.exports = SmoothScroll;
        else
            window.SmoothScroll = SmoothScroll;
    })();
})]);